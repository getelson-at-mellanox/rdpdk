/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }}
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }}
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }}
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }}
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _ASSERT_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BUS_AUXILIARY: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_MLX5: u32 = 1;
pub const RTE_COMPRESS_MLX5: u32 = 1;
pub const RTE_CRYPTO_MLX5: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_ENV_FREEBSD: u32 = 0;
pub const RTE_ENV_LINUX: u32 = 1;
pub const RTE_ENV_WINDOWS: u32 = 2;
pub const RTE_EXEC_ENV: u32 = 1;
pub const RTE_EXEC_ENV_IS_FREEBSD: u32 = 0;
pub const RTE_EXEC_ENV_IS_LINUX: u32 = 1;
pub const RTE_EXEC_ENV_IS_WINDOWS: u32 = 0;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_HAS_LIBPCAP: u32 = 1;
pub const RTE_HAS_OPENSSL: u32 = 1;
pub const RTE_IOVA_IN_MBUF: u32 = 1;
pub const RTE_LIBRTE_BPF_ELF: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_ARGPARSE: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISPATCHER: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_DMADEV: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_GPUDEV: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LOG: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_MLDEV: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCAPNG: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDCP: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_PTR_COMPRESS: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 32;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_MLX5: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_REGEX_MLX5: u32 = 1;
pub const RTE_USE_LIBBSD: u32 = 1;
pub const RTE_VDPA_MLX5: u32 = 1;
pub const RTE_VER_MINOR: u32 = 0;
pub const RTE_VER_MONTH: u32 = 3;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1] = b"\0";
pub const RTE_VER_YEAR: u32 = 25;
pub const RTE_TOOLCHAIN: &[u8; 6] = b"clang\0";
pub const RTE_TOOLCHAIN_CLANG: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5] = b"DPDK\0";
pub const RTE_CACHE_GUARD_LINES: u32 = 1;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_LCORE_VAR: u32 = 131072;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_TRACE: u32 = 1;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11] = b"ring_mp_mc\0";
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_MAX_MULTI_HOST_CTRLS: u32 = 4;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_CRYPTO_CALLBACKS: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_PORTS_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_PROFILES_PER_PORT: u32 = 8;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_DMA_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 8;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_MAX_UNCORE_FREQS: u32 = 64;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_PMD_ZSDA_MAX_PCI_DEVICES: u32 = 256;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1] = b"\0";
pub const _ALLOCA_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RTE_UUID_STRLEN: u32 = 37;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MP_MAX_FD_NUM: u32 = 253;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const RTE_THREAD_NAME_SIZE: u32 = 16;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_THREAD_INTERNAL_PREFIX: &[u8; 6] = b"dpdk-\0";
pub const RTE_THREAD_INTERNAL_NAME_SIZE: u32 = 11;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MPLOCKED: &[u8; 8] = b"lock ; \0";
pub const _RTE_RTM_H_: u32 = 1;
pub const __SAVE_GPRBX: &[u8; 30] = b"mov {%%rbx, %%rax |rax, rbx};\0";
pub const __RESTORE_GPRBX: &[u8; 30] = b"mov {%%rax, %%rbx |rbx, rax};\0";
pub const __TMPGPR: &[u8; 4] = b"rax\0";
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _MM_PCOMCTRL_LT: u32 = 0;
pub const _MM_PCOMCTRL_LE: u32 = 1;
pub const _MM_PCOMCTRL_GT: u32 = 2;
pub const _MM_PCOMCTRL_GE: u32 = 3;
pub const _MM_PCOMCTRL_EQ: u32 = 4;
pub const _MM_PCOMCTRL_NEQ: u32 = 5;
pub const _MM_PCOMCTRL_FALSE: u32 = 6;
pub const _MM_PCOMCTRL_TRUE: u32 = 7;
pub const __RDPRU_MPERF: u32 = 0;
pub const __RDPRU_APERF: u32 = 1;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_LOG_MAX: u32 = 8;
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_RWLOCK_WAIT: u32 = 1;
pub const RTE_RWLOCK_WRITE: u32 = 2;
pub const RTE_RWLOCK_MASK: u32 = 3;
pub const RTE_RWLOCK_READ: u32 = 4;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4] = b"RG_\0";
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RING_F_MP_RTS_ENQ: u32 = 8;
pub const RING_F_MC_RTS_DEQ: u32 = 16;
pub const RING_F_MP_HTS_ENQ: u32 = 32;
pub const RING_F_MC_HTS_DEQ: u32 = 64;
pub const XMM_SIZE: u32 = 16;
pub const XMM_MASK: u32 = 15;
pub const ALIGNMENT_MASK: u32 = 15;
pub const _CTYPE_H: u32 = 1;
pub const LIBBSD_SYS_TIME_BITS: u32 = 64;
pub const LIBBSD_SYS_HAS_TIME64: u32 = 1;
pub const __RTE_TRACE_EMIT_STRING_LEN_MAX: u32 = 32;
pub const RTE_TRACE_BLOB_LEN_MAX: u32 = 64;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const RTE_MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const RTE_MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const RTE_MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_F_NON_IO: u32 = 64;
pub const RTE_MEMPOOL_VALID_USER_FLAGS: u32 = 47;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_ESP: u32 = 2048;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_ESP: u32 = 134217728;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_MBUF_F_RX_VLAN: u32 = 1;
pub const RTE_MBUF_F_RX_RSS_HASH: u32 = 2;
pub const RTE_MBUF_F_RX_FDIR: u32 = 4;
pub const RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD: u32 = 32;
pub const RTE_MBUF_F_RX_VLAN_STRIPPED: u32 = 64;
pub const RTE_MBUF_F_RX_IP_CKSUM_MASK: u32 = 144;
pub const RTE_MBUF_F_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_IP_CKSUM_BAD: u32 = 16;
pub const RTE_MBUF_F_RX_IP_CKSUM_GOOD: u32 = 128;
pub const RTE_MBUF_F_RX_IP_CKSUM_NONE: u32 = 144;
pub const RTE_MBUF_F_RX_L4_CKSUM_MASK: u32 = 264;
pub const RTE_MBUF_F_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_L4_CKSUM_BAD: u32 = 8;
pub const RTE_MBUF_F_RX_L4_CKSUM_GOOD: u32 = 256;
pub const RTE_MBUF_F_RX_L4_CKSUM_NONE: u32 = 264;
pub const RTE_MBUF_F_RX_IEEE1588_PTP: u32 = 512;
pub const RTE_MBUF_F_RX_IEEE1588_TMST: u32 = 1024;
pub const RTE_MBUF_F_RX_FDIR_ID: u32 = 8192;
pub const RTE_MBUF_F_RX_FDIR_FLX: u32 = 16384;
pub const RTE_MBUF_F_RX_QINQ_STRIPPED: u32 = 32768;
pub const RTE_MBUF_F_RX_LRO: u32 = 65536;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD: u32 = 262144;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const RTE_MBUF_F_RX_QINQ: u32 = 1048576;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const RTE_MBUF_F_FIRST_FREE: u32 = 8388608;
pub const RTE_MBUF_F_LAST_FREE: u64 = 1099511627776;
pub const RTE_MBUF_F_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const RTE_MBUF_F_TX_UDP_SEG: u64 = 4398046511104;
pub const RTE_MBUF_F_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const RTE_MBUF_F_TX_MACSEC: u64 = 17592186044416;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const RTE_MBUF_F_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const RTE_MBUF_F_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const RTE_MBUF_F_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const RTE_MBUF_F_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const RTE_MBUF_F_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const RTE_MBUF_F_TX_TUNNEL_ESP: u64 = 281474976710656;
pub const RTE_MBUF_F_TX_TUNNEL_IP: u64 = 457396837154816;
pub const RTE_MBUF_F_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const RTE_MBUF_F_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const RTE_MBUF_F_TX_QINQ: u64 = 562949953421312;
pub const RTE_MBUF_F_TX_TCP_SEG: u64 = 1125899906842624;
pub const RTE_MBUF_F_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const RTE_MBUF_F_TX_L4_NO_CKSUM: u32 = 0;
pub const RTE_MBUF_F_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const RTE_MBUF_F_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const RTE_MBUF_F_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_L4_MASK: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_IP_CKSUM: u64 = 18014398509481984;
pub const RTE_MBUF_F_TX_IPV4: u64 = 36028797018963968;
pub const RTE_MBUF_F_TX_IPV6: u64 = 72057594037927936;
pub const RTE_MBUF_F_TX_VLAN: u64 = 144115188075855872;
pub const RTE_MBUF_F_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const RTE_MBUF_F_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const RTE_MBUF_F_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const RTE_MBUF_F_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_F_EXTERNAL: u64 = 2305843009213693952;
pub const RTE_MBUF_F_INDIRECT: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const MBUF_INVALID_PORT: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
#[doc = " Physical address"]
pub type phys_addr_t = u64;
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Generic marker for any place in a structure."]
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
#[doc = " Marker for 1B alignment in a structure."]
pub type RTE_MARKER8 = [u8; 0usize];
#[doc = " Marker for 2B alignment in a structure."]
pub type RTE_MARKER16 = [u16; 0usize];
#[doc = " Marker for 4B alignment in a structure."]
pub type RTE_MARKER32 = [u32; 0usize];
#[doc = " Marker for 8B alignment in a structure."]
pub type RTE_MARKER64 = [u64; 0usize];
unsafe extern "C" {
    #[doc = " Converts a numeric string to the equivalent uint64_t value.\n As well as straight number conversion, also recognises the suffixes\n k, m and g for kilobytes, megabytes and gigabytes respectively.\n\n If a negative number is passed in  i.e. a string with the first non-black\n character being \"-\", zero is returned. Zero is also returned in the case of\n an error with the strtoull call in the function.\n\n @param str\n     String containing number to convert.\n @return\n     Number."]
    pub fn rte_str_to_size(str_: *const ::std::os::raw::c_char) -> u64;
}
unsafe extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error\n message and returning the exit_code back to the shell.\n\n This function never returns\n\n @param exit_code\n     The exit code to be returned by the application\n @param format\n     The format string to be used for printing the message. This can include\n     printf format characters which will be expanded using any further parameters\n     to the function."]
    pub fn rte_exit(
        exit_code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
#[doc = " Struct describing a Universal Unique Identifier"]
pub type rte_uuid_t = [::std::os::raw::c_uchar; 16usize];
unsafe extern "C" {
    #[doc = " Test if UUID is all zeros.\n\n @param uu\n    The uuid to check.\n @return\n    true if uuid is NULL value, false otherwise"]
    pub fn rte_uuid_is_null(uu: *const ::std::os::raw::c_uchar) -> bool;
}
unsafe extern "C" {
    #[doc = " Compare two UUID's\n\n @param a\n    A UUID to compare\n @param b\n    A UUID to compare\n @return\n   returns an integer less than, equal to, or greater than zero if UUID a is\n   is less than, equal, or greater than UUID b."]
    pub fn rte_uuid_compare(
        a: *const ::std::os::raw::c_uchar,
        b: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Extract UUID from string\n\n @param in\n    Pointer to string of characters to convert\n @param uu\n    Destination UUID\n @return\n    Returns 0 on success, and -1 if string is not a valid UUID."]
    pub fn rte_uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Convert UUID to string\n\n @param uu\n    UUID to format\n @param out\n    Resulting string buffer\n @param len\n    Sizeof the available string buffer"]
    pub fn rte_uuid_unparse(
        uu: *const ::std::os::raw::c_uchar,
        out: *mut ::std::os::raw::c_char,
        len: usize,
    );
}
pub const rte_intr_mode_RTE_INTR_MODE_NONE: rte_intr_mode = 0;
pub const rte_intr_mode_RTE_INTR_MODE_LEGACY: rte_intr_mode = 1;
pub const rte_intr_mode_RTE_INTR_MODE_MSI: rte_intr_mode = 2;
pub const rte_intr_mode_RTE_INTR_MODE_MSIX: rte_intr_mode = 3;
pub type rte_intr_mode = ::std::os::raw::c_uint;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
#[doc = " The type of process in a linux, multi-process setup"]
pub type rte_proc_type_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Get the process type in a multi-process setup\n\n @return\n   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
unsafe extern "C" {
    #[doc = " Request iopl privilege for all RPL.\n\n This function should be called by pmds which need access to ioports.\n\n @return\n   - On success, returns 0.\n   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL).\n\n This function is to be executed on the MAIN lcore only, as soon\n as possible in the application's main() function.\n It puts the WORKER lcores in the WAIT state.\n\n @param argc\n   A non-negative value.  If it is greater than 0, the array members\n   for argv[0] through argv[argc] (non-inclusive) shall contain pointers\n   to strings.\n @param argv\n   An array of strings.  The contents of the array, as well as the strings\n   which are pointed to by the array, may be modified by this function.\n   The program name pointer argv[0] is copied into the last parsed argv\n   so that argv[0] is still the same after deducing the parsed arguments.\n @return\n   - On success, the number of parsed arguments, which is greater or\n     equal to zero. After the call to rte_eal_init(),\n     all arguments argv[x] with x < ret may have been modified by this\n     function call and should not be further interpreted by the\n     application.  The EAL does not take any ownership of the memory used\n     for either the argv array, or its members.\n   - On failure, -1 and rte_errno is set to a value indicating the cause\n     for failure.  In some instances, the application will need to be\n     restarted as part of clearing the issue.\n\n   Error codes returned via rte_errno:\n     EACCES indicates a permissions issue.\n\n     EAGAIN indicates either a bus or system resource was not available,\n            setup may be attempted again.\n\n     EALREADY indicates that the rte_eal_init function has already been\n              called, and cannot be called again.\n\n     EFAULT indicates the tailq configuration name was not found in\n            memory configuration.\n\n     EINVAL indicates invalid parameters were passed as argv/argc.\n\n     ENOMEM indicates failure likely caused by an out-of-memory condition.\n\n     ENODEV indicates memory setup issues.\n\n     ENOTSUP indicates that the EAL cannot initialize on this system.\n\n     EPROTO indicates that the PCI bus is either not present, or is not\n            readable by the eal.\n\n     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)\n\n This function must be called to release any internal resources that EAL has\n allocated during rte_eal_init(). After this call, no DPDK function calls may\n be made. It is expected that common usage of this function is to call it\n just before terminating the process.\n\n @return\n  - 0 Successfully released all internal EAL resources.\n  - -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a primary process is currently alive\n\n This function returns true when a primary process is currently\n active.\n\n @param config_file_path\n   The config_file_path argument provided should point at the location\n   that the primary process will create its config file. If NULL, the default\n   config file path is used.\n\n @return\n  - If alive, returns 1.\n  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 253usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[doc = " Action function typedef used by other components.\n\n As we create  socket channel for primary/secondary communication, use\n this function typedef to register action for coming messages.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components.\n\n As we create socket channel for primary/secondary communication, use\n this function typedef to register action for coming responses to asynchronous\n requests.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Usage function typedef used by the application usage function.\n\n Use this function typedef to define and call rte_set_application_usage_hook()\n routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine.\n\n This function allows the application to include its usage message\n in the EAL system usage message. The routine rte_set_application_usage_hook()\n needs to be called before the rte_eal_init() routine in the application.\n\n This routine is optional for the application and will behave as if the set\n routine was never called as the default behavior.\n\n @param usage_func\n   The func argument is a function pointer to the application usage routine.\n   Called function is defined using rte_usage_hook_t typedef, which is of\n   the form void rte_usage_func(const char * prgname).\n\n   Calling this routine with a NULL value will reset the usage hook routine and\n   return the current value, which could be NULL.\n @return\n   - Returns the current value of the rte_application_usage pointer to allow\n     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option).\n The no-huge mode is not compatible with all drivers or features.\n\n @return\n   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using PCI bus.\n Disabled by --no-pci option.\n\n @return\n   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device.\n\n @return\n   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The user-configured vfio interrupt mode.\n\n @return\n   Interrupt mode configured with the command line,\n   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
unsafe extern "C" {
    #[doc = " Copy the user-configured vfio VF token.\n\n @param vf_token\n   vfio VF token configured with the command line is copied\n   into this parameter, zero uuid by default."]
    pub fn rte_eal_vfio_get_vf_token(vf_token: *mut ::std::os::raw::c_uchar);
}
unsafe extern "C" {
    #[doc = " A wrap API for syscall gettid.\n\n @return\n   On success, returns the thread ID of calling process.\n   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut per_lcore__thread_id: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the OS-specific EAL base address.\n\n @return\n    The base address."]
    pub fn rte_eal_get_baseaddr() -> u64;
}
pub const rte_iova_mode_RTE_IOVA_DC: rte_iova_mode = 0;
pub const rte_iova_mode_RTE_IOVA_PA: rte_iova_mode = 1;
pub const rte_iova_mode_RTE_IOVA_VA: rte_iova_mode = 2;
#[doc = " IOVA mapping mode.\n\n IOVA mapping mode is iommu programming mode of a device.\n That device (for example: IOMMU backed DMA device) based\n on rte_iova_mode will generate physical or virtual address."]
pub type rte_iova_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the iova mode\n\n @return\n   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
unsafe extern "C" {
    #[doc = " Get user provided pool ops name for mbuf\n\n @return\n   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the runtime directory of DPDK\n\n @return\n  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a string describing a mask of core ids into an array of core ids.\n\n On success, the passed array is filled with the orders of the core ids\n present in the mask (-1 indicating that a core id is absent).\n For example, passing a 0xa coremask results in cores[1] = 0, cores[3] = 1,\n and the rest of the array is set to -1.\n\n @param coremask\n   A string describing a mask of core ids.\n @param cores\n   An array where to store the core ids orders.\n   This array must be at least RTE_MAX_LCORE large.\n @return\n   0 on success, -1 if the string content was invalid."]
    pub fn rte_eal_parse_coremask(
        coremask: *const ::std::os::raw::c_char,
        cores: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
#[doc = " State of an lcore."]
pub type rte_lcore_state_t = ::std::os::raw::c_uint;
#[doc = " Definition of a remote launch function."]
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Launch a function on another lcore.\n\n To be executed on the MAIN lcore only.\n\n Sends a message to a worker lcore (identified by the worker_id) that\n is in the WAIT state (this is true after the first call to\n rte_eal_init()). This can be checked by first calling\n rte_eal_wait_lcore(worker_id).\n\n When the remote lcore receives the message, it switches to\n the RUNNING state, then calls the function f with argument arg. Once the\n execution is done, the remote lcore switches to WAIT state and\n the return value of f is stored in a local variable to be read using\n rte_eal_wait_lcore().\n\n The MAIN lcore returns as soon as the message is sent and knows\n nothing about the completion of f.\n\n Note: This function is not designed to offer optimum\n performance. It is just a practical way to launch a function on\n another lcore at initialization time.\n\n @param f\n   The function to be called.\n @param arg\n   The argument for the function.\n @param worker_id\n   The identifier of the lcore on which the function should be executed.\n @return\n   - 0: Success. Execution of function f started on the remote lcore.\n   - (-EBUSY): The remote lcore is not in a WAIT state.\n   - (-EPIPE): Error reading or writing pipe to worker thread"]
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        worker_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< lcore handler not executed by main core."]
pub const rte_rmt_call_main_t_SKIP_MAIN: rte_rmt_call_main_t = 0;
#[doc = "< lcore handler executed by main core."]
pub const rte_rmt_call_main_t_CALL_MAIN: rte_rmt_call_main_t = 1;
#[doc = " This enum indicates whether the main core must execute the handler\n launched on all logical cores."]
pub type rte_rmt_call_main_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Launch a function on all lcores.\n\n Check that each WORKER lcore is in a WAIT state, then call\n rte_eal_remote_launch() for each lcore.\n\n @param f\n   The function to be called.\n @param arg\n   The argument for the function.\n @param call_main\n   If call_main set to SKIP_MAIN, the MAIN lcore does not call\n   the function. If call_main is set to CALL_MAIN, the function\n   is also called on main before returning. In any case, the main\n   lcore returns as soon as it finished its job and knows nothing\n   about the completion of f on the other lcores.\n @return\n   - 0: Success. Execution of function f started on all remote lcores.\n   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this\n     case, no message is sent to any of the lcores."]
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_main: rte_rmt_call_main_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the state of the lcore identified by worker_id.\n\n To be executed on the MAIN lcore only.\n\n @param worker_id\n   The identifier of the lcore.\n @return\n   The state of the lcore."]
    pub fn rte_eal_get_lcore_state(worker_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
unsafe extern "C" {
    #[doc = " Wait until an lcore finishes its job.\n\n To be executed on the MAIN lcore only.\n\n If the lcore identified by the worker_id is in RUNNING state, wait until\n the lcore finishes its job and moves to the WAIT state.\n\n @param worker_id\n   The identifier of the lcore.\n @return\n   - 0: If the remote launch function was never called on the lcore\n     identified by the worker_id.\n   - The value that was returned by the previous remote launch\n     function call."]
    pub fn rte_eal_wait_lcore(worker_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Wait until all lcores finish their jobs.\n\n To be executed on the MAIN lcore only. Issue an\n rte_eal_wait_lcore() for every lcore. The return values are\n ignored.\n\n After a call to rte_eal_mp_wait_lcore(), the caller can assume\n that all worker lcores are in a WAIT state."]
    pub fn rte_eal_mp_wait_lcore();
}
#[doc = " Thread id descriptor."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_t {
    #[doc = "< thread identifier"]
    pub opaque_id: usize,
}
#[doc = " Thread function\n\n Function pointer to thread start routine.\n\n @param arg\n   Argument passed to rte_thread_create().\n @return\n   Thread function exit value."]
pub type rte_thread_func =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> u32>;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_NORMAL: rte_thread_priority = 0;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_REALTIME_CRITICAL: rte_thread_priority = 1;
#[doc = " Thread priority values."]
pub type rte_thread_priority = ::std::os::raw::c_uint;
#[doc = " Representation for thread attributes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_attr_t {
    #[doc = "< thread priority"]
    pub priority: rte_thread_priority,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eal_tls_key {
    _unused: [u8; 0],
}
#[doc = " TLS key type, an opaque pointer."]
pub type rte_thread_key = *mut eal_tls_key;
unsafe extern "C" {
    #[doc = " Create a new thread that will invoke the 'thread_func' routine.\n\n @param thread_id\n    A pointer that will store the id of the newly created thread.\n\n @param thread_attr\n    Attributes that are used at the creation of the new thread.\n\n @param thread_func\n    The routine that the new thread will invoke when starting execution.\n\n @param arg\n    Argument to be passed to the 'thread_func' routine.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_create(
        thread_id: *mut rte_thread_t,
        thread_attr: *const rte_thread_attr_t,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a control thread.\n\n Creates a control thread with the given name and attributes. The\n affinity of the new thread is based on the CPU affinity retrieved\n at the time rte_eal_init() was called, the EAL threads are then\n excluded. If setting the name of the thread fails, the error is\n ignored and a debug message is logged.\n\n @param thread\n   Filled with the thread id of the new created thread.\n @param name\n   The name of the control thread\n   (max RTE_THREAD_NAME_SIZE characters including '\\0').\n @param thread_func\n   Function to be executed by the new thread.\n @param arg\n   Argument passed to thread_func.\n @return\n   On success, returns 0; on error, it returns a negative value\n   corresponding to the error number."]
    pub fn rte_thread_create_control(
        thread: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create an internal control thread.\n\n Creates a control thread with the given name prefixed.\n If setting the name of the thread fails, the error is ignored and logged.\n\n The affinity of the new thread is based on the CPU affinity retrieved\n at the time rte_eal_init() was called, the EAL threads are then excluded.\n\n @param id\n   Filled with the thread ID of the new created thread.\n @param name\n   The name of the control thread.\n   See RTE_THREAD_INTERNAL_NAME_SIZE for maximum length.\n   The name of the driver or library should be first,\n   then followed by a hyphen and more details.\n   It will be prefixed with RTE_THREAD_INTERNAL_PREFIX by this function.\n @param func\n   Function to be executed by the new thread.\n @param arg\n   Argument passed to func.\n @return\n   On success, returns 0; a negative value otherwise."]
    pub fn rte_thread_create_internal_control(
        id: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Waits for the thread identified by 'thread_id' to terminate\n\n @param thread_id\n    The identifier of the thread.\n\n @param value_ptr\n    Stores the exit status of the thread.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_join(thread_id: rte_thread_t, value_ptr: *mut u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Indicate that the return value of the thread is not needed and\n all thread resources should be release when the thread terminates.\n\n @param thread_id\n    The id of the thread to be detached.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_detach(thread_id: rte_thread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the id of the calling thread.\n\n @return\n   Return the thread id of the calling thread."]
    pub fn rte_thread_self() -> rte_thread_t;
}
unsafe extern "C" {
    #[doc = " Set the name of the thread.\n\n This API is a noop if the underlying platform does not\n support setting the thread name or the platform-specific\n API used to set the thread name fails.\n\n @param thread_id\n    The id of the thread to set name.\n\n @param thread_name\n    The name to set. Truncated to RTE_THREAD_NAME_SIZE,\n    including terminating NUL if necessary."]
    pub fn rte_thread_set_name(thread_id: rte_thread_t, thread_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the name of an internal thread with the common prefix.\n\n This API is a noop if the underlying platform does not support\n setting the thread name, or if it fails.\n\n @param id\n   The ID of the thread to set name.\n\n @param name\n   The name to set after being prefixed.\n   See RTE_THREAD_INTERNAL_NAME_SIZE for maximum length.\n   The name of the driver or library should be first,\n   then followed by a hyphen and more details.\n   It will be prefixed with RTE_THREAD_INTERNAL_PREFIX by this function."]
    pub fn rte_thread_set_prefixed_name(id: rte_thread_t, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Check if 2 thread ids are equal.\n\n @param t1\n   First thread id.\n\n @param t2\n   Second thread id.\n\n @return\n   If the ids are equal, return nonzero.\n   Otherwise, return 0."]
    pub fn rte_thread_equal(t1: rte_thread_t, t2: rte_thread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize the attributes of a thread.\n These attributes can be passed to the rte_thread_create() function\n that will create a new thread and set its attributes according to attr.\n\n @param attr\n   Thread attributes to initialize.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_attr_init(attr: *mut rte_thread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the thread priority value in the thread attributes pointed to\n by 'thread_attr'.\n\n @param thread_attr\n   Points to the thread attributes in which priority will be updated.\n\n @param priority\n   Points to the value of the priority to be set.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_attr_set_priority(
        thread_attr: *mut rte_thread_attr_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the priority of a thread.\n\n @param thread_id\n   Id of the thread for which to get priority.\n\n @param priority\n   Location to store the retrieved priority.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_get_priority(
        thread_id: rte_thread_t,
        priority: *mut rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the priority of a thread.\n\n @param thread_id\n   Id of the thread for which to set priority.\n\n @param priority\n   Priority value to be set.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_set_priority(
        thread_id: rte_thread_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a TLS data key visible to all threads in the process.\n the created key is later used to get/set a value.\n and optional destructor can be set to be called when a thread exits.\n\n @param key\n   Pointer to store the allocated key.\n @param destructor\n   The function to be called when the thread exits.\n   Ignored on Windows OS.\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: ENOMEM  - Memory allocation error.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_create(
        key: *mut rte_thread_key,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a TLS data key visible to all threads in the process.\n\n @param key\n   The key allocated by rte_thread_key_create().\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_delete(key: rte_thread_key) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set value bound to the TLS key on behalf of the calling thread.\n\n @param key\n   The key allocated by rte_thread_key_create().\n @param value\n   The value bound to the rte_thread_key key for the calling thread.\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_set(
        key: rte_thread_key,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get value bound to the TLS key on behalf of the calling thread.\n\n @param key\n   The key allocated by rte_thread_key_create().\n\n @return\n   On success, value data pointer (can also be NULL).\n   On failure, NULL and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_get(key: rte_thread_key) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "< Per thread \"lcore id\"."]
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
pub const rte_lcore_role_t_ROLE_NON_EAL: rte_lcore_role_t = 3;
#[doc = " The lcore role (used in RTE or not)."]
pub type rte_lcore_role_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get a lcore's role.\n\n @param lcore_id\n   The identifier of the lcore, which MUST be between 0 and RTE_MAX_LCORE-1.\n @return\n   The role of the lcore."]
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
unsafe extern "C" {
    #[doc = " Get the id of the main lcore\n\n @return\n   the id of the main lcore"]
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return the ID of the physical socket of the logical core we are\n running on.\n @return\n   the ID of current lcoreid's physical socket"]
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return number of physical sockets detected on the system.\n\n Note that number of nodes may not be correspondent to their physical id's:\n for example, a system may report two socket id's, but the actual socket id's\n may be 0 and 8.\n\n @return\n   the number of physical sockets as recognized by EAL"]
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return socket id with a particular index.\n\n This will return socket id at a particular position in list of all detected\n physical socket id's. For example, on a machine with sockets [0, 8], passing\n 1 as a parameter will return 8.\n\n @param idx\n   index of physical socket id to return\n\n @return\n   - physical socket id as recognized by EAL\n   - -1 on error, with errno set to EINVAL"]
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next enabled lcore ID.\n\n @param i\n   The current lcore (reference).\n @param skip_main\n   If true, do not return the ID of the main lcore.\n @param wrap\n   If true, go back to 0 when RTE_MAX_LCORE is reached; otherwise,\n   return RTE_MAX_LCORE.\n @return\n   The next lcore_id or RTE_MAX_LCORE if not found."]
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_main: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Callback prototype for initializing lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer passed at callback registration.\n @return\n   - -1 when refusing this operation,\n   - 0 otherwise."]
pub type rte_lcore_init_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback prototype for uninitializing lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer passed at callback registration."]
pub type rte_lcore_uninit_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void),
>;
#[doc = " Callback prototype for iterating over lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer coming from the caller.\n @return\n   - 0 lets the iteration continue.\n   - !0 makes the iteration stop."]
pub type rte_lcore_iterate_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " lcore usage statistics."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_lcore_usage {
    #[doc = " The total amount of time that the application has been running on\n this lcore, in TSC cycles."]
    pub total_cycles: u64,
    #[doc = " The amount of time the application was busy, handling some\n workload on this lcore, in TSC cycles."]
    pub busy_cycles: u64,
}
#[doc = " Callback to allow applications to report lcore usage.\n\n @param [in] lcore_id\n   The lcore to consider.\n @param [out] usage\n   Counters representing this lcore usage. This can never be NULL.\n @return\n   - 0 if fields in usage were updated successfully. The fields that the\n     application does not support must not be modified.\n   - a negative value if the information is not available or if any error\n     occurred."]
pub type rte_lcore_usage_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        usage: *mut rte_lcore_usage,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register current non-EAL thread as a lcore.\n\n @note This API is not compatible with the multi-process feature:\n - if a primary process registers a non-EAL thread, then no secondary process\n   will initialise.\n - if a secondary process initialises successfully, trying to register a\n   non-EAL thread from either primary or secondary processes will always end\n   up with the thread getting LCORE_ID_ANY as lcore.\n\n @return\n   On success, return 0; otherwise return -1 with rte_errno set."]
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister current thread and release lcore if one was associated."]
    pub fn rte_thread_unregister();
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mm_sfence();
}
unsafe extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = [__BindgenFloat16; 8usize];
pub type __m128h = [__BindgenFloat16; 8usize];
pub type __m128h_u = [__BindgenFloat16; 8usize];
pub type __v8bf = u128;
pub type __m128bh = u128;
unsafe extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _mm_lfence();
}
unsafe extern "C" {
    pub fn _mm_mfence();
}
unsafe extern "C" {
    pub fn _mm_pause();
}
pub type rte_memory_order = ::std::os::raw::c_int;
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic16_t {
    #[doc = "< An internal counter value."]
    pub cnt: i16,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic32_t {
    #[doc = "< An internal counter value."]
    pub cnt: i32,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic64_t {
    #[doc = "< Internal counter value."]
    pub cnt: i64,
}
#[doc = " 128-bit integer structure."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[doc = " The rte_spinlock_recursive_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    #[doc = "< the actual spinlock"]
    pub sl: rte_spinlock_t,
    #[doc = "< core id using lock, -1 for unused"]
    pub user: ::std::os::raw::c_int,
    #[doc = "< count of time this lock has been called"]
    pub count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __uintr_frame {
    pub rip: ::std::os::raw::c_ulonglong,
    pub rflags: ::std::os::raw::c_ulonglong,
    pub rsp: ::std::os::raw::c_ulonglong,
}
pub const _CMPCCX_ENUM__CMPCCX_O: _CMPCCX_ENUM = 0;
pub const _CMPCCX_ENUM__CMPCCX_NO: _CMPCCX_ENUM = 1;
pub const _CMPCCX_ENUM__CMPCCX_B: _CMPCCX_ENUM = 2;
pub const _CMPCCX_ENUM__CMPCCX_NB: _CMPCCX_ENUM = 3;
pub const _CMPCCX_ENUM__CMPCCX_Z: _CMPCCX_ENUM = 4;
pub const _CMPCCX_ENUM__CMPCCX_NZ: _CMPCCX_ENUM = 5;
pub const _CMPCCX_ENUM__CMPCCX_BE: _CMPCCX_ENUM = 6;
pub const _CMPCCX_ENUM__CMPCCX_NBE: _CMPCCX_ENUM = 7;
pub const _CMPCCX_ENUM__CMPCCX_S: _CMPCCX_ENUM = 8;
pub const _CMPCCX_ENUM__CMPCCX_NS: _CMPCCX_ENUM = 9;
pub const _CMPCCX_ENUM__CMPCCX_P: _CMPCCX_ENUM = 10;
pub const _CMPCCX_ENUM__CMPCCX_NP: _CMPCCX_ENUM = 11;
pub const _CMPCCX_ENUM__CMPCCX_L: _CMPCCX_ENUM = 12;
pub const _CMPCCX_ENUM__CMPCCX_NL: _CMPCCX_ENUM = 13;
pub const _CMPCCX_ENUM__CMPCCX_LE: _CMPCCX_ENUM = 14;
pub const _CMPCCX_ENUM__CMPCCX_NLE: _CMPCCX_ENUM = 15;
pub type _CMPCCX_ENUM = ::std::os::raw::c_uint;
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v16hf = [__BindgenFloat16; 16usize];
pub type __m256h = [__BindgenFloat16; 16usize];
pub type __m256h_u = [__BindgenFloat16; 16usize];
pub type __v16bf = __BindgenOpaqueArray<u8, 32usize>;
pub type __m256bh = __BindgenOpaqueArray<u8, 32usize>;
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __v64qs = [::std::os::raw::c_schar; 64usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = ::std::os::raw::c_uint;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = ::std::os::raw::c_uint;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_A: _MM_TERNLOG_ENUM = 240;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_B: _MM_TERNLOG_ENUM = 204;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_C: _MM_TERNLOG_ENUM = 170;
pub type _MM_TERNLOG_ENUM = ::std::os::raw::c_uint;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __v32hf = [__BindgenFloat16; 32usize];
pub type __m512h = [__BindgenFloat16; 32usize];
pub type __m512h_u = [__BindgenFloat16; 32usize];
pub type __v32bf = __BindgenOpaqueArray<u8, 64usize>;
pub type __m512bh = __BindgenOpaqueArray<u8, 64usize>;
pub type __bfloat16 = u16;
pub type _tile1024i = [::std::os::raw::c_int; 256usize];
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct __tile1024i_str {
    pub row: ::std::os::raw::c_ushort,
    pub col: ::std::os::raw::c_ushort,
    pub __bindgen_padding_0: [u64; 7usize],
    pub tile: _tile1024i,
}
pub type __tile1024i = __tile1024i_str;
#[doc = "< SSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
#[doc = "< PCLMULQDQ"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
#[doc = "< DTES64"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
#[doc = "< MONITOR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
#[doc = "< DS_CPL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
#[doc = "< VMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
#[doc = "< SMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
#[doc = "< EIST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
#[doc = "< TM2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
#[doc = "< SSSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
#[doc = "< CNXT_ID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
#[doc = "< FMA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
#[doc = "< CMPXCHG16B"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
#[doc = "< XTPR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
#[doc = "< PDCM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
#[doc = "< PCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
#[doc = "< DCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
#[doc = "< SSE4_1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
#[doc = "< SSE4_2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
#[doc = "< X2APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
#[doc = "< MOVBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
#[doc = "< POPCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
#[doc = "< TSC_DEADLINE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
#[doc = "< AES"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
#[doc = "< XSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
#[doc = "< OSXSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
#[doc = "< AVX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
#[doc = "< F16C"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
#[doc = "< RDRAND"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
#[doc = "< Running in a VM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HYPERVISOR: rte_cpu_flag_t = 29;
#[doc = "< FPU"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 30;
#[doc = "< VME"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 31;
#[doc = "< DE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 32;
#[doc = "< PSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 33;
#[doc = "< TSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 34;
#[doc = "< MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 35;
#[doc = "< PAE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 36;
#[doc = "< MCE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 37;
#[doc = "< CX8"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 38;
#[doc = "< APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 39;
#[doc = "< SEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 40;
#[doc = "< MTRR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 41;
#[doc = "< PGE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 42;
#[doc = "< MCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 43;
#[doc = "< CMOV"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 44;
#[doc = "< PAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 45;
#[doc = "< PSE36"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 46;
#[doc = "< PSN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 47;
#[doc = "< CLFSH"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 48;
#[doc = "< DS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 49;
#[doc = "< ACPI"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 50;
#[doc = "< MMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 51;
#[doc = "< FXSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 52;
#[doc = "< SSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 53;
#[doc = "< SSE2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 54;
#[doc = "< SS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 55;
#[doc = "< HTT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 56;
#[doc = "< TM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 57;
#[doc = "< PBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 58;
#[doc = "< DIGTEMP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 59;
#[doc = "< TRBOBST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 60;
#[doc = "< ARAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 61;
#[doc = "< PLN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 62;
#[doc = "< ECMD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 63;
#[doc = "< PTM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 64;
#[doc = "< MPERF_APERF_MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 65;
#[doc = "< ACNT2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 66;
#[doc = "< ENERGY_EFF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 67;
#[doc = "< FSGSBASE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 68;
#[doc = "< BMI1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 69;
#[doc = "< Hardware Lock elision"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 70;
#[doc = "< AVX2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 71;
#[doc = "< SMEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 72;
#[doc = "< BMI2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 73;
#[doc = "< ERMS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 74;
#[doc = "< INVPCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 75;
#[doc = "< Transactional memory"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 76;
#[doc = "< AVX512F"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 77;
#[doc = "< RDSEED instruction"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDSEED: rte_cpu_flag_t = 78;
#[doc = "< LAHF_SAHF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 79;
#[doc = "< LZCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 80;
#[doc = "< SYSCALL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 81;
#[doc = "< XD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 82;
#[doc = "< 1GB_PG"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 83;
#[doc = "< RDTSCP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 84;
#[doc = "< EM64T"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 85;
#[doc = "< INVTSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 86;
#[doc = "< AVX512 Doubleword and Quadword"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512DQ: rte_cpu_flag_t = 87;
#[doc = "< AVX512 Integer Fused Multiply-Add"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512IFMA: rte_cpu_flag_t = 88;
#[doc = "< AVX512 Conflict Detection"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512CD: rte_cpu_flag_t = 89;
#[doc = "< AVX512 Byte and Word"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BW: rte_cpu_flag_t = 90;
#[doc = "< AVX512 Vector Length"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VL: rte_cpu_flag_t = 91;
#[doc = "< AVX512 Vector Bit Manipulation"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI: rte_cpu_flag_t = 92;
#[doc = "< AVX512 Vector Bit Manipulation 2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI2: rte_cpu_flag_t = 93;
#[doc = "< Galois Field New Instructions"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_GFNI: rte_cpu_flag_t = 94;
#[doc = "< Vector AES"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VAES: rte_cpu_flag_t = 95;
#[doc = "< Vector Carry-less Multiply"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VPCLMULQDQ: rte_cpu_flag_t = 96;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VNNI: rte_cpu_flag_t = 97;
#[doc = "< AVX512 Bit Algorithms"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BITALG: rte_cpu_flag_t = 98;
#[doc = "< AVX512 Vector Popcount"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VPOPCNTDQ: rte_cpu_flag_t = 99;
#[doc = "< Cache Line Demote"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLDEMOTE: rte_cpu_flag_t = 100;
#[doc = "< Direct Store Instructions"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIRI: rte_cpu_flag_t = 101;
#[doc = "< Direct Store Instructions 64B"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIR64B: rte_cpu_flag_t = 102;
#[doc = "< AVX512 Two Register Intersection"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VP2INTERSECT: rte_cpu_flag_t = 103;
#[doc = "< UMONITOR/UMWAIT/TPAUSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_WAITPKG: rte_cpu_flag_t = 104;
#[doc = "< MONITORX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITORX: rte_cpu_flag_t = 105;
#[doc = " Enumeration of all CPU features supported"]
pub type rte_cpu_flag_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[doc = " Structure used to describe platform-specific intrinsics that may or may not\n be supported at runtime."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_cpu_intrinsics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_cpu_intrinsics {
    #[inline]
    pub fn power_monitor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_monitor_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_monitor_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_pause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_pause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_pause_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_pause_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_monitor_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_monitor_multi_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_monitor_multi_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        power_monitor: u32,
        power_pause: u32,
        power_monitor_multi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let power_monitor: u32 = unsafe { ::std::mem::transmute(power_monitor) };
            power_monitor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_pause: u32 = unsafe { ::std::mem::transmute(power_pause) };
            power_pause as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let power_monitor_multi: u32 = unsafe { ::std::mem::transmute(power_monitor_multi) };
            power_monitor_multi as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " Check CPU support for various intrinsics at runtime.\n\n @param intrinsics\n     Pointer to a structure to be filled."]
    pub fn rte_cpu_get_intrinsics_support(intrinsics: *mut rte_cpu_intrinsics);
}
unsafe extern "C" {
    #[doc = " Get name of CPU flag\n\n @param feature\n     CPU flag ID\n @return\n     flag name\n     NULL if flag ID is invalid"]
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Function for checking a CPU flag availability\n\n @param feature\n     CPU flag to query CPU for\n @return\n     1 if flag is available\n     0 if flag is not available\n     -ENOENT if flag is invalid"]
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features\n that were specified at compile time. It is called automatically within the\n EAL, so does not need to be used by applications.  This version returns a\n result so that decisions may be made (for instance, graceful shutdowns)."]
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function attempts to retrieve a value from the auxiliary vector.\n If it is unsuccessful, the result will be 0, and errno will be set.\n\n @return A value from the auxiliary vector.  When the value is 0, check\n errno to determine if an error occurred."]
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " This function retrieves a value from the auxiliary vector, and compares it\n as a string against the value retrieved.\n\n @return The result of calling strcmp() against the value retrieved from\n the auxiliary vector.  When the value is 0 (meaning a match is found),\n check errno to determine if an error occurred."]
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Change the stream that will be used by the logging system.\n\n This can be done at any time. The f argument represents the stream\n to be used to send the logs. If f is NULL, the default output is\n used (stderr).\n\n @param f\n   Pointer to the stream.\n @return\n   - 0 on success.\n   - Negative on error."]
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the stream used by the logging system (see rte_openlog_stream()\n to change it).\n\n @return\n   Pointer to the stream."]
    pub fn rte_log_get_stream() -> *mut FILE;
}
unsafe extern "C" {
    #[doc = " Set the global log level.\n\n After this call, logs with a level lower or equal than the level\n passed as argument will be displayed.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    pub fn rte_log_set_global_level(level: u32);
}
unsafe extern "C" {
    #[doc = " Get the global log level.\n\n @return\n   The current global log level."]
    pub fn rte_log_get_global_level() -> u32;
}
unsafe extern "C" {
    #[doc = " Get the log level for a given type.\n\n @param logtype\n   The log type identifier.\n @return\n   0 on success, a negative value if logtype is invalid."]
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " For a given `logtype`, check if a log with `loglevel` can be printed.\n\n @param logtype\n   The log type identifier\n @param loglevel\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @return\n Returns 'true' if log can be printed and 'false' if it can't."]
    pub fn rte_log_can_log(logtype: u32, loglevel: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type based on globbing pattern.\n\n @param pattern\n   The globbing pattern identifying the log type.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type based on regular expression.\n\n @param regex\n   The regular expression identifying the log type.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type.\n\n @param logtype\n   The log type identifier.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if logtype or level is invalid."]
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current loglevel for the message being processed.\n\n Before calling the user-defined stream for logging, the log\n subsystem sets a per-lcore variable containing the loglevel and the\n logtype of the message being processed. This information can be\n accessed by the user-defined log output function through this\n function.\n\n @return\n   The loglevel of the message being processed."]
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current logtype for the message being processed.\n\n Before calling the user-defined stream for logging, the log\n subsystem sets a per-lcore variable containing the loglevel and the\n logtype of the message being processed. This information can be\n accessed by the user-defined log output function through this\n function.\n\n @return\n   The logtype of the message being processed."]
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register a dynamic log type\n\n If a log is already registered with the same type, the returned value\n is the same than the previous one.\n\n @param name\n   The string identifying the log type.\n @return\n   - >0: success, the returned value is the log type identifier.\n   - (-ENOMEM): cannot allocate memory."]
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register a dynamic log type and try to pick its level from EAL options\n\n rte_log_register() is called inside. If successful, the function tries\n to search for matching regexp in the list of EAL log level options and\n pick the level from the last matching entry. If nothing can be applied\n from the list, the level will be set to the user-defined default value.\n\n @param name\n    Name for the log type to be registered\n @param level_def\n    Fallback level to be set if the global list has no matching options\n @return\n    - >=0: the newly registered log type\n    - <0: rte_log_register() error value"]
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump name of each logtype, one per line.\n\n @param out\n   Stream where the list is sent.\n @param prefix\n   String preceding each logtype in the output."]
    pub fn rte_log_list_types(out: *mut FILE, prefix: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Dump log information.\n\n Dump the global level and the registered log types.\n\n @param f\n   The output stream where the dump should be sent."]
    pub fn rte_log_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Generates a log message.\n\n The message will be sent in the stream defined by the previous call\n to rte_openlog_stream().\n\n The level argument determines if the log should be displayed or\n not, depending on the loglevel settings.\n\n The preferred alternative is the RTE_LOG() because it adds the\n level and type in the logged string.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @param logtype\n   The log type, for example, RTE_LOGTYPE_EAL.\n @param format\n   The format string, as in printf(3), followed by the variable arguments\n   required by the format.\n @return\n   - 0: Success.\n   - Negative on error."]
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Generates a log message.\n\n The message will be sent in the stream defined by the previous call\n to rte_openlog_stream().\n\n The level argument determines if the log should be displayed or\n not, depending on the loglevel settings. A trailing\n newline may be added if needed.\n\n The preferred alternative is the RTE_LOG() because it adds the\n level and type in the logged string.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @param logtype\n   The log type, for example, RTE_LOGTYPE_EAL.\n @param format\n   The format string, as in printf(3), followed by the variable arguments\n   required by the format.\n @param ap\n   The va_list of the variable arguments required by the format.\n @return\n   - 0: Success.\n   - Negative on error."]
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the stack of the calling core to the standard error."]
    pub fn rte_dump_stack();
}
unsafe extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static mut eal_timer_source: timer_source;
}
unsafe extern "C" {
    #[doc = " Get the measured frequency of the RDTSC counter\n\n @return\n   The TSC frequency for this lcore"]
    pub fn rte_get_tsc_hz() -> u64;
}
unsafe extern "C" {
    #[doc = " Wait at least us microseconds.\n This function can be replaced with user-defined function.\n @see rte_delay_us_callback_register\n\n @param us\n   The number of microseconds to wait."]
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
unsafe extern "C" {
    #[doc = " Blocking delay function.\n\n @param us\n   Number of microseconds to wait."]
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Delay function that uses system sleep.\n Does not block the CPU core.\n\n @param us\n   Number of microseconds to wait."]
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Replace rte_delay_us with user defined function.\n\n @param userfunc\n   User function which replaces rte_delay_us. rte_delay_us_block restores\n   builtin block delay function."]
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
unsafe extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
unsafe extern "C" {
    #[doc = " Internal helpers used for lock annotations."]
    pub fn rte_mcfg_mem_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_tailq_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_mempool_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_timer_get_lock() -> *mut rte_spinlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_ethdev_get_lock() -> *mut rte_spinlock_t;
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_unlock();
}
unsafe extern "C" {
    #[doc = " If true, pages are put in single files (per memseg list),\n as opposed to creating a file per page."]
    pub fn rte_mcfg_get_single_file_segments() -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
unsafe extern "C" {
    #[doc = " Set up ``rte_fbarray`` structure and allocate underlying resources.\n\n Call this function to correctly set up ``rte_fbarray`` and allocate\n underlying files that will be backing the data in the current process. Note\n that in order to use and share ``rte_fbarray`` between multiple processes,\n data pointed to by ``arr`` pointer must itself be allocated in shared memory.\n\n @param arr\n   Valid pointer to allocated ``rte_fbarray`` structure.\n\n @param name\n   Unique name to be assigned to this array.\n\n @param len\n   Number of elements initially available in the array.\n\n @param elt_sz\n   Size of each element.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attach to a file backing an already allocated and correctly set up\n ``rte_fbarray`` structure.\n\n Call this function to attach to file that will be backing the data in the\n current process. The structure must have been previously correctly set up\n with a call to ``rte_fbarray_init()``. Calls to ``rte_fbarray_attach()`` are\n usually meant to be performed in a multiprocessing scenario, with data\n pointed to by ``arr`` pointer allocated in shared memory.\n\n @param arr\n   Valid pointer to allocated and correctly set up rte_fbarray structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up\n ``rte_fbarray`` structure, and remove the underlying file.\n\n Call this function to deallocate all resources associated with an\n ``rte_fbarray`` structure within the current process. This will also\n zero-fill data pointed to by ``arr`` pointer and remove the underlying file\n backing the data, so it is expected that by the time this function is called,\n all other processes have detached from this ``rte_fbarray``.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up\n ``rte_fbarray`` structure.\n\n Call this function to deallocate all resources associated with an\n ``rte_fbarray`` structure within current process.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get pointer to element residing at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Index of an element to get a pointer to.\n\n @return\n  - non-NULL pointer on success.\n  - NULL on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Find index of a specified element within the array.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param elt\n   Pointer to element to find index to.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Mark specified element as used.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to mark as used.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Mark specified element as free.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to mark as free.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check whether element at specified index is marked as used.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to check as used.\n\n @return\n  - 1 if element is used.\n  - 0 if element is unused.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next free element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next used element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next chunk of ``n`` free elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of free elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next chunk of ``n`` used elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of used elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more free entries there are, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more used entries there are, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of previous free element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of previous used element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` free elements, down from specified\n index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of free elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` used elements, down from specified\n index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of used elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more free entries there are before specified index (like\n ``rte_fbarray_find_contig_free`` but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more used entries there are before specified index (like\n ``rte_fbarray_find_contig_used`` but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of free elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of used elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of free elements before a specified index (like\n ``rte_fbarray_find_biggest_free``, but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of used elements before a specified index (like\n ``rte_fbarray_find_biggest_used``, but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump ``rte_fbarray`` metadata.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param f\n   File object to dump information into."]
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
#[doc = " Physical memory segment descriptor."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    #[doc = "< Length of the segment."]
    pub len: usize,
    #[doc = "< The pagesize of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Number of channels."]
    pub nchannel: u32,
    #[doc = "< Number of ranks."]
    pub nrank: u32,
    #[doc = "< Memseg-specific flags"]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64 bits"]
    pub addr_64: u64,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data\n together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
unsafe extern "C" {
    #[doc = " Lock page in physical memory and prevent from swapping.\n\n @param virt\n   The virtual address.\n @return\n   0 on success, negative on error."]
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get physical address of any mapped virtual address in the current process.\n It is found by browsing the /proc/self/pagemap special file.\n The page must be locked.\n\n @param virt\n   The virtual address.\n @return\n   The physical address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
unsafe extern "C" {
    #[doc = " Get IO virtual address of any mapped virtual address in the current process.\n\n @note This function will not check internal page table. Instead, in IOVA as\n       PA mode, it will fall back to getting real physical address (which may\n       not match the expected IOVA, such as what was specified for external\n       memory).\n\n @param virt\n   The virtual address.\n @return\n   The IO address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
unsafe extern "C" {
    #[doc = " Get virtual memory address corresponding to iova address.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @param iova\n   The iova address.\n @return\n   Virtual address corresponding to iova address (or NULL if address does not\n   exist within DPDK memory map)."]
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get memseg to which a particular virtual address belongs.\n\n @param virt\n   The virtual address.\n @param msl\n   The memseg list in which to look up based on ``virt`` address\n   (can be NULL).\n @return\n   Memseg pointer on success, or NULL on error."]
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
unsafe extern "C" {
    #[doc = " Get memseg list corresponding to virtual memory address.\n\n @param virt\n   The virtual address.\n @return\n   Memseg list to which this virtual address belongs to."]
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
#[doc = " Memseg walk function prototype.\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg contig walk function prototype. This will trigger a callback on every\n VA-contiguous area starting at memseg ``ms``, so total valid VA space at each\n callback call will be [``ms->addr``, ``ms->addr + len``).\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg list walk function prototype. This will trigger a callback on every\n allocated memseg list.\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register external memory chunk with DPDK.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA mapping. It is expected that user\n   will do that themselves.\n\n @note Before accessing this memory in other processes, it needs to be\n   attached in each of those processes by calling ``rte_extmem_attach`` in\n   each other process.\n\n @param va_addr\n   Start of virtual area to register. Must be aligned by ``page_sz``.\n @param len\n   Length of virtual area to register. Must be aligned by ``page_sz``.\n @param iova_addrs\n   Array of page IOVA addresses corresponding to each page in this memory\n   area. Can be NULL, in which case page IOVA addresses will be set to\n   RTE_BAD_IOVA.\n @param n_pages\n   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``\n   is NULL.\n @param page_sz\n   Page size of the underlying memory\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     EEXIST - memory chunk is already registered\n     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister external memory chunk with DPDK.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA unmapping. It is expected that user\n   will do that themselves.\n\n @note Before calling this function, all other processes must call\n   ``rte_extmem_detach`` to detach from the memory area.\n\n @param va_addr\n   Start of virtual area to unregister\n @param len\n   Length of virtual area to unregister\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attach to external memory chunk registered in another process.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA mapping. It is expected that user\n   will do that themselves.\n\n @param va_addr\n   Start of virtual area to register\n @param len\n   Length of virtual area to register\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Detach from external memory chunk registered in another process.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA unmapping. It is expected that user\n   will do that themselves.\n\n @param va_addr\n   Start of virtual area to unregister\n @param len\n   Length of virtual area to unregister\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the physical memory layout to a file.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Get the total amount of available physical memory.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @return\n    The total amount of available physical memory in bytes."]
    pub fn rte_eal_get_physmem_size() -> u64;
}
unsafe extern "C" {
    #[doc = " Get the number of memory channels.\n\n @return\n   The number of memory channels on the system. The value is 0 if unknown\n   or not the same on all devices."]
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Get the number of memory ranks.\n\n @return\n   The number of memory ranks on the system. The value is 0 if unknown or\n   not the same on all devices."]
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with\n supplied DMA address width.\n\n  @param maskbits\n    Address width to check against."]
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with\n supplied DMA address width. This function will use\n rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying\n memory_hotplug_lock will not be acquired avoiding deadlock during\n memory initialization.\n\n This function is just for EAL core memory internal use. Drivers should\n use the previous rte_mem_check_dma_mask.\n\n  @param maskbits\n    Address width to check against."]
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set dma mask to use once memory initialization is done. Previous functions\n  rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be\n  used safely until memory has been initialized."]
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
unsafe extern "C" {
    #[doc = " Drivers based on uio will not load unless physical\n addresses are obtainable. It is only possible to get\n physical addresses when running as a privileged user.\n\n @return\n   1 if the system is able to obtain physical addresses.\n   0 if using DMA addresses through an IOMMU."]
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
#[doc = "< Allocation event."]
pub const rte_mem_event_RTE_MEM_EVENT_ALLOC: rte_mem_event = 0;
#[doc = "< Deallocation event."]
pub const rte_mem_event_RTE_MEM_EVENT_FREE: rte_mem_event = 1;
#[doc = " Enum indicating which kind of memory event has happened. Used by callbacks to\n distinguish between memory allocations and deallocations."]
pub type rte_mem_event = ::std::os::raw::c_uint;
#[doc = " Function typedef used to register callbacks for memory events."]
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Function used to register callbacks for memory events.\n\n @note callbacks will happen while memory hotplug subsystem is write-locked,\n       therefore some functions (e.g. `rte_memseg_walk()`) will cause a\n       deadlock when called from within such callbacks.\n\n @note mem event callbacks not being supported is an expected error condition,\n       so user code needs to handle this situation. In these cases, return\n       value will be -1, and rte_errno will be set to ENOTSUP.\n\n @param name\n   Name associated with specified callback to be added to the list.\n\n @param clb\n   Callback function pointer.\n\n @param arg\n   Argument to pass to the callback.\n\n @return\n   0 on successful callback register\n   -1 on unsuccessful callback register, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Function used to unregister callbacks for memory events.\n\n @param name\n   Name associated with specified callback to be removed from the list.\n\n @param arg\n   Argument to look for among callbacks with specified callback name.\n\n @return\n   0 on successful callback unregister\n   -1 on unsuccessful callback unregister, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function typedef used to register memory allocation validation callbacks.\n\n Returning 0 will allow allocation attempt to continue. Returning -1 will\n prevent allocation from succeeding."]
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: usize,
        new_len: usize,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @brief Register validator callback for memory allocations.\n\n Callbacks registered by this function will be called right before memory\n allocator is about to trigger allocation of more pages from the system if\n said allocation will bring total memory usage above specified limit on\n specified socket. User will be able to cancel pending allocation if callback\n returns -1.\n\n @note callbacks will happen while memory hotplug subsystem is write-locked,\n       therefore some functions (e.g. `rte_memseg_walk()`) will cause a\n       deadlock when called from within such callbacks.\n\n @note validator callbacks not being supported is an expected error condition,\n       so user code needs to handle this situation. In these cases, return\n       value will be -1, and rte_errno will be set to ENOTSUP.\n\n @param name\n   Name associated with specified callback to be added to the list.\n\n @param clb\n   Callback function pointer.\n\n @param socket_id\n   Socket ID on which to watch for allocations.\n\n @param limit\n   Limit above which to trigger callbacks.\n\n @return\n   0 on successful callback register\n   -1 on unsuccessful callback register, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unregister validator callback for memory allocations.\n\n @param name\n   Name associated with specified callback to be removed from the list.\n\n @param socket_id\n   Socket ID on which to watch for allocations.\n\n @return\n   0 on successful callback unregister\n   -1 on unsuccessful callback unregister, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[doc = " Enq/Deq a fixed number of items from a ring"]
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
#[doc = " Enq/Deq as many items as possible from ring"]
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
#[doc = " enqueue/dequeue behavior types"]
pub type rte_ring_queue_behavior = ::std::os::raw::c_uint;
#[doc = "< multi-thread safe (default mode)"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
#[doc = "< single thread only"]
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
#[doc = "< multi-thread relaxed tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
#[doc = "< multi-thread head/tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
#[doc = " prod/cons sync types"]
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[doc = " structures to hold a pair of head/tail values and other metadata.\n Depending on sync_type format of that structure might be different,\n but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure.\n\n The producer and the consumer have a head and a tail index. The particularity\n of these index is that they are not between 0 and size(ring)-1. These indexes\n are between 0 and 2^32 -1, and we mask their value when we access the ring[]\n field. Thanks to this assumption, we can do subtractions between 2 index\n values in a modulo-32bit base: that's why the overflow of the indexes is not\n a problem."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
unsafe extern "C" {
    #[doc = " Calculate the memory size needed for a ring with given element size\n\n This function returns the number of bytes needed for a ring, given\n the number of elements in it and the size of the element. This value\n is the sum of the size of the structure rte_ring and the size of the\n memory needed for storing the elements. The value is aligned to a cache\n line size.\n\n @param esize\n   The size of ring element, in bytes. It must be a multiple of 4.\n @param count\n   The number of elements in the ring (must be a power of 2).\n @return\n   - The memory size needed for the ring on success.\n   - -EINVAL - esize is not a multiple of 4 or count provided is not a\n\t\t power of 2."]
    pub fn rte_ring_get_memsize_elem(
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = " Create a new ring named *name* that stores elements with given size.\n\n This function uses ``memzone_reserve()`` to allocate memory. Then it\n calls rte_ring_init() to initialize an empty ring.\n\n The new ring size is set to *count*, which must be a power of\n two. Water marking is disabled by default. The real usable ring size\n is *count-1* instead of *count* to differentiate a full ring from an\n empty ring.\n\n The ring is added in RTE_TAILQ_RING list.\n\n @param name\n   The name of the ring.\n @param esize\n   The size of ring element, in bytes. It must be a multiple of 4.\n @param count\n   The number of elements in the ring (must be a power of 2).\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n @return\n   On success, the pointer to the new allocated ring. NULL on error with\n    rte_errno set appropriately. Possible errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - esize is not a multiple of 4 or count provided is not a\n\t\t power of 2.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create_elem(
        name: *const ::std::os::raw::c_char,
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
#[doc = " Ring zero-copy information structure.\n\n This structure contains the pointers and length of the space\n reserved on the ring storage."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring_zc_data {
    pub ptr1: *mut ::std::os::raw::c_void,
    pub ptr2: *mut ::std::os::raw::c_void,
    pub n1: ::std::os::raw::c_uint,
}
unsafe extern "C" {
    #[doc = " Calculate the memory size needed for a ring\n\n This function returns the number of bytes needed for a ring, given\n the number of elements in it. This value is the sum of the size of\n the structure rte_ring and the size of the memory needed by the\n objects pointers. The value is aligned to a cache line size.\n\n @param count\n   The number of elements in the ring (must be a power of 2).\n @return\n   - The memory size needed for the ring on success.\n   - -EINVAL if count is not a power of 2."]
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
unsafe extern "C" {
    #[doc = " Initialize a ring structure.\n\n Initialize a ring structure in memory pointed by \"r\". The size of the\n memory area must be large enough to store the ring structure and the\n object table. It is advised to use rte_ring_get_memsize() to get the\n appropriate size.\n\n The ring size is set to *count*, which must be a power of two.\n The real usable ring size is *count-1* instead of *count* to\n differentiate a full ring from an empty ring.\n\n The ring is not added in RTE_TAILQ_RING global list. Indeed, the\n memory given by the caller may not be shareable among dpdk\n processes.\n\n @param r\n   The pointer to the ring structure followed by the objects table.\n @param name\n   The name of the ring.\n @param count\n   The number of elements in the ring (must be a power of 2,\n   unless RING_F_EXACT_SZ is set in flags).\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the\n     requested number of entries, and the requested size will be rounded up\n     to the next power of two, but the usable space will be exactly that\n     requested. Worst case, if a power-of-2 size is requested, half the\n     ring space will be wasted.\n     Without this flag set, the ring size requested must be a power of 2,\n     and the usable space will be that size - 1.\n @return\n   0 on success, or a negative value on error."]
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " De-allocate all memory used by the ring.\n\n @param r\n   Ring to free.\n   If NULL then, the function does nothing."]
    pub fn rte_ring_free(r: *mut rte_ring);
}
unsafe extern "C" {
    #[doc = " Create a new ring named *name* in memory.\n\n This function uses ``memzone_reserve()`` to allocate memory. Then it\n calls rte_ring_init() to initialize an empty ring.\n\n The new ring size is set to *count*, which must be a power of two.\n The real usable ring size is *count-1* instead of *count* to\n differentiate a full ring from an empty ring.\n\n The ring is added in RTE_TAILQ_RING list.\n\n @param name\n   The name of the ring.\n @param count\n   The size of the ring (must be a power of 2,\n   unless RING_F_EXACT_SZ is set in flags).\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the\n     requested number of entries, and the requested size will be rounded up\n     to the next power of two, but the usable space will be exactly that\n     requested. Worst case, if a power-of-2 size is requested, half the\n     ring space will be wasted.\n     Without this flag set, the ring size requested must be a power of 2,\n     and the usable space will be that size - 1.\n @return\n   On success, the pointer to the new allocated ring. NULL on error with\n    rte_errno set appropriately. Possible errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - count provided is not a power of 2\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
unsafe extern "C" {
    #[doc = " Dump the status of the ring to a file.\n\n @param f\n   A pointer to a file for output\n @param r\n   A pointer to the ring structure."]
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Dump the status of a headtail to a file.\n\n @param f\n   A pointer to a file for output\n @param prefix\n   A string to prefix each output line with\n @param r\n   A pointer to a ring headtail structure."]
    pub fn rte_ring_headtail_dump(
        f: *mut FILE,
        prefix: *const ::std::os::raw::c_char,
        r: *const rte_ring_headtail,
    );
}
unsafe extern "C" {
    #[doc = " Flush a ring.\n\n This function flush all the elements in a ring\n\n @warning\n Make sure the ring is not in use while calling this function.\n\n @param r\n   A pointer to the ring structure."]
    pub fn rte_ring_reset(r: *mut rte_ring);
}
unsafe extern "C" {
    #[doc = " Dump the status of all rings on the console\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_ring_list_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Search a ring from its name\n\n @param name\n   The name of the ring.\n @return\n   The pointer to the ring matching the name, or NULL if not found,\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - ENOENT - required entry not available to return."]
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
#[doc = " 64 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64u8_t = [u8; 8usize];
#[doc = " 64 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v64u16_t){ a0, a1, a2, a3 }"]
pub type rte_v64u16_t = [u16; 4usize];
#[doc = " 64 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v64u32_t){ a0, a1 }"]
pub type rte_v64u32_t = [u32; 2usize];
#[doc = " 128 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128u8_t = [u8; 16usize];
#[doc = " 128 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128u16_t = [u16; 8usize];
#[doc = " 128 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v128u32_t){ a0, a1, a2, a3 }"]
pub type rte_v128u32_t = [u32; 4usize];
#[doc = " 128 bits vector size to use with unsigned 64 bits elements.\n\n a = (rte_v128u64_t){ a0, a1 }"]
pub type rte_v128u64_t = [u64; 2usize];
#[doc = " 256 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15,\n                     a16, a17, a18, a19, a20, a21, a22, a23,\n                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256u8_t = [u8; 32usize];
#[doc = " 256 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256u16_t = [u16; 16usize];
#[doc = " 256 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256u32_t = [u32; 8usize];
#[doc = " 256 bits vector size to use with unsigned 64 bits elements.\n\n a = (rte_v256u64_t){ a0, a1, a2, a3 }"]
pub type rte_v256u64_t = [u64; 4usize];
#[doc = " 64 bits vector size to use with 8 bits elements.\n\n a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64s8_t = [i8; 8usize];
#[doc = " 64 bits vector size to use with 16 bits elements.\n\n a = (rte_v64s16_t){ a0, a1, a2, a3 }"]
pub type rte_v64s16_t = [i16; 4usize];
#[doc = " 64 bits vector size to use with 32 bits elements.\n\n a = (rte_v64s32_t){ a0, a1 }"]
pub type rte_v64s32_t = [i32; 2usize];
#[doc = " 128 bits vector size to use with 8 bits elements.\n\n a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128s8_t = [i8; 16usize];
#[doc = " 128 bits vector size to use with 16 bits elements.\n\n a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128s16_t = [i16; 8usize];
#[doc = " 128 bits vector size to use with 32 bits elements.\n\n a = (rte_v128s32_t){ a0, a1, a2, a3 }"]
pub type rte_v128s32_t = [i32; 4usize];
#[doc = " 128 bits vector size to use with 64 bits elements.\n\n a = (rte_v128s64_t){ a1, a2 }"]
pub type rte_v128s64_t = [i64; 2usize];
#[doc = " 256 bits vector size to use with 8 bits elements.\n\n a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15,\n                     a16, a17, a18, a19, a20, a21, a22, a23,\n                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256s8_t = [i8; 32usize];
#[doc = " 256 bits vector size to use with 16 bits elements.\n\n a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256s16_t = [i16; 16usize];
#[doc = " 256 bits vector size to use with 32 bits elements.\n\n a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256s32_t = [i32; 8usize];
#[doc = " 256 bits vector size to use with 64 bits elements.\n\n a = (rte_v256s64_t){ a0, a1, a2, a3 }"]
pub type rte_v256s64_t = [i64; 4usize];
pub const rte_vect_max_simd_RTE_VECT_SIMD_DISABLED: rte_vect_max_simd = 64;
pub const rte_vect_max_simd_RTE_VECT_SIMD_128: rte_vect_max_simd = 128;
#[doc = "< Limits path selection to AVX2 or below."]
pub const rte_vect_max_simd_RTE_VECT_SIMD_256: rte_vect_max_simd = 256;
#[doc = "< Limits path selection to AVX512 or below."]
pub const rte_vect_max_simd_RTE_VECT_SIMD_512: rte_vect_max_simd = 512;
pub const rte_vect_max_simd_RTE_VECT_SIMD_MAX: rte_vect_max_simd = 32768;
#[doc = " The max SIMD bitwidth value to limit vector path selection."]
pub type rte_vect_max_simd = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the supported SIMD bitwidth.\n\n @return\n   uint16_t bitwidth."]
    pub fn rte_vect_get_max_simd_bitwidth() -> u16;
}
unsafe extern "C" {
    #[doc = " Set the supported SIMD bitwidth.\n This API should only be called once at initialization, before EAL init.\n\n @param bitwidth\n   uint16_t bitwidth.\n @return\n   - 0 on success.\n   - -EINVAL on invalid bitwidth parameter.\n   - -EPERM if bitwidth is forced."]
    pub fn rte_vect_set_max_simd_bitwidth(bitwidth: u16) -> ::std::os::raw::c_int;
}
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
pub type rte_xmm_t = rte_xmm;
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Takes string \"string\" parameter and splits it at character \"delim\"\n up to maxtokens-1 times - to give \"maxtokens\" resulting tokens. Like\n strtok or strsep functions, this modifies its input string, by replacing\n instances of \"delim\" with '\\\\0'. All resultant tokens are returned in the\n \"tokens\" array which must have enough entries to hold \"maxtokens\".\n\n @param string\n   The input string to be split into tokens\n\n @param stringlen\n   The max length of the input buffer\n\n @param tokens\n   The array to hold the pointers to the tokens in the string\n\n @param maxtokens\n   The number of elements in the tokens array. At most, maxtokens-1 splits\n   of the string will be done.\n\n @param delim\n   The character on which the split of the data will be done\n\n @return\n   The number of tokens in the tokens array."]
    pub fn rte_strsplit(
        string: *mut ::std::os::raw::c_char,
        stringlen: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
        maxtokens: ::std::os::raw::c_int,
        delim: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strnstr(
        str_: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
        str_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strmode(mode: mode_t, str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Copy string src to buffer dst of size dsize.\n At most dsize-1 chars will be copied.\n Always NUL-terminates, unless (dsize == 0).\n\n @param dst\n   The destination string.\n\n @param src\n   The input string to be copied.\n\n @param dsize\n   Length in bytes of the destination buffer.\n\n @return\n   The number of bytes copied (terminating NUL-byte excluded) on success.\n   -E2BIG if the destination buffer is too small.\n   rte_errno is set."]
    pub fn rte_strscpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dsize: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = "  Test if trace is enabled.\n\n  @return\n     true if trace is enabled, false otherwise."]
    pub fn rte_trace_is_enabled() -> bool;
}
#[doc = " In this mode, when no space is left in the trace buffer, the\n subsequent events overwrite the old events."]
pub const rte_trace_mode_RTE_TRACE_MODE_OVERWRITE: rte_trace_mode = 0;
#[doc = " In this mode, when no space is left in the trace buffer, the\n subsequent events shall not be recorded."]
pub const rte_trace_mode_RTE_TRACE_MODE_DISCARD: rte_trace_mode = 1;
#[doc = " Enumerate trace mode operation."]
pub type rte_trace_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Set the trace mode.\n\n @param mode\n   Trace mode."]
    pub fn rte_trace_mode_set(mode: rte_trace_mode);
}
unsafe extern "C" {
    #[doc = " Get the trace mode.\n\n @return\n   The current trace mode."]
    pub fn rte_trace_mode_get() -> rte_trace_mode;
}
unsafe extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on globbing pattern.\n\n @param pattern\n   The globbing pattern identifying the tracepoint.\n @param enable\n   true to enable tracepoint, false to disable the tracepoint, upon match.\n @return\n   - 0: Success and no pattern match.\n   - 1: Success and found pattern match.\n   - (-ERANGE): Tracepoint object is not registered."]
    pub fn rte_trace_pattern(
        pattern: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on regular expression.\n\n @param regex\n   A regular expression identifying the tracepoint.\n @param enable\n   true to enable tracepoint, false to disable the tracepoint, upon match.\n @return\n   - 0: Success and no pattern match.\n   - 1: Success and found pattern match.\n   - (-ERANGE): Tracepoint object is not registered.\n   - (-EINVAL): Invalid regular expression rule."]
    pub fn rte_trace_regexp(
        regex: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Save the trace buffer to the trace directory.\n\n By default, trace directory will be created at $HOME directory and this can\n be overridden by --trace-dir EAL parameter.\n\n @return\n   - 0: Success.\n   - <0 : Failure."]
    pub fn rte_trace_save() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the trace metadata to a file.\n\n @param f\n   A pointer to a file for output\n @return\n   - 0: Success.\n   - <0 : Failure."]
    pub fn rte_trace_metadata_dump(f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the trace subsystem status to a file.\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_trace_dump(f: *mut FILE);
}
#[doc = " The tracepoint object."]
pub type rte_trace_point_t = u64;
unsafe extern "C" {
    #[doc = " Enable recording events of the given tracepoint in the trace buffer.\n\n @param tp\n   The tracepoint object to enable.\n @return\n   - 0: Success.\n   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_enable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable recording events of the given tracepoint in the trace buffer.\n\n @param tp\n   The tracepoint object to disable.\n @return\n   - 0: Success.\n   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_disable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test if recording events from the given tracepoint is enabled.\n\n @param tp\n    The tracepoint object.\n @return\n    true if tracepoint is enabled, false otherwise."]
    pub fn rte_trace_point_is_enabled(tp: *mut rte_trace_point_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Lookup a tracepoint object from its name.\n\n @param name\n   The name of the tracepoint.\n @return\n   The tracepoint object or NULL if not found."]
    pub fn rte_trace_point_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_trace_point_t;
}
unsafe extern "C" {
    #[doc = " @internal\n\n Allocate trace memory buffer per thread."]
    pub fn __rte_trace_mem_per_thread_alloc();
}
unsafe extern "C" {
    #[doc = " @internal\n\n Helper function to emit field.\n\n @param sz\n   The tracepoint size.\n @param field\n   The name of the trace event.\n @param type\n   The datatype of the trace event as string.\n @return\n   - 0: Success.\n   - <0: Failure."]
    pub fn __rte_trace_point_emit_field(
        sz: usize,
        field: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " @internal\n\n Helper function to register a dynamic tracepoint.\n Use RTE_TRACE_POINT_REGISTER macro for tracepoint registration.\n\n @param trace\n   The tracepoint object created using RTE_TRACE_POINT_REGISTER.\n @param name\n   The name of the tracepoint object.\n @param register_fn\n   Trace registration function.\n @return\n   - 0: Successfully registered the tracepoint.\n   - <0: Failure to register the tracepoint."]
    pub fn __rte_trace_point_register(
        trace: *mut rte_trace_point_t,
        name: *const ::std::os::raw::c_char,
        register_fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_contig_blocks: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_enqueue_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_generic_put: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_put_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_generic_get: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_get_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_get_contig_blocks: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_default_cache: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_cache_flush: rte_trace_point_t;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
unsafe extern "C" {
    #[doc = " @internal Logtype used for mempool related messages."]
    pub static mut rte_mempool_logtype: ::std::os::raw::c_int;
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " Additional information about the mempool\n\n The structure is cache-line aligned to avoid ABI breakages in\n a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
#[doc = " Prototype for implementation specific data provisioning function.\n\n The function should provide the implementation specific memory for\n use by the other mempool ops functions in a given mempool ops struct.\n E.g. the default ops provides an instance of the rte_ring for this purpose.\n it will most likely point to a different type of data structure, and\n will be transparent to the application programmer.\n This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue 'n' objects into the external pool.\n @return\n   - 0: Success\n   - <0: Error"]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue 'n' objects from the external pool.\n @return\n   - 0: Success\n   - <0: Error"]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects.\n\n If mempool objects are not required to be IOVA-contiguous\n (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines\n virtually contiguous chunk size. Otherwise, if mempool objects must\n be IOVA-contiguous (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is clear),\n min_chunk_size defines IOVA-contiguous chunk size.\n\n @param[in] mp\n   Pointer to the memory pool.\n @param[in] obj_num\n   Number of objects.\n @param[in] pg_shift\n   LOG2 of the physical pages size. If set to 0, ignore page boundaries.\n @param[out] min_chunk_size\n   Location for minimum size of the memory chunk which may be used to\n   store memory pool objects.\n @param[out] align\n   Location for required memory chunk alignment.\n @return\n   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
#[doc = " Function to be called for each populated object.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] opaque\n   An opaque pointer passed to iterator.\n @param[in] vaddr\n   Object virtual address.\n @param[in] iova\n   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk.\n\n Populated objects should be enqueued to the pool, e.g. using\n rte_mempool_ops_enqueue_bulk().\n\n If the given IO address is unknown (iova = RTE_BAD_IOVA),\n the chunk doesn't need to be physically contiguous (only virtually),\n and allocated objects may span two pages.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] max_objs\n   Maximum number of objects to be populated.\n @param[in] vaddr\n   The virtual address of memory that should be used to store objects.\n @param[in] iova\n   The IO address\n @param[in] len\n   The length of memory in bytes.\n @param[in] obj_cb\n   Callback function to be executed for each populated object.\n @param[in] obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   The number of objects added on success.\n   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to\n store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using\n provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[doc = " Structure storing the table of registered ops structs, each of which contain\n the function pointers for the mempool ops functions.\n Each process has its own storage for this ops struct array so that\n the mempools can be shared across primary and secondary processes.\n The indices used to access the array are valid across processes, whereas\n any function pointers stored directly in the mempool struct would not be.\n This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
unsafe extern "C" {
    #[doc = " Array of registered ops structs."]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
#[doc = " An object callback function for mempool.\n\n Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool.\n\n Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function.\n\n Arguments are the mempool and the opaque pointer given by the user in\n rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A structure used to retrieve information about the memory range\n of the mempool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_mem_range_info {
    #[doc = " Start of the memory range used by mempool objects"]
    pub start: *mut ::std::os::raw::c_void,
    #[doc = " Length of the memory range used by mempool objects"]
    pub length: usize,
    #[doc = " Are all memory addresses used by mempool objects contiguous"]
    pub is_contiguous: bool,
}
#[doc = " Occurs after a mempool is fully populated."]
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_READY: rte_mempool_event = 0;
#[doc = " Occurs before the destruction of a mempool begins."]
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_DESTROY: rte_mempool_event = 1;
#[doc = " Mempool event type.\n @internal"]
pub type rte_mempool_event = ::std::os::raw::c_uint;
#[doc = " @internal\n Mempool event callback.\n\n rte_mempool_event_callback_register() may be called from within the callback,\n but the callbacks registered this way will not be invoked for the same event.\n rte_mempool_event_callback_unregister() may only be safely called\n to remove the running callback."]
pub type rte_mempool_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        event: rte_mempool_event,
        mp: *mut rte_mempool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Get the name of the l2 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the l3 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the l4 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the tunnel packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l2 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l3 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l4 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Write the packet type name into the buffer\n\n @param ptype\n   The packet type value.\n @param buf\n   The buffer where the string is written.\n @param buflen\n   The length of the buffer.\n @return\n   - 0 on success\n   - (-1) if the buffer is too small"]
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_2 = 7;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_2 = 9;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_2 = 8;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_2 = 16;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_2 = 9;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_2 = 7;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_2 = 8;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_2 = 0;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_2 = 7;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_2 = 16;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_2 = 24;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_2 = 40;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_2 = 49;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_2 = 56;
#[doc = " enum for the tx_offload bit-fields lengths and offsets.\n defines the layout of rte_mbuf tx_offload field."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n layout for the first cache line for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
unsafe extern "C" {
    #[doc = " Get the name of a RX offload flag\n\n @param mask\n   The mask describing the flag.\n @return\n   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer\n\n @param mask\n   The mask describing the RX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the name of a TX offload flag\n\n @param mask\n   The mask describing the flag. Usually only one bit must be set.\n   Several bits can be given if they belong to the same mask.\n   Ex: RTE_MBUF_F_TX_L4_MASK.\n @return\n   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer\n\n @param mask\n   The mask describing the TX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Private data in case of pktmbuf pool.\n\n A structure that contains some pktmbuf_pool-specific data that are\n appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
unsafe extern "C" {
    #[doc = " Sanity checks on an mbuf.\n\n Check the consistency of the given mbuf. The function will cause a\n panic if corruption is detected.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Sanity checks on a mbuf.\n\n Almost like rte_mbuf_sanity_check(), but this function gives the reason\n if corruption is detected rather than panic.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)\n @param reason\n   A reference to a string pointer where to store the reason why a mbuf is\n   considered invalid.\n @return\n   - 0 if no issue has been found, reason is left untouched.\n   - -1 if a problem is detected, reason then points to a string describing\n     the reason why the mbuf is deemed invalid."]
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The packet mbuf constructor.\n\n This function initializes some fields in the mbuf structure that are\n not modified by the user once created (origin pool, buffer start\n address, and so on). This function is given as a callback function to\n rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.\n\n This function expects that the mempool private area was previously\n initialized with rte_pktmbuf_pool_init().\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_obj_iter() or rte_mempool_create().\n @param m\n   The mbuf to initialize.\n @param i\n   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " A packet mbuf pool constructor.\n\n This function initializes the mempool private data in the case of a\n pktmbuf pool. This private data is needed by the driver. The\n function must be called on the mempool before it is used, or it\n can be given as a callback function to rte_mempool_create() at\n pool creation. It can be extended by the user, for example, to\n provide another packet size.\n\n The mempool private area size must be at least equal to\n sizeof(struct rte_pktmbuf_pool_private).\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Create a mbuf pool.\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Create a mbuf pool with a given mempool ops name\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @param ops_name\n   The mempool ops name to be used for this mempool instead of\n   default mempool. The value can be *NULL* to use default mempool.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
#[doc = " A structure that describes the pinned external buffer segment."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pktmbuf_extmem {
    #[doc = "< The virtual address of data buffer."]
    pub buf_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The IO address of the data buffer."]
    pub buf_iova: rte_iova_t,
    #[doc = "< External buffer length in bytes."]
    pub buf_len: usize,
    #[doc = "< mbuf element size in bytes."]
    pub elt_size: u16,
}
unsafe extern "C" {
    #[doc = " Create a mbuf pool with external pinned data buffers.\n\n This function creates and initializes a packet mbuf pool that contains\n only mbufs with external buffer. It is a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @param ext_mem\n   Pointer to the array of structures describing the external memory\n   for data buffers. It is caller responsibility to register this memory\n   with rte_extmem_register() (if needed), map this memory to appropriate\n   physical device, etc.\n @param ext_num\n   Number of elements in the ext_mem array.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_extbuf(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ext_mem: *const rte_pktmbuf_extmem,
        ext_num: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools.\n\n Free a bulk of mbufs, and all their segments in case of chained buffers.\n Each segment is added back into its original mempool.\n\n  @param mbufs\n    Array of pointers to packet mbufs.\n    The array may contain NULL pointers.\n  @param count\n    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Create a \"clone\" of the given packet mbuf.\n\n Walks through all segments of the given packet mbuf, and for each of them:\n  - Creates a new packet mbuf from the given pool.\n  - Attaches newly created mbuf to the segment.\n Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values\n from the original packet mbuf.\n\n @param md\n   The packet mbuf to be cloned.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
unsafe extern "C" {
    #[doc = " Create a full copy of a given packet mbuf.\n\n Copies all the data from a given packet mbuf to a newly allocated\n set of mbufs. The private data are is not copied.\n\n @param m\n   The packet mbuf to be copied.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @param offset\n   The number of bytes to skip before copying.\n   If the mbuf does not have that many bytes, it is an error\n   and NULL is returned.\n @param length\n   The upper limit on bytes to copy.  Passing UINT32_MAX\n   means all data (after offset).\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_copy(
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        offset: u32,
        length: u32,
    ) -> *mut rte_mbuf;
}
unsafe extern "C" {
    #[doc = " @internal used by rte_pktmbuf_read()."]
    pub fn __rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @internal used by rte_pktmbuf_linearize()."]
    pub fn __rte_pktmbuf_linearize(mbuf: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump an mbuf structure to a file.\n\n Dump all fields for the given packet mbuf and all its associated\n segments (in the case of a chained buffer).\n\n @param f\n   A pointer to a file for output\n @param m\n   The packet mbuf.\n @param dump_len\n   If dump_len != 0, also dump the \"dump_len\" first data bytes of\n   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
