/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }}
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }}
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }}
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }}
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _ASSERT_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BUS_AUXILIARY: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_MLX5: u32 = 1;
pub const RTE_COMPRESS_MLX5: u32 = 1;
pub const RTE_CRYPTO_MLX5: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_ENV_FREEBSD: u32 = 0;
pub const RTE_ENV_LINUX: u32 = 1;
pub const RTE_ENV_WINDOWS: u32 = 2;
pub const RTE_EXEC_ENV: u32 = 1;
pub const RTE_EXEC_ENV_IS_FREEBSD: u32 = 0;
pub const RTE_EXEC_ENV_IS_LINUX: u32 = 1;
pub const RTE_EXEC_ENV_IS_WINDOWS: u32 = 0;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_HAS_LIBPCAP: u32 = 1;
pub const RTE_HAS_OPENSSL: u32 = 1;
pub const RTE_IOVA_IN_MBUF: u32 = 1;
pub const RTE_LIBRTE_BPF_ELF: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_ARGPARSE: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISPATCHER: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_DMADEV: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_GPUDEV: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LOG: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_MLDEV: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCAPNG: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDCP: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_PTR_COMPRESS: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 32;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_MLX5: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_REGEX_MLX5: u32 = 1;
pub const RTE_USE_LIBBSD: u32 = 1;
pub const RTE_VDPA_MLX5: u32 = 1;
pub const RTE_VER_MINOR: u32 = 0;
pub const RTE_VER_MONTH: u32 = 3;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1] = b"\0";
pub const RTE_VER_YEAR: u32 = 25;
pub const RTE_TOOLCHAIN: &[u8; 6] = b"clang\0";
pub const RTE_TOOLCHAIN_CLANG: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5] = b"DPDK\0";
pub const RTE_CACHE_GUARD_LINES: u32 = 1;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_LCORE_VAR: u32 = 131072;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_TRACE: u32 = 1;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11] = b"ring_mp_mc\0";
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_MAX_MULTI_HOST_CTRLS: u32 = 4;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_CRYPTO_CALLBACKS: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_PORTS_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_PROFILES_PER_PORT: u32 = 8;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_DMA_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 8;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_MAX_UNCORE_FREQS: u32 = 64;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_PMD_ZSDA_MAX_PCI_DEVICES: u32 = 256;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1] = b"\0";
pub const _ALLOCA_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_LOG_MAX: u32 = 8;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_DEVARGS_KEY_BUS: &[u8; 4] = b"bus\0";
pub const RTE_DEVARGS_KEY_CLASS: &[u8; 6] = b"class\0";
pub const RTE_DEVARGS_KEY_DRIVER: &[u8; 7] = b"driver\0";
pub const __ELASTERROR: u32 = 1000;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RTE_UUID_STRLEN: u32 = 37;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MP_MAX_FD_NUM: u32 = 253;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const RTE_THREAD_NAME_SIZE: u32 = 16;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_THREAD_INTERNAL_PREFIX: &[u8; 6] = b"dpdk-\0";
pub const RTE_THREAD_INTERNAL_NAME_SIZE: u32 = 11;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MPLOCKED: &[u8; 8] = b"lock ; \0";
pub const _RTE_RTM_H_: u32 = 1;
pub const __SAVE_GPRBX: &[u8; 30] = b"mov {%%rbx, %%rax |rax, rbx};\0";
pub const __RESTORE_GPRBX: &[u8; 30] = b"mov {%%rax, %%rbx |rbx, rax};\0";
pub const __TMPGPR: &[u8; 4] = b"rax\0";
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _MM_PCOMCTRL_LT: u32 = 0;
pub const _MM_PCOMCTRL_LE: u32 = 1;
pub const _MM_PCOMCTRL_GT: u32 = 2;
pub const _MM_PCOMCTRL_GE: u32 = 3;
pub const _MM_PCOMCTRL_EQ: u32 = 4;
pub const _MM_PCOMCTRL_NEQ: u32 = 5;
pub const _MM_PCOMCTRL_FALSE: u32 = 6;
pub const _MM_PCOMCTRL_TRUE: u32 = 7;
pub const __RDPRU_MPERF: u32 = 0;
pub const __RDPRU_APERF: u32 = 1;
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_POWER_MONITOR_OPAQUE_SZ: u32 = 4;
pub const _CTYPE_H: u32 = 1;
pub const LIBBSD_SYS_TIME_BITS: u32 = 64;
pub const LIBBSD_SYS_HAS_TIME64: u32 = 1;
pub const __RTE_TRACE_EMIT_STRING_LEN_MAX: u32 = 32;
pub const RTE_TRACE_BLOB_LEN_MAX: u32 = 64;
pub const RTE_ETH_REG_NAME_SIZE: u32 = 64;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const RTE_ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const RTE_ETH_LINK_SPEED_FIXED: u32 = 1;
pub const RTE_ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const RTE_ETH_LINK_SPEED_10M: u32 = 4;
pub const RTE_ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const RTE_ETH_LINK_SPEED_100M: u32 = 16;
pub const RTE_ETH_LINK_SPEED_1G: u32 = 32;
pub const RTE_ETH_LINK_SPEED_2_5G: u32 = 64;
pub const RTE_ETH_LINK_SPEED_5G: u32 = 128;
pub const RTE_ETH_LINK_SPEED_10G: u32 = 256;
pub const RTE_ETH_LINK_SPEED_20G: u32 = 512;
pub const RTE_ETH_LINK_SPEED_25G: u32 = 1024;
pub const RTE_ETH_LINK_SPEED_40G: u32 = 2048;
pub const RTE_ETH_LINK_SPEED_50G: u32 = 4096;
pub const RTE_ETH_LINK_SPEED_56G: u32 = 8192;
pub const RTE_ETH_LINK_SPEED_100G: u32 = 16384;
pub const RTE_ETH_LINK_SPEED_200G: u32 = 32768;
pub const RTE_ETH_LINK_SPEED_400G: u32 = 65536;
pub const RTE_ETH_SPEED_NUM_NONE: u32 = 0;
pub const RTE_ETH_SPEED_NUM_10M: u32 = 10;
pub const RTE_ETH_SPEED_NUM_100M: u32 = 100;
pub const RTE_ETH_SPEED_NUM_1G: u32 = 1000;
pub const RTE_ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const RTE_ETH_SPEED_NUM_5G: u32 = 5000;
pub const RTE_ETH_SPEED_NUM_10G: u32 = 10000;
pub const RTE_ETH_SPEED_NUM_20G: u32 = 20000;
pub const RTE_ETH_SPEED_NUM_25G: u32 = 25000;
pub const RTE_ETH_SPEED_NUM_40G: u32 = 40000;
pub const RTE_ETH_SPEED_NUM_50G: u32 = 50000;
pub const RTE_ETH_SPEED_NUM_56G: u32 = 56000;
pub const RTE_ETH_SPEED_NUM_100G: u32 = 100000;
pub const RTE_ETH_SPEED_NUM_200G: u32 = 200000;
pub const RTE_ETH_SPEED_NUM_400G: u32 = 400000;
pub const RTE_ETH_SPEED_NUM_UNKNOWN: u32 = 4294967295;
pub const RTE_ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const RTE_ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const RTE_ETH_LINK_DOWN: u32 = 0;
pub const RTE_ETH_LINK_UP: u32 = 1;
pub const RTE_ETH_LINK_FIXED: u32 = 0;
pub const RTE_ETH_LINK_AUTONEG: u32 = 1;
pub const RTE_ETH_LINK_MAX_STR_LEN: u32 = 40;
pub const RTE_ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const RTE_ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const RTE_ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const RTE_ETH_RSS_IPV4: u32 = 4;
pub const RTE_ETH_RSS_FRAG_IPV4: u32 = 8;
pub const RTE_ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const RTE_ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const RTE_ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const RTE_ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const RTE_ETH_RSS_IPV6: u32 = 256;
pub const RTE_ETH_RSS_FRAG_IPV6: u32 = 512;
pub const RTE_ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const RTE_ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const RTE_ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const RTE_ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const RTE_ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const RTE_ETH_RSS_IPV6_EX: u32 = 32768;
pub const RTE_ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const RTE_ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const RTE_ETH_RSS_PORT: u32 = 262144;
pub const RTE_ETH_RSS_VXLAN: u32 = 524288;
pub const RTE_ETH_RSS_GENEVE: u32 = 1048576;
pub const RTE_ETH_RSS_NVGRE: u32 = 2097152;
pub const RTE_ETH_RSS_GTPU: u32 = 8388608;
pub const RTE_ETH_RSS_ETH: u32 = 16777216;
pub const RTE_ETH_RSS_S_VLAN: u32 = 33554432;
pub const RTE_ETH_RSS_C_VLAN: u32 = 67108864;
pub const RTE_ETH_RSS_ESP: u32 = 134217728;
pub const RTE_ETH_RSS_AH: u32 = 268435456;
pub const RTE_ETH_RSS_L2TPV3: u32 = 536870912;
pub const RTE_ETH_RSS_PFCP: u32 = 1073741824;
pub const RTE_ETH_RSS_PPPOE: u32 = 2147483648;
pub const RTE_ETH_RSS_ECPRI: u64 = 4294967296;
pub const RTE_ETH_RSS_MPLS: u64 = 8589934592;
pub const RTE_ETH_RSS_IPV4_CHKSUM: u64 = 17179869184;
pub const RTE_ETH_RSS_L4_CHKSUM: u64 = 34359738368;
pub const RTE_ETH_RSS_L2TPV2: u64 = 68719476736;
pub const RTE_ETH_RSS_IPV6_FLOW_LABEL: u64 = 137438953472;
pub const RTE_ETH_RSS_L3_SRC_ONLY: i64 = -9223372036854775808;
pub const RTE_ETH_RSS_L3_DST_ONLY: u64 = 4611686018427387904;
pub const RTE_ETH_RSS_L4_SRC_ONLY: u64 = 2305843009213693952;
pub const RTE_ETH_RSS_L4_DST_ONLY: u64 = 1152921504606846976;
pub const RTE_ETH_RSS_L2_SRC_ONLY: u64 = 576460752303423488;
pub const RTE_ETH_RSS_L2_DST_ONLY: u64 = 288230376151711744;
pub const RTE_ETH_RSS_L3_PRE32: u64 = 144115188075855872;
pub const RTE_ETH_RSS_L3_PRE40: u64 = 72057594037927936;
pub const RTE_ETH_RSS_L3_PRE48: u64 = 36028797018963968;
pub const RTE_ETH_RSS_L3_PRE56: u64 = 18014398509481984;
pub const RTE_ETH_RSS_L3_PRE64: u64 = 9007199254740992;
pub const RTE_ETH_RSS_L3_PRE96: u64 = 4503599627370496;
pub const RTE_ETH_RSS_LEVEL_PMD_DEFAULT: u32 = 0;
pub const RTE_ETH_RSS_LEVEL_OUTERMOST: u64 = 1125899906842624;
pub const RTE_ETH_RSS_LEVEL_INNERMOST: u64 = 2251799813685248;
pub const RTE_ETH_RSS_LEVEL_MASK: u64 = 3377699720527872;
pub const RTE_ETH_RSS_IPV6_PRE32: u64 = 144115188075856128;
pub const RTE_ETH_RSS_IPV6_PRE40: u64 = 72057594037928192;
pub const RTE_ETH_RSS_IPV6_PRE48: u64 = 36028797018964224;
pub const RTE_ETH_RSS_IPV6_PRE56: u64 = 18014398509482240;
pub const RTE_ETH_RSS_IPV6_PRE64: u64 = 9007199254741248;
pub const RTE_ETH_RSS_IPV6_PRE96: u64 = 4503599627370752;
pub const RTE_ETH_RSS_IPV6_PRE32_UDP: u64 = 144115188075857920;
pub const RTE_ETH_RSS_IPV6_PRE40_UDP: u64 = 72057594037929984;
pub const RTE_ETH_RSS_IPV6_PRE48_UDP: u64 = 36028797018966016;
pub const RTE_ETH_RSS_IPV6_PRE56_UDP: u64 = 18014398509484032;
pub const RTE_ETH_RSS_IPV6_PRE64_UDP: u64 = 9007199254743040;
pub const RTE_ETH_RSS_IPV6_PRE96_UDP: u64 = 4503599627372544;
pub const RTE_ETH_RSS_IPV6_PRE32_TCP: u64 = 144115188075856896;
pub const RTE_ETH_RSS_IPV6_PRE40_TCP: u64 = 72057594037928960;
pub const RTE_ETH_RSS_IPV6_PRE48_TCP: u64 = 36028797018964992;
pub const RTE_ETH_RSS_IPV6_PRE56_TCP: u64 = 18014398509483008;
pub const RTE_ETH_RSS_IPV6_PRE64_TCP: u64 = 9007199254742016;
pub const RTE_ETH_RSS_IPV6_PRE96_TCP: u64 = 4503599627371520;
pub const RTE_ETH_RSS_IPV6_PRE32_SCTP: u64 = 144115188075859968;
pub const RTE_ETH_RSS_IPV6_PRE40_SCTP: u64 = 72057594037932032;
pub const RTE_ETH_RSS_IPV6_PRE48_SCTP: u64 = 36028797018968064;
pub const RTE_ETH_RSS_IPV6_PRE56_SCTP: u64 = 18014398509486080;
pub const RTE_ETH_RSS_IPV6_PRE64_SCTP: u64 = 9007199254745088;
pub const RTE_ETH_RSS_IPV6_PRE96_SCTP: u64 = 4503599627374592;
pub const RTE_ETH_RSS_IP: u32 = 41868;
pub const RTE_ETH_RSS_UDP: u32 = 133152;
pub const RTE_ETH_RSS_TCP: u32 = 66576;
pub const RTE_ETH_RSS_SCTP: u32 = 4160;
pub const RTE_ETH_RSS_TUNNEL: u32 = 3670016;
pub const RTE_ETH_RSS_VLAN: u32 = 100663296;
pub const RTE_ETH_RSS_PROTO_MASK: u64 = 8594128892;
pub const RTE_ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const RTE_ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const RTE_ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const RTE_ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_ETH_RETA_GROUP_SIZE: u32 = 64;
pub const RTE_ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const RTE_ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const RTE_ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_DCB_PG_SUPPORT: u32 = 1;
pub const RTE_ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const RTE_ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_OFFLOAD: u32 = 8;
pub const RTE_ETH_VLAN_STRIP_MASK: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_MASK: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_MASK: u32 = 8;
pub const RTE_ETH_VLAN_ID_MAX: u32 = 4095;
pub const RTE_ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const RTE_ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const RTE_ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const RTE_ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const RTE_ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const RTE_ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_RWLOCK_WAIT: u32 = 1;
pub const RTE_RWLOCK_WRITE: u32 = 2;
pub const RTE_RWLOCK_MASK: u32 = 3;
pub const RTE_RWLOCK_READ: u32 = 4;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4] = b"RG_\0";
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RING_F_MP_RTS_ENQ: u32 = 8;
pub const RING_F_MC_RTS_DEQ: u32 = 16;
pub const RING_F_MP_HTS_ENQ: u32 = 32;
pub const RING_F_MC_HTS_DEQ: u32 = 64;
pub const XMM_SIZE: u32 = 16;
pub const XMM_MASK: u32 = 15;
pub const ALIGNMENT_MASK: u32 = 15;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const RTE_MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const RTE_MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const RTE_MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_F_NON_IO: u32 = 64;
pub const RTE_MEMPOOL_VALID_USER_FLAGS: u32 = 47;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_ESP: u32 = 2048;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_ESP: u32 = 134217728;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_MBUF_F_RX_VLAN: u32 = 1;
pub const RTE_MBUF_F_RX_RSS_HASH: u32 = 2;
pub const RTE_MBUF_F_RX_FDIR: u32 = 4;
pub const RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD: u32 = 32;
pub const RTE_MBUF_F_RX_VLAN_STRIPPED: u32 = 64;
pub const RTE_MBUF_F_RX_IP_CKSUM_MASK: u32 = 144;
pub const RTE_MBUF_F_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_IP_CKSUM_BAD: u32 = 16;
pub const RTE_MBUF_F_RX_IP_CKSUM_GOOD: u32 = 128;
pub const RTE_MBUF_F_RX_IP_CKSUM_NONE: u32 = 144;
pub const RTE_MBUF_F_RX_L4_CKSUM_MASK: u32 = 264;
pub const RTE_MBUF_F_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_L4_CKSUM_BAD: u32 = 8;
pub const RTE_MBUF_F_RX_L4_CKSUM_GOOD: u32 = 256;
pub const RTE_MBUF_F_RX_L4_CKSUM_NONE: u32 = 264;
pub const RTE_MBUF_F_RX_IEEE1588_PTP: u32 = 512;
pub const RTE_MBUF_F_RX_IEEE1588_TMST: u32 = 1024;
pub const RTE_MBUF_F_RX_FDIR_ID: u32 = 8192;
pub const RTE_MBUF_F_RX_FDIR_FLX: u32 = 16384;
pub const RTE_MBUF_F_RX_QINQ_STRIPPED: u32 = 32768;
pub const RTE_MBUF_F_RX_LRO: u32 = 65536;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD: u32 = 262144;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const RTE_MBUF_F_RX_QINQ: u32 = 1048576;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const RTE_MBUF_F_FIRST_FREE: u32 = 8388608;
pub const RTE_MBUF_F_LAST_FREE: u64 = 1099511627776;
pub const RTE_MBUF_F_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const RTE_MBUF_F_TX_UDP_SEG: u64 = 4398046511104;
pub const RTE_MBUF_F_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const RTE_MBUF_F_TX_MACSEC: u64 = 17592186044416;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const RTE_MBUF_F_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const RTE_MBUF_F_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const RTE_MBUF_F_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const RTE_MBUF_F_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const RTE_MBUF_F_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const RTE_MBUF_F_TX_TUNNEL_ESP: u64 = 281474976710656;
pub const RTE_MBUF_F_TX_TUNNEL_IP: u64 = 457396837154816;
pub const RTE_MBUF_F_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const RTE_MBUF_F_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const RTE_MBUF_F_TX_QINQ: u64 = 562949953421312;
pub const RTE_MBUF_F_TX_TCP_SEG: u64 = 1125899906842624;
pub const RTE_MBUF_F_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const RTE_MBUF_F_TX_L4_NO_CKSUM: u32 = 0;
pub const RTE_MBUF_F_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const RTE_MBUF_F_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const RTE_MBUF_F_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_L4_MASK: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_IP_CKSUM: u64 = 18014398509481984;
pub const RTE_MBUF_F_TX_IPV4: u64 = 36028797018963968;
pub const RTE_MBUF_F_TX_IPV6: u64 = 72057594037927936;
pub const RTE_MBUF_F_TX_VLAN: u64 = 144115188075855872;
pub const RTE_MBUF_F_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const RTE_MBUF_F_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const RTE_MBUF_F_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const RTE_MBUF_F_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_F_EXTERNAL: u64 = 2305843009213693952;
pub const RTE_MBUF_F_INDIRECT: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const MBUF_INVALID_PORT: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_VLAN_HLEN: u32 = 4;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_VLAN_DEI_SHIFT: u32 = 12;
pub const RTE_VLAN_PRI_SHIFT: u32 = 13;
pub const RTE_VLAN_PRI_MASK: u32 = 57344;
pub const RTE_VLAN_DEI_MASK: u32 = 4096;
pub const RTE_VLAN_ID_MASK: u32 = 4095;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_PRT_FMT: &[u8; 30] = b"%02X:%02X:%02X:%02X:%02X:%02X\0";
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_QINQ1: u32 = 37120;
pub const RTE_ETHER_TYPE_QINQ2: u32 = 37376;
pub const RTE_ETHER_TYPE_QINQ3: u32 = 37632;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETHER_TYPE_ECPRI: u32 = 44798;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_ICMP_TYPE_ECHO_REPLY: u32 = 0;
pub const RTE_ICMP_TYPE_DEST_UNREACHABLE: u32 = 3;
pub const RTE_ICMP_TYPE_REDIRECT: u32 = 5;
pub const RTE_ICMP_TYPE_ECHO_REQUEST: u32 = 8;
pub const RTE_ICMP_TYPE_TTL_EXCEEDED: u32 = 11;
pub const RTE_ICMP_TYPE_PARAM_PROBLEM: u32 = 12;
pub const RTE_ICMP_TYPE_TIMESTAMP_REQUEST: u32 = 13;
pub const RTE_ICMP_TYPE_TIMESTAMP_REPLY: u32 = 14;
pub const RTE_ICMP_CODE_UNREACH_NET: u32 = 0;
pub const RTE_ICMP_CODE_UNREACH_HOST: u32 = 1;
pub const RTE_ICMP_CODE_UNREACH_PROTO: u32 = 2;
pub const RTE_ICMP_CODE_UNREACH_PORT: u32 = 3;
pub const RTE_ICMP_CODE_UNREACH_FRAG: u32 = 4;
pub const RTE_ICMP_CODE_UNREACH_SRC: u32 = 5;
pub const RTE_ICMP_CODE_TTL_EXCEEDED: u32 = 0;
pub const RTE_ICMP_CODE_TTL_FRAG: u32 = 1;
pub const RTE_ICMP_CODE_REDIRECT_NET: u32 = 0;
pub const RTE_ICMP_CODE_REDIRECT_HOST: u32 = 1;
pub const RTE_ICMP_CODE_REDIRECT_TOS_NET: u32 = 2;
pub const RTE_ICMP_CODE_REDIRECT_TOS_HOST: u32 = 3;
pub const RTE_ICMP6_ECHO_REQUEST: u32 = 128;
pub const RTE_ICMP6_ECHO_REPLY: u32 = 129;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOL_VSOCK: u32 = 287;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_LOCAL_PORT_RANGE: u32 = 51;
pub const IP_PROTOCOL: u32 = 52;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _ARPA_INET_H: u32 = 1;
pub const __NETINET_IP_H: u32 = 1;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const IPVERSION: u32 = 4;
pub const IP_MAXPACKET: u32 = 65535;
pub const IPTOS_ECN_MASK: u32 = 3;
pub const IPTOS_ECN_NOT_ECT: u32 = 0;
pub const IPTOS_ECN_ECT1: u32 = 1;
pub const IPTOS_ECN_ECT0: u32 = 2;
pub const IPTOS_ECN_CE: u32 = 3;
pub const IPTOS_DSCP_MASK: u32 = 252;
pub const IPTOS_DSCP_AF11: u32 = 40;
pub const IPTOS_DSCP_AF12: u32 = 48;
pub const IPTOS_DSCP_AF13: u32 = 56;
pub const IPTOS_DSCP_AF21: u32 = 72;
pub const IPTOS_DSCP_AF22: u32 = 80;
pub const IPTOS_DSCP_AF23: u32 = 88;
pub const IPTOS_DSCP_AF31: u32 = 104;
pub const IPTOS_DSCP_AF32: u32 = 112;
pub const IPTOS_DSCP_AF33: u32 = 120;
pub const IPTOS_DSCP_AF41: u32 = 136;
pub const IPTOS_DSCP_AF42: u32 = 144;
pub const IPTOS_DSCP_AF43: u32 = 152;
pub const IPTOS_DSCP_EF: u32 = 184;
pub const IPTOS_DSCP_VA: u32 = 176;
pub const IPTOS_DSCP_LE: u32 = 4;
pub const IPTOS_CLASS_MASK: u32 = 224;
pub const IPTOS_CLASS_CS0: u32 = 0;
pub const IPTOS_CLASS_CS1: u32 = 32;
pub const IPTOS_CLASS_CS2: u32 = 64;
pub const IPTOS_CLASS_CS3: u32 = 96;
pub const IPTOS_CLASS_CS4: u32 = 128;
pub const IPTOS_CLASS_CS5: u32 = 160;
pub const IPTOS_CLASS_CS6: u32 = 192;
pub const IPTOS_CLASS_CS7: u32 = 224;
pub const IPTOS_CLASS_DEFAULT: u32 = 0;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CLASS_MASK: u32 = 96;
pub const IPOPT_NUMBER_MASK: u32 = 31;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_DEBMEAS: u32 = 64;
pub const IPOPT_MEASUREMENT: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_END: u32 = 0;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_NOOP: u32 = 1;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_TIMESTAMP: u32 = 68;
pub const IPOPT_SECURITY: u32 = 130;
pub const IPOPT_SEC: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_SATID: u32 = 136;
pub const IPOPT_SID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_MINOFF: u32 = 4;
pub const MAX_IPOPTLEN: u32 = 40;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 3;
pub const IPOPT_SECUR_UNCLASS: u32 = 0;
pub const IPOPT_SECUR_CONFID: u32 = 61749;
pub const IPOPT_SECUR_EFTO: u32 = 30874;
pub const IPOPT_SECUR_MMMM: u32 = 48205;
pub const IPOPT_SECUR_RESTR: u32 = 44819;
pub const IPOPT_SECUR_SECRET: u32 = 55176;
pub const IPOPT_SECUR_TOPSECRET: u32 = 27589;
pub const MAXTTL: u32 = 255;
pub const IPDEFTTL: u32 = 64;
pub const IPFRAGTTL: u32 = 60;
pub const IPTTLDEC: u32 = 1;
pub const IP_MSS: u32 = 576;
pub const _NETINET_IP6_H: u32 = 1;
pub const IP6F_OFF_MASK: u32 = 63743;
pub const IP6F_RESERVED_MASK: u32 = 1536;
pub const IP6F_MORE_FRAG: u32 = 256;
pub const IP6OPT_TYPE_SKIP: u32 = 0;
pub const IP6OPT_TYPE_DISCARD: u32 = 64;
pub const IP6OPT_TYPE_FORCEICMP: u32 = 128;
pub const IP6OPT_TYPE_ICMP: u32 = 192;
pub const IP6OPT_TYPE_MUTABLE: u32 = 32;
pub const IP6OPT_PAD1: u32 = 0;
pub const IP6OPT_PADN: u32 = 1;
pub const IP6OPT_JUMBO: u32 = 194;
pub const IP6OPT_NSAP_ADDR: u32 = 195;
pub const IP6OPT_TUNNEL_LIMIT: u32 = 4;
pub const IP6OPT_ROUTER_ALERT: u32 = 5;
pub const IP6OPT_JUMBO_LEN: u32 = 6;
pub const IP6_ALERT_MLD: u32 = 0;
pub const IP6_ALERT_RSVP: u32 = 256;
pub const IP6_ALERT_AN: u32 = 512;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_HDR_OPT_EOL: u32 = 0;
pub const RTE_IPV4_HDR_OPT_NOP: u32 = 1;
pub const RTE_IPV4_HDR_OPT_MAX_LEN: u32 = 40;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_ADDR_SIZE: u32 = 16;
pub const RTE_IPV6_ADDR_FMT: &[u8; 72] =
    b"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\0";
pub const RTE_IPV6_SRCRT_TYPE_4: u32 = 4;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_MIN_MTU: u32 = 1280;
pub const RTE_IPV6_EHDR_MF_SHIFT: u32 = 0;
pub const RTE_IPV6_EHDR_MF_MASK: u32 = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV6_EHDR_FO_MASK: i32 = -8;
pub const RTE_IPV6_EHDR_FO_ALIGN: u32 = 8;
pub const RTE_IPV6_FRAG_USED_MASK: i32 = -7;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_VXLAN_DEFAULT_PORT: u32 = 4789;
pub const RTE_VXLAN_GPE_DEFAULT_PORT: u32 = 4790;
pub const RTE_VXLAN_GPE_TYPE_IPV4: u32 = 1;
pub const RTE_VXLAN_GPE_TYPE_IPV6: u32 = 2;
pub const RTE_VXLAN_GPE_TYPE_ETH: u32 = 3;
pub const RTE_VXLAN_GPE_TYPE_NSH: u32 = 4;
pub const RTE_VXLAN_GPE_TYPE_MPLS: u32 = 5;
pub const RTE_VXLAN_GPE_TYPE_GBP: u32 = 6;
pub const RTE_VXLAN_GPE_TYPE_VBNG: u32 = 7;
pub const RTE_ECPRI_REV_UP_TO_20: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_IQ_DATA: u32 = 0;
pub const RTE_ECPRI_MSG_TYPE_BIT_SEQ: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_RTC_CTRL: u32 = 2;
pub const RTE_ECPRI_MSG_TYPE_GEN_DATA: u32 = 3;
pub const RTE_ECPRI_MSG_TYPE_RM_ACC: u32 = 4;
pub const RTE_ECPRI_MSG_TYPE_DLY_MSR: u32 = 5;
pub const RTE_ECPRI_MSG_TYPE_RMT_RST: u32 = 6;
pub const RTE_ECPRI_MSG_TYPE_EVT_IND: u32 = 7;
pub const RTE_ECPRI_MSG_TYPE_IWF_UP: u32 = 8;
pub const RTE_ECPRI_MSG_TYPE_IWF_OPT: u32 = 9;
pub const RTE_ECPRI_MSG_TYPE_IWF_MAP: u32 = 10;
pub const RTE_ECPRI_MSG_TYPE_IWF_DCTRL: u32 = 11;
pub const RTE_ECPRI_EVT_IND_FAULT_IND: u32 = 0;
pub const RTE_ECPRI_EVT_IND_FAULT_ACK: u32 = 1;
pub const RTE_ECPRI_EVT_IND_NTFY_IND: u32 = 2;
pub const RTE_ECPRI_EVT_IND_SYNC_REQ: u32 = 3;
pub const RTE_ECPRI_EVT_IND_SYNC_ACK: u32 = 4;
pub const RTE_ECPRI_EVT_IND_SYNC_END: u32 = 5;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &[u8; 27] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &[u8; 26] = b"rte_flow_dynflag_metadata\0";
pub const RTE_MBUF_DYNFIELD_TIMESTAMP_NAME: &[u8; 23] = b"rte_dynfield_timestamp\0";
pub const RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME: &[u8; 25] = b"rte_dynflag_rx_timestamp\0";
pub const RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME: &[u8; 25] = b"rte_dynflag_tx_timestamp\0";
pub const RTE_MBUF_DYNFIELD_IP_REASSEMBLY_NAME: &[u8; 27] = b"rte_dynfield_ip_reassembly\0";
pub const RTE_MBUF_DYNFLAG_IP_REASSEMBLY_INCOMPLETE_NAME: &[u8; 37] =
    b"rte_dynflag_ip_reassembly_incomplete\0";
pub const RTE_GTP_TYPE_IPV4: u32 = 64;
pub const RTE_GTP_TYPE_IPV6: u32 = 96;
pub const RTE_GTPC_UDP_PORT: u32 = 2123;
pub const RTE_GTPU_UDP_PORT: u32 = 2152;
pub const RTE_L2TPV2_MSG_TYPE_CONTROL: u32 = 51202;
pub const RTE_L2TPV2_MSG_TYPE_DATA: u32 = 2;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L: u32 = 16386;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S: u32 = 2050;
pub const RTE_L2TPV2_MSG_TYPE_DATA_O: u32 = 514;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S: u32 = 18434;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_O: u32 = 16898;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S_O: u32 = 2562;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S_O: u32 = 18946;
pub const RTE_MACSEC_TCI_VER_MASK: u32 = 128;
pub const RTE_MACSEC_TCI_ES: u32 = 64;
pub const RTE_MACSEC_TCI_SC: u32 = 32;
pub const RTE_MACSEC_TCI_SCB: u32 = 16;
pub const RTE_MACSEC_TCI_E: u32 = 8;
pub const RTE_MACSEC_TCI_C: u32 = 4;
pub const RTE_MACSEC_AN_MASK: u32 = 3;
pub const RTE_MACSEC_SCI_LEN: u32 = 8;
pub const RTE_ROCEV2_DEFAULT_PORT: u32 = 4791;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const RTE_ETH_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const RTE_ETH_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const RTE_ETH_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const RTE_ETH_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const RTE_ETH_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const RTE_ETH_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const RTE_ETH_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const RTE_ETH_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const RTE_ETH_RX_OFFLOAD_VLAN_FILTER: u32 = 512;
pub const RTE_ETH_RX_OFFLOAD_VLAN_EXTEND: u32 = 1024;
pub const RTE_ETH_RX_OFFLOAD_SCATTER: u32 = 8192;
pub const RTE_ETH_RX_OFFLOAD_TIMESTAMP: u32 = 16384;
pub const RTE_ETH_RX_OFFLOAD_SECURITY: u32 = 32768;
pub const RTE_ETH_RX_OFFLOAD_KEEP_CRC: u32 = 65536;
pub const RTE_ETH_RX_OFFLOAD_SCTP_CKSUM: u32 = 131072;
pub const RTE_ETH_RX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 262144;
pub const RTE_ETH_RX_OFFLOAD_RSS_HASH: u32 = 524288;
pub const RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT: u32 = 1048576;
pub const RTE_ETH_RX_OFFLOAD_CHECKSUM: u32 = 14;
pub const RTE_ETH_RX_OFFLOAD_VLAN: u32 = 1569;
pub const RTE_ETH_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const RTE_ETH_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const RTE_ETH_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const RTE_ETH_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const RTE_ETH_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const RTE_ETH_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const RTE_ETH_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const RTE_ETH_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const RTE_ETH_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const RTE_ETH_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const RTE_ETH_TX_OFFLOAD_MULTI_SEGS: u32 = 32768;
pub const RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE: u32 = 65536;
pub const RTE_ETH_TX_OFFLOAD_SECURITY: u32 = 131072;
pub const RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO: u32 = 262144;
pub const RTE_ETH_TX_OFFLOAD_IP_TNL_TSO: u32 = 524288;
pub const RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 1048576;
pub const RTE_ETH_TX_OFFLOAD_SEND_ON_TIMESTAMP: u32 = 2097152;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_CAPA_RXQ_SHARE: u32 = 4;
pub const RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP: u32 = 8;
pub const RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP: u32 = 16;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const RTE_ETH_QUEUE_STATE_HAIRPIN: u32 = 2;
pub const RTE_ETH_BURST_FLAG_PER_QUEUE: u32 = 1;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_ETH_DCB_NUM_TCS: u32 = 8;
pub const RTE_ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_FLOW_OPS_THREAD_SAFE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDING_MEMBER: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub const RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS: u32 = 64;
pub const RTE_ETH_RX_METADATA_USER_FLAG: u32 = 1;
pub const RTE_ETH_RX_METADATA_USER_MARK: u32 = 2;
pub const RTE_ETH_RX_METADATA_TUNNEL_ID: u32 = 4;
pub const RTE_ETH_DEV_REASSEMBLY_F_IPV4: u32 = 1;
pub const RTE_ETH_DEV_REASSEMBLY_F_IPV6: u32 = 2;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
#[doc = " Physical address"]
pub type phys_addr_t = u64;
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Generic marker for any place in a structure."]
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
#[doc = " Marker for 1B alignment in a structure."]
pub type RTE_MARKER8 = [u8; 0usize];
#[doc = " Marker for 2B alignment in a structure."]
pub type RTE_MARKER16 = [u16; 0usize];
#[doc = " Marker for 4B alignment in a structure."]
pub type RTE_MARKER32 = [u32; 0usize];
#[doc = " Marker for 8B alignment in a structure."]
pub type RTE_MARKER64 = [u64; 0usize];
unsafe extern "C" {
    #[doc = " Converts a numeric string to the equivalent uint64_t value.\n As well as straight number conversion, also recognises the suffixes\n k, m and g for kilobytes, megabytes and gigabytes respectively.\n\n If a negative number is passed in  i.e. a string with the first non-black\n character being \"-\", zero is returned. Zero is also returned in the case of\n an error with the strtoull call in the function.\n\n @param str\n     String containing number to convert.\n @return\n     Number."]
    pub fn rte_str_to_size(str_: *const ::std::os::raw::c_char) -> u64;
}
unsafe extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error\n message and returning the exit_code back to the shell.\n\n This function never returns\n\n @param exit_code\n     The exit code to be returned by the application\n @param format\n     The format string to be used for printing the message. This can include\n     printf format characters which will be expanded using any further parameters\n     to the function."]
    pub fn rte_exit(
        exit_code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
unsafe extern "C" {
    #[doc = " Change the stream that will be used by the logging system.\n\n This can be done at any time. The f argument represents the stream\n to be used to send the logs. If f is NULL, the default output is\n used (stderr).\n\n @param f\n   Pointer to the stream.\n @return\n   - 0 on success.\n   - Negative on error."]
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the stream used by the logging system (see rte_openlog_stream()\n to change it).\n\n @return\n   Pointer to the stream."]
    pub fn rte_log_get_stream() -> *mut FILE;
}
unsafe extern "C" {
    #[doc = " Set the global log level.\n\n After this call, logs with a level lower or equal than the level\n passed as argument will be displayed.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    pub fn rte_log_set_global_level(level: u32);
}
unsafe extern "C" {
    #[doc = " Get the global log level.\n\n @return\n   The current global log level."]
    pub fn rte_log_get_global_level() -> u32;
}
unsafe extern "C" {
    #[doc = " Get the log level for a given type.\n\n @param logtype\n   The log type identifier.\n @return\n   0 on success, a negative value if logtype is invalid."]
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " For a given `logtype`, check if a log with `loglevel` can be printed.\n\n @param logtype\n   The log type identifier\n @param loglevel\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @return\n Returns 'true' if log can be printed and 'false' if it can't."]
    pub fn rte_log_can_log(logtype: u32, loglevel: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type based on globbing pattern.\n\n @param pattern\n   The globbing pattern identifying the log type.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type based on regular expression.\n\n @param regex\n   The regular expression identifying the log type.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the log level for a given type.\n\n @param logtype\n   The log type identifier.\n @param level\n   The level to be set.\n @return\n   0 on success, a negative value if logtype or level is invalid."]
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current loglevel for the message being processed.\n\n Before calling the user-defined stream for logging, the log\n subsystem sets a per-lcore variable containing the loglevel and the\n logtype of the message being processed. This information can be\n accessed by the user-defined log output function through this\n function.\n\n @return\n   The loglevel of the message being processed."]
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current logtype for the message being processed.\n\n Before calling the user-defined stream for logging, the log\n subsystem sets a per-lcore variable containing the loglevel and the\n logtype of the message being processed. This information can be\n accessed by the user-defined log output function through this\n function.\n\n @return\n   The logtype of the message being processed."]
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register a dynamic log type\n\n If a log is already registered with the same type, the returned value\n is the same than the previous one.\n\n @param name\n   The string identifying the log type.\n @return\n   - >0: success, the returned value is the log type identifier.\n   - (-ENOMEM): cannot allocate memory."]
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register a dynamic log type and try to pick its level from EAL options\n\n rte_log_register() is called inside. If successful, the function tries\n to search for matching regexp in the list of EAL log level options and\n pick the level from the last matching entry. If nothing can be applied\n from the list, the level will be set to the user-defined default value.\n\n @param name\n    Name for the log type to be registered\n @param level_def\n    Fallback level to be set if the global list has no matching options\n @return\n    - >=0: the newly registered log type\n    - <0: rte_log_register() error value"]
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump name of each logtype, one per line.\n\n @param out\n   Stream where the list is sent.\n @param prefix\n   String preceding each logtype in the output."]
    pub fn rte_log_list_types(out: *mut FILE, prefix: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Dump log information.\n\n Dump the global level and the registered log types.\n\n @param f\n   The output stream where the dump should be sent."]
    pub fn rte_log_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Generates a log message.\n\n The message will be sent in the stream defined by the previous call\n to rte_openlog_stream().\n\n The level argument determines if the log should be displayed or\n not, depending on the loglevel settings.\n\n The preferred alternative is the RTE_LOG() because it adds the\n level and type in the logged string.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @param logtype\n   The log type, for example, RTE_LOGTYPE_EAL.\n @param format\n   The format string, as in printf(3), followed by the variable arguments\n   required by the format.\n @return\n   - 0: Success.\n   - Negative on error."]
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Generates a log message.\n\n The message will be sent in the stream defined by the previous call\n to rte_openlog_stream().\n\n The level argument determines if the log should be displayed or\n not, depending on the loglevel settings. A trailing\n newline may be added if needed.\n\n The preferred alternative is the RTE_LOG() because it adds the\n level and type in the logged string.\n\n @param level\n   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).\n @param logtype\n   The log type, for example, RTE_LOGTYPE_EAL.\n @param format\n   The format string, as in printf(3), followed by the variable arguments\n   required by the format.\n @param ap\n   The va_list of the variable arguments required by the format.\n @return\n   - 0: Success.\n   - Negative on error."]
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the stack of the calling core to the standard error."]
    pub fn rte_dump_stack();
}
unsafe extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub type rte_memory_order = ::std::os::raw::c_int;
#[doc = " Congestion based on Random Early Detection.\n\n https://en.wikipedia.org/wiki/Random_early_detection\n http://www.aciri.org/floyd/papers/red/red.html\n @see struct rte_cman_red_params"]
pub const rte_cman_mode_RTE_CMAN_RED: rte_cman_mode = 1;
#[doc = " Congestion management modes"]
pub type rte_cman_mode = ::std::os::raw::c_uint;
#[doc = " RED based congestion management configuration parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_cman_red_params {
    #[doc = " Minimum threshold (min_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub min_th: u8,
    #[doc = " Maximum threshold (max_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub max_th: u8,
    #[doc = " Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv)"]
    pub maxp_inv: u16,
}
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_epoll_data {
    #[doc = "< event type"]
    pub event: u32,
    #[doc = "< User data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< IN: callback fun"]
    pub cb_fun: rte_intr_event_cb_t,
    #[doc = "< IN: callback arg"]
    pub cb_arg: *mut ::std::os::raw::c_void,
}
pub const RTE_EPOLL_INVALID: _bindgen_ty_1 = 0;
pub const RTE_EPOLL_VALID: _bindgen_ty_1 = 1;
pub const RTE_EPOLL_EXEC: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " interrupt epoll event obj, taken by epoll_event.ptr"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_epoll_event {
    #[doc = "< OUT: event status"]
    pub status: u32,
    #[doc = "< OUT: event fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< OUT: epoll instance the ev associated with"]
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
unsafe extern "C" {
    #[doc = " It waits for events on the epoll instance.\n Retries if signal received.\n\n @param epfd\n   Epoll instance fd on which the caller wait for events.\n @param events\n   Memory area contains the events that will be available for the caller.\n @param maxevents\n   Up to maxevents are returned, must greater than zero.\n @param timeout\n   Specifying a timeout of -1 causes a block indefinitely.\n   Specifying a timeout equal to zero cause to return immediately.\n @return\n   - On success, returns the number of available event.\n   - On failure, a negative value."]
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It waits for events on the epoll instance.\n Does not retry if signal received.\n\n @param epfd\n   Epoll instance fd on which the caller wait for events.\n @param events\n   Memory area contains the events that will be available for the caller.\n @param maxevents\n   Up to maxevents are returned, must greater than zero.\n @param timeout\n   Specifying a timeout of -1 causes a block indefinitely.\n   Specifying a timeout equal to zero cause to return immediately.\n @return\n   - On success, returns the number of available event.\n   - On failure, a negative value."]
    pub fn rte_epoll_wait_interruptible(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It performs control operations on epoll instance referred by the epfd.\n It requests that the operation op be performed for the target fd.\n\n @param epfd\n   Epoll instance fd on which the caller perform control operations.\n @param op\n   The operation be performed for the target fd.\n @param fd\n   The target fd on which the control ops perform.\n @param event\n   Describes the object linked to the fd.\n   Note: The caller must take care the object deletion after CTL_DEL.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    _unused: [u8; 0],
}
#[doc = "< generic unknown handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UNKNOWN: rte_intr_handle_type = 0;
#[doc = "< uio device handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO: rte_intr_handle_type = 1;
#[doc = "< uio generic handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO_INTX: rte_intr_handle_type = 2;
#[doc = "< vfio device handle (legacy)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_LEGACY: rte_intr_handle_type = 3;
#[doc = "< vfio device handle (MSI)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSI: rte_intr_handle_type = 4;
#[doc = "< vfio device handle (MSIX)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSIX: rte_intr_handle_type = 5;
#[doc = "< alarm handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_ALARM: rte_intr_handle_type = 6;
#[doc = "< external handler"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_EXT: rte_intr_handle_type = 7;
#[doc = "< virtual device"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VDEV: rte_intr_handle_type = 8;
#[doc = "< device event handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_DEV_EVENT: rte_intr_handle_type = 9;
#[doc = "< VFIO request handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_REQ: rte_intr_handle_type = 10;
#[doc = "< count of elements"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_MAX: rte_intr_handle_type = 11;
#[doc = " The interrupt source type, e.g. UIO, VFIO, ALARM etc."]
pub type rte_intr_handle_type = ::std::os::raw::c_uint;
#[doc = " Function to be registered for the specific interrupt"]
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
#[doc = " Function to call after a callback is unregistered.\n Can be used to close fd and free cb_arg."]
pub type rte_intr_unregister_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(intr_handle: *mut rte_intr_handle, cb_arg: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " It registers the callback for the specific interrupt. Multiple\n callbacks can be registered at the same time.\n @param intr_handle\n  Pointer to the interrupt handle.\n @param cb\n  callback address.\n @param cb_arg\n  address of parameter for callback.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It unregisters the callback according to the specified interrupt handle.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param cb\n  callback address.\n @param cb_arg\n  address of parameter for callback, (void *)-1 means to remove all\n  registered which has the same callback address.\n\n @return\n  - On success, return the number of callback entities removed.\n  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister the callback according to the specified interrupt handle,\n after it's no longer active. Fail if source is not active.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param cb_fn\n  callback address.\n @param cb_arg\n  address of parameter for callback, (void *)-1 means to remove all\n  registered which has the same callback address.\n @param ucb_fn\n  callback to call before cb is unregistered (optional).\n  can be used to close fd and free cb_arg.\n\n @return\n  - On success, return the number of callback entities marked for remove.\n  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister_pending(
        intr_handle: *const rte_intr_handle,
        cb_fn: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
        ucb_fn: rte_intr_unregister_callback_fn,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Loop until rte_intr_callback_unregister() succeeds.\n After a call to this function,\n the callback provided by the specified interrupt handle is unregistered.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param cb\n  callback address.\n @param cb_arg\n  address of parameter for callback, (void *)-1 means to remove all\n  registered which has the same callback address.\n\n @return\n  - On success, return the number of callback entities removed.\n  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister_sync(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It enables the interrupt for the specified handle.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It disables the interrupt for the specified handle.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It acknowledges an interrupt raised for the specified handle.\n\n This function should be called at the end of each interrupt handler either\n from application or driver, so that currently raised interrupt is acked and\n further new interrupts are raised.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_intr_ack(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if currently executing in interrupt context\n\n @return\n  - non zero in case of interrupt context\n  - zero in case of process context"]
    pub fn rte_thread_is_intr() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It allocates memory for interrupt instance. API takes flag as an argument\n which define from where memory should be allocated i.e. using DPDK memory\n management library APIs or normal heap allocation.\n Default memory allocation for event fds and event list array is done which\n can be realloced later based on size of MSIX interrupts supported by a PCI\n device.\n\n This function should be called from application or driver, before calling\n any of the interrupt APIs.\n\n @param flags\n  See RTE_INTR_INSTANCE_F_* flags definitions.\n\n @return\n  - On success, address of interrupt handle.\n  - On failure, NULL."]
    pub fn rte_intr_instance_alloc(flags: u32) -> *mut rte_intr_handle;
}
unsafe extern "C" {
    #[doc = " Free the memory allocated for interrupt handle resources.\n\n @param intr_handle\n  Interrupt handle allocated with rte_intr_instance_alloc().\n  If intr_handle is NULL, no operation is performed."]
    pub fn rte_intr_instance_free(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    #[doc = " Set the fd field of interrupt handle with user provided\n file descriptor.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param fd\n  file descriptor value provided by user.\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_fd_set(
        intr_handle: *mut rte_intr_handle,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the fd field of the given interrupt handle instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, fd field.\n  - On failure, a negative value."]
    pub fn rte_intr_fd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the type field of interrupt handle with user provided\n interrupt type.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param type\n  interrupt type\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_type_set(
        intr_handle: *mut rte_intr_handle,
        type_: rte_intr_handle_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the type field of the given interrupt handle instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, interrupt type\n  - On failure, RTE_INTR_HANDLE_UNKNOWN."]
    pub fn rte_intr_type_get(intr_handle: *const rte_intr_handle) -> rte_intr_handle_type;
}
unsafe extern "C" {
    #[doc = " @internal\n The function returns the per thread epoll instance.\n\n @return\n   epfd the epoll instance referred to."]
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n @param intr_handle\n   Pointer to the interrupt handle.\n @param epfd\n   Epoll instance fd which the intr vector associated to.\n @param op\n   The operation be performed for the vector.\n   Operation type of {ADD, DEL}.\n @param vec\n   RX intr vector number added to the epoll instance wait list.\n @param data\n   User raw data.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n It deletes registered eventfds.\n\n @param intr_handle\n   Pointer to the interrupt handle."]
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    #[doc = " @internal\n It enables the packet I/O interrupt event if it's necessary.\n It creates event fd for each interrupt vector when MSIX is used,\n otherwise it multiplexes a single event fd.\n\n @param intr_handle\n   Pointer to the interrupt handle.\n @param nb_efd\n   Number of interrupt vector trying to enable.\n   The value 0 is not allowed.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n It disables the packet I/O interrupt event.\n It deletes registered eventfds and closes the open fds.\n\n @param intr_handle\n   Pointer to the interrupt handle."]
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    #[doc = " @internal\n The packet I/O interrupt on datapath is enabled or not.\n\n @param intr_handle\n   Pointer to the interrupt handle."]
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n The interrupt handle instance allows other causes or not.\n Other causes stand for any none packet I/O interrupts.\n\n @param intr_handle\n   Pointer to the interrupt handle."]
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n The multiple interrupt vector capability of interrupt handle instance.\n It returns zero if no multiple interrupt vector support.\n\n @param intr_handle\n   Pointer to the interrupt handle."]
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Creates a clone of src by allocating a new handle and copying src content.\n\n @param src\n  Source interrupt handle to be cloned.\n\n @return\n  - On success, address of interrupt handle.\n  - On failure, NULL."]
    pub fn rte_intr_instance_dup(src: *const rte_intr_handle) -> *mut rte_intr_handle;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the device fd field of interrupt handle with user\n provided dev fd. Device fd corresponds to VFIO device fd or UIO config fd.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param fd\n  interrupt type\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_dev_fd_set(
        intr_handle: *mut rte_intr_handle,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the device fd field of the given interrupt handle instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, dev fd.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_dev_fd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the max intr field of interrupt handle with user\n provided max intr value.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param max_intr\n  interrupt type\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_max_intr_set(
        intr_handle: *mut rte_intr_handle,
        max_intr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the max intr field of the given interrupt handle instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, max intr.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_max_intr_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the number of event fd field of interrupt handle\n with user provided available event file descriptor value.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param nb_efd\n  Available event fd\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_efd_set(
        intr_handle: *mut rte_intr_handle,
        nb_efd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the number of available event fd field of the given interrupt handle\n instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, nb_efd\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_efd_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the number of interrupt vector field of the given interrupt handle\n instance. This field is to configured on device probe time, and based on\n this value efds and elist arrays are dynamically allocated. By default\n this value is set to RTE_MAX_RXTX_INTR_VEC_ID.\n For eg. in case of PCI device, its msix size is queried and efds/elist\n arrays are allocated accordingly.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, nb_intr\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_nb_intr_get(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the event fd counter size field of interrupt handle\n with user provided efd counter size.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param efd_counter_size\n  size of efd counter.\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efd_counter_size_set(
        intr_handle: *mut rte_intr_handle,
        efd_counter_size: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the event fd counter size field of the given interrupt handle\n instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, efd_counter_size\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efd_counter_size_get(
        intr_handle: *const rte_intr_handle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the event fd array index with the given fd.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  efds array index to be set\n @param fd\n  event fd\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efds_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the fd value of event fds array at a given index.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  efds array index to be returned\n\n @return\n  - On success, fd\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_efds_index_get(
        intr_handle: *const rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the epoll event object array index with the given\n elist instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  elist array index to be set\n @param elist\n  epoll event instance of struct rte_epoll_event\n\n @return\n  - On success, zero.\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_elist_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        elist: rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the address of epoll event instance from elist array at a given\n index.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  elist array index to be returned\n\n @return\n  - On success, elist\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_elist_index_get(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> *mut rte_epoll_event;
}
unsafe extern "C" {
    #[doc = " @internal\n Allocates the memory of interrupt vector list array, with size defining the\n number of elements required in the array.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param name\n  Name assigned to the allocation, or NULL.\n @param size\n  Number of element required in the array.\n\n @return\n  - On success, zero\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_alloc(
        intr_handle: *mut rte_intr_handle,
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Sets the vector value at given index of interrupt vector list field of given\n interrupt handle.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  intr_vec array index to be set\n @param vec\n  Interrupt vector value.\n\n @return\n  - On success, zero\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_index_set(
        intr_handle: *mut rte_intr_handle,
        index: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the vector value at the given index of interrupt vector list array.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param index\n  intr_vec array index to be returned\n\n @return\n  - On success, interrupt vector\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_index_get(
        intr_handle: *const rte_intr_handle,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Frees the memory allocated for interrupt vector list array.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, zero\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_vec_list_free(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    #[doc = " @internal\n Reallocates the size efds and elist array based on size provided by user.\n By default efds and elist array are allocated with default size\n RTE_MAX_RXTX_INTR_VEC_ID on interrupt handle array creation. Later on device\n probe, device may have capability of more interrupts than\n RTE_MAX_RXTX_INTR_VEC_ID. Using this API, PMDs can reallocate the arrays as\n per the max interrupts capability of device.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param size\n  efds and elist array size.\n\n @return\n  - On success, zero\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_event_list_update(
        intr_handle: *mut rte_intr_handle,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal\n Returns the Windows handle of the given interrupt instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n\n @return\n  - On success, Windows handle.\n  - On failure, NULL."]
    pub fn rte_intr_instance_windows_handle_get(
        intr_handle: *mut rte_intr_handle,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @internal\n Set the Windows handle for the given interrupt instance.\n\n @param intr_handle\n  pointer to the interrupt handle.\n @param windows_handle\n  Windows handle to be set.\n\n @return\n  - On success, zero\n  - On failure, a negative value and rte_errno is set."]
    pub fn rte_intr_instance_windows_handle_set(
        intr_handle: *mut rte_intr_handle,
        windows_handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver {
    _unused: [u8; 0],
}
#[doc = "< device being added"]
pub const rte_dev_event_type_RTE_DEV_EVENT_ADD: rte_dev_event_type = 0;
#[doc = "< device being removed"]
pub const rte_dev_event_type_RTE_DEV_EVENT_REMOVE: rte_dev_event_type = 1;
#[doc = "< max value of this enum"]
pub const rte_dev_event_type_RTE_DEV_EVENT_MAX: rte_dev_event_type = 2;
#[doc = " The device event type."]
pub type rte_dev_event_type = ::std::os::raw::c_uint;
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const rte_dev_policy_RTE_DEV_ALLOWED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLOCKED: rte_dev_policy = 1;
#[doc = " Device policies."]
pub type rte_dev_policy = ::std::os::raw::c_uint;
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " Retrieve a driver name.\n\n @param driver\n   A pointer to a driver structure.\n @return\n   A pointer to the driver name string."]
    pub fn rte_driver_name(driver: *const rte_driver) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve a device bus.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A pointer to this device bus."]
    pub fn rte_dev_bus(dev: *const rte_device) -> *const rte_bus;
}
unsafe extern "C" {
    #[doc = " Retrieve bus specific information for a device.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A string describing this device or NULL if none is available."]
    pub fn rte_dev_bus_info(dev: *const rte_device) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve a device arguments.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A pointer to this device devargs."]
    pub fn rte_dev_devargs(dev: *const rte_device) -> *const rte_devargs;
}
unsafe extern "C" {
    #[doc = " Retrieve a device driver.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A pointer to this device driver."]
    pub fn rte_dev_driver(dev: *const rte_device) -> *const rte_driver;
}
unsafe extern "C" {
    #[doc = " Retrieve a device name.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A pointer to this device name."]
    pub fn rte_dev_name(dev: *const rte_device) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve a device numa node.\n\n @param dev\n   A pointer to a device structure.\n @return\n   A pointer to this device numa node."]
    pub fn rte_dev_numa_node(dev: *const rte_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query status of a device.\n\n @param dev\n   Generic device pointer.\n @return\n   (int)true if already probed successfully, 0 otherwise."]
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Hotplug add a given device to a specific bus.\n\n In multi-process, it will request other processes to add the same device.\n A failure, in any process, will rollback the action\n\n @param busname\n   The bus name the device is added to.\n @param devname\n   The device name. Based on this device name, eal will identify a driver\n   capable of handling it and pass it to the driver probing function.\n @param drvargs\n   Device arguments to be passed to the driver.\n @return\n   0 on success, negative on error."]
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add matching devices.\n\n In multi-process, it will request other processes to add the same device.\n A failure, in any process, will rollback the action\n\n @param devargs\n   Device arguments including bus, class and driver properties.\n @return\n   0 on success, negative on error."]
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Hotplug remove a given device from a specific bus.\n\n In multi-process, it will request other processes to remove the same device.\n A failure, in any process, will rollback the action\n\n @param busname\n   The bus name the device is removed from.\n @param devname\n   The device name being removed.\n @return\n   0 on success, negative on error."]
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove one device.\n\n In multi-process, it will request other processes to remove the same device.\n A failure, in any process, will rollback the action\n\n @param dev\n   Data structure of the device to remove.\n @return\n   0 on success, negative on error."]
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
#[doc = " Device comparison function.\n\n This type of function is used to compare an rte_device with arbitrary\n data.\n\n @param dev\n   Device handle.\n\n @param data\n   Data to compare against. The type of this parameter is determined by\n   the kind of comparison performed by the function.\n\n @return\n   0 if the device matches the data.\n   !0 if the device does not match.\n   <0 if ordering is possible and the device is lower than the data.\n   >0 if ordering is possible and the device is greater than the data."]
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Iteration context.\n\n This context carries over the current iteration state."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_iterator {
    #[doc = "< device string."]
    pub dev_str: *const ::std::os::raw::c_char,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< current position."]
    pub device: *mut rte_device,
    #[doc = "< additional specialized context."]
    pub class_device: *mut ::std::os::raw::c_void,
}
#[doc = " Device iteration function.\n\n Find the next device matching properties passed in parameters.\n The function takes an additional ``start`` parameter, that is\n used as starting context when relevant.\n\n The function returns the current element in the iteration.\n This return value will potentially be used as a start parameter\n in subsequent calls to the function.\n\n The additional iterator parameter is only there if a specific\n implementation needs additional context. It must not be modified by\n the iteration function itself.\n\n @param start\n   Starting iteration context.\n\n @param devstr\n   Device description string.\n\n @param it\n   Device iterator.\n\n @return\n   The address of the current element matching the device description\n   string."]
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    #[doc = " Initializes a device iterator.\n\n This iterator allows accessing a list of devices matching a criteria.\n The device matching is made among all buses and classes currently registered,\n filtered by the device description given as parameter.\n\n This function will not allocate any memory. It is safe to stop the\n iteration at any moment and let the iterator go out of context.\n\n @param it\n   Device iterator handle.\n\n @param str\n   Device description string.\n\n @return\n   0 on successful initialization.\n   <0 on error."]
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iterates on a device iterator.\n\n Generates a new rte_device handle corresponding to the next element\n in the list described in comprehension by the iterator.\n\n The next object is returned, and the iterator is updated.\n\n @param it\n   Device iterator handle.\n\n @return\n   An rte_device handle if found.\n   NULL if an error occurred (rte_errno is set).\n   NULL if no device could be found (rte_errno is not set)."]
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
unsafe extern "C" {
    #[doc = " It registers the callback for the specific device.\n Multiple callbacks can be registered at the same time.\n\n @param device_name\n  The device name, that is the param name of the struct rte_device,\n  null value means for all devices.\n @param cb_fn\n  callback address.\n @param cb_arg\n  address of parameter for callback.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " It unregisters the callback according to the specified device.\n\n @param device_name\n  The device name, that is the param name of the struct rte_device,\n  null value means for all devices and their callbacks.\n @param cb_fn\n  callback address.\n @param cb_arg\n  address of parameter for callback, (void *)-1 means to remove all\n  registered which has the same callback address.\n\n @return\n  - On success, return the number of callback entities removed.\n  - On failure, a negative value."]
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes all the user application registered callbacks for\n the specific device.\n\n @param device_name\n  The device name.\n @param event\n  the device event type."]
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
    );
}
unsafe extern "C" {
    #[doc = " Start the device event monitoring.\n\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the device event monitoring.\n\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable hotplug handling for devices.\n\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable hotplug handling for devices.\n\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Device level DMA map function.\n After a successful call, the memory segment will be mapped to the\n given device.\n\n @note: Memory must be registered in advance using rte_extmem_* APIs.\n\n @param dev\n\tDevice pointer.\n @param addr\n\tVirtual address to map.\n @param iova\n\tIOVA address to map.\n @param len\n\tLength of the memory segment being mapped.\n\n @return\n\t0 if mapping was successful.\n\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Device level DMA unmap function.\n After a successful call, the memory segment will no longer be\n accessible by the given device.\n\n @note: Memory must be registered in advance using rte_extmem_* APIs.\n\n @param dev\n\tDevice pointer.\n @param addr\n\tVirtual address to unmap.\n @param iova\n\tIOVA address to unmap.\n @param len\n\tLength of the memory segment being mapped.\n\n @return\n\t0 if un-mapping was successful.\n\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
pub const rte_devtype_RTE_DEVTYPE_ALLOWED: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLOCKED: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
#[doc = " Type of generic device"]
pub type rte_devtype = ::std::os::raw::c_uint;
#[doc = " Structure that stores a device given by the user with its arguments\n\n A user device is a physical or a virtual device given by the user to\n the DPDK application at startup through command line arguments.\n\n The structure stores the configuration of the device, its PCI\n identifier if it's a PCI device or the driver name if it's a virtual\n device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< raw string including bus, class and driver parts."]
    pub data: *mut ::std::os::raw::c_char,
}
#[doc = " Next in list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = "< legacy name."]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< driver-related part of device string."]
    pub drv_str: *const ::std::os::raw::c_char,
}
unsafe extern "C" {
    #[doc = " Parse a device string.\n\n Verify that a bus is capable of handling the device passed\n in argument. Store which bus will handle the device, its name\n and the eventual device parameters.\n\n The syntax is:\n\n     bus:device_identifier,arg1=val1,arg2=val2\n\n where \"bus:\" is the bus name followed by any character separator.\n The bus name is optional. If no bus name is specified, each bus\n will attempt to recognize the device identifier. The first one\n to succeed will be used.\n\n Examples:\n\n     pci:0000:05.00.0,arg=val\n     05.00.0,arg=val\n     vdev:net_ring0\n\n @param da\n   The devargs structure holding the device information.\n\n @param dev\n   String describing a device.\n\n @return\n   - 0 on success.\n   - Negative errno on error."]
    pub fn rte_devargs_parse(
        da: *mut rte_devargs,
        dev: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Parse a device string.\n\n Verify that a bus is capable of handling the device passed\n in argument. Store which bus will handle the device, its name\n and the eventual device parameters.\n\n The device string is built with a printf-like syntax.\n\n The syntax is:\n\n     bus:device_identifier,arg1=val1,arg2=val2\n\n where \"bus:\" is the bus name followed by any character separator.\n The bus name is optional. If no bus name is specified, each bus\n will attempt to recognize the device identifier. The first one\n to succeed will be used.\n\n Examples:\n\n     pci:0000:05.00.0,arg=val\n     05.00.0,arg=val\n     vdev:net_ring0\n\n @param da\n   The devargs structure holding the device information.\n @param format\n   Format string describing a device.\n\n @return\n   - 0 on success.\n   - Negative errno on error."]
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Free resources in devargs.\n\n @param da\n   The devargs structure holding the device information."]
    pub fn rte_devargs_reset(da: *mut rte_devargs);
}
unsafe extern "C" {
    #[doc = " Insert an rte_devargs in the global list.\n\n @param da\n  The devargs structure to insert.\n  If a devargs for the same device is already inserted,\n  it will be updated and returned. It means *da pointer can change.\n\n @return\n   - 0 on success\n   - Negative on error."]
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a device to the user device list\n See rte_devargs_parse() for details.\n\n @param devtype\n   The type of the device.\n @param devargs_str\n   The arguments as given by the user.\n\n @return\n   - 0 on success\n   - A negative value on error"]
    pub fn rte_devargs_add(
        devtype: rte_devtype,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a device from the user device list.\n Its resources are freed.\n If the devargs cannot be found, nothing happens.\n\n @param devargs\n   The instance or a copy of devargs to remove.\n\n @return\n   0 on success.\n   <0 on error.\n   >0 if the devargs was not within the user device list."]
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Count the number of user devices of a specified type\n\n @param devtype\n   The type of the devices to counted.\n\n @return\n   The number of devices."]
    pub fn rte_devargs_type_count(devtype: rte_devtype) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " This function dumps the list of user device and their arguments.\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_devargs_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Find next rte_devargs matching the provided bus name.\n\n @param busname\n   Limit the iteration to devargs related to buses\n   matching this name.\n   Will return any next rte_devargs if NULL.\n\n @param start\n   Starting iteration point. The iteration will start at\n   the first rte_devargs if NULL.\n\n @return\n   Next rte_devargs entry matching the requested bus,\n   NULL if there is none."]
    pub fn rte_devargs_next(
        busname: *const ::std::os::raw::c_char,
        start: *const rte_devargs,
    ) -> *mut rte_devargs;
}
unsafe extern "C" {
    #[doc = "< Per core error number."]
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Function which returns a printable string describing a particular\n error code. For non-RTE-specific error codes, this function returns\n the value from the libc strerror function.\n\n @param errnum\n   The error number to be looked up - generally the value of rte_errno\n @return\n   A pointer to a thread-local string containing the text describing\n   the error."]
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = "< Start numbering above std errno vals"]
pub const RTE_MIN_ERRNO: _bindgen_ty_2 = 1000;
#[doc = "< Operation not allowed in secondary processes"]
pub const E_RTE_SECONDARY: _bindgen_ty_2 = 1001;
#[doc = "< Missing rte_config"]
pub const E_RTE_NO_CONFIG: _bindgen_ty_2 = 1002;
#[doc = "< Max RTE error number"]
pub const RTE_MAX_ERRNO: _bindgen_ty_2 = 1003;
#[doc = " Error types"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
#[doc = " Struct describing a Universal Unique Identifier"]
pub type rte_uuid_t = [::std::os::raw::c_uchar; 16usize];
unsafe extern "C" {
    #[doc = " Test if UUID is all zeros.\n\n @param uu\n    The uuid to check.\n @return\n    true if uuid is NULL value, false otherwise"]
    pub fn rte_uuid_is_null(uu: *const ::std::os::raw::c_uchar) -> bool;
}
unsafe extern "C" {
    #[doc = " Compare two UUID's\n\n @param a\n    A UUID to compare\n @param b\n    A UUID to compare\n @return\n   returns an integer less than, equal to, or greater than zero if UUID a is\n   is less than, equal, or greater than UUID b."]
    pub fn rte_uuid_compare(
        a: *const ::std::os::raw::c_uchar,
        b: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Extract UUID from string\n\n @param in\n    Pointer to string of characters to convert\n @param uu\n    Destination UUID\n @return\n    Returns 0 on success, and -1 if string is not a valid UUID."]
    pub fn rte_uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Convert UUID to string\n\n @param uu\n    UUID to format\n @param out\n    Resulting string buffer\n @param len\n    Sizeof the available string buffer"]
    pub fn rte_uuid_unparse(
        uu: *const ::std::os::raw::c_uchar,
        out: *mut ::std::os::raw::c_char,
        len: usize,
    );
}
pub const rte_intr_mode_RTE_INTR_MODE_NONE: rte_intr_mode = 0;
pub const rte_intr_mode_RTE_INTR_MODE_LEGACY: rte_intr_mode = 1;
pub const rte_intr_mode_RTE_INTR_MODE_MSI: rte_intr_mode = 2;
pub const rte_intr_mode_RTE_INTR_MODE_MSIX: rte_intr_mode = 3;
pub type rte_intr_mode = ::std::os::raw::c_uint;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
#[doc = " The type of process in a linux, multi-process setup"]
pub type rte_proc_type_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Get the process type in a multi-process setup\n\n @return\n   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
unsafe extern "C" {
    #[doc = " Request iopl privilege for all RPL.\n\n This function should be called by pmds which need access to ioports.\n\n @return\n   - On success, returns 0.\n   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL).\n\n This function is to be executed on the MAIN lcore only, as soon\n as possible in the application's main() function.\n It puts the WORKER lcores in the WAIT state.\n\n @param argc\n   A non-negative value.  If it is greater than 0, the array members\n   for argv[0] through argv[argc] (non-inclusive) shall contain pointers\n   to strings.\n @param argv\n   An array of strings.  The contents of the array, as well as the strings\n   which are pointed to by the array, may be modified by this function.\n   The program name pointer argv[0] is copied into the last parsed argv\n   so that argv[0] is still the same after deducing the parsed arguments.\n @return\n   - On success, the number of parsed arguments, which is greater or\n     equal to zero. After the call to rte_eal_init(),\n     all arguments argv[x] with x < ret may have been modified by this\n     function call and should not be further interpreted by the\n     application.  The EAL does not take any ownership of the memory used\n     for either the argv array, or its members.\n   - On failure, -1 and rte_errno is set to a value indicating the cause\n     for failure.  In some instances, the application will need to be\n     restarted as part of clearing the issue.\n\n   Error codes returned via rte_errno:\n     EACCES indicates a permissions issue.\n\n     EAGAIN indicates either a bus or system resource was not available,\n            setup may be attempted again.\n\n     EALREADY indicates that the rte_eal_init function has already been\n              called, and cannot be called again.\n\n     EFAULT indicates the tailq configuration name was not found in\n            memory configuration.\n\n     EINVAL indicates invalid parameters were passed as argv/argc.\n\n     ENOMEM indicates failure likely caused by an out-of-memory condition.\n\n     ENODEV indicates memory setup issues.\n\n     ENOTSUP indicates that the EAL cannot initialize on this system.\n\n     EPROTO indicates that the PCI bus is either not present, or is not\n            readable by the eal.\n\n     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)\n\n This function must be called to release any internal resources that EAL has\n allocated during rte_eal_init(). After this call, no DPDK function calls may\n be made. It is expected that common usage of this function is to call it\n just before terminating the process.\n\n @return\n  - 0 Successfully released all internal EAL resources.\n  - -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a primary process is currently alive\n\n This function returns true when a primary process is currently\n active.\n\n @param config_file_path\n   The config_file_path argument provided should point at the location\n   that the primary process will create its config file. If NULL, the default\n   config file path is used.\n\n @return\n  - If alive, returns 1.\n  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 253usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[doc = " Action function typedef used by other components.\n\n As we create  socket channel for primary/secondary communication, use\n this function typedef to register action for coming messages.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components.\n\n As we create socket channel for primary/secondary communication, use\n this function typedef to register action for coming responses to asynchronous\n requests.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Usage function typedef used by the application usage function.\n\n Use this function typedef to define and call rte_set_application_usage_hook()\n routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine.\n\n This function allows the application to include its usage message\n in the EAL system usage message. The routine rte_set_application_usage_hook()\n needs to be called before the rte_eal_init() routine in the application.\n\n This routine is optional for the application and will behave as if the set\n routine was never called as the default behavior.\n\n @param usage_func\n   The func argument is a function pointer to the application usage routine.\n   Called function is defined using rte_usage_hook_t typedef, which is of\n   the form void rte_usage_func(const char * prgname).\n\n   Calling this routine with a NULL value will reset the usage hook routine and\n   return the current value, which could be NULL.\n @return\n   - Returns the current value of the rte_application_usage pointer to allow\n     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option).\n The no-huge mode is not compatible with all drivers or features.\n\n @return\n   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using PCI bus.\n Disabled by --no-pci option.\n\n @return\n   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device.\n\n @return\n   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The user-configured vfio interrupt mode.\n\n @return\n   Interrupt mode configured with the command line,\n   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
unsafe extern "C" {
    #[doc = " Copy the user-configured vfio VF token.\n\n @param vf_token\n   vfio VF token configured with the command line is copied\n   into this parameter, zero uuid by default."]
    pub fn rte_eal_vfio_get_vf_token(vf_token: *mut ::std::os::raw::c_uchar);
}
unsafe extern "C" {
    #[doc = " A wrap API for syscall gettid.\n\n @return\n   On success, returns the thread ID of calling process.\n   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut per_lcore__thread_id: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the OS-specific EAL base address.\n\n @return\n    The base address."]
    pub fn rte_eal_get_baseaddr() -> u64;
}
pub const rte_iova_mode_RTE_IOVA_DC: rte_iova_mode = 0;
pub const rte_iova_mode_RTE_IOVA_PA: rte_iova_mode = 1;
pub const rte_iova_mode_RTE_IOVA_VA: rte_iova_mode = 2;
#[doc = " IOVA mapping mode.\n\n IOVA mapping mode is iommu programming mode of a device.\n That device (for example: IOMMU backed DMA device) based\n on rte_iova_mode will generate physical or virtual address."]
pub type rte_iova_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the iova mode\n\n @return\n   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
unsafe extern "C" {
    #[doc = " Get user provided pool ops name for mbuf\n\n @return\n   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the runtime directory of DPDK\n\n @return\n  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert a string describing a mask of core ids into an array of core ids.\n\n On success, the passed array is filled with the orders of the core ids\n present in the mask (-1 indicating that a core id is absent).\n For example, passing a 0xa coremask results in cores[1] = 0, cores[3] = 1,\n and the rest of the array is set to -1.\n\n @param coremask\n   A string describing a mask of core ids.\n @param cores\n   An array where to store the core ids orders.\n   This array must be at least RTE_MAX_LCORE large.\n @return\n   0 on success, -1 if the string content was invalid."]
    pub fn rte_eal_parse_coremask(
        coremask: *const ::std::os::raw::c_char,
        cores: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
#[doc = " State of an lcore."]
pub type rte_lcore_state_t = ::std::os::raw::c_uint;
#[doc = " Definition of a remote launch function."]
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Launch a function on another lcore.\n\n To be executed on the MAIN lcore only.\n\n Sends a message to a worker lcore (identified by the worker_id) that\n is in the WAIT state (this is true after the first call to\n rte_eal_init()). This can be checked by first calling\n rte_eal_wait_lcore(worker_id).\n\n When the remote lcore receives the message, it switches to\n the RUNNING state, then calls the function f with argument arg. Once the\n execution is done, the remote lcore switches to WAIT state and\n the return value of f is stored in a local variable to be read using\n rte_eal_wait_lcore().\n\n The MAIN lcore returns as soon as the message is sent and knows\n nothing about the completion of f.\n\n Note: This function is not designed to offer optimum\n performance. It is just a practical way to launch a function on\n another lcore at initialization time.\n\n @param f\n   The function to be called.\n @param arg\n   The argument for the function.\n @param worker_id\n   The identifier of the lcore on which the function should be executed.\n @return\n   - 0: Success. Execution of function f started on the remote lcore.\n   - (-EBUSY): The remote lcore is not in a WAIT state.\n   - (-EPIPE): Error reading or writing pipe to worker thread"]
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        worker_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< lcore handler not executed by main core."]
pub const rte_rmt_call_main_t_SKIP_MAIN: rte_rmt_call_main_t = 0;
#[doc = "< lcore handler executed by main core."]
pub const rte_rmt_call_main_t_CALL_MAIN: rte_rmt_call_main_t = 1;
#[doc = " This enum indicates whether the main core must execute the handler\n launched on all logical cores."]
pub type rte_rmt_call_main_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Launch a function on all lcores.\n\n Check that each WORKER lcore is in a WAIT state, then call\n rte_eal_remote_launch() for each lcore.\n\n @param f\n   The function to be called.\n @param arg\n   The argument for the function.\n @param call_main\n   If call_main set to SKIP_MAIN, the MAIN lcore does not call\n   the function. If call_main is set to CALL_MAIN, the function\n   is also called on main before returning. In any case, the main\n   lcore returns as soon as it finished its job and knows nothing\n   about the completion of f on the other lcores.\n @return\n   - 0: Success. Execution of function f started on all remote lcores.\n   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this\n     case, no message is sent to any of the lcores."]
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_main: rte_rmt_call_main_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the state of the lcore identified by worker_id.\n\n To be executed on the MAIN lcore only.\n\n @param worker_id\n   The identifier of the lcore.\n @return\n   The state of the lcore."]
    pub fn rte_eal_get_lcore_state(worker_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
unsafe extern "C" {
    #[doc = " Wait until an lcore finishes its job.\n\n To be executed on the MAIN lcore only.\n\n If the lcore identified by the worker_id is in RUNNING state, wait until\n the lcore finishes its job and moves to the WAIT state.\n\n @param worker_id\n   The identifier of the lcore.\n @return\n   - 0: If the remote launch function was never called on the lcore\n     identified by the worker_id.\n   - The value that was returned by the previous remote launch\n     function call."]
    pub fn rte_eal_wait_lcore(worker_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Wait until all lcores finish their jobs.\n\n To be executed on the MAIN lcore only. Issue an\n rte_eal_wait_lcore() for every lcore. The return values are\n ignored.\n\n After a call to rte_eal_mp_wait_lcore(), the caller can assume\n that all worker lcores are in a WAIT state."]
    pub fn rte_eal_mp_wait_lcore();
}
#[doc = " Thread id descriptor."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_t {
    #[doc = "< thread identifier"]
    pub opaque_id: usize,
}
#[doc = " Thread function\n\n Function pointer to thread start routine.\n\n @param arg\n   Argument passed to rte_thread_create().\n @return\n   Thread function exit value."]
pub type rte_thread_func =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> u32>;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_NORMAL: rte_thread_priority = 0;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_REALTIME_CRITICAL: rte_thread_priority = 1;
#[doc = " Thread priority values."]
pub type rte_thread_priority = ::std::os::raw::c_uint;
#[doc = " Representation for thread attributes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_attr_t {
    #[doc = "< thread priority"]
    pub priority: rte_thread_priority,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eal_tls_key {
    _unused: [u8; 0],
}
#[doc = " TLS key type, an opaque pointer."]
pub type rte_thread_key = *mut eal_tls_key;
unsafe extern "C" {
    #[doc = " Create a new thread that will invoke the 'thread_func' routine.\n\n @param thread_id\n    A pointer that will store the id of the newly created thread.\n\n @param thread_attr\n    Attributes that are used at the creation of the new thread.\n\n @param thread_func\n    The routine that the new thread will invoke when starting execution.\n\n @param arg\n    Argument to be passed to the 'thread_func' routine.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_create(
        thread_id: *mut rte_thread_t,
        thread_attr: *const rte_thread_attr_t,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a control thread.\n\n Creates a control thread with the given name and attributes. The\n affinity of the new thread is based on the CPU affinity retrieved\n at the time rte_eal_init() was called, the EAL threads are then\n excluded. If setting the name of the thread fails, the error is\n ignored and a debug message is logged.\n\n @param thread\n   Filled with the thread id of the new created thread.\n @param name\n   The name of the control thread\n   (max RTE_THREAD_NAME_SIZE characters including '\\0').\n @param thread_func\n   Function to be executed by the new thread.\n @param arg\n   Argument passed to thread_func.\n @return\n   On success, returns 0; on error, it returns a negative value\n   corresponding to the error number."]
    pub fn rte_thread_create_control(
        thread: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create an internal control thread.\n\n Creates a control thread with the given name prefixed.\n If setting the name of the thread fails, the error is ignored and logged.\n\n The affinity of the new thread is based on the CPU affinity retrieved\n at the time rte_eal_init() was called, the EAL threads are then excluded.\n\n @param id\n   Filled with the thread ID of the new created thread.\n @param name\n   The name of the control thread.\n   See RTE_THREAD_INTERNAL_NAME_SIZE for maximum length.\n   The name of the driver or library should be first,\n   then followed by a hyphen and more details.\n   It will be prefixed with RTE_THREAD_INTERNAL_PREFIX by this function.\n @param func\n   Function to be executed by the new thread.\n @param arg\n   Argument passed to func.\n @return\n   On success, returns 0; a negative value otherwise."]
    pub fn rte_thread_create_internal_control(
        id: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Waits for the thread identified by 'thread_id' to terminate\n\n @param thread_id\n    The identifier of the thread.\n\n @param value_ptr\n    Stores the exit status of the thread.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_join(thread_id: rte_thread_t, value_ptr: *mut u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Indicate that the return value of the thread is not needed and\n all thread resources should be release when the thread terminates.\n\n @param thread_id\n    The id of the thread to be detached.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_detach(thread_id: rte_thread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the id of the calling thread.\n\n @return\n   Return the thread id of the calling thread."]
    pub fn rte_thread_self() -> rte_thread_t;
}
unsafe extern "C" {
    #[doc = " Set the name of the thread.\n\n This API is a noop if the underlying platform does not\n support setting the thread name or the platform-specific\n API used to set the thread name fails.\n\n @param thread_id\n    The id of the thread to set name.\n\n @param thread_name\n    The name to set. Truncated to RTE_THREAD_NAME_SIZE,\n    including terminating NUL if necessary."]
    pub fn rte_thread_set_name(thread_id: rte_thread_t, thread_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the name of an internal thread with the common prefix.\n\n This API is a noop if the underlying platform does not support\n setting the thread name, or if it fails.\n\n @param id\n   The ID of the thread to set name.\n\n @param name\n   The name to set after being prefixed.\n   See RTE_THREAD_INTERNAL_NAME_SIZE for maximum length.\n   The name of the driver or library should be first,\n   then followed by a hyphen and more details.\n   It will be prefixed with RTE_THREAD_INTERNAL_PREFIX by this function."]
    pub fn rte_thread_set_prefixed_name(id: rte_thread_t, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Check if 2 thread ids are equal.\n\n @param t1\n   First thread id.\n\n @param t2\n   Second thread id.\n\n @return\n   If the ids are equal, return nonzero.\n   Otherwise, return 0."]
    pub fn rte_thread_equal(t1: rte_thread_t, t2: rte_thread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize the attributes of a thread.\n These attributes can be passed to the rte_thread_create() function\n that will create a new thread and set its attributes according to attr.\n\n @param attr\n   Thread attributes to initialize.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_attr_init(attr: *mut rte_thread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the thread priority value in the thread attributes pointed to\n by 'thread_attr'.\n\n @param thread_attr\n   Points to the thread attributes in which priority will be updated.\n\n @param priority\n   Points to the value of the priority to be set.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_attr_set_priority(
        thread_attr: *mut rte_thread_attr_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the priority of a thread.\n\n @param thread_id\n   Id of the thread for which to get priority.\n\n @param priority\n   Location to store the retrieved priority.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_get_priority(
        thread_id: rte_thread_t,
        priority: *mut rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the priority of a thread.\n\n @param thread_id\n   Id of the thread for which to set priority.\n\n @param priority\n   Priority value to be set.\n\n @return\n   On success, return 0.\n   On failure, return a positive errno-style error number."]
    pub fn rte_thread_set_priority(
        thread_id: rte_thread_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a TLS data key visible to all threads in the process.\n the created key is later used to get/set a value.\n and optional destructor can be set to be called when a thread exits.\n\n @param key\n   Pointer to store the allocated key.\n @param destructor\n   The function to be called when the thread exits.\n   Ignored on Windows OS.\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: ENOMEM  - Memory allocation error.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_create(
        key: *mut rte_thread_key,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a TLS data key visible to all threads in the process.\n\n @param key\n   The key allocated by rte_thread_key_create().\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_key_delete(key: rte_thread_key) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set value bound to the TLS key on behalf of the calling thread.\n\n @param key\n   The key allocated by rte_thread_key_create().\n @param value\n   The value bound to the rte_thread_key key for the calling thread.\n\n @return\n   On success, zero.\n   On failure, a negative number and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_set(
        key: rte_thread_key,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get value bound to the TLS key on behalf of the calling thread.\n\n @param key\n   The key allocated by rte_thread_key_create().\n\n @return\n   On success, value data pointer (can also be NULL).\n   On failure, NULL and an error number is set in rte_errno.\n   rte_errno can be: EINVAL  - Invalid parameter passed.\n                     ENOEXEC - Specific OS error."]
    pub fn rte_thread_value_get(key: rte_thread_key) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "< Per thread \"lcore id\"."]
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
pub const rte_lcore_role_t_ROLE_NON_EAL: rte_lcore_role_t = 3;
#[doc = " The lcore role (used in RTE or not)."]
pub type rte_lcore_role_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get a lcore's role.\n\n @param lcore_id\n   The identifier of the lcore, which MUST be between 0 and RTE_MAX_LCORE-1.\n @return\n   The role of the lcore."]
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
unsafe extern "C" {
    #[doc = " Test if the core supplied has a specific role\n\n @param lcore_id\n   The identifier of the lcore, which MUST be between 0 and\n   RTE_MAX_LCORE-1.\n @param role\n   The role to be checked against.\n @return\n   Boolean value: positive if test is true; otherwise returns 0."]
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the id of the main lcore\n\n @return\n   the id of the main lcore"]
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return the number of execution units (lcores) on the system.\n\n @return\n   the number of execution units (lcores) on the system."]
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return the index of the lcore starting from zero.\n\n When option -c or -l is given, the index corresponds\n to the order in the list.\n For example:\n -c 0x30, lcore 4 has index 0, and 5 has index 1.\n -l 22,18 lcore 22 has index 0, and 18 has index 1.\n\n @param lcore_id\n   The targeted lcore, or -1 for the current one.\n @return\n   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the ID of the physical socket of the logical core we are\n running on.\n @return\n   the ID of current lcoreid's physical socket"]
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return number of physical sockets detected on the system.\n\n Note that number of nodes may not be correspondent to their physical id's:\n for example, a system may report two socket id's, but the actual socket id's\n may be 0 and 8.\n\n @return\n   the number of physical sockets as recognized by EAL"]
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return socket id with a particular index.\n\n This will return socket id at a particular position in list of all detected\n physical socket id's. For example, on a machine with sockets [0, 8], passing\n 1 as a parameter will return 8.\n\n @param idx\n   index of physical socket id to return\n\n @return\n   - physical socket id as recognized by EAL\n   - -1 on error, with errno set to EINVAL"]
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the ID of the physical socket of the specified lcore\n\n @param lcore_id\n   the targeted lcore, which MUST be between 0 and RTE_MAX_LCORE-1.\n @return\n   the ID of lcoreid's physical socket"]
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return the id of the lcore on a socket starting from zero.\n\n @param lcore_id\n   The targeted lcore, or -1 for the current one.\n @return\n   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test if an lcore is enabled.\n\n @param lcore_id\n   The identifier of the lcore, which MUST be between 0 and\n   RTE_MAX_LCORE-1.\n @return\n   True if the given lcore is enabled; false otherwise."]
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next enabled lcore ID.\n\n @param i\n   The current lcore (reference).\n @param skip_main\n   If true, do not return the ID of the main lcore.\n @param wrap\n   If true, go back to 0 when RTE_MAX_LCORE is reached; otherwise,\n   return RTE_MAX_LCORE.\n @return\n   The next lcore_id or RTE_MAX_LCORE if not found."]
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_main: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Callback prototype for initializing lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer passed at callback registration.\n @return\n   - -1 when refusing this operation,\n   - 0 otherwise."]
pub type rte_lcore_init_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback prototype for uninitializing lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer passed at callback registration."]
pub type rte_lcore_uninit_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " Register callbacks invoked when initializing and uninitializing a lcore.\n\n This function calls the init callback with all initialized lcores.\n Any error reported by the init callback triggers a rollback calling the\n uninit callback for each lcore.\n If this step succeeds, the callbacks are put in the lcore callbacks list\n that will get called for each lcore allocation/release.\n\n Note: callbacks execution is serialised under a write lock protecting the\n lcores and callbacks list.\n\n @param name\n   A name serving as a small description for this callback.\n @param init\n   The callback invoked when a lcore_id is initialized.\n   init can be NULL.\n @param uninit\n   The callback invoked when a lcore_id is uninitialized.\n   uninit can be NULL.\n @param arg\n   An optional argument that gets passed to the callback when it gets\n   invoked.\n @return\n   On success, returns an opaque pointer for the registered object.\n   On failure (either memory allocation issue in the function itself or an\n   error is returned by the init callback itself), returns NULL."]
    pub fn rte_lcore_callback_register(
        name: *const ::std::os::raw::c_char,
        init: rte_lcore_init_cb,
        uninit: rte_lcore_uninit_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Unregister callbacks previously registered with rte_lcore_callback_register.\n\n This function calls the uninit callback with all initialized lcores.\n The callbacks are then removed from the lcore callbacks list.\n\n @param handle\n   The handle pointer returned by a former successful call to\n   rte_lcore_callback_register."]
    pub fn rte_lcore_callback_unregister(handle: *mut ::std::os::raw::c_void);
}
#[doc = " Callback prototype for iterating over lcores.\n\n @param lcore_id\n   The lcore to consider.\n @param arg\n   An opaque pointer coming from the caller.\n @return\n   - 0 lets the iteration continue.\n   - !0 makes the iteration stop."]
pub type rte_lcore_iterate_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Iterate on all active lcores (ROLE_RTE, ROLE_SERVICE and ROLE_NON_EAL).\n No modification on the lcore states is allowed in the callback.\n\n Note: as opposed to init/uninit callbacks, iteration callbacks can be\n invoked in parallel as they are run under a read lock protecting the lcores\n and callbacks list.\n\n @param cb\n   The callback that gets passed each lcore.\n @param arg\n   An opaque pointer passed to cb.\n @return\n   Same return code as the callback last invocation (see rte_lcore_iterate_cb\n   description)."]
    pub fn rte_lcore_iterate(
        cb: rte_lcore_iterate_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " lcore usage statistics."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_lcore_usage {
    #[doc = " The total amount of time that the application has been running on\n this lcore, in TSC cycles."]
    pub total_cycles: u64,
    #[doc = " The amount of time the application was busy, handling some\n workload on this lcore, in TSC cycles."]
    pub busy_cycles: u64,
}
#[doc = " Callback to allow applications to report lcore usage.\n\n @param [in] lcore_id\n   The lcore to consider.\n @param [out] usage\n   Counters representing this lcore usage. This can never be NULL.\n @return\n   - 0 if fields in usage were updated successfully. The fields that the\n     application does not support must not be modified.\n   - a negative value if the information is not available or if any error\n     occurred."]
pub type rte_lcore_usage_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        usage: *mut rte_lcore_usage,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register a callback from an application to be called in rte_lcore_dump() and\n the /eal/lcore/info telemetry endpoint handler. Applications are expected to\n report lcore usage statistics via this callback.\n\n If a callback was already registered, it can be replaced with another callback\n or unregistered with NULL. The previously registered callback may remain in\n use for an undetermined period of time.\n\n @param cb\n   The callback function."]
    pub fn rte_lcore_register_usage_cb(cb: rte_lcore_usage_cb);
}
unsafe extern "C" {
    #[doc = " List all lcores.\n\n @param f\n   The output stream where the dump should be sent."]
    pub fn rte_lcore_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Register current non-EAL thread as a lcore.\n\n @note This API is not compatible with the multi-process feature:\n - if a primary process registers a non-EAL thread, then no secondary process\n   will initialise.\n - if a secondary process initialises successfully, trying to register a\n   non-EAL thread from either primary or secondary processes will always end\n   up with the thread getting LCORE_ID_ANY as lcore.\n\n @return\n   On success, return 0; otherwise return -1 with rte_errno set."]
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister current thread and release lcore if one was associated."]
    pub fn rte_thread_unregister();
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mm_sfence();
}
unsafe extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = [__BindgenFloat16; 8usize];
pub type __m128h = [__BindgenFloat16; 8usize];
pub type __m128h_u = [__BindgenFloat16; 8usize];
pub type __v8bf = u128;
pub type __m128bh = u128;
unsafe extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _mm_lfence();
}
unsafe extern "C" {
    pub fn _mm_mfence();
}
unsafe extern "C" {
    pub fn _mm_pause();
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic16_t {
    #[doc = "< An internal counter value."]
    pub cnt: i16,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic32_t {
    #[doc = "< An internal counter value."]
    pub cnt: i32,
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_atomic64_t {
    #[doc = "< Internal counter value."]
    pub cnt: i64,
}
#[doc = " 128-bit integer structure."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[doc = " The rte_spinlock_recursive_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    #[doc = "< the actual spinlock"]
    pub sl: rte_spinlock_t,
    #[doc = "< core id using lock, -1 for unused"]
    pub user: ::std::os::raw::c_int,
    #[doc = "< count of time this lock has been called"]
    pub count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __uintr_frame {
    pub rip: ::std::os::raw::c_ulonglong,
    pub rflags: ::std::os::raw::c_ulonglong,
    pub rsp: ::std::os::raw::c_ulonglong,
}
pub const _CMPCCX_ENUM__CMPCCX_O: _CMPCCX_ENUM = 0;
pub const _CMPCCX_ENUM__CMPCCX_NO: _CMPCCX_ENUM = 1;
pub const _CMPCCX_ENUM__CMPCCX_B: _CMPCCX_ENUM = 2;
pub const _CMPCCX_ENUM__CMPCCX_NB: _CMPCCX_ENUM = 3;
pub const _CMPCCX_ENUM__CMPCCX_Z: _CMPCCX_ENUM = 4;
pub const _CMPCCX_ENUM__CMPCCX_NZ: _CMPCCX_ENUM = 5;
pub const _CMPCCX_ENUM__CMPCCX_BE: _CMPCCX_ENUM = 6;
pub const _CMPCCX_ENUM__CMPCCX_NBE: _CMPCCX_ENUM = 7;
pub const _CMPCCX_ENUM__CMPCCX_S: _CMPCCX_ENUM = 8;
pub const _CMPCCX_ENUM__CMPCCX_NS: _CMPCCX_ENUM = 9;
pub const _CMPCCX_ENUM__CMPCCX_P: _CMPCCX_ENUM = 10;
pub const _CMPCCX_ENUM__CMPCCX_NP: _CMPCCX_ENUM = 11;
pub const _CMPCCX_ENUM__CMPCCX_L: _CMPCCX_ENUM = 12;
pub const _CMPCCX_ENUM__CMPCCX_NL: _CMPCCX_ENUM = 13;
pub const _CMPCCX_ENUM__CMPCCX_LE: _CMPCCX_ENUM = 14;
pub const _CMPCCX_ENUM__CMPCCX_NLE: _CMPCCX_ENUM = 15;
pub type _CMPCCX_ENUM = ::std::os::raw::c_uint;
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v16hf = [__BindgenFloat16; 16usize];
pub type __m256h = [__BindgenFloat16; 16usize];
pub type __m256h_u = [__BindgenFloat16; 16usize];
pub type __v16bf = __BindgenOpaqueArray<u8, 32usize>;
pub type __m256bh = __BindgenOpaqueArray<u8, 32usize>;
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __v64qs = [::std::os::raw::c_schar; 64usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = ::std::os::raw::c_uint;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = ::std::os::raw::c_uint;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_A: _MM_TERNLOG_ENUM = 240;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_B: _MM_TERNLOG_ENUM = 204;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_C: _MM_TERNLOG_ENUM = 170;
pub type _MM_TERNLOG_ENUM = ::std::os::raw::c_uint;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __v32hf = [__BindgenFloat16; 32usize];
pub type __m512h = [__BindgenFloat16; 32usize];
pub type __m512h_u = [__BindgenFloat16; 32usize];
pub type __v32bf = __BindgenOpaqueArray<u8, 64usize>;
pub type __m512bh = __BindgenOpaqueArray<u8, 64usize>;
pub type __bfloat16 = u16;
pub type _tile1024i = [::std::os::raw::c_int; 256usize];
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct __tile1024i_str {
    pub row: ::std::os::raw::c_ushort,
    pub col: ::std::os::raw::c_ushort,
    pub __bindgen_padding_0: [u64; 7usize],
    pub tile: _tile1024i,
}
pub type __tile1024i = __tile1024i_str;
#[doc = "< SSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
#[doc = "< PCLMULQDQ"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
#[doc = "< DTES64"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
#[doc = "< MONITOR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
#[doc = "< DS_CPL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
#[doc = "< VMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
#[doc = "< SMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
#[doc = "< EIST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
#[doc = "< TM2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
#[doc = "< SSSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
#[doc = "< CNXT_ID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
#[doc = "< FMA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
#[doc = "< CMPXCHG16B"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
#[doc = "< XTPR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
#[doc = "< PDCM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
#[doc = "< PCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
#[doc = "< DCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
#[doc = "< SSE4_1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
#[doc = "< SSE4_2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
#[doc = "< X2APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
#[doc = "< MOVBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
#[doc = "< POPCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
#[doc = "< TSC_DEADLINE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
#[doc = "< AES"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
#[doc = "< XSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
#[doc = "< OSXSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
#[doc = "< AVX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
#[doc = "< F16C"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
#[doc = "< RDRAND"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
#[doc = "< Running in a VM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HYPERVISOR: rte_cpu_flag_t = 29;
#[doc = "< FPU"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 30;
#[doc = "< VME"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 31;
#[doc = "< DE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 32;
#[doc = "< PSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 33;
#[doc = "< TSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 34;
#[doc = "< MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 35;
#[doc = "< PAE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 36;
#[doc = "< MCE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 37;
#[doc = "< CX8"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 38;
#[doc = "< APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 39;
#[doc = "< SEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 40;
#[doc = "< MTRR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 41;
#[doc = "< PGE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 42;
#[doc = "< MCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 43;
#[doc = "< CMOV"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 44;
#[doc = "< PAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 45;
#[doc = "< PSE36"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 46;
#[doc = "< PSN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 47;
#[doc = "< CLFSH"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 48;
#[doc = "< DS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 49;
#[doc = "< ACPI"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 50;
#[doc = "< MMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 51;
#[doc = "< FXSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 52;
#[doc = "< SSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 53;
#[doc = "< SSE2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 54;
#[doc = "< SS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 55;
#[doc = "< HTT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 56;
#[doc = "< TM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 57;
#[doc = "< PBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 58;
#[doc = "< DIGTEMP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 59;
#[doc = "< TRBOBST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 60;
#[doc = "< ARAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 61;
#[doc = "< PLN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 62;
#[doc = "< ECMD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 63;
#[doc = "< PTM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 64;
#[doc = "< MPERF_APERF_MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 65;
#[doc = "< ACNT2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 66;
#[doc = "< ENERGY_EFF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 67;
#[doc = "< FSGSBASE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 68;
#[doc = "< BMI1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 69;
#[doc = "< Hardware Lock elision"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 70;
#[doc = "< AVX2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 71;
#[doc = "< SMEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 72;
#[doc = "< BMI2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 73;
#[doc = "< ERMS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 74;
#[doc = "< INVPCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 75;
#[doc = "< Transactional memory"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 76;
#[doc = "< AVX512F"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 77;
#[doc = "< RDSEED instruction"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDSEED: rte_cpu_flag_t = 78;
#[doc = "< LAHF_SAHF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 79;
#[doc = "< LZCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 80;
#[doc = "< SYSCALL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 81;
#[doc = "< XD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 82;
#[doc = "< 1GB_PG"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 83;
#[doc = "< RDTSCP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 84;
#[doc = "< EM64T"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 85;
#[doc = "< INVTSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 86;
#[doc = "< AVX512 Doubleword and Quadword"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512DQ: rte_cpu_flag_t = 87;
#[doc = "< AVX512 Integer Fused Multiply-Add"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512IFMA: rte_cpu_flag_t = 88;
#[doc = "< AVX512 Conflict Detection"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512CD: rte_cpu_flag_t = 89;
#[doc = "< AVX512 Byte and Word"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BW: rte_cpu_flag_t = 90;
#[doc = "< AVX512 Vector Length"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VL: rte_cpu_flag_t = 91;
#[doc = "< AVX512 Vector Bit Manipulation"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI: rte_cpu_flag_t = 92;
#[doc = "< AVX512 Vector Bit Manipulation 2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI2: rte_cpu_flag_t = 93;
#[doc = "< Galois Field New Instructions"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_GFNI: rte_cpu_flag_t = 94;
#[doc = "< Vector AES"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VAES: rte_cpu_flag_t = 95;
#[doc = "< Vector Carry-less Multiply"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VPCLMULQDQ: rte_cpu_flag_t = 96;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VNNI: rte_cpu_flag_t = 97;
#[doc = "< AVX512 Bit Algorithms"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BITALG: rte_cpu_flag_t = 98;
#[doc = "< AVX512 Vector Popcount"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VPOPCNTDQ: rte_cpu_flag_t = 99;
#[doc = "< Cache Line Demote"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLDEMOTE: rte_cpu_flag_t = 100;
#[doc = "< Direct Store Instructions"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIRI: rte_cpu_flag_t = 101;
#[doc = "< Direct Store Instructions 64B"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIR64B: rte_cpu_flag_t = 102;
#[doc = "< AVX512 Two Register Intersection"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VP2INTERSECT: rte_cpu_flag_t = 103;
#[doc = "< UMONITOR/UMWAIT/TPAUSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_WAITPKG: rte_cpu_flag_t = 104;
#[doc = "< MONITORX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITORX: rte_cpu_flag_t = 105;
#[doc = " Enumeration of all CPU features supported"]
pub type rte_cpu_flag_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[doc = " Structure used to describe platform-specific intrinsics that may or may not\n be supported at runtime."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_cpu_intrinsics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_cpu_intrinsics {
    #[inline]
    pub fn power_monitor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_monitor_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_monitor_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_pause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_pause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_pause_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_pause_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_monitor_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_monitor_multi_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_power_monitor_multi_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        power_monitor: u32,
        power_pause: u32,
        power_monitor_multi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let power_monitor: u32 = unsafe { ::std::mem::transmute(power_monitor) };
            power_monitor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_pause: u32 = unsafe { ::std::mem::transmute(power_pause) };
            power_pause as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let power_monitor_multi: u32 = unsafe { ::std::mem::transmute(power_monitor_multi) };
            power_monitor_multi as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " Check CPU support for various intrinsics at runtime.\n\n @param intrinsics\n     Pointer to a structure to be filled."]
    pub fn rte_cpu_get_intrinsics_support(intrinsics: *mut rte_cpu_intrinsics);
}
unsafe extern "C" {
    #[doc = " Get name of CPU flag\n\n @param feature\n     CPU flag ID\n @return\n     flag name\n     NULL if flag ID is invalid"]
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Function for checking a CPU flag availability\n\n @param feature\n     CPU flag to query CPU for\n @return\n     1 if flag is available\n     0 if flag is not available\n     -ENOENT if flag is invalid"]
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features\n that were specified at compile time. It is called automatically within the\n EAL, so does not need to be used by applications.  This version returns a\n result so that decisions may be made (for instance, graceful shutdowns)."]
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function attempts to retrieve a value from the auxiliary vector.\n If it is unsuccessful, the result will be 0, and errno will be set.\n\n @return A value from the auxiliary vector.  When the value is 0, check\n errno to determine if an error occurred."]
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " This function retrieves a value from the auxiliary vector, and compares it\n as a string against the value retrieved.\n\n @return The result of calling strcmp() against the value retrieved from\n the auxiliary vector.  When the value is 0 (meaning a match is found),\n check errno to determine if an error occurred."]
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static mut eal_timer_source: timer_source;
}
unsafe extern "C" {
    #[doc = " Get the measured frequency of the RDTSC counter\n\n @return\n   The TSC frequency for this lcore"]
    pub fn rte_get_tsc_hz() -> u64;
}
unsafe extern "C" {
    #[doc = " Wait at least us microseconds.\n This function can be replaced with user-defined function.\n @see rte_delay_us_callback_register\n\n @param us\n   The number of microseconds to wait."]
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
unsafe extern "C" {
    #[doc = " Blocking delay function.\n\n @param us\n   Number of microseconds to wait."]
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Delay function that uses system sleep.\n Does not block the CPU core.\n\n @param us\n   Number of microseconds to wait."]
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Replace rte_delay_us with user defined function.\n\n @param userfunc\n   User function which replaces rte_delay_us. rte_delay_us_block restores\n   builtin block delay function."]
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
unsafe extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[doc = " Callback definition for monitoring conditions. Callbacks with this signature\n will be used by `rte_power_monitor()` to check if the entering of power\n optimized state should be aborted.\n\n @param val\n   The value read from memory.\n @param opaque\n   Callback-specific data.\n\n @return\n   0 if entering of power optimized state should proceed\n   -1 if entering of power optimized state should be aborted"]
pub type rte_power_monitor_clb_t = ::std::option::Option<
    unsafe extern "C" fn(val: u64, opaque: *const u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_power_monitor_cond {
    #[doc = "< Address to monitor for changes"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (in bytes) that will be read from the\n   monitored memory location (`addr`). Can be 1, 2,\n   4, or 8. Supplying any other value will result in\n   an error."]
    pub size: u8,
    #[doc = "< Callback to be used to check if\n   entering power optimized state should\n   be aborted."]
    pub fn_: rte_power_monitor_clb_t,
    pub opaque: [u64; 4usize],
}
unsafe extern "C" {
    #[doc = " Monitor specific address for changes. This will cause the CPU to enter an\n architecture-defined optimized power state until either the specified\n memory address is written to, a certain TSC timestamp is reached, or other\n reasons cause the CPU to wake up.\n\n Additionally, an expected value (`pmc->val`), mask (`pmc->mask`), and data\n size (`pmc->size`) are provided in the `pmc` power monitoring condition. If\n the mask is non-zero, the current value pointed to by the `pmc->addr` pointer\n will be read and compared against the expected value, and if they match, the\n entering of optimized power state will be aborted. This is intended to\n prevent the CPU from entering optimized power state and waiting on a write\n that has already happened by the time this API is called.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n\n @param pmc\n   The monitoring condition structure.\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor(
        pmc: *const rte_power_monitor_cond,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Wake up a specific lcore that is in a power optimized state and is monitoring\n an address.\n\n @note It is safe to call this function if the lcore in question is not\n   sleeping. The function will have no effect.\n\n @note This function will *not* wake up a core that is in a power optimized\n   state due to calling `rte_power_pause`.\n\n @param lcore_id\n   Lcore ID of a sleeping thread."]
    pub fn rte_power_monitor_wakeup(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enter an architecture-defined optimized power state until a certain TSC\n timestamp is reached.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_pause(tsc_timestamp: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Monitor a set of addresses for changes. This will cause the CPU to enter an\n architecture-defined optimized power state until either one of the specified\n memory addresses is written to, a certain TSC timestamp is reached, or other\n reasons cause the CPU to wake up.\n\n Additionally, `expected` 64-bit values and 64-bit masks are provided. If\n mask is non-zero, the current value pointed to by the `p` pointer will be\n checked against the expected value, and if they do not match, the entering of\n optimized power state may be aborted.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n   Failing to do so may result in an illegal CPU instruction error.\n\n @param pmc\n   An array of monitoring condition structures.\n @param num\n   Length of the `pmc` array.\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor_multi(
        pmc: *const rte_power_monitor_cond,
        num: u32,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_3 = 256;
pub const _ISlower: _bindgen_ty_3 = 512;
pub const _ISalpha: _bindgen_ty_3 = 1024;
pub const _ISdigit: _bindgen_ty_3 = 2048;
pub const _ISxdigit: _bindgen_ty_3 = 4096;
pub const _ISspace: _bindgen_ty_3 = 8192;
pub const _ISprint: _bindgen_ty_3 = 16384;
pub const _ISgraph: _bindgen_ty_3 = 32768;
pub const _ISblank: _bindgen_ty_3 = 1;
pub const _IScntrl: _bindgen_ty_3 = 2;
pub const _ISpunct: _bindgen_ty_3 = 4;
pub const _ISalnum: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Takes string \"string\" parameter and splits it at character \"delim\"\n up to maxtokens-1 times - to give \"maxtokens\" resulting tokens. Like\n strtok or strsep functions, this modifies its input string, by replacing\n instances of \"delim\" with '\\\\0'. All resultant tokens are returned in the\n \"tokens\" array which must have enough entries to hold \"maxtokens\".\n\n @param string\n   The input string to be split into tokens\n\n @param stringlen\n   The max length of the input buffer\n\n @param tokens\n   The array to hold the pointers to the tokens in the string\n\n @param maxtokens\n   The number of elements in the tokens array. At most, maxtokens-1 splits\n   of the string will be done.\n\n @param delim\n   The character on which the split of the data will be done\n\n @return\n   The number of tokens in the tokens array."]
    pub fn rte_strsplit(
        string: *mut ::std::os::raw::c_char,
        stringlen: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
        maxtokens: ::std::os::raw::c_int,
        delim: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strnstr(
        str_: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
        str_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strmode(mode: mode_t, str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Copy string src to buffer dst of size dsize.\n At most dsize-1 chars will be copied.\n Always NUL-terminates, unless (dsize == 0).\n\n @param dst\n   The destination string.\n\n @param src\n   The input string to be copied.\n\n @param dsize\n   Length in bytes of the destination buffer.\n\n @return\n   The number of bytes copied (terminating NUL-byte excluded) on success.\n   -E2BIG if the destination buffer is too small.\n   rte_errno is set."]
    pub fn rte_strscpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dsize: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = "  Test if trace is enabled.\n\n  @return\n     true if trace is enabled, false otherwise."]
    pub fn rte_trace_is_enabled() -> bool;
}
#[doc = " In this mode, when no space is left in the trace buffer, the\n subsequent events overwrite the old events."]
pub const rte_trace_mode_RTE_TRACE_MODE_OVERWRITE: rte_trace_mode = 0;
#[doc = " In this mode, when no space is left in the trace buffer, the\n subsequent events shall not be recorded."]
pub const rte_trace_mode_RTE_TRACE_MODE_DISCARD: rte_trace_mode = 1;
#[doc = " Enumerate trace mode operation."]
pub type rte_trace_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Set the trace mode.\n\n @param mode\n   Trace mode."]
    pub fn rte_trace_mode_set(mode: rte_trace_mode);
}
unsafe extern "C" {
    #[doc = " Get the trace mode.\n\n @return\n   The current trace mode."]
    pub fn rte_trace_mode_get() -> rte_trace_mode;
}
unsafe extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on globbing pattern.\n\n @param pattern\n   The globbing pattern identifying the tracepoint.\n @param enable\n   true to enable tracepoint, false to disable the tracepoint, upon match.\n @return\n   - 0: Success and no pattern match.\n   - 1: Success and found pattern match.\n   - (-ERANGE): Tracepoint object is not registered."]
    pub fn rte_trace_pattern(
        pattern: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable a set of tracepoints based on regular expression.\n\n @param regex\n   A regular expression identifying the tracepoint.\n @param enable\n   true to enable tracepoint, false to disable the tracepoint, upon match.\n @return\n   - 0: Success and no pattern match.\n   - 1: Success and found pattern match.\n   - (-ERANGE): Tracepoint object is not registered.\n   - (-EINVAL): Invalid regular expression rule."]
    pub fn rte_trace_regexp(
        regex: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Save the trace buffer to the trace directory.\n\n By default, trace directory will be created at $HOME directory and this can\n be overridden by --trace-dir EAL parameter.\n\n @return\n   - 0: Success.\n   - <0 : Failure."]
    pub fn rte_trace_save() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the trace metadata to a file.\n\n @param f\n   A pointer to a file for output\n @return\n   - 0: Success.\n   - <0 : Failure."]
    pub fn rte_trace_metadata_dump(f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the trace subsystem status to a file.\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_trace_dump(f: *mut FILE);
}
#[doc = " The tracepoint object."]
pub type rte_trace_point_t = u64;
unsafe extern "C" {
    #[doc = " Enable recording events of the given tracepoint in the trace buffer.\n\n @param tp\n   The tracepoint object to enable.\n @return\n   - 0: Success.\n   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_enable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable recording events of the given tracepoint in the trace buffer.\n\n @param tp\n   The tracepoint object to disable.\n @return\n   - 0: Success.\n   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_disable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test if recording events from the given tracepoint is enabled.\n\n @param tp\n    The tracepoint object.\n @return\n    true if tracepoint is enabled, false otherwise."]
    pub fn rte_trace_point_is_enabled(tp: *mut rte_trace_point_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Lookup a tracepoint object from its name.\n\n @param name\n   The name of the tracepoint.\n @return\n   The tracepoint object or NULL if not found."]
    pub fn rte_trace_point_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_trace_point_t;
}
unsafe extern "C" {
    #[doc = " @internal\n\n Allocate trace memory buffer per thread."]
    pub fn __rte_trace_mem_per_thread_alloc();
}
unsafe extern "C" {
    #[doc = " @internal\n\n Helper function to emit field.\n\n @param sz\n   The tracepoint size.\n @param field\n   The name of the trace event.\n @param type\n   The datatype of the trace event as string.\n @return\n   - 0: Success.\n   - <0: Failure."]
    pub fn __rte_trace_point_emit_field(
        sz: usize,
        field: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " @internal\n\n Helper function to register a dynamic tracepoint.\n Use RTE_TRACE_POINT_REGISTER macro for tracepoint registration.\n\n @param trace\n   The tracepoint object created using RTE_TRACE_POINT_REGISTER.\n @param name\n   The name of the tracepoint object.\n @param register_fn\n   Trace registration function.\n @return\n   - 0: Successfully registered the tracepoint.\n   - <0: Failure to register the tracepoint."]
    pub fn __rte_trace_point_register(
        trace: *mut rte_trace_point_t,
        name: *const ::std::os::raw::c_char,
        register_fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __rte_ethdev_trace_rx_burst_empty: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_ethdev_trace_rx_burst_nonempty: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_ethdev_trace_tx_burst: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_call_rx_callbacks_empty: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_call_rx_callbacks_nonempty: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_call_tx_callbacks: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_tx_buffer_drop_callback: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_tx_buffer_count_callback: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_eth_trace_tx_queue_count: rte_trace_point_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_reg_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
    #[doc = " Name of target module, filter for target subset of registers.\n This field could affects register selection for data/length/names."]
    pub filter: *const ::std::os::raw::c_char,
    #[doc = "< Registers name saver"]
    pub names: *mut rte_eth_reg_name,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return EEPROM"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start EEPROM address for access"]
    pub offset: u32,
    #[doc = "< Length of EEPROM region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[doc = " Placeholder for accessing plugin module EEPROM"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module EEPROM"]
    pub type_: u32,
    #[doc = "< Length of plugin module EEPROM"]
    pub eeprom_len: u32,
}
unsafe extern "C" {
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initializes a device iterator.\n\n This iterator allows accessing a list of devices matching some devargs.\n\n @param iter\n   Device iterator handle initialized by the function.\n   The fields bus_str and cls_str might be dynamically allocated,\n   and could be freed by calling rte_eth_iterator_cleanup().\n\n @param devargs\n   Device description string.\n\n @return\n   0 on successful initialization, negative otherwise."]
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iterates on devices with devargs filter.\n The ownership is not checked.\n\n The next port ID is returned, and the iterator is updated.\n\n @param iter\n   Device iterator handle initialized by rte_eth_iterator_init().\n   Some fields bus_str and cls_str might be freed when no more port is found,\n   by calling rte_eth_iterator_cleanup().\n\n @return\n   A port ID if found, RTE_MAX_ETHPORTS otherwise."]
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
unsafe extern "C" {
    #[doc = " Free some allocated fields of the iterator.\n\n This function is automatically called by rte_eth_iterator_next()\n on the last iteration (i.e. when no more matching port is found).\n\n It is safe to call this function twice; it will do nothing more.\n\n @param iter\n   Device iterator handle initialized by rte_eth_iterator_init().\n   The fields bus_str and cls_str are freed if needed."]
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
#[doc = " A structure used to retrieve statistics for an Ethernet port.\n Not all statistics fields in struct rte_eth_stats are supported\n by any type of network interface card (NIC). If any statistics\n field is not supported, its value is 0.\n All byte-related statistics do not include Ethernet FCS regardless\n of whether these bytes have been delivered to the application\n (see RTE_ETH_RX_OFFLOAD_KEEP_CRC)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    #[doc = " Total of Rx packets dropped by the HW,\n because there are no available buffer (i.e. Rx queues are full)."]
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of Rx mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = " Total number of queue Rx packets."]
    pub q_ipackets: [u64; 16usize],
    #[doc = " Total number of queue Tx packets."]
    pub q_opackets: [u64; 16usize],
    #[doc = " Total number of successfully received queue bytes."]
    pub q_ibytes: [u64; 16usize],
    #[doc = " Total number of successfully transmitted queue bytes."]
    pub q_obytes: [u64; 16usize],
    #[doc = " Total number of queue packets received that are dropped."]
    pub q_errors: [u64; 16usize],
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link {
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_link__bindgen_ty_1 {
    #[doc = "< used for atomic64 read/write"]
    pub val64: u64,
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< RTE_ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_duplex_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_duplex_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_autoneg_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_autoneg_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_status_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to get and set lanes capabilities per link speed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_speed_lanes_capa {
    pub speed: u32,
    pub capa: u32,
}
#[doc = " A structure used to configure the ring threshold registers of an Rx/Tx\n queue for an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[doc = " None of DCB, RSS or VMDq mode"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For Rx side, only RSS is on"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For Rx side,only DCB is on."]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDq, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDq+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDq and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route\n  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = ::std::os::raw::c_uint;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For Tx side,only DCB is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For Tx side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit\n packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Rx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Requested MTU."]
    pub mtu: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = " Per-port Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.\n Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = ::std::os::raw::c_uint;
#[doc = " A structure used to describe a VLAN filter.\n If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[doc = " DEFAULT means driver decides which hash algorithm to pick."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT:
    rte_eth_hash_function = 4;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 5;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature\n of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = " In rte_eth_dev_rss_hash_conf_get(), the *rss_key_len* should be\n greater than or equal to the *hash_key_size* which get from\n rte_eth_dev_info_get() API. And the *rss_key* should contain at least\n *hash_key_size* bytes. If not meet these requirements, the query\n result is unreliable even if the operation returns success.\n\n In rte_eth_dev_rss_hash_update() or rte_eth_dev_configure(), if\n *rss_key* is not NULL, the *rss_key_len* indicates the length of the\n *rss_key* in bytes and it should be equal to *hash_key_size*.\n If *rss_key* is NULL, drivers are free to use a random or a default key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = " Indicates the type of packets or the specific part of packets to\n which RSS hashing is to be applied."]
    pub rss_hf: u64,
    #[doc = "< Hash algorithm."]
    pub algorithm: rte_eth_hash_function,
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the\n Receive Side Scaling (RSS) feature of an Ethernet port. To configure\n more than 64 entries supported by hardware, an array of this structure\n is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    #[doc = " Mask bits indicate which entries need to be updated/queried."]
    pub mask: u64,
    #[doc = " Group of 64 redirection table entries."]
    pub reta: [u16; 64usize],
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes\n in DCB configurations"]
pub type rte_eth_nb_tcs = ::std::os::raw::c_uint;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools\n in VMDq configurations."]
pub type rte_eth_nb_pools = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[doc = " A structure used to configure the VMDq+DCB feature\n of an Ethernet port.\n\n Using this feature, packets are routed to a pool of queues, based\n on the VLAN ID in the VLAN tag, and then to a specific queue within\n that pool, using the user priority VLAN tag field.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    #[doc = " Selects a queue in a pool"]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the VMDq feature of an Ethernet port when\n not combined with the DCB feature.\n\n Using this feature, packets are routed to a pool of queues. By default,\n the pool selection is based on the MAC address, the VLAN ID in the\n VLAN tag as specified in the pool_map array.\n Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool\n selection using only the MAC address. MAC address to pool mapping is done\n using the rte_eth_dev_mac_addr_add function, with the pool parameter\n corresponding to the pool ID.\n\n Queue selection within the selected pool will be done using RSS when\n it is enabled or revert to the first queue of the pool if not.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from RTE_ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the Tx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< Tx multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_tagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_tagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_untagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_untagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_pvid_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_pvid_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A structure used to configure an Rx packet segment to split.\n\n If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,\n the PMD will split the received packets into multiple segments\n according to the specification in the description array:\n\n - The first network buffer will be allocated from the memory pool,\n   specified in the first array element, the second buffer, from the\n   pool in the second element, and so on.\n\n - The proto_hdrs in the elements define the split position of\n   received packets.\n\n - The offsets from the segment description elements specify\n   the data offset from the buffer beginning except the first mbuf.\n   The first segment offset is added with RTE_PKTMBUF_HEADROOM.\n\n - The lengths in the elements define the maximal data amount\n   being received to each segment. The receiving starts with filling\n   up the first mbuf data buffer up to specified length. If the\n   there are data remaining (packet is longer than buffer in the first\n   mbuf) the following data will be pushed to the next segment\n   up to its own length, and so on.\n\n - If the length in the segment description element is zero\n   the actual buffer size will be deduced from the appropriate\n   memory pool properties.\n\n - If there is not enough elements to describe the buffer for entire\n   packet of maximal length the following parameters will be used\n   for the all remaining segments:\n     - pool from the last valid element\n     - the buffer size from this pool\n     - zero offset\n\n - Length based buffer split:\n     - mp, length, offset should be configured.\n     - The proto_hdr field must be 0.\n\n - Protocol header based buffer split:\n     - mp, offset, proto_hdr should be configured.\n     - The length field must be 0.\n     - The proto_hdr field in the last segment should be 0.\n\n - When protocol header split is enabled, NIC may receive packets\n   which do not match all the protocol headers within the Rx segments.\n   At this point, NIC will have two possible split behaviors according to\n   matching results, one is exact match, another is longest match.\n   The split result of NIC must belong to one of them.\n   The exact match means NIC only do split when the packets exactly match all\n   the protocol headers in the segments.\n   Otherwise, the whole packet will be put into the last valid mempool.\n   The longest match means NIC will do split until packets mismatch\n   the protocol header in the segments.\n   The rest will be put into the last valid pool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = " proto_hdr defines a bit mask of the protocol sequence as RTE_PTYPE_*.\n The last RTE_PTYPE* in the mask indicates the split position.\n\n If one protocol header is defined to split packets into two segments,\n for non-tunneling packets, the complete protocol sequence should be defined.\n For tunneling packets, for simplicity, only the tunnel and inner part of\n complete protocol sequence is required.\n If several protocol headers are defined to split packets into multi-segments,\n the repeated parts of adjacent segments should be omitted."]
    pub proto_hdr: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[doc = " A structure used to configure an Rx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< Rx ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of Rx descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Share group index in Rx domain and switch domain.\n Non-zero value to enable Rx queue share, zero value disable share.\n PMD is responsible for Rx queue consistency checks to avoid member\n port's configuration contradict to each other."]
    pub share_group: u16,
    #[doc = "< Shared Rx queue ID in group"]
    pub share_qid: u16,
    #[doc = " Per-queue Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_queue_offload_capa or rx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet.\n Array elements are properties for consecutive Rx segments.\n\n The supported capabilities of receiving segmentation is reported\n in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = " Array of mempools to allocate Rx buffers from.\n\n This provides support for multiple mbuf pools per Rx queue.\n The capability is reported in device info via positive\n max_rx_mempools.\n\n It could be useful for more efficient usage of memory when an\n application creates different mempools to steer the specific\n size of the packet.\n\n If many mempools are specified, packets received using Rx\n burst may belong to any provided mempool. From ethdev user point\n of view it is undefined how PMD/NIC chooses mempool for a packet.\n\n If Rx scatter is enabled, a packet may be delivered using a chain\n of mbufs obtained from single mempool or multiple mempools based\n on the NIC implementation."]
    pub rx_mempools: *mut *mut rte_mempool,
    pub rx_nmempool: u16,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " A structure used to configure a Tx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< Tx ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing Tx buffers if there are\nless free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_queue_offload_capa or tx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the Tx or Rx hairpin queue capabilities."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_queue_cap {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_eth_hairpin_queue_cap {
    #[inline]
    pub fn locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        locked_device_memory: u32,
        rte_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let locked_device_memory: u32 = unsafe { ::std::mem::transmute(locked_device_memory) };
            locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rte_memory: u32 = unsafe { ::std::mem::transmute(rte_memory) };
            rte_memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
    #[doc = "< Rx hairpin queue capabilities."]
    pub rx_cap: rte_eth_hairpin_queue_cap,
    #[doc = "< Tx hairpin queue capabilities."]
    pub tx_cap: rte_eth_hairpin_queue_cap,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure hairpin binding."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_conf {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
impl rte_eth_hairpin_conf {
    #[inline]
    pub fn peer_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_peer_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn peer_count_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_peer_count_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_explicit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_explicit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_explicit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_explicit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn manual_bind(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manual_bind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn manual_bind_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_manual_bind_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn force_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_force_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        peer_count: u32,
        tx_explicit: u32,
        manual_bind: u32,
        use_locked_device_memory: u32,
        use_rte_memory: u32,
        force_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let peer_count: u32 = unsafe { ::std::mem::transmute(peer_count) };
            peer_count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_explicit: u32 = unsafe { ::std::mem::transmute(tx_explicit) };
            tx_explicit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let manual_bind: u32 = unsafe { ::std::mem::transmute(manual_bind) };
            manual_bind as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let use_locked_device_memory: u32 =
                unsafe { ::std::mem::transmute(use_locked_device_memory) };
            use_locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let use_rte_memory: u32 = unsafe { ::std::mem::transmute(use_rte_memory) };
            use_rte_memory as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let force_memory: u32 = unsafe { ::std::mem::transmute(force_memory) };
            force_memory as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet.\n\n - For TSO packet this is the total number of data descriptors allowed\n   by device.\n\n @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU.\n\n - For non-TSO packet, this is the maximum allowed number of segments\n   in a single transmit packet.\n\n - For TSO packet each segment within the TSO may span up to this\n   value.\n\n @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_ETH_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< Rx pause frame, enable flowctrl on Tx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< Tx pause frame, enable flowctrl on Rx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure Ethernet flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[doc = " A structure used to configure Ethernet priority flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to retrieve information of queue based PFC."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_info {
    #[doc = " Maximum supported traffic class as per PFC (802.1Qbb) specification."]
    pub tc_max: u8,
    #[doc = " PFC queue mode capabilities."]
    pub mode_capa: rte_eth_fc_mode,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure Ethernet priority flow control parameters for\n ethdev queues.\n\n rte_eth_pfc_queue_conf::rx_pause structure shall be used to configure given\n tx_qid with corresponding tc. When ethdev device receives PFC frame with\n rte_eth_pfc_queue_conf::rx_pause::tc, traffic will be paused on\n rte_eth_pfc_queue_conf::rx_pause::tx_qid for that tc.\n\n rte_eth_pfc_queue_conf::tx_pause structure shall be used to configure given\n rx_qid. When rx_qid is congested, PFC frames are generated with\n rte_eth_pfc_queue_conf::rx_pause::tc and\n rte_eth_pfc_queue_conf::rx_pause::pause_time to the peer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf {
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    pub rx_pause: rte_eth_pfc_queue_conf__bindgen_ty_1,
    pub tx_pause: rte_eth_pfc_queue_conf__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_1 {
    #[doc = "< Tx queue ID"]
    pub tx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_2 {
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Rx queue ID"]
    pub rx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_NONE: rte_eth_tunnel_type = 0;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_VXLAN: rte_eth_tunnel_type = 1;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_GENEVE: rte_eth_tunnel_type = 2;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_TEREDO: rte_eth_tunnel_type = 3;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_NVGRE: rte_eth_tunnel_type = 4;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_IP_IN_GRE: rte_eth_tunnel_type = 5;
pub const rte_eth_tunnel_type_RTE_ETH_L2_TUNNEL_TYPE_E_TAG: rte_eth_tunnel_type = 6;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_VXLAN_GPE: rte_eth_tunnel_type = 7;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_ECPRI: rte_eth_tunnel_type = 8;
pub const rte_eth_tunnel_type_RTE_ETH_TUNNEL_TYPE_MAX: rte_eth_tunnel_type = 9;
#[doc = " Tunnel type for device-specific classifier configuration.\n @see rte_eth_udp_tunnel"]
pub type rte_eth_tunnel_type = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Seed the pseudo-random generator.\n\n The generator is automatically seeded by the EAL init with a timer\n value. It may need to be re-seeded by the user with a real random\n value.\n\n This function is not multi-thread safe in regards to other\n rte_srand() calls, nor is it in relation to concurrent rte_rand(),\n rte_rand_max() or rte_drand() calls.\n\n @param seedval\n   The value of the seed."]
    pub fn rte_srand(seedval: u64);
}
unsafe extern "C" {
    #[doc = " Get a pseudo-random value.\n\n The generator is not cryptographically secure.\n\n rte_rand(), rte_rand_max() and rte_drand() are multi-thread safe,\n with the exception that they may not be called by multiple\n _unregistered_ non-EAL threads in parallel.\n\n @return\n   A pseudo-random value between 0 and (1<<64)-1."]
    pub fn rte_rand() -> u64;
}
unsafe extern "C" {
    #[doc = " Generates a pseudo-random number with an upper bound.\n\n This function returns an uniformly distributed (unbiased) random\n number less than a user-specified maximum value.\n\n rte_rand(), rte_rand_max() and rte_drand() are multi-thread safe,\n with the exception that they may not be called by multiple\n _unregistered_ non-EAL threads in parallel.\n\n @param upper_bound\n   The upper bound of the generated number.\n @return\n   A pseudo-random value between 0 and (upper_bound-1)."]
    pub fn rte_rand_max(upper_bound: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " Generates a pseudo-random floating point number.\n\n This function returns a non-negative double-precision floating random\n number uniformly distributed over the interval [0.0, 1.0).\n\n The generator is not cryptographically secure.\n\n rte_rand(), rte_rand_max() and rte_drand() are multi-thread safe,\n with the exception that they may not be called by multiple\n _unregistered_ non-EAL threads in parallel.\n\n @return\n   A pseudo-random value between 0 and 1.0."]
    pub fn rte_drand() -> f64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
unsafe extern "C" {
    #[doc = " Internal helpers used for lock annotations."]
    pub fn rte_mcfg_mem_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_tailq_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_mempool_get_lock() -> *mut rte_rwlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_timer_get_lock() -> *mut rte_spinlock_t;
}
unsafe extern "C" {
    pub fn rte_mcfg_ethdev_get_lock() -> *mut rte_spinlock_t;
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_unlock();
}
unsafe extern "C" {
    #[doc = " Lock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_lock();
}
unsafe extern "C" {
    #[doc = " Unlock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_unlock();
}
unsafe extern "C" {
    #[doc = " If true, pages are put in single files (per memseg list),\n as opposed to creating a file per page."]
    pub fn rte_mcfg_get_single_file_segments() -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
unsafe extern "C" {
    #[doc = " Set up ``rte_fbarray`` structure and allocate underlying resources.\n\n Call this function to correctly set up ``rte_fbarray`` and allocate\n underlying files that will be backing the data in the current process. Note\n that in order to use and share ``rte_fbarray`` between multiple processes,\n data pointed to by ``arr`` pointer must itself be allocated in shared memory.\n\n @param arr\n   Valid pointer to allocated ``rte_fbarray`` structure.\n\n @param name\n   Unique name to be assigned to this array.\n\n @param len\n   Number of elements initially available in the array.\n\n @param elt_sz\n   Size of each element.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attach to a file backing an already allocated and correctly set up\n ``rte_fbarray`` structure.\n\n Call this function to attach to file that will be backing the data in the\n current process. The structure must have been previously correctly set up\n with a call to ``rte_fbarray_init()``. Calls to ``rte_fbarray_attach()`` are\n usually meant to be performed in a multiprocessing scenario, with data\n pointed to by ``arr`` pointer allocated in shared memory.\n\n @param arr\n   Valid pointer to allocated and correctly set up rte_fbarray structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up\n ``rte_fbarray`` structure, and remove the underlying file.\n\n Call this function to deallocate all resources associated with an\n ``rte_fbarray`` structure within the current process. This will also\n zero-fill data pointed to by ``arr`` pointer and remove the underlying file\n backing the data, so it is expected that by the time this function is called,\n all other processes have detached from this ``rte_fbarray``.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up\n ``rte_fbarray`` structure.\n\n Call this function to deallocate all resources associated with an\n ``rte_fbarray`` structure within current process.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get pointer to element residing at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Index of an element to get a pointer to.\n\n @return\n  - non-NULL pointer on success.\n  - NULL on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Find index of a specified element within the array.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param elt\n   Pointer to element to find index to.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Mark specified element as used.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to mark as used.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Mark specified element as free.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to mark as free.\n\n @return\n  - 0 on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check whether element at specified index is marked as used.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param idx\n   Element index to check as used.\n\n @return\n  - 1 if element is used.\n  - 0 if element is unused.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next free element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next used element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next chunk of ``n`` free elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of free elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of next chunk of ``n`` used elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of used elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more free entries there are, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more used entries there are, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of previous free element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of previous used element, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` free elements, down from specified\n index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of free elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` used elements, down from specified\n index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @param n\n   Number of used elements to look for.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more free entries there are before specified index (like\n ``rte_fbarray_find_contig_free`` but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find how many more used entries there are before specified index (like\n ``rte_fbarray_find_contig_used`` but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of free elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of used elements, starting at specified index.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of free elements before a specified index (like\n ``rte_fbarray_find_biggest_free``, but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find index of biggest chunk of used elements before a specified index (like\n ``rte_fbarray_find_biggest_used``, but going in reverse).\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param start\n   Element index to start search from.\n\n @return\n  - non-negative integer on success.\n  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump ``rte_fbarray`` metadata.\n\n @param arr\n   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.\n\n @param f\n   File object to dump information into."]
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
#[doc = " Physical memory segment descriptor."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    #[doc = "< Length of the segment."]
    pub len: usize,
    #[doc = "< The pagesize of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Number of channels."]
    pub nchannel: u32,
    #[doc = "< Number of ranks."]
    pub nrank: u32,
    #[doc = "< Memseg-specific flags"]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64 bits"]
    pub addr_64: u64,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data\n together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
unsafe extern "C" {
    #[doc = " Lock page in physical memory and prevent from swapping.\n\n @param virt\n   The virtual address.\n @return\n   0 on success, negative on error."]
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get physical address of any mapped virtual address in the current process.\n It is found by browsing the /proc/self/pagemap special file.\n The page must be locked.\n\n @param virt\n   The virtual address.\n @return\n   The physical address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
unsafe extern "C" {
    #[doc = " Get IO virtual address of any mapped virtual address in the current process.\n\n @note This function will not check internal page table. Instead, in IOVA as\n       PA mode, it will fall back to getting real physical address (which may\n       not match the expected IOVA, such as what was specified for external\n       memory).\n\n @param virt\n   The virtual address.\n @return\n   The IO address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
unsafe extern "C" {
    #[doc = " Get virtual memory address corresponding to iova address.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @param iova\n   The iova address.\n @return\n   Virtual address corresponding to iova address (or NULL if address does not\n   exist within DPDK memory map)."]
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get memseg to which a particular virtual address belongs.\n\n @param virt\n   The virtual address.\n @param msl\n   The memseg list in which to look up based on ``virt`` address\n   (can be NULL).\n @return\n   Memseg pointer on success, or NULL on error."]
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
unsafe extern "C" {
    #[doc = " Get memseg list corresponding to virtual memory address.\n\n @param virt\n   The virtual address.\n @return\n   Memseg list to which this virtual address belongs to."]
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
#[doc = " Memseg walk function prototype.\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg contig walk function prototype. This will trigger a callback on every\n VA-contiguous area starting at memseg ``ms``, so total valid VA space at each\n callback call will be [``ms->addr``, ``ms->addr + len``).\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg list walk function prototype. This will trigger a callback on every\n allocated memseg list.\n\n Returning 0 will continue walk\n Returning 1 will stop the walk\n Returning -1 will stop the walk and report error"]
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register external memory chunk with DPDK.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA mapping. It is expected that user\n   will do that themselves.\n\n @note Before accessing this memory in other processes, it needs to be\n   attached in each of those processes by calling ``rte_extmem_attach`` in\n   each other process.\n\n @param va_addr\n   Start of virtual area to register. Must be aligned by ``page_sz``.\n @param len\n   Length of virtual area to register. Must be aligned by ``page_sz``.\n @param iova_addrs\n   Array of page IOVA addresses corresponding to each page in this memory\n   area. Can be NULL, in which case page IOVA addresses will be set to\n   RTE_BAD_IOVA.\n @param n_pages\n   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``\n   is NULL.\n @param page_sz\n   Page size of the underlying memory\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     EEXIST - memory chunk is already registered\n     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister external memory chunk with DPDK.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA unmapping. It is expected that user\n   will do that themselves.\n\n @note Before calling this function, all other processes must call\n   ``rte_extmem_detach`` to detach from the memory area.\n\n @param va_addr\n   Start of virtual area to unregister\n @param len\n   Length of virtual area to unregister\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attach to external memory chunk registered in another process.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA mapping. It is expected that user\n   will do that themselves.\n\n @param va_addr\n   Start of virtual area to register\n @param len\n   Length of virtual area to register\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Detach from external memory chunk registered in another process.\n\n @note Using this API is mutually exclusive with ``rte_malloc`` family of\n   API's.\n\n @note This API will not perform any DMA unmapping. It is expected that user\n   will do that themselves.\n\n @param va_addr\n   Start of virtual area to unregister\n @param len\n   Length of virtual area to unregister\n\n @return\n   - 0 on success\n   - -1 in case of error, with rte_errno set to one of the following:\n     EINVAL - one of the parameters was invalid\n     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dump the physical memory layout to a file.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Get the total amount of available physical memory.\n\n @note This function read-locks the memory hotplug subsystem, and thus cannot\n       be used within memory-related callback functions.\n\n @return\n    The total amount of available physical memory in bytes."]
    pub fn rte_eal_get_physmem_size() -> u64;
}
unsafe extern "C" {
    #[doc = " Get the number of memory channels.\n\n @return\n   The number of memory channels on the system. The value is 0 if unknown\n   or not the same on all devices."]
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Get the number of memory ranks.\n\n @return\n   The number of memory ranks on the system. The value is 0 if unknown or\n   not the same on all devices."]
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with\n supplied DMA address width.\n\n  @param maskbits\n    Address width to check against."]
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if all currently allocated memory segments are compliant with\n supplied DMA address width. This function will use\n rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying\n memory_hotplug_lock will not be acquired avoiding deadlock during\n memory initialization.\n\n This function is just for EAL core memory internal use. Drivers should\n use the previous rte_mem_check_dma_mask.\n\n  @param maskbits\n    Address width to check against."]
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set dma mask to use once memory initialization is done. Previous functions\n  rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be\n  used safely until memory has been initialized."]
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
unsafe extern "C" {
    #[doc = " Drivers based on uio will not load unless physical\n addresses are obtainable. It is only possible to get\n physical addresses when running as a privileged user.\n\n @return\n   1 if the system is able to obtain physical addresses.\n   0 if using DMA addresses through an IOMMU."]
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
#[doc = "< Allocation event."]
pub const rte_mem_event_RTE_MEM_EVENT_ALLOC: rte_mem_event = 0;
#[doc = "< Deallocation event."]
pub const rte_mem_event_RTE_MEM_EVENT_FREE: rte_mem_event = 1;
#[doc = " Enum indicating which kind of memory event has happened. Used by callbacks to\n distinguish between memory allocations and deallocations."]
pub type rte_mem_event = ::std::os::raw::c_uint;
#[doc = " Function typedef used to register callbacks for memory events."]
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Function used to register callbacks for memory events.\n\n @note callbacks will happen while memory hotplug subsystem is write-locked,\n       therefore some functions (e.g. `rte_memseg_walk()`) will cause a\n       deadlock when called from within such callbacks.\n\n @note mem event callbacks not being supported is an expected error condition,\n       so user code needs to handle this situation. In these cases, return\n       value will be -1, and rte_errno will be set to ENOTSUP.\n\n @param name\n   Name associated with specified callback to be added to the list.\n\n @param clb\n   Callback function pointer.\n\n @param arg\n   Argument to pass to the callback.\n\n @return\n   0 on successful callback register\n   -1 on unsuccessful callback register, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Function used to unregister callbacks for memory events.\n\n @param name\n   Name associated with specified callback to be removed from the list.\n\n @param arg\n   Argument to look for among callbacks with specified callback name.\n\n @return\n   0 on successful callback unregister\n   -1 on unsuccessful callback unregister, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function typedef used to register memory allocation validation callbacks.\n\n Returning 0 will allow allocation attempt to continue. Returning -1 will\n prevent allocation from succeeding."]
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: usize,
        new_len: usize,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @brief Register validator callback for memory allocations.\n\n Callbacks registered by this function will be called right before memory\n allocator is about to trigger allocation of more pages from the system if\n said allocation will bring total memory usage above specified limit on\n specified socket. User will be able to cancel pending allocation if callback\n returns -1.\n\n @note callbacks will happen while memory hotplug subsystem is write-locked,\n       therefore some functions (e.g. `rte_memseg_walk()`) will cause a\n       deadlock when called from within such callbacks.\n\n @note validator callbacks not being supported is an expected error condition,\n       so user code needs to handle this situation. In these cases, return\n       value will be -1, and rte_errno will be set to ENOTSUP.\n\n @param name\n   Name associated with specified callback to be added to the list.\n\n @param clb\n   Callback function pointer.\n\n @param socket_id\n   Socket ID on which to watch for allocations.\n\n @param limit\n   Limit above which to trigger callbacks.\n\n @return\n   0 on successful callback register\n   -1 on unsuccessful callback register, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unregister validator callback for memory allocations.\n\n @param name\n   Name associated with specified callback to be removed from the list.\n\n @param socket_id\n   Socket ID on which to watch for allocations.\n\n @return\n   0 on successful callback unregister\n   -1 on unsuccessful callback unregister, with rte_errno value indicating\n   reason for failure."]
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[doc = " Enq/Deq a fixed number of items from a ring"]
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
#[doc = " Enq/Deq as many items as possible from ring"]
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
#[doc = " enqueue/dequeue behavior types"]
pub type rte_ring_queue_behavior = ::std::os::raw::c_uint;
#[doc = "< multi-thread safe (default mode)"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
#[doc = "< single thread only"]
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
#[doc = "< multi-thread relaxed tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
#[doc = "< multi-thread head/tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
#[doc = " prod/cons sync types"]
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[doc = " structures to hold a pair of head/tail values and other metadata.\n Depending on sync_type format of that structure might be different,\n but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure.\n\n The producer and the consumer have a head and a tail index. The particularity\n of these index is that they are not between 0 and size(ring)-1. These indexes\n are between 0 and 2^32 -1, and we mask their value when we access the ring[]\n field. Thanks to this assumption, we can do subtractions between 2 index\n values in a modulo-32bit base: that's why the overflow of the indexes is not\n a problem."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
unsafe extern "C" {
    #[doc = " Calculate the memory size needed for a ring with given element size\n\n This function returns the number of bytes needed for a ring, given\n the number of elements in it and the size of the element. This value\n is the sum of the size of the structure rte_ring and the size of the\n memory needed for storing the elements. The value is aligned to a cache\n line size.\n\n @param esize\n   The size of ring element, in bytes. It must be a multiple of 4.\n @param count\n   The number of elements in the ring (must be a power of 2).\n @return\n   - The memory size needed for the ring on success.\n   - -EINVAL - esize is not a multiple of 4 or count provided is not a\n\t\t power of 2."]
    pub fn rte_ring_get_memsize_elem(
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = " Create a new ring named *name* that stores elements with given size.\n\n This function uses ``memzone_reserve()`` to allocate memory. Then it\n calls rte_ring_init() to initialize an empty ring.\n\n The new ring size is set to *count*, which must be a power of\n two. Water marking is disabled by default. The real usable ring size\n is *count-1* instead of *count* to differentiate a full ring from an\n empty ring.\n\n The ring is added in RTE_TAILQ_RING list.\n\n @param name\n   The name of the ring.\n @param esize\n   The size of ring element, in bytes. It must be a multiple of 4.\n @param count\n   The number of elements in the ring (must be a power of 2).\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n @return\n   On success, the pointer to the new allocated ring. NULL on error with\n    rte_errno set appropriately. Possible errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - esize is not a multiple of 4 or count provided is not a\n\t\t power of 2.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create_elem(
        name: *const ::std::os::raw::c_char,
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
#[doc = " Ring zero-copy information structure.\n\n This structure contains the pointers and length of the space\n reserved on the ring storage."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring_zc_data {
    pub ptr1: *mut ::std::os::raw::c_void,
    pub ptr2: *mut ::std::os::raw::c_void,
    pub n1: ::std::os::raw::c_uint,
}
unsafe extern "C" {
    #[doc = " Calculate the memory size needed for a ring\n\n This function returns the number of bytes needed for a ring, given\n the number of elements in it. This value is the sum of the size of\n the structure rte_ring and the size of the memory needed by the\n objects pointers. The value is aligned to a cache line size.\n\n @param count\n   The number of elements in the ring (must be a power of 2).\n @return\n   - The memory size needed for the ring on success.\n   - -EINVAL if count is not a power of 2."]
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
unsafe extern "C" {
    #[doc = " Initialize a ring structure.\n\n Initialize a ring structure in memory pointed by \"r\". The size of the\n memory area must be large enough to store the ring structure and the\n object table. It is advised to use rte_ring_get_memsize() to get the\n appropriate size.\n\n The ring size is set to *count*, which must be a power of two.\n The real usable ring size is *count-1* instead of *count* to\n differentiate a full ring from an empty ring.\n\n The ring is not added in RTE_TAILQ_RING global list. Indeed, the\n memory given by the caller may not be shareable among dpdk\n processes.\n\n @param r\n   The pointer to the ring structure followed by the objects table.\n @param name\n   The name of the ring.\n @param count\n   The number of elements in the ring (must be a power of 2,\n   unless RING_F_EXACT_SZ is set in flags).\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the\n     requested number of entries, and the requested size will be rounded up\n     to the next power of two, but the usable space will be exactly that\n     requested. Worst case, if a power-of-2 size is requested, half the\n     ring space will be wasted.\n     Without this flag set, the ring size requested must be a power of 2,\n     and the usable space will be that size - 1.\n @return\n   0 on success, or a negative value on error."]
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " De-allocate all memory used by the ring.\n\n @param r\n   Ring to free.\n   If NULL then, the function does nothing."]
    pub fn rte_ring_free(r: *mut rte_ring);
}
unsafe extern "C" {
    #[doc = " Create a new ring named *name* in memory.\n\n This function uses ``memzone_reserve()`` to allocate memory. Then it\n calls rte_ring_init() to initialize an empty ring.\n\n The new ring size is set to *count*, which must be a power of two.\n The real usable ring size is *count-1* instead of *count* to\n differentiate a full ring from an empty ring.\n\n The ring is added in RTE_TAILQ_RING list.\n\n @param name\n   The name of the ring.\n @param count\n   The size of the ring (must be a power of 2,\n   unless RING_F_EXACT_SZ is set in flags).\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   An OR of the following:\n   - One of mutually exclusive flags that define producer behavior:\n      - RING_F_SP_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"single-producer\".\n      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer RTS mode\".\n      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when\n        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``\n        is \"multi-producer HTS mode\".\n     If none of these flags is set, then default \"multi-producer\"\n     behavior is selected.\n   - One of mutually exclusive flags that define consumer behavior:\n      - RING_F_SC_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"single-consumer\". Otherwise, it is \"multi-consumers\".\n      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer RTS mode\".\n      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when\n        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``\n        is \"multi-consumer HTS mode\".\n     If none of these flags is set, then default \"multi-consumer\"\n     behavior is selected.\n   - RING_F_EXACT_SZ: If this flag is set, the ring will hold exactly the\n     requested number of entries, and the requested size will be rounded up\n     to the next power of two, but the usable space will be exactly that\n     requested. Worst case, if a power-of-2 size is requested, half the\n     ring space will be wasted.\n     Without this flag set, the ring size requested must be a power of 2,\n     and the usable space will be that size - 1.\n @return\n   On success, the pointer to the new allocated ring. NULL on error with\n    rte_errno set appropriately. Possible errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - count provided is not a power of 2\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
unsafe extern "C" {
    #[doc = " Dump the status of the ring to a file.\n\n @param f\n   A pointer to a file for output\n @param r\n   A pointer to the ring structure."]
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Dump the status of a headtail to a file.\n\n @param f\n   A pointer to a file for output\n @param prefix\n   A string to prefix each output line with\n @param r\n   A pointer to a ring headtail structure."]
    pub fn rte_ring_headtail_dump(
        f: *mut FILE,
        prefix: *const ::std::os::raw::c_char,
        r: *const rte_ring_headtail,
    );
}
unsafe extern "C" {
    #[doc = " Flush a ring.\n\n This function flush all the elements in a ring\n\n @warning\n Make sure the ring is not in use while calling this function.\n\n @param r\n   A pointer to the ring structure."]
    pub fn rte_ring_reset(r: *mut rte_ring);
}
unsafe extern "C" {
    #[doc = " Dump the status of all rings on the console\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_ring_list_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Search a ring from its name\n\n @param name\n   The name of the ring.\n @return\n   The pointer to the ring matching the name, or NULL if not found,\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - ENOENT - required entry not available to return."]
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
#[doc = " 64 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64u8_t = [u8; 8usize];
#[doc = " 64 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v64u16_t){ a0, a1, a2, a3 }"]
pub type rte_v64u16_t = [u16; 4usize];
#[doc = " 64 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v64u32_t){ a0, a1 }"]
pub type rte_v64u32_t = [u32; 2usize];
#[doc = " 128 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128u8_t = [u8; 16usize];
#[doc = " 128 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128u16_t = [u16; 8usize];
#[doc = " 128 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v128u32_t){ a0, a1, a2, a3 }"]
pub type rte_v128u32_t = [u32; 4usize];
#[doc = " 128 bits vector size to use with unsigned 64 bits elements.\n\n a = (rte_v128u64_t){ a0, a1 }"]
pub type rte_v128u64_t = [u64; 2usize];
#[doc = " 256 bits vector size to use with unsigned 8 bits elements.\n\n a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15,\n                     a16, a17, a18, a19, a20, a21, a22, a23,\n                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256u8_t = [u8; 32usize];
#[doc = " 256 bits vector size to use with unsigned 16 bits elements.\n\n a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256u16_t = [u16; 16usize];
#[doc = " 256 bits vector size to use with unsigned 32 bits elements.\n\n a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256u32_t = [u32; 8usize];
#[doc = " 256 bits vector size to use with unsigned 64 bits elements.\n\n a = (rte_v256u64_t){ a0, a1, a2, a3 }"]
pub type rte_v256u64_t = [u64; 4usize];
#[doc = " 64 bits vector size to use with 8 bits elements.\n\n a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64s8_t = [i8; 8usize];
#[doc = " 64 bits vector size to use with 16 bits elements.\n\n a = (rte_v64s16_t){ a0, a1, a2, a3 }"]
pub type rte_v64s16_t = [i16; 4usize];
#[doc = " 64 bits vector size to use with 32 bits elements.\n\n a = (rte_v64s32_t){ a0, a1 }"]
pub type rte_v64s32_t = [i32; 2usize];
#[doc = " 128 bits vector size to use with 8 bits elements.\n\n a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128s8_t = [i8; 16usize];
#[doc = " 128 bits vector size to use with 16 bits elements.\n\n a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128s16_t = [i16; 8usize];
#[doc = " 128 bits vector size to use with 32 bits elements.\n\n a = (rte_v128s32_t){ a0, a1, a2, a3 }"]
pub type rte_v128s32_t = [i32; 4usize];
#[doc = " 128 bits vector size to use with 64 bits elements.\n\n a = (rte_v128s64_t){ a1, a2 }"]
pub type rte_v128s64_t = [i64; 2usize];
#[doc = " 256 bits vector size to use with 8 bits elements.\n\n a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                     a08, a09, a10, a11, a12, a13, a14, a15,\n                     a16, a17, a18, a19, a20, a21, a22, a23,\n                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256s8_t = [i8; 32usize];
#[doc = " 256 bits vector size to use with 16 bits elements.\n\n a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,\n                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256s16_t = [i16; 16usize];
#[doc = " 256 bits vector size to use with 32 bits elements.\n\n a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256s32_t = [i32; 8usize];
#[doc = " 256 bits vector size to use with 64 bits elements.\n\n a = (rte_v256s64_t){ a0, a1, a2, a3 }"]
pub type rte_v256s64_t = [i64; 4usize];
pub const rte_vect_max_simd_RTE_VECT_SIMD_DISABLED: rte_vect_max_simd = 64;
pub const rte_vect_max_simd_RTE_VECT_SIMD_128: rte_vect_max_simd = 128;
#[doc = "< Limits path selection to AVX2 or below."]
pub const rte_vect_max_simd_RTE_VECT_SIMD_256: rte_vect_max_simd = 256;
#[doc = "< Limits path selection to AVX512 or below."]
pub const rte_vect_max_simd_RTE_VECT_SIMD_512: rte_vect_max_simd = 512;
pub const rte_vect_max_simd_RTE_VECT_SIMD_MAX: rte_vect_max_simd = 32768;
#[doc = " The max SIMD bitwidth value to limit vector path selection."]
pub type rte_vect_max_simd = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the supported SIMD bitwidth.\n\n @return\n   uint16_t bitwidth."]
    pub fn rte_vect_get_max_simd_bitwidth() -> u16;
}
unsafe extern "C" {
    #[doc = " Set the supported SIMD bitwidth.\n This API should only be called once at initialization, before EAL init.\n\n @param bitwidth\n   uint16_t bitwidth.\n @return\n   - 0 on success.\n   - -EINVAL on invalid bitwidth parameter.\n   - -EPERM if bitwidth is forced."]
    pub fn rte_vect_set_max_simd_bitwidth(bitwidth: u16) -> ::std::os::raw::c_int;
}
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
pub type rte_xmm_t = rte_xmm;
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_contig_blocks: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_ops_enqueue_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_generic_put: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_put_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_generic_get: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_get_bulk: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_get_contig_blocks: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_default_cache: rte_trace_point_t;
}
unsafe extern "C" {
    pub static mut __rte_mempool_trace_cache_flush: rte_trace_point_t;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
unsafe extern "C" {
    #[doc = " @internal Logtype used for mempool related messages."]
    pub static mut rte_mempool_logtype: ::std::os::raw::c_int;
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " Additional information about the mempool\n\n The structure is cache-line aligned to avoid ABI breakages in\n a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
#[doc = " Prototype for implementation specific data provisioning function.\n\n The function should provide the implementation specific memory for\n use by the other mempool ops functions in a given mempool ops struct.\n E.g. the default ops provides an instance of the rte_ring for this purpose.\n it will most likely point to a different type of data structure, and\n will be transparent to the application programmer.\n This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue 'n' objects into the external pool.\n @return\n   - 0: Success\n   - <0: Error"]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue 'n' objects from the external pool.\n @return\n   - 0: Success\n   - <0: Error"]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects.\n\n If mempool objects are not required to be IOVA-contiguous\n (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines\n virtually contiguous chunk size. Otherwise, if mempool objects must\n be IOVA-contiguous (the flag RTE_MEMPOOL_F_NO_IOVA_CONTIG is clear),\n min_chunk_size defines IOVA-contiguous chunk size.\n\n @param[in] mp\n   Pointer to the memory pool.\n @param[in] obj_num\n   Number of objects.\n @param[in] pg_shift\n   LOG2 of the physical pages size. If set to 0, ignore page boundaries.\n @param[out] min_chunk_size\n   Location for minimum size of the memory chunk which may be used to\n   store memory pool objects.\n @param[out] align\n   Location for required memory chunk alignment.\n @return\n   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
#[doc = " Function to be called for each populated object.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] opaque\n   An opaque pointer passed to iterator.\n @param[in] vaddr\n   Object virtual address.\n @param[in] iova\n   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk.\n\n Populated objects should be enqueued to the pool, e.g. using\n rte_mempool_ops_enqueue_bulk().\n\n If the given IO address is unknown (iova = RTE_BAD_IOVA),\n the chunk doesn't need to be physically contiguous (only virtually),\n and allocated objects may span two pages.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] max_objs\n   Maximum number of objects to be populated.\n @param[in] vaddr\n   The virtual address of memory that should be used to store objects.\n @param[in] iova\n   The IO address\n @param[in] len\n   The length of memory in bytes.\n @param[in] obj_cb\n   Callback function to be executed for each populated object.\n @param[in] obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   The number of objects added on success.\n   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to\n store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using\n provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[doc = " Structure storing the table of registered ops structs, each of which contain\n the function pointers for the mempool ops functions.\n Each process has its own storage for this ops struct array so that\n the mempools can be shared across primary and secondary processes.\n The indices used to access the array are valid across processes, whereas\n any function pointers stored directly in the mempool struct would not be.\n This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
unsafe extern "C" {
    #[doc = " Array of registered ops structs."]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
#[doc = " An object callback function for mempool.\n\n Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool.\n\n Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function.\n\n Arguments are the mempool and the opaque pointer given by the user in\n rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A structure used to retrieve information about the memory range\n of the mempool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_mem_range_info {
    #[doc = " Start of the memory range used by mempool objects"]
    pub start: *mut ::std::os::raw::c_void,
    #[doc = " Length of the memory range used by mempool objects"]
    pub length: usize,
    #[doc = " Are all memory addresses used by mempool objects contiguous"]
    pub is_contiguous: bool,
}
#[doc = " Occurs after a mempool is fully populated."]
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_READY: rte_mempool_event = 0;
#[doc = " Occurs before the destruction of a mempool begins."]
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_DESTROY: rte_mempool_event = 1;
#[doc = " Mempool event type.\n @internal"]
pub type rte_mempool_event = ::std::os::raw::c_uint;
#[doc = " @internal\n Mempool event callback.\n\n rte_mempool_event_callback_register() may be called from within the callback,\n but the callbacks registered this way will not be invoked for the same event.\n rte_mempool_event_callback_unregister() may only be safely called\n to remove the running callback."]
pub type rte_mempool_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        event: rte_mempool_event,
        mp: *mut rte_mempool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Get the name of the l2 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the l3 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the l4 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the tunnel packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l2 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l3 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the inner_l4 packet type\n\n @param ptype\n   The packet type value.\n @return\n   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Write the packet type name into the buffer\n\n @param ptype\n   The packet type value.\n @param buf\n   The buffer where the string is written.\n @param buflen\n   The length of the buffer.\n @return\n   - 0 on success\n   - (-1) if the buffer is too small"]
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_4 = 7;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_4 = 9;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_4 = 8;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_4 = 16;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_4 = 9;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_4 = 7;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_4 = 8;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_4 = 0;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_4 = 7;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_4 = 16;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_4 = 24;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_4 = 40;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_4 = 49;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_4 = 56;
#[doc = " enum for the tx_offload bit-fields lengths and offsets.\n defines the layout of rte_mbuf tx_offload field."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n layout for the first cache line for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
unsafe extern "C" {
    #[doc = " Get the name of a RX offload flag\n\n @param mask\n   The mask describing the flag.\n @return\n   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer\n\n @param mask\n   The mask describing the RX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the name of a TX offload flag\n\n @param mask\n   The mask describing the flag. Usually only one bit must be set.\n   Several bits can be given if they belong to the same mask.\n   Ex: RTE_MBUF_F_TX_L4_MASK.\n @return\n   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer\n\n @param mask\n   The mask describing the TX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Private data in case of pktmbuf pool.\n\n A structure that contains some pktmbuf_pool-specific data that are\n appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
#[doc = " A structure that describes the pinned external buffer segment."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pktmbuf_extmem {
    #[doc = "< The virtual address of data buffer."]
    pub buf_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The IO address of the data buffer."]
    pub buf_iova: rte_iova_t,
    #[doc = "< External buffer length in bytes."]
    pub buf_len: usize,
    #[doc = "< mbuf element size in bytes."]
    pub elt_size: u16,
}
#[doc = " Ethernet address:\n A universally administered address is uniquely assigned to a device by its\n manufacturer. The first three octets (in transmission order) contain the\n Organizationally Unique Identifier (OUI). The following three (MAC-48 and\n EUI-48) octets are assigned by that organization with the only constraint\n of uniqueness.\n A locally administered address is assigned to a device by a network\n administrator and does not contain OUIs.\n See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
unsafe extern "C" {
    #[doc = " Generate a random Ethernet address that is locally administered\n and not multicast.\n @param addr\n   A pointer to Ethernet address."]
    pub fn rte_eth_random_addr(addr: *mut u8);
}
unsafe extern "C" {
    #[doc = " Format 48bits Ethernet address in pattern xx:xx:xx:xx:xx:xx.\n\n @param buf\n   A pointer to buffer contains the formatted MAC address.\n @param size\n   The format buffer size.\n @param eth_addr\n   A pointer to a ether_addr structure."]
    pub fn rte_ether_format_addr(
        buf: *mut ::std::os::raw::c_char,
        size: u16,
        eth_addr: *const rte_ether_addr,
    );
}
unsafe extern "C" {
    #[doc = " Convert string with Ethernet address to an ether_addr.\n\n @param str\n   A pointer to buffer contains the formatted MAC address.\n   Accepts either byte or word format separated by colon,\n   hyphen or period.\n\n   The example formats are:\n     XX:XX:XX:XX:XX:XX - Canonical form\n     XX-XX-XX-XX-XX-XX - Windows and IEEE 802\n     XXXX.XXXX.XXXX    - Cisco\n   where XX is a hex digit: 0-9, a-f, or A-F.\n   In the byte format, leading zeros are optional.\n @param eth_addr\n   A pointer to a ether_addr structure.\n @return\n   0 if successful\n   -1 and sets rte_errno if invalid string"]
    pub fn rte_ether_unformat_addr(
        str_: *const ::std::os::raw::c_char,
        eth_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Ethernet header: Contains the destination address, source address\n and frame type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ether_hdr {
    #[doc = "< Destination address."]
    pub dst_addr: rte_ether_addr,
    #[doc = "< Source address."]
    pub src_addr: rte_ether_addr,
    #[doc = "< Frame type."]
    pub ether_type: rte_be16_t,
}
#[doc = " Ethernet VLAN Header.\n Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type\n of the encapsulated frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_hdr {
    #[doc = "< Priority (3) + CFI (1) + Identifier Code (12)"]
    pub vlan_tci: rte_be16_t,
    #[doc = "< Ethernet type of encapsulated frame."]
    pub eth_proto: rte_be16_t,
}
#[doc = " ARP header IPv4 payload."]
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_arp_ipv4 {
    #[doc = "< sender hardware address"]
    pub arp_sha: rte_ether_addr,
    #[doc = "< sender IP address"]
    pub arp_sip: rte_be32_t,
    #[doc = "< target hardware address"]
    pub arp_tha: rte_ether_addr,
    #[doc = "< target IP address"]
    pub arp_tip: rte_be32_t,
}
#[doc = " ARP header."]
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_arp_hdr {
    #[doc = "< format of hardware address"]
    pub arp_hardware: rte_be16_t,
    #[doc = "< format of protocol address"]
    pub arp_protocol: rte_be16_t,
    #[doc = "< length of hardware address"]
    pub arp_hlen: u8,
    #[doc = "< length of protocol address"]
    pub arp_plen: u8,
    #[doc = "< ARP opcode (command)"]
    pub arp_opcode: rte_be16_t,
    pub arp_data: rte_arp_ipv4,
}
unsafe extern "C" {
    #[doc = " Make a RARP packet based on MAC addr.\n\n @param mpool\n   Pointer to the rte_mempool\n @param mac\n   Pointer to the MAC addr\n\n @return\n   - RARP packet pointer on success, or NULL on error"]
    pub fn rte_net_make_rarp_packet(
        mpool: *mut rte_mempool,
        mac: *const rte_ether_addr,
    ) -> *mut rte_mbuf;
}
#[doc = " ICMP base header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_icmp_base_hdr {
    pub type_: u8,
    pub code: u8,
    pub checksum: rte_be16_t,
}
#[doc = " ICMP echo header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_icmp_echo_hdr {
    pub base: rte_icmp_base_hdr,
    pub identifier: rte_be16_t,
    pub sequence: rte_be16_t,
}
#[doc = " ICMP Header\n\n @see rte_icmp_echo_hdr which is similar."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: rte_be16_t,
    pub icmp_ident: rte_be16_t,
    pub icmp_seq_nb: rte_be16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
pub const MSG_OOB: _bindgen_ty_5 = 1;
pub const MSG_PEEK: _bindgen_ty_5 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_5 = 4;
pub const MSG_CTRUNC: _bindgen_ty_5 = 8;
pub const MSG_PROXY: _bindgen_ty_5 = 16;
pub const MSG_TRUNC: _bindgen_ty_5 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_5 = 64;
pub const MSG_EOR: _bindgen_ty_5 = 128;
pub const MSG_WAITALL: _bindgen_ty_5 = 256;
pub const MSG_FIN: _bindgen_ty_5 = 512;
pub const MSG_SYN: _bindgen_ty_5 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_5 = 2048;
pub const MSG_RST: _bindgen_ty_5 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_5 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_5 = 16384;
pub const MSG_MORE: _bindgen_ty_5 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_5 = 65536;
pub const MSG_BATCH: _bindgen_ty_5 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_5 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_5 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_5 = 1073741824;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
unsafe extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
pub const SHUT_RD: _bindgen_ty_7 = 0;
pub const SHUT_WR: _bindgen_ty_7 = 1;
pub const SHUT_RDWR: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
pub const IPPROTO_IP: _bindgen_ty_8 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_8 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_8 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_8 = 4;
pub const IPPROTO_TCP: _bindgen_ty_8 = 6;
pub const IPPROTO_EGP: _bindgen_ty_8 = 8;
pub const IPPROTO_PUP: _bindgen_ty_8 = 12;
pub const IPPROTO_UDP: _bindgen_ty_8 = 17;
pub const IPPROTO_IDP: _bindgen_ty_8 = 22;
pub const IPPROTO_TP: _bindgen_ty_8 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_8 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_8 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_8 = 46;
pub const IPPROTO_GRE: _bindgen_ty_8 = 47;
pub const IPPROTO_ESP: _bindgen_ty_8 = 50;
pub const IPPROTO_AH: _bindgen_ty_8 = 51;
pub const IPPROTO_MTP: _bindgen_ty_8 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_8 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_8 = 98;
pub const IPPROTO_PIM: _bindgen_ty_8 = 103;
pub const IPPROTO_COMP: _bindgen_ty_8 = 108;
pub const IPPROTO_L2TP: _bindgen_ty_8 = 115;
pub const IPPROTO_SCTP: _bindgen_ty_8 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_8 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_8 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_8 = 143;
pub const IPPROTO_RAW: _bindgen_ty_8 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_8 = 262;
pub const IPPROTO_MAX: _bindgen_ty_8 = 263;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_9 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_9 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_9 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_9 = 58;
pub const IPPROTO_NONE: _bindgen_ty_9 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_9 = 60;
pub const IPPROTO_MH: _bindgen_ty_9 = 135;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_10 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_10 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_10 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_10 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_10 = 15;
pub const IPPORT_FTP: _bindgen_ty_10 = 21;
pub const IPPORT_TELNET: _bindgen_ty_10 = 23;
pub const IPPORT_SMTP: _bindgen_ty_10 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_10 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_10 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_10 = 43;
pub const IPPORT_MTP: _bindgen_ty_10 = 57;
pub const IPPORT_TFTP: _bindgen_ty_10 = 69;
pub const IPPORT_RJE: _bindgen_ty_10 = 77;
pub const IPPORT_FINGER: _bindgen_ty_10 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_10 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_10 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_10 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_10 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_10 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_10 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_10 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_10 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_10 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_10 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_10 = 5000;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
unsafe extern "C" {
    pub static in6addr_any: in6_addr;
}
unsafe extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
unsafe extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
unsafe extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __len: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_aton(
        __cp: *const ::std::os::raw::c_char,
        __inp: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_net_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __bits: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_net_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_uchar,
        __len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_uchar,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timestamp {
    pub len: u8,
    pub ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
impl timestamp {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flags_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flags_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overflow(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_overflow(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overflow_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overflow_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        overflow: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let overflow: u32 = unsafe { ::std::mem::transmute(overflow) };
            overflow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: u8,
    pub tot_len: u16,
    pub id: u16,
    pub frag_off: u16,
    pub ttl: u8,
    pub protocol: u8,
    pub check: u16,
    pub saddr: u32,
    pub daddr: u32,
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ihl_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ihl_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ihl: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u32 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ip_tos: u8,
    pub ip_len: ::std::os::raw::c_ushort,
    pub ip_id: ::std::os::raw::c_ushort,
    pub ip_off: ::std::os::raw::c_ushort,
    pub ip_ttl: u8,
    pub ip_p: u8,
    pub ip_sum: ::std::os::raw::c_ushort,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_hl_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ip_hl_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_v(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_v_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ip_v_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_hl: ::std::os::raw::c_uint,
        ip_v: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u32 = unsafe { ::std::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u32 = unsafe { ::std::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_timestamp {
    pub ipt_code: u8,
    pub ipt_len: u8,
    pub ipt_ptr: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: [u32; 9usize],
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipt_flg_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ipt_flg_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipt_oflw_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ipt_oflw_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipt_flg: ::std::os::raw::c_uint,
        ipt_oflw: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ipt_flg: u32 = unsafe { ::std::mem::transmute(ipt_flg) };
            ipt_flg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ipt_oflw: u32 = unsafe { ::std::mem::transmute(ipt_oflw) };
            ipt_oflw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr {
    pub ip6_ctlun: ip6_hdr__bindgen_ty_1,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip6_hdr__bindgen_ty_1 {
    pub ip6_un1: ip6_hdr__bindgen_ty_1_ip6_hdrctl,
    pub ip6_un2_vfc: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr__bindgen_ty_1_ip6_hdrctl {
    pub ip6_un1_flow: u32,
    pub ip6_un1_plen: u16,
    pub ip6_un1_nxt: u8,
    pub ip6_un1_hlim: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_ext {
    pub ip6e_nxt: u8,
    pub ip6e_len: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hbh {
    pub ip6h_nxt: u8,
    pub ip6h_len: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_dest {
    pub ip6d_nxt: u8,
    pub ip6d_len: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_rthdr {
    pub ip6r_nxt: u8,
    pub ip6r_len: u8,
    pub ip6r_type: u8,
    pub ip6r_segleft: u8,
}
#[repr(C)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: u8,
    pub ip6r0_len: u8,
    pub ip6r0_type: u8,
    pub ip6r0_segleft: u8,
    pub ip6r0_reserved: u8,
    pub ip6r0_slmap: [u8; 3usize],
    pub ip6r0_addr: __IncompleteArrayField<in6_addr>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_frag {
    pub ip6f_nxt: u8,
    pub ip6f_reserved: u8,
    pub ip6f_offlg: u16,
    pub ip6f_ident: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_opt {
    pub ip6o_type: u8,
    pub ip6o_len: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_opt_jumbo {
    pub ip6oj_type: u8,
    pub ip6oj_len: u8,
    pub ip6oj_jumbo_len: [u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_opt_nsap {
    pub ip6on_type: u8,
    pub ip6on_len: u8,
    pub ip6on_src_nsap_len: u8,
    pub ip6on_dst_nsap_len: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_opt_tunnel {
    pub ip6ot_type: u8,
    pub ip6ot_len: u8,
    pub ip6ot_encap_limit: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_opt_router {
    pub ip6or_type: u8,
    pub ip6or_len: u8,
    pub ip6or_value: [u8; 2usize],
}
#[doc = " IPv4 Header"]
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ipv4_hdr {
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1,
    #[doc = "< type of service"]
    pub type_of_service: u8,
    #[doc = "< length of packet"]
    pub total_length: rte_be16_t,
    #[doc = "< packet ID"]
    pub packet_id: rte_be16_t,
    #[doc = "< fragmentation offset"]
    pub fragment_offset: rte_be16_t,
    #[doc = "< time to live"]
    pub time_to_live: u8,
    #[doc = "< protocol ID"]
    pub next_proto_id: u8,
    #[doc = "< header checksum"]
    pub hdr_checksum: rte_be16_t,
    #[doc = "< source address"]
    pub src_addr: rte_be32_t,
    #[doc = "< destination address"]
    pub dst_addr: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ipv4_hdr__bindgen_ty_1 {
    #[doc = "< version and header length"]
    pub version_ihl: u8,
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ihl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ihl_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ihl_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: u8, version: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " IPv6 Address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ipv6_addr {
    pub a: [u8; 16usize],
}
#[doc = " Invalid multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_NONE: rte_ipv6_mc_scope = 0;
#[doc = " Interface-local multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_IFACELOCAL: rte_ipv6_mc_scope = 1;
#[doc = " Link-local multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_LINKLOCAL: rte_ipv6_mc_scope = 2;
#[doc = " Site-local multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_SITELOCAL: rte_ipv6_mc_scope = 5;
#[doc = " Organizational-local multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_ORGLOCAL: rte_ipv6_mc_scope = 8;
#[doc = " Global multicast scope."]
pub const rte_ipv6_mc_scope_RTE_IPV6_MC_SCOPE_GLOBAL: rte_ipv6_mc_scope = 14;
#[doc = " IPv6 multicast scope values as defined in RFC 4291, section 2.7."]
pub type rte_ipv6_mc_scope = ::std::os::raw::c_uint;
#[doc = " IPv6 Header"]
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ipv6_hdr {
    pub __bindgen_anon_1: rte_ipv6_hdr__bindgen_ty_1,
    #[doc = "< IP payload size, including ext. headers"]
    pub payload_len: rte_be16_t,
    #[doc = "< Protocol, next header."]
    pub proto: u8,
    #[doc = "< Hop limits."]
    pub hop_limits: u8,
    #[doc = "< IP address of source host."]
    pub src_addr: rte_ipv6_addr,
    #[doc = "< IP address of destination host(s)."]
    pub dst_addr: rte_ipv6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ipv6_hdr__bindgen_ty_1 {
    #[doc = "< IP version, traffic class & flow label."]
    pub vtc_flow: rte_be32_t,
    pub __bindgen_anon_1: rte_ipv6_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ipv6_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_ipv6_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn flow_label(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_flow_label(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_label_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_label_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ecn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ecn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ecn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ecn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ds_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ds_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flow_label: u32,
        ecn: u32,
        ds: u32,
        version: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let flow_label: u32 = unsafe { ::std::mem::transmute(flow_label) };
            flow_label as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let ecn: u32 = unsafe { ::std::mem::transmute(ecn) };
            ecn as u64
        });
        __bindgen_bitfield_unit.set(22usize, 6u8, {
            let ds: u32 = unsafe { ::std::mem::transmute(ds) };
            ds as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " IPv6 Routing Extension Header"]
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ipv6_routing_ext {
    #[doc = "< Protocol, next header."]
    pub next_hdr: u8,
    #[doc = "< Header length."]
    pub hdr_len: u8,
    #[doc = "< Extension header type."]
    pub type_: u8,
    #[doc = "< Valid segments number."]
    pub segments_left: u8,
    pub __bindgen_anon_1: rte_ipv6_routing_ext__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ipv6_routing_ext__bindgen_ty_1 {
    #[doc = "< Packet control data per type."]
    pub flags: rte_be32_t,
    pub __bindgen_anon_1: rte_ipv6_routing_ext__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ipv6_routing_ext__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The last_entry field of SRH"]
    pub last_entry: u8,
    #[doc = "< Packet flag."]
    pub flag: u8,
    #[doc = "< Packet tag."]
    pub tag: rte_be16_t,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ipv6_fragment_ext {
    #[doc = "< Next header type"]
    pub next_header: u8,
    #[doc = "< Reserved"]
    pub reserved: u8,
    #[doc = "< All fragmentation data"]
    pub frag_data: rte_be16_t,
    #[doc = "< Packet ID"]
    pub id: rte_be32_t,
}
#[doc = " SCTP Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_sctp_hdr {
    #[doc = "< Source port."]
    pub src_port: rte_be16_t,
    #[doc = "< Destin port."]
    pub dst_port: rte_be16_t,
    #[doc = "< Validation tag."]
    pub tag: rte_be32_t,
    #[doc = "< Checksum."]
    pub cksum: rte_be32_t,
}
#[doc = " TCP Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_tcp_hdr {
    #[doc = "< TCP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< TCP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< TX data sequence number."]
    pub sent_seq: rte_be32_t,
    #[doc = "< RX data acknowledgment sequence number."]
    pub recv_ack: rte_be32_t,
    #[doc = "< Data offset."]
    pub data_off: u8,
    #[doc = "< TCP flags"]
    pub tcp_flags: u8,
    #[doc = "< RX flow control window."]
    pub rx_win: rte_be16_t,
    #[doc = "< TCP checksum."]
    pub cksum: rte_be16_t,
    #[doc = "< TCP urgent pointer, if any."]
    pub tcp_urp: rte_be16_t,
}
#[doc = " UDP Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_udp_hdr {
    #[doc = "< UDP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< UDP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< UDP datagram length"]
    pub dgram_len: rte_be16_t,
    #[doc = "< UDP datagram checksum"]
    pub dgram_cksum: rte_be16_t,
}
#[doc = " VXLAN protocol header.\n Contains the 8-bit flag, 24-bit VXLAN Network Identifier and\n Reserved fields (24 bits and 8 bits)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr {
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_1,
    pub __bindgen_anon_2: rte_vxlan_hdr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_1 {
    #[doc = "< flags (8 bits) + extensions (24 bits)."]
    pub vx_flags: rte_be32_t,
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Default is I bit, others are extensions."]
    pub flags: u8,
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn flag_o(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_o(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_o_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_o_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_b(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_b(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_b_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_b_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_p(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_p(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_p_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_p_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_i(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_i(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_i_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_i_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_ver(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_flag_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_ver_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_ver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_rsvd_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_rsvd_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_g(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_g_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_g_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flag_o: u8,
        flag_b: u8,
        flag_p: u8,
        flag_i: u8,
        flag_ver: u8,
        flag_rsvd: u8,
        flag_g: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flag_o: u8 = unsafe { ::std::mem::transmute(flag_o) };
            flag_o as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flag_b: u8 = unsafe { ::std::mem::transmute(flag_b) };
            flag_b as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let flag_p: u8 = unsafe { ::std::mem::transmute(flag_p) };
            flag_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flag_i: u8 = unsafe { ::std::mem::transmute(flag_i) };
            flag_i as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let flag_ver: u8 = unsafe { ::std::mem::transmute(flag_ver) };
            flag_ver as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let flag_rsvd: u8 = unsafe { ::std::mem::transmute(flag_rsvd) };
            flag_rsvd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let flag_g: u8 = unsafe { ::std::mem::transmute(flag_g) };
            flag_g as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub rsvd0: [u8; 3usize],
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1:
        rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { # [doc = "< GBP Identifier."] pub policy_id : u16 , pub __bindgen_anon_1 : rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub rsvd0_gpe: u8,
    #[doc = "< GPE Next protocol."]
    pub proto: u8,
}
impl rte_vxlan_hdr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rsvd0_gbp3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0_gbp3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_gbp3_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_gbp3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_a(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_a(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_a_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_a_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd0_gbp2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0_gbp2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_gbp2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_gbp2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag_d(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flag_d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag_d_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag_d_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd0_gbp1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0_gbp1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_gbp1_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_gbp1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsvd0_gbp3: u8,
        flag_a: u8,
        rsvd0_gbp2: u8,
        flag_d: u8,
        rsvd0_gbp1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rsvd0_gbp3: u8 = unsafe { ::std::mem::transmute(rsvd0_gbp3) };
            rsvd0_gbp3 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flag_a: u8 = unsafe { ::std::mem::transmute(flag_a) };
            flag_a as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rsvd0_gbp2: u8 = unsafe { ::std::mem::transmute(rsvd0_gbp2) };
            rsvd0_gbp2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let flag_d: u8 = unsafe { ::std::mem::transmute(flag_d) };
            flag_d as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rsvd0_gbp1: u8 = unsafe { ::std::mem::transmute(rsvd0_gbp1) };
            rsvd0_gbp1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_2 {
    #[doc = "< VNI (24 bits) + reserved (8 bits)."]
    pub vx_vni: rte_be32_t,
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_hdr__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< VXLAN Identifier."]
    pub vni: [u8; 3usize],
    pub __bindgen_anon_1: rte_vxlan_hdr__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_hdr__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Reserved."]
    pub rsvd1: u8,
    #[doc = "< Reserved."]
    pub last_rsvd: u8,
}
#[doc = " @deprecated\n @see rte_vxlan_hdr\n\n VXLAN-GPE protocol header (draft-ietf-nvo3-vxlan-gpe-05).\n Contains the 8-bit flag, 8-bit next-protocol, 24-bit VXLAN Network\n Identifier and Reserved fields (16 bits and 8 bits)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_gpe_hdr {
    pub __bindgen_anon_1: rte_vxlan_gpe_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_vxlan_gpe_hdr__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_vxlan_gpe_hdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: rte_vxlan_gpe_hdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_gpe_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< flag (8)."]
    pub vx_flags: u8,
    #[doc = "< Reserved (16)."]
    pub reserved: [u8; 2usize],
    #[doc = "< next-protocol (8)."]
    pub protocol: u8,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vxlan_gpe_hdr__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Flags."]
    pub flags: u8,
    #[doc = "< Reserved."]
    pub rsvd0: [u8; 2usize],
    #[doc = "< Next protocol."]
    pub proto: u8,
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved."]
    pub rsvd1: u8,
}
#[doc = " ESP Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_esp_hdr {
    #[doc = "< Security Parameters Index"]
    pub spi: rte_be32_t,
    #[doc = "< packet sequence number"]
    pub seq: rte_be32_t,
}
#[doc = " ESP Trailer"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_esp_tail {
    #[doc = "< number of pad bytes (0-255)"]
    pub pad_len: u8,
    #[doc = "< IPv4 or IPv6 or next layer header"]
    pub next_proto: u8,
}
#[doc = " higig2 frc header."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_higig2_frc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_higig2_frc {
    #[inline]
    pub fn ksop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ksop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ksop_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ksop_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mcst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mcst_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mcst_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_modid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_modid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_pid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_pid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_modid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_src_modid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_pid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_src_pid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lbid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lbid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lbid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ppd_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppd_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ppd_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ppd_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resv1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ksop: u32,
        tc: u32,
        mcst: u32,
        resv: u32,
        dst_modid: u32,
        dst_pid: u32,
        src_modid: u32,
        src_pid: u32,
        lbid: u32,
        ppd_type: u32,
        resv1: u32,
        dp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ksop: u32 = unsafe { ::std::mem::transmute(ksop) };
            ksop as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let tc: u32 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mcst: u32 = unsafe { ::std::mem::transmute(mcst) };
            mcst as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let resv: u32 = unsafe { ::std::mem::transmute(resv) };
            resv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dst_modid: u32 = unsafe { ::std::mem::transmute(dst_modid) };
            dst_modid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dst_pid: u32 = unsafe { ::std::mem::transmute(dst_pid) };
            dst_pid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let src_modid: u32 = unsafe { ::std::mem::transmute(src_modid) };
            src_modid as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let src_pid: u32 = unsafe { ::std::mem::transmute(src_pid) };
            src_pid as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let lbid: u32 = unsafe { ::std::mem::transmute(lbid) };
            lbid as u64
        });
        __bindgen_bitfield_unit.set(56usize, 3u8, {
            let ppd_type: u32 = unsafe { ::std::mem::transmute(ppd_type) };
            ppd_type as u64
        });
        __bindgen_bitfield_unit.set(59usize, 3u8, {
            let resv1: u32 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 2u8, {
            let dp: u32 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type0 header"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_higig2_ppt_type0 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_higig2_ppt_type0 {
    #[inline]
    pub fn mirror(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_done(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_done_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_done_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_only_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_only_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress_tagged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress_tagged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_tagged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_tagged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_tgid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dst_tgid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_tgid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_tgid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dst_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_t_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_t_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn label_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_label_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn label_present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_label_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vid_high(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vid_high_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vid_high_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vid_low(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vid_low_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vid_low_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn opc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_opc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn srce_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srce_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn srce_t_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_srce_t_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hdr_ext_length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hdr_ext_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hdr_ext_length_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hdr_ext_length_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mirror: u32,
        mirror_done: u32,
        mirror_only: u32,
        ingress_tagged: u32,
        dst_tgid: u32,
        dst_t: u32,
        vc_label2: u32,
        label_present: u32,
        l3: u32,
        res: u32,
        vc_label1: u32,
        vc_label0: u32,
        vid_high: u32,
        vid_low: u32,
        opc: u32,
        res1: u32,
        srce_t: u32,
        pf: u32,
        res2: u32,
        hdr_ext_length: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirror: u32 = unsafe { ::std::mem::transmute(mirror) };
            mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mirror_done: u32 = unsafe { ::std::mem::transmute(mirror_done) };
            mirror_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mirror_only: u32 = unsafe { ::std::mem::transmute(mirror_only) };
            mirror_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ingress_tagged: u32 = unsafe { ::std::mem::transmute(ingress_tagged) };
            ingress_tagged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let dst_tgid: u32 = unsafe { ::std::mem::transmute(dst_tgid) };
            dst_tgid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dst_t: u32 = unsafe { ::std::mem::transmute(dst_t) };
            dst_t as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let vc_label2: u32 = unsafe { ::std::mem::transmute(vc_label2) };
            vc_label2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let label_present: u32 = unsafe { ::std::mem::transmute(label_present) };
            label_present as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let l3: u32 = unsafe { ::std::mem::transmute(l3) };
            l3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let vc_label1: u32 = unsafe { ::std::mem::transmute(vc_label1) };
            vc_label1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let vc_label0: u32 = unsafe { ::std::mem::transmute(vc_label0) };
            vc_label0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let vid_high: u32 = unsafe { ::std::mem::transmute(vid_high) };
            vid_high as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vid_low: u32 = unsafe { ::std::mem::transmute(vid_low) };
            vid_low as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(51usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let srce_t: u32 = unsafe { ::std::mem::transmute(srce_t) };
            srce_t as u64
        });
        __bindgen_bitfield_unit.set(54usize, 2u8, {
            let pf: u32 = unsafe { ::std::mem::transmute(pf) };
            pf as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let hdr_ext_length: u32 = unsafe { ::std::mem::transmute(hdr_ext_length) };
            hdr_ext_length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type1 header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_ppt_type1 {
    pub classification: rte_be16_t,
    pub resv: rte_be16_t,
    pub vid: rte_be16_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl rte_higig2_ppt_type1 {
    #[inline]
    pub fn opcode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opcode_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_opcode_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv1_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_resv1_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_src_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_t_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_src_t_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pfm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pfm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pfm_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_pfm_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_resv2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv2_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_resv2_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hdr_ext_len(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_hdr_ext_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hdr_ext_len_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_hdr_ext_len_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opcode: u16,
        resv1: u16,
        src_t: u16,
        pfm: u16,
        resv2: u16,
        hdr_ext_len: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let opcode: u16 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let resv1: u16 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let src_t: u16 = unsafe { ::std::mem::transmute(src_t) };
            src_t as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let pfm: u16 = unsafe { ::std::mem::transmute(pfm) };
            pfm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let resv2: u16 = unsafe { ::std::mem::transmute(resv2) };
            resv2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdr_ext_len: u16 = unsafe { ::std::mem::transmute(hdr_ext_len) };
            hdr_ext_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_hdr {
    pub fcr: rte_higig2_frc,
    pub __bindgen_anon_1: rte_higig2_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_higig2_hdr__bindgen_ty_1 {
    pub ppt0: rte_higig2_ppt_type0,
    pub ppt1: rte_higig2_ppt_type1,
}
#[doc = " eCPRI Common Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_common_hdr {
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_common_hdr__bindgen_ty_1 {
    #[doc = "< 4B common header in BE"]
    pub u32_: rte_be32_t,
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn revision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_revision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn revision_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_revision_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        type_: u32,
        c: u32,
        res: u32,
        revision: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let c: u32 = unsafe { ::std::mem::transmute(c) };
            c as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let revision: u32 = unsafe { ::std::mem::transmute(revision) };
            revision as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " eCPRI Message Header of Type #0: IQ Data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_iq_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #1: Bit Sequence"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_bit_seq {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #2: Real-Time Control Data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_rtc_ctrl {
    #[doc = "< Real-Time Control Data ID"]
    pub rtc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[doc = " eCPRI Message Header of Type #3: Generic Data Transfer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_gen_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be32_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be32_t,
}
#[doc = " eCPRI Message Header of Type #4: Remote Memory Access"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_rm_access {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< 48-bits address"]
    pub addr: [u8; 6usize],
    #[doc = "< number of bytes"]
    pub length: rte_be16_t,
}
impl rte_ecpri_msg_rm_access {
    #[inline]
    pub fn ele_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ele_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ele_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ele_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rw_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rw_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rma_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rma_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rma_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rma_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ele_id: u32,
        rr: u32,
        rw: u32,
        rma_id: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ele_id: u32 = unsafe { ::std::mem::transmute(ele_id) };
            ele_id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rr: u32 = unsafe { ::std::mem::transmute(rr) };
            rr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let rw: u32 = unsafe { ::std::mem::transmute(rw) };
            rw as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let rma_id: u32 = unsafe { ::std::mem::transmute(rma_id) };
            rma_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " eCPRI Message Header of Type #5: One-Way Delay Measurement"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_delay_measure {
    #[doc = "< Measurement ID"]
    pub msr_id: u8,
    #[doc = "< Action Type"]
    pub act_type: u8,
}
#[doc = " eCPRI Message Header of Type #6: Remote Reset"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_remote_reset {
    #[doc = "< Reset ID"]
    pub rst_id: rte_be16_t,
    #[doc = "< Reset Code Op"]
    pub rst_op: u8,
}
#[doc = " eCPRI Message Header of Type #7: Event Indication"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_msg_event_ind {
    #[doc = "< Event ID"]
    pub evt_id: u8,
    #[doc = "< Event Type"]
    pub evt_type: u8,
    #[doc = "< Sequence Number"]
    pub seq: u8,
    #[doc = "< Number of Faults/Notif"]
    pub number: u8,
}
#[doc = " eCPRI Combined Message Header Format: Common Header + Message Types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_combined_msg_hdr {
    pub common: rte_ecpri_common_hdr,
    pub __bindgen_anon_1: rte_ecpri_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_combined_msg_hdr__bindgen_ty_1 {
    pub type0: rte_ecpri_msg_iq_data,
    pub type1: rte_ecpri_msg_bit_seq,
    pub type2: rte_ecpri_msg_rtc_ctrl,
    pub type3: rte_ecpri_msg_gen_data,
    pub type4: rte_ecpri_msg_rm_access,
    pub type5: rte_ecpri_msg_delay_measure,
    pub type6: rte_ecpri_msg_remote_reset,
    pub type7: rte_ecpri_msg_event_ind,
    pub dummy: [rte_be32_t; 3usize],
}
#[doc = " Structure describing the parameters of a mbuf dynamic field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynfield {
    #[doc = "< Name of the field."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< The number of bytes to reserve."]
    pub size: usize,
    #[doc = "< The alignment constraint (power of 2)."]
    pub align: usize,
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
#[doc = " Structure describing the parameters of a mbuf dynamic flag."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynflag {
    #[doc = "< Name of the dynamic flag."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
pub type rte_mbuf_timestamp_t = u64;
#[doc = "< Green"]
pub const rte_color_RTE_COLOR_GREEN: rte_color = 0;
#[doc = "< Yellow"]
pub const rte_color_RTE_COLOR_YELLOW: rte_color = 1;
#[doc = "< Red"]
pub const rte_color_RTE_COLOR_RED: rte_color = 2;
#[doc = "< Number of colors"]
pub const rte_color_RTE_COLORS: rte_color = 3;
#[doc = " Color"]
pub type rte_color = ::std::os::raw::c_uint;
#[doc = " srTCM parameters per metered traffic flow. The CIR, CBS and EBS parameters only\ncount bytes of IP packets and do not include link specific headers. At least one of\nthe CBS or EBS parameters has to be greater than zero."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_srtcm_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Committed Burst Size (CBS).  Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Excess Burst Size (EBS).  Measured in bytes."]
    pub ebs: u64,
}
#[doc = " trTCM parameters per metered traffic flow. The CIR, PIR, CBS and PBS parameters\nonly count bytes of IP packets and do not include link specific headers. PIR has to\nbe greater than or equal to CIR. Both CBS or EBS have to be greater than zero."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Peak Information Rate (PIR). Measured in bytes per second."]
    pub pir: u64,
    #[doc = "< Committed Burst Size (CBS). Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Peak Burst Size (PBS). Measured in bytes."]
    pub pbs: u64,
}
#[doc = " trTCM parameters per metered traffic flow. The CIR, EIR, CBS and EBS\nparameters only count bytes of IP packets and do not include link specific\nheaders. The CBS and EBS need to be greater than zero if CIR and EIR are\nnone-zero respectively."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115_params {
    #[doc = "< Committed Information Rate (CIR). Measured in bytes per second."]
    pub cir: u64,
    #[doc = "< Excess Information Rate (EIR). Measured in bytes per second."]
    pub eir: u64,
    #[doc = "< Committed Burst Size (CBS). Measured in bytes."]
    pub cbs: u64,
    #[doc = "< Excess Burst Size (EBS). Measured in bytes."]
    pub ebs: u64,
}
unsafe extern "C" {
    #[doc = " srTCM profile configuration\n\n @param p\n    Pointer to pre-allocated srTCM profile data structure\n @param params\n    srTCM profile parameters\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_srtcm_profile_config(
        p: *mut rte_meter_srtcm_profile,
        params: *mut rte_meter_srtcm_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " trTCM profile configuration\n\n @param p\n    Pointer to pre-allocated trTCM profile data structure\n @param params\n    trTCM profile parameters\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_profile_config(
        p: *mut rte_meter_trtcm_profile,
        params: *mut rte_meter_trtcm_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " trTCM RFC 4115 profile configuration\n\n @param p\n    Pointer to pre-allocated trTCM profile data structure\n @param params\n    trTCM profile parameters\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_rfc4115_profile_config(
        p: *mut rte_meter_trtcm_rfc4115_profile,
        params: *mut rte_meter_trtcm_rfc4115_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " srTCM configuration per metered traffic flow\n\n @param m\n    Pointer to pre-allocated srTCM data structure\n @param p\n    srTCM profile. Needs to be valid.\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_srtcm_config(
        m: *mut rte_meter_srtcm,
        p: *mut rte_meter_srtcm_profile,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " trTCM configuration per metered traffic flow\n\n @param m\n    Pointer to pre-allocated trTCM data structure\n @param p\n    trTCM profile. Needs to be valid.\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_config(
        m: *mut rte_meter_trtcm,
        p: *mut rte_meter_trtcm_profile,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " trTCM RFC 4115 configuration per metered traffic flow\n\n @param m\n    Pointer to pre-allocated trTCM data structure\n @param p\n    trTCM profile. Needs to be valid.\n @return\n    0 upon success, error code otherwise"]
    pub fn rte_meter_trtcm_rfc4115_config(
        m: *mut rte_meter_trtcm_rfc4115,
        p: *mut rte_meter_trtcm_rfc4115_profile,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Internal data structure storing the srTCM configuration profile. Typically\n shared by multiple srTCM objects."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_srtcm_profile {
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the srTCM run-time context per metered traffic flow."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_srtcm {
    pub time: u64,
    pub tc: u64,
    pub te: u64,
}
#[doc = " Internal data structure storing the trTCM configuration profile. Typically\n shared by multiple trTCM objects."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm_profile {
    pub cbs: u64,
    pub pbs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub pir_period: u64,
    pub pir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the trTCM run-time context per metered traffic flow."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm {
    pub time_tc: u64,
    pub time_tp: u64,
    pub tc: u64,
    pub tp: u64,
}
#[doc = " Internal data structure storing the trTCM RFC4115 configuration profile.\n Typically shared by multiple trTCM objects."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115_profile {
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub eir_period: u64,
    pub eir_bytes_per_period: u64,
}
#[doc = " Internal data structure storing the trTCM RFC4115 run-time context per\n metered traffic flow."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_meter_trtcm_rfc4115 {
    pub time_tc: u64,
    pub time_te: u64,
    pub tc: u64,
    pub te: u64,
}
#[doc = " Simplified GTP protocol header.\n Contains 8-bit header info, 8-bit message type,\n 16-bit payload length after mandatory header, 32-bit TEID.\n No optional fields and next extension header."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gtp_hdr {
    pub __bindgen_anon_1: rte_gtp_hdr__bindgen_ty_1,
    #[doc = "< GTP message type"]
    pub msg_type: u8,
    #[doc = "< Total payload length"]
    pub plen: rte_be16_t,
    #[doc = "< Tunnel endpoint ID"]
    pub teid: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_gtp_hdr__bindgen_ty_1 {
    #[doc = "< GTP header info"]
    pub gtp_hdr_info: u8,
    pub __bindgen_anon_1: rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_gtp_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pn_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pn_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn s(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn s_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_s_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn e(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn e_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_e_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pt_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pt_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ver(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ver_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pn: u8,
        s: u8,
        e: u8,
        res1: u8,
        pt: u8,
        ver: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pn: u8 = unsafe { ::std::mem::transmute(pn) };
            pn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let s: u8 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let e: u8 = unsafe { ::std::mem::transmute(e) };
            e as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let res1: u8 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pt: u8 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ver: u8 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gtp_hdr_ext_word {
    #[doc = "< Sequence Number."]
    pub sqn: rte_be16_t,
    #[doc = "< N-PDU number."]
    pub npdu: u8,
    #[doc = "< Next Extension Header Type."]
    pub next_ext: u8,
}
#[doc = " Optional extension for GTP with next_ext set to 0x85\n defined based on RFC 38415-g30."]
#[repr(C, packed)]
pub struct rte_gtp_psc_generic_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_generic_hdr {
    #[inline]
    pub fn pad(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pad_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pad_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qmp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qmp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qmp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qfi_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qfi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spare(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_spare(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spare_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_spare_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad: u8,
        qmp: u8,
        type_: u8,
        qfi: u8,
        spare: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pad: u8 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let qmp: u8 = unsafe { ::std::mem::transmute(qmp) };
            qmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let spare: u8 = unsafe { ::std::mem::transmute(spare) };
            spare as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional extension for GTP with next_ext set to 0x85\n type0 defined based on RFC 38415-g30"]
#[repr(C, packed)]
pub struct rte_gtp_psc_type0_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_type0_hdr {
    #[inline]
    pub fn spare_dl1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_spare_dl1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spare_dl1_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_spare_dl1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn snp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_snp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn snp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_snp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qmp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qmp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qmp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qfi_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qfi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rqi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rqi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rqi_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rqi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ppp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ppp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ppp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ppp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        spare_dl1: u8,
        snp: u8,
        qmp: u8,
        type_: u8,
        qfi: u8,
        rqi: u8,
        ppp: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let spare_dl1: u8 = unsafe { ::std::mem::transmute(spare_dl1) };
            spare_dl1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let snp: u8 = unsafe { ::std::mem::transmute(snp) };
            snp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let qmp: u8 = unsafe { ::std::mem::transmute(qmp) };
            qmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rqi: u8 = unsafe { ::std::mem::transmute(rqi) };
            rqi as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ppp: u8 = unsafe { ::std::mem::transmute(ppp) };
            ppp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional extension for GTP with next_ext set to 0x85\n type1 defined based on RFC 38415-g30"]
#[repr(C, packed)]
pub struct rte_gtp_psc_type1_hdr {
    #[doc = "< PDU ext hdr len in multiples of 4 bytes"]
    pub ext_hdr_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< variable length data fields"]
    pub data: __IncompleteArrayField<u8>,
}
impl rte_gtp_psc_type1_hdr {
    #[inline]
    pub fn snp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_snp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn snp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_snp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ul_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ul_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ul_delay_ind_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ul_delay_ind_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dl_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_delay_ind_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dl_delay_ind_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qmp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qmp_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qmp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qfi(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_qfi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qfi_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qfi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spare_ul2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spare_ul2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spare_ul2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_spare_ul2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_delay_ind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_n_delay_ind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_delay_ind_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_n_delay_ind_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        snp: u8,
        ul_delay_ind: u8,
        dl_delay_ind: u8,
        qmp: u8,
        type_: u8,
        qfi: u8,
        spare_ul2: u8,
        n_delay_ind: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let snp: u8 = unsafe { ::std::mem::transmute(snp) };
            snp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ul_delay_ind: u8 = unsafe { ::std::mem::transmute(ul_delay_ind) };
            ul_delay_ind as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_delay_ind: u8 = unsafe { ::std::mem::transmute(dl_delay_ind) };
            dl_delay_ind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let qmp: u8 = unsafe { ::std::mem::transmute(qmp) };
            qmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let qfi: u8 = unsafe { ::std::mem::transmute(qfi) };
            qfi as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let spare_ul2: u8 = unsafe { ::std::mem::transmute(spare_ul2) };
            spare_ul2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let n_delay_ind: u8 = unsafe { ::std::mem::transmute(n_delay_ind) };
            n_delay_ind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " L2TPv2 Common Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_common_hdr {
    pub __bindgen_anon_1: rte_l2tpv2_common_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_common_hdr__bindgen_ty_1 {
    #[doc = " header flags and protocol version"]
    pub flags_version: rte_be16_t,
    pub __bindgen_anon_1: rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ver_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ver_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res3_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res3_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn p_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_p_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn o(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_o(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn o_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_o_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res2_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res2_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn s_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_s_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_l_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn t_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_t_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ver: u16,
        res3: u16,
        p: u16,
        o: u16,
        res2: u16,
        s: u16,
        res1: u16,
        l: u16,
        t: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ver: u16 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let res3: u16 = unsafe { ::std::mem::transmute(res3) };
            res3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let o: u16 = unsafe { ::std::mem::transmute(o) };
            o as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let t: u16 = unsafe { ::std::mem::transmute(t) };
            t as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " L2TPv2 message Header contains all options(length, ns, nr,\n offset size, offset padding)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_with_all_options {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except length(ns, nr,\n offset size, offset padding)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_without_length {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except ns_nr(length,\n offset size, offset padding).\n Ns and Nr MUST be together."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_without_ns_nr {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains all options except ns_nr(length, ns, nr).\n offset size and offset padding MUST be together."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_without_offset {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
}
#[doc = " L2TPv2 message Header contains options offset size and offset padding."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_with_offset {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< offset size(16)"]
    pub offset_size: rte_be16_t,
    #[doc = "< offset padding(variable length)"]
    pub offset_padding: *mut u8,
}
#[doc = " L2TPv2 message Header contains options ns and nr."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_with_ns_nr {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
    #[doc = "< Ns(16)"]
    pub ns: rte_be16_t,
    #[doc = "< Nr(16)"]
    pub nr: rte_be16_t,
}
#[doc = " L2TPv2 message Header contains option length."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_with_length {
    #[doc = "< length(16)"]
    pub length: rte_be16_t,
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
}
#[doc = " L2TPv2 message Header without all options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_msg_without_all_options {
    #[doc = "< tunnel ID(16)"]
    pub tunnel_id: rte_be16_t,
    #[doc = "< session ID(16)"]
    pub session_id: rte_be16_t,
}
#[doc = " L2TPv2 Combined Message Header Format: Common Header + Options"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_combined_msg_hdr {
    #[doc = "< common header"]
    pub common: rte_l2tpv2_common_hdr,
    pub __bindgen_anon_1: rte_l2tpv2_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_combined_msg_hdr__bindgen_ty_1 {
    #[doc = " header with all options"]
    pub type0: rte_l2tpv2_msg_with_all_options,
    #[doc = " header with all options except length"]
    pub type1: rte_l2tpv2_msg_without_length,
    #[doc = " header with all options except ns/nr"]
    pub type2: rte_l2tpv2_msg_without_ns_nr,
    #[doc = " header with all options except offset"]
    pub type3: rte_l2tpv2_msg_without_offset,
    #[doc = " header with offset options"]
    pub type4: rte_l2tpv2_msg_with_offset,
    #[doc = " header with ns/nr options"]
    pub type5: rte_l2tpv2_msg_with_ns_nr,
    #[doc = " header with length option"]
    pub type6: rte_l2tpv2_msg_with_length,
    #[doc = " header without all options"]
    pub type7: rte_l2tpv2_msg_without_all_options,
}
#[doc = " PPP Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_ppp_hdr {
    #[doc = "< PPP address(8)"]
    pub addr: u8,
    #[doc = "< PPP control(8)"]
    pub ctrl: u8,
    #[doc = "< PPP protocol identifier(16)"]
    pub proto_id: rte_be16_t,
}
#[doc = " GRE Header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gre_hdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< Protocol Type"]
    pub proto: rte_be16_t,
}
impl rte_gre_hdr {
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res2_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res2_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn s_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_s_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn k(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_k(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn k_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_k_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn c(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn c_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_c_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ver_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ver_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res3_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res3_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res2: u16,
        s: u16,
        k: u16,
        res1: u16,
        c: u16,
        ver: u16,
        res3: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let k: u16 = unsafe { ::std::mem::transmute(k) };
            k as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let c: u16 = unsafe { ::std::mem::transmute(c) };
            c as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let ver: u16 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let res3: u16 = unsafe { ::std::mem::transmute(res3) };
            res3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Optional field checksum in GRE header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gre_hdr_opt_checksum_rsvd {
    pub checksum: rte_be16_t,
    pub reserved1: rte_be16_t,
}
#[doc = " Optional field key in GRE header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gre_hdr_opt_key {
    pub key: rte_be32_t,
}
#[doc = " Optional field sequence in GRE header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_gre_hdr_opt_sequence {
    pub sequence: rte_be32_t,
}
#[doc = " MACsec Header (SecTAG)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_macsec_hdr {
    #[doc = " Tag control information and Association number of secure channel.\n Various bits of TCI and AN are masked using RTE_MACSEC_TCI_* and RTE_MACSEC_AN_MASK."]
    pub tci_an: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Packet number to support replay protection."]
    pub packet_number: rte_be32_t,
}
impl rte_macsec_hdr {
    #[inline]
    pub fn short_length(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_short_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn short_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_short_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unused(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unused_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_unused_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(short_length: u8, unused: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let short_length: u8 = unsafe { ::std::mem::transmute(short_length) };
            short_length as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let unused: u8 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " MACsec SCI header (8 bytes) after the MACsec header\n which is present if SC bit is set in tci_an."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_macsec_sci_hdr {
    #[doc = "< Optional secure channel ID."]
    pub sci: [u8; 8usize],
}
#[doc = " InfiniBand Base Transport Header according to\n IB Specification Vol 1-Release-1.4."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_ib_bth {
    #[doc = "< Opcode."]
    pub opcode: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Partition key."]
    pub pkey: rte_be16_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Destination QP"]
    pub dst_qp: [u8; 3usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Packet Sequence Number"]
    pub psn: [u8; 3usize],
}
impl rte_ib_bth {
    #[inline]
    pub fn tver(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tver_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn padcnt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_padcnt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn padcnt_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_padcnt_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn m(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_m(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn m_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_m_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn se(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_se(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn se_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_se_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tver: u8,
        padcnt: u8,
        m: u8,
        se: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tver: u8 = unsafe { ::std::mem::transmute(tver) };
            tver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let padcnt: u8 = unsafe { ::std::mem::transmute(padcnt) };
            padcnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let m: u8 = unsafe { ::std::mem::transmute(m) };
            m as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let se: u8 = unsafe { ::std::mem::transmute(se) };
            se as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn b(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn b_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_b_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_f(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_f_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(rsvd0: u8, b: u8, f: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let rsvd0: u8 = unsafe { ::std::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let b: u8 = unsafe { ::std::mem::transmute(b) };
            b as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let f: u8 = unsafe { ::std::mem::transmute(f) };
            f as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd1_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn a(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_a(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn a_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_a_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(rsvd1: u8, a: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let rsvd1: u8 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let a: u8 = unsafe { ::std::mem::transmute(a) };
            a as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flow rule attributes.\n\n Priorities are set on a per rule based within groups.\n\n Lower values denote higher priority, the highest priority for a flow rule\n is 0, so that a flow that matches for than one rule, the rule with the\n lowest priority value will always be matched.\n\n Although optional, applications are encouraged to group similar rules as\n much as possible to fully take advantage of hardware capabilities\n (e.g. optimized matching) and work around limitations (e.g. a single\n pattern type possibly allowed in a given group). Applications should be\n aware that groups are not linked by default, and that they must be\n explicitly linked by the application using the JUMP action.\n\n Priority levels are arbitrary and up to the application, they\n do not need to be contiguous nor start from 0, however the maximum number\n varies between devices and may be affected by existing flow rules.\n\n If a packet is matched by several rules of a given group for a given\n priority level, the outcome is undefined. It can take any path, may be\n duplicated or even cause unrecoverable errors.\n\n Note that support for more than a single group and priority level is not\n guaranteed.\n\n At vNIC / ethdev level, flow rules can apply to inbound and / or outbound\n traffic (ingress / egress), with respect to the vNIC / ethdev in question.\n At embedded switch level, flow rules apply to all traffic seen by it\n unless fitting meta items are used to set concrete traffic source(s).\n\n Several pattern items and actions are valid and can be used in both\n directions. Those valid for only one direction are described as such.\n\n At least one direction must be specified.\n\n Specifying both directions at once for a given rule is not recommended\n but may be valid in a few cases."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_attr {
    #[doc = " A group is a superset of multiple rules.\n The default group is 0 and is processed for all packets.\n Rules in other groups are processed only if the group is chained\n by a jump action from a previously matched rule.\n It means the group hierarchy is made by the flow rules,\n and the group 0 is the hierarchy root.\n Note there is no automatic dead loop protection.\n @see rte_flow_action_jump"]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_group_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_group_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " [META]\n\n End marker for item lists. Prevents further processing of items,\n thereby ending the pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_END: rte_flow_item_type = 0;
#[doc = " [META]\n\n Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VOID: rte_flow_item_type = 1;
#[doc = " [META]\n\n Inverted matching, i.e. process packets that do not match the\n pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INVERT: rte_flow_item_type = 2;
#[doc = " Matches any protocol in place of the current layer, a single ANY\n may also stand for several protocol layers.\n\n See struct rte_flow_item_any."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ANY: rte_flow_item_type = 3;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT\n\n [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n given DPDK port ID.\n\n See struct rte_flow_item_port_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_ID: rte_flow_item_type = 4;
#[doc = " Matches a byte string of a given length at a given offset.\n\n See struct rte_flow_item_raw."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RAW: rte_flow_item_type = 5;
#[doc = " Matches an Ethernet header.\n\n See struct rte_flow_item_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ETH: rte_flow_item_type = 6;
#[doc = " Matches an 802.1Q/ad VLAN tag.\n\n See struct rte_flow_item_vlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VLAN: rte_flow_item_type = 7;
#[doc = " Matches an IPv4 header.\n\n See struct rte_flow_item_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV4: rte_flow_item_type = 8;
#[doc = " Matches an IPv6 header.\n\n See struct rte_flow_item_ipv6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6: rte_flow_item_type = 9;
#[doc = " Matches an ICMP header.\n\n See struct rte_flow_item_icmp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP: rte_flow_item_type = 10;
#[doc = " Matches a UDP header.\n\n See struct rte_flow_item_udp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_UDP: rte_flow_item_type = 11;
#[doc = " Matches a TCP header.\n\n See struct rte_flow_item_tcp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TCP: rte_flow_item_type = 12;
#[doc = " Matches a SCTP header.\n\n See struct rte_flow_item_sctp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_SCTP: rte_flow_item_type = 13;
#[doc = " Matches a VXLAN header.\n\n See struct rte_flow_item_vxlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN: rte_flow_item_type = 14;
#[doc = " Matches a E_TAG header.\n\n See struct rte_flow_item_e_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_E_TAG: rte_flow_item_type = 15;
#[doc = " Matches a NVGRE header.\n\n See struct rte_flow_item_nvgre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NVGRE: rte_flow_item_type = 16;
#[doc = " Matches a MPLS header.\n\n See struct rte_flow_item_mpls."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MPLS: rte_flow_item_type = 17;
#[doc = " Matches a GRE header.\n\n See struct rte_flow_item_gre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE: rte_flow_item_type = 18;
#[doc = " [META]\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy matching option.\n Usually a fuzzy matching is fast but the cost is accuracy.\n\n See struct rte_flow_item_fuzzy."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FUZZY: rte_flow_item_type = 19;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP: rte_flow_item_type = 20;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-C packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPC: rte_flow_item_type = 21;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-U packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPU: rte_flow_item_type = 22;
#[doc = " Matches a ESP header.\n\n See struct rte_flow_item_esp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ESP: rte_flow_item_type = 23;
#[doc = " Matches a GENEVE header.\n\n See struct rte_flow_item_geneve."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE: rte_flow_item_type = 24;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_VXLAN\n\n Matches a VXLAN-GPE header.\n\n See struct rte_flow_item_vxlan_gpe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN_GPE: rte_flow_item_type = 25;
#[doc = " Matches an ARP header for Ethernet/IPv4.\n\n See struct rte_flow_item_arp_eth_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: rte_flow_item_type = 26;
#[doc = " Matches the presence of any IPv6 extension header.\n\n See struct rte_flow_item_ipv6_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_EXT: rte_flow_item_type = 27;
#[doc = " Matches any ICMPv6 header.\n\n See struct rte_flow_item_icmp6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6: rte_flow_item_type = 28;
#[doc = " Matches an ICMPv6 neighbor discovery solicitation.\n\n See struct rte_flow_item_icmp6_nd_ns."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: rte_flow_item_type = 29;
#[doc = " Matches an ICMPv6 neighbor discovery advertisement.\n\n See struct rte_flow_item_icmp6_nd_na."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: rte_flow_item_type = 30;
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option.\n\n See struct rte_flow_item_icmp6_nd_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: rte_flow_item_type = 31;
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: rte_flow_item_type = 32;
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: rte_flow_item_type = 33;
#[doc = " Matches specified mark field.\n\n See struct rte_flow_item_mark."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MARK: rte_flow_item_type = 34;
#[doc = " [META]\n\n Matches a metadata value.\n\n See struct rte_flow_item_meta."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_META: rte_flow_item_type = 35;
#[doc = " Matches a GRE optional key field.\n\n The value should a big-endian 32bit integer.\n\n When this item present the K bit is implicitly matched as \"1\"\n in the default mask.\n\n @p spec/mask type:\n @code rte_be32_t * @endcode"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_KEY: rte_flow_item_type = 36;
#[doc = " Matches a GTP extension header: PDU session container.\n\n Configure flow for GTP packets with extension header type 0x85.\n\n See struct rte_flow_item_gtp_psc."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP_PSC: rte_flow_item_type = 37;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE session packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOES: rte_flow_item_type = 38;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE discovery packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOED: rte_flow_item_type = 39;
#[doc = " Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n See struct rte_flow_item_pppoe_proto_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: rte_flow_item_type = 40;
#[doc = " Matches Network service header (NSH).\n See struct rte_flow_item_nsh.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NSH: rte_flow_item_type = 41;
#[doc = " Matches Internet Group Management Protocol (IGMP).\n See struct rte_flow_item_igmp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IGMP: rte_flow_item_type = 42;
#[doc = " Matches IP Authentication Header (AH).\n See struct rte_flow_item_ah.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AH: rte_flow_item_type = 43;
#[doc = " Matches a HIGIG header.\n see struct rte_flow_item_higig2_hdr."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_HIGIG2: rte_flow_item_type = 44;
#[doc = " [META]\n\n Matches a tag value.\n\n See struct rte_flow_item_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TAG: rte_flow_item_type = 45;
#[doc = " Matches a L2TPv3 over IP header.\n\n Configure flow for L2TPv3 over IP packets.\n\n See struct rte_flow_item_l2tpv3oip."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV3OIP: rte_flow_item_type = 46;
#[doc = " Matches PFCP Header.\n See struct rte_flow_item_pfcp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PFCP: rte_flow_item_type = 47;
#[doc = " Matches eCPRI Header.\n\n Configure flow for eCPRI over ETH or UDP packets.\n\n See struct rte_flow_item_ecpri."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ECPRI: rte_flow_item_type = 48;
#[doc = " Matches the presence of IPv6 fragment extension header.\n\n See struct rte_flow_item_ipv6_frag_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT: rte_flow_item_type = 49;
#[doc = " Matches Geneve Variable Length Option\n\n See struct rte_flow_item_geneve_opt"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE_OPT: rte_flow_item_type = 50;
#[doc = " [META]\n\n Matches on packet integrity.\n For some devices application needs to enable integration checks in HW\n before using this item.\n\n @see struct rte_flow_item_integrity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INTEGRITY: rte_flow_item_type = 51;
#[doc = " [META]\n\n Matches conntrack state.\n\n @see struct rte_flow_item_conntrack."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_CONNTRACK: rte_flow_item_type = 52;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR: rte_flow_item_type = 53;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from\n the entity represented by the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT: rte_flow_item_type = 54;
#[doc = " Matches a configured set of fields at runtime calculated offsets\n over the generic network header with variable length and\n flexible pattern\n\n @see struct rte_flow_item_flex."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FLEX: rte_flow_item_type = 55;
#[doc = " Matches L2TPv2 Header.\n\n See struct rte_flow_item_l2tpv2."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV2: rte_flow_item_type = 56;
#[doc = " Matches PPP Header.\n\n See struct rte_flow_item_ppp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPP: rte_flow_item_type = 57;
#[doc = " Matches GRE optional fields.\n\n See struct rte_flow_item_gre_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_OPTION: rte_flow_item_type = 58;
#[doc = " Matches MACsec Ethernet Header.\n\n See struct rte_flow_item_macsec."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MACSEC: rte_flow_item_type = 59;
#[doc = " Matches Meter Color Marker.\n\n See struct rte_flow_item_meter_color."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_METER_COLOR: rte_flow_item_type = 60;
#[doc = " Matches the presence of IPv6 routing extension header.\n\n @see struct rte_flow_item_ipv6_routing_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_ROUTING_EXT: rte_flow_item_type = 61;
#[doc = " Matches an ICMPv6 echo request.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REQUEST: rte_flow_item_type = 62;
#[doc = " Matches an ICMPv6 echo reply.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REPLY: rte_flow_item_type = 63;
#[doc = " Match Quota state\n\n @see struct rte_flow_item_quota"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_QUOTA: rte_flow_item_type = 64;
#[doc = " Matches on the aggregated port of the received packet.\n Used in case multiple ports are aggregated to the a DPDK port.\n First port is number 1.\n\n @see struct rte_flow_item_aggr_affinity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AGGR_AFFINITY: rte_flow_item_type = 65;
#[doc = " Match Tx queue number.\n This is valid only for egress rules.\n\n @see struct rte_flow_item_tx_queue"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TX_QUEUE: rte_flow_item_type = 66;
#[doc = " Matches an InfiniBand base transport header in RoCE packet.\n\n @see struct rte_flow_item_ib_bth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IB_BTH: rte_flow_item_type = 67;
#[doc = " Matches the packet type as defined in rte_mbuf_ptype.\n\n See struct rte_flow_item_ptype.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PTYPE: rte_flow_item_type = 68;
#[doc = " [META]\n\n Matches a random value.\n\n This value is not based on the packet data/headers.\n The application shouldn't assume that this value is kept\n during the lifetime of the packet.\n\n @see struct rte_flow_item_random."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RANDOM: rte_flow_item_type = 69;
#[doc = " Match packet with various comparison types.\n\n See struct rte_flow_item_compare."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_COMPARE: rte_flow_item_type = 70;
#[doc = " Matching pattern item types.\n\n Pattern items fall in two categories:\n\n - Matching protocol headers and packet data, usually associated with a\n   specification structure. These must be stacked in the same order as the\n   protocol layers to match inside packets, starting from the lowest.\n\n - Matching meta-data or affecting pattern processing, often without a\n   specification structure. Since they do not match packet contents, their\n   position in the list is usually not relevant.\n\n See the description of individual types for more information. Those\n marked with [META] fall into the second category."]
pub type rte_flow_item_type = ::std::os::raw::c_uint;
#[doc = "< PASS quota state"]
pub const rte_flow_quota_state_RTE_FLOW_QUOTA_STATE_PASS: rte_flow_quota_state = 0;
#[doc = "< BLOCK quota state"]
pub const rte_flow_quota_state_RTE_FLOW_QUOTA_STATE_BLOCK: rte_flow_quota_state = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n QUOTA state.\n\n @see struct rte_flow_item_quota"]
pub type rte_flow_quota_state = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ITEM_TYPE_QUOTA\n\n Matches QUOTA state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_quota {
    pub state: rte_flow_quota_state,
}
unsafe extern "C" {
    pub static rte_flow_item_quota_mask: rte_flow_item_quota;
}
#[doc = " RTE_FLOW_ITEM_TYPE_HIGIG2\n Matches higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_higig2_hdr {
    pub hdr: rte_higig2_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_higig2_hdr_mask: rte_flow_item_higig2_hdr;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ANY\n\n Matches any protocol in place of the current layer, a single ANY may also\n stand for several protocol layers.\n\n This is usually specified as the first pattern item when looking for a\n protocol anywhere in a packet.\n\n A zeroed mask stands for any number of layers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_any {
    #[doc = "< Number of layers covered."]
    pub num: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT\n\n RTE_FLOW_ITEM_TYPE_PORT_ID\n\n Matches traffic originating from (ingress) or going to (egress) a given\n DPDK port ID.\n\n Normally only supported if the port ID in question is known by the\n underlying PMD and related to the device the flow rule is created\n against."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_port_id {
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_port_id_mask: rte_flow_item_port_id;
}
#[doc = " RTE_FLOW_ITEM_TYPE_RAW\n\n Matches a byte string of a given length at a given offset.\n\n Offset is either absolute (using the start of the packet) or relative to\n the end of the previous matched item in the stack, in which case negative\n values are allowed.\n\n If search is enabled, offset is used as the starting point. The search\n area can be delimited by setting limit to a nonzero value, which is the\n maximum number of bytes after offset where the pattern may start.\n\n Matching a zero-length pattern is allowed, doing so resets the relative\n offset for subsequent items.\n\n This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_raw {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Absolute or relative offset for pattern."]
    pub offset: i32,
    #[doc = "< Search area limit for start of pattern."]
    pub limit: u16,
    #[doc = "< Pattern length."]
    pub length: u16,
    #[doc = "< Byte string to look for."]
    pub pattern: *const u8,
}
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relative_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relative_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn search_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_search_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relative: u32,
        search: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relative: u32 = unsafe { ::std::mem::transmute(relative) };
            relative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let search: u32 = unsafe { ::std::mem::transmute(search) };
            search as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ETH\n\n Matches an Ethernet header.\n\n Inside @p hdr field, the sub-field @p ether_type stands either for EtherType\n or TPID, depending on whether the item is followed by a VLAN item or not. If\n two VLAN items follow, the sub-field refers to the outer one, which, in turn,\n contains the inner TPID in the similar header field. The innermost VLAN item\n contains a layer-3 EtherType. All of that follows the order seen on the wire.\n\n If the field in question contains a TPID value, only tagged packets with the\n specified TPID will match the pattern. Alternatively, it's possible to match\n any type of tagged packets by means of the field @p has_vlan rather than use\n the EtherType/TPID field. Also, it's possible to leave the two fields unused.\n If this is the case, both tagged and untagged packets will match the pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_eth {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_eth__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_ether_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Destination MAC."]
    pub dst: rte_ether_addr,
    #[doc = "< Source MAC."]
    pub src: rte_ether_addr,
    #[doc = "< EtherType or TPID."]
    pub type_: rte_be16_t,
}
impl rte_flow_item_eth {
    #[inline]
    pub fn has_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_vlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_vlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vlan: u32 = unsafe { ::std::mem::transmute(has_vlan) };
            has_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VLAN\n\n Matches an 802.1Q/ad VLAN tag.\n\n The corresponding standard outer EtherType (TPID) values are\n RTE_ETHER_TYPE_VLAN or RTE_ETHER_TYPE_QINQ. It can be overridden by\n the preceding pattern item.\n If a @p VLAN item is present in the pattern, then only tagged packets will\n match the pattern.\n The field @p has_more_vlan can be used to match any type of tagged packets,\n instead of using the @p eth_proto field of @p hdr.\n If the @p eth_proto of @p hdr and @p has_more_vlan fields are not specified,\n then any tagged packets will match the pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vlan {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vlan_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Tag control information."]
    pub tci: rte_be16_t,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
impl rte_flow_item_vlan {
    #[inline]
    pub fn has_more_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_more_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_more_vlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_more_vlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_more_vlan: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_more_vlan: u32 = unsafe { ::std::mem::transmute(has_more_vlan) };
            has_more_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV4\n\n Matches an IPv4 header.\n\n Note: IPv4 options are handled by dedicated pattern items."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv4 {
    #[doc = "< IPv4 header definition."]
    pub hdr: rte_ipv4_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6.\n\n Matches an IPv6 header.\n\n Dedicated flags indicate if header contains specific extension headers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv6 {
    #[doc = "< IPv6 header definition."]
    pub hdr: rte_ipv6_hdr,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_item_ipv6 {
    #[inline]
    pub fn has_hop_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_hop_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_hop_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_route_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_route_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_route_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_route_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_frag_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frag_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_frag_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_frag_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_auth_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_auth_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_auth_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_auth_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_esp_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_esp_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_esp_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_esp_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_dest_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_dest_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_dest_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_dest_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_mobil_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mobil_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_mobil_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_mobil_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_hip_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hip_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_hip_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_hip_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_shim6_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_shim6_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_shim6_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_shim6_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_ext: u32,
        has_route_ext: u32,
        has_frag_ext: u32,
        has_auth_ext: u32,
        has_esp_ext: u32,
        has_dest_ext: u32,
        has_mobil_ext: u32,
        has_hip_ext: u32,
        has_shim6_ext: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_ext: u32 = unsafe { ::std::mem::transmute(has_hop_ext) };
            has_hop_ext as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_route_ext: u32 = unsafe { ::std::mem::transmute(has_route_ext) };
            has_route_ext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_frag_ext: u32 = unsafe { ::std::mem::transmute(has_frag_ext) };
            has_frag_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_auth_ext: u32 = unsafe { ::std::mem::transmute(has_auth_ext) };
            has_auth_ext as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_esp_ext: u32 = unsafe { ::std::mem::transmute(has_esp_ext) };
            has_esp_ext as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_dest_ext: u32 = unsafe { ::std::mem::transmute(has_dest_ext) };
            has_dest_ext as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_mobil_ext: u32 = unsafe { ::std::mem::transmute(has_mobil_ext) };
            has_mobil_ext as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_hip_ext: u32 = unsafe { ::std::mem::transmute(has_hip_ext) };
            has_hip_ext as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_shim6_ext: u32 = unsafe { ::std::mem::transmute(has_shim6_ext) };
            has_shim6_ext as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ITEM_TYPE_IPV6_ROUTING_EXT.\n\n Matches an IPv6 routing extension header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv6_routing_ext {
    pub hdr: rte_ipv6_routing_ext,
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP.\n\n Matches an ICMP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp {
    #[doc = "< ICMP header definition."]
    pub hdr: rte_icmp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_UDP.\n\n Matches a UDP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_udp {
    #[doc = "< UDP header definition."]
    pub hdr: rte_udp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_TCP.\n\n Matches a TCP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_tcp {
    #[doc = "< TCP header definition."]
    pub hdr: rte_tcp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_SCTP.\n\n Matches a SCTP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_sctp {
    #[doc = "< SCTP header definition."]
    pub hdr: rte_sctp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN.\n\n Matches a VXLAN header (RFC 7348),\n including GPE (draft-ietf-nvo3-vxlan-gpe-13.txt)\n and GBP (draft-smith-vxlan-group-policy-05.txt).\n\n GPE is distinguished with its UDP port.\n UDP port may be specified with ``rte_eth_dev_udp_tunnel_port_add()``."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vxlan {
    pub __bindgen_anon_1: rte_flow_item_vxlan__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vxlan__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vxlan__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vxlan_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vxlan__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Normally 0x08 (I flag)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x000000."]
    pub rsvd0: [u8; 3usize],
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_E_TAG.\n\n Matches a E-tag header.\n\n The corresponding standard outer EtherType (TPID) value is\n RTE_ETHER_TYPE_ETAG. It can be overridden by the preceding pattern item."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_e_tag {
    #[doc = " E-Tag control information (E-TCI).\n E-PCP (3b), E-DEI (1b), ingress E-CID base (12b)."]
    pub epcp_edei_in_ecid_b: rte_be16_t,
    #[doc = " Reserved (2b), GRP (2b), E-CID base (12b)."]
    pub rsvd_grp_ecid_b: rte_be16_t,
    #[doc = "< Ingress E-CID ext."]
    pub in_ecid_e: u8,
    #[doc = "< E-CID ext."]
    pub ecid_e: u8,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
unsafe extern "C" {
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_NVGRE.\n\n Matches a NVGRE header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_nvgre {
    #[doc = " Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),\n reserved 0 (9b), version (3b).\n\n c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637."]
    pub c_k_s_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type (0x6558)."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual subnet ID."]
    pub tni: [u8; 3usize],
    #[doc = "< Flow ID."]
    pub flow_id: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_MPLS.\n\n Matches a MPLS header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_mpls {
    #[doc = " Label (20b), TC (3b), Bottom of Stack (1b)."]
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE.\n\n Matches a GRE header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_gre {
    #[doc = " Checksum (1b), reserved 0 (12b), version (3b).\n Refer to RFC 2784."]
    pub c_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
}
unsafe extern "C" {
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE_OPTION.\n\n Matches GRE optional fields in header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_gre_opt {
    pub checksum_rsvd: rte_gre_hdr_opt_checksum_rsvd,
    pub key: rte_gre_hdr_opt_key,
    pub sequence: rte_gre_hdr_opt_sequence,
}
#[doc = " RTE_FLOW_ITEM_TYPE_MACSEC.\n\n Matches MACsec header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_macsec {
    pub macsec_hdr: rte_macsec_hdr,
}
#[doc = " RTE_FLOW_ITEM_TYPE_FUZZY\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy match option.\n Usually a fuzzy match is fast but the cost is accuracy.\n i.e. Signature Match only match pattern's hash value, but it is\n possible two different patterns have the same hash value.\n\n Matching accuracy level can be configure by threshold.\n Driver can divide the range of threshold and map to different\n accuracy levels that device support.\n\n Threshold 0 means perfect match (no fuzziness), while threshold\n 0xffffffff means fuzziest match."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_fuzzy {
    #[doc = "< Accuracy threshold."]
    pub thresh: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP.\n\n Matches a GTPv1 header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_gtp {
    pub __bindgen_anon_1: rte_flow_item_gtp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_gtp__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_gtp__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< GTP header definition."]
    pub hdr: rte_gtp_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_gtp__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Version (3b), protocol type (1b), reserved (1b),\n Extension header flag (1b),\n Sequence number flag (1b),\n N-PDU number flag (1b)."]
    pub v_pt_rsv_flags: u8,
    #[doc = "< Message type."]
    pub msg_type: u8,
    #[doc = "< Message length."]
    pub msg_len: rte_be16_t,
    #[doc = "< Tunnel endpoint identifier."]
    pub teid: rte_be32_t,
}
unsafe extern "C" {
    pub static rte_flow_item_gtp_mask: rte_flow_item_gtp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ESP\n\n Matches an ESP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_esp {
    #[doc = "< ESP header definition."]
    pub hdr: rte_esp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_esp_mask: rte_flow_item_esp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE.\n\n Matches a GENEVE header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_geneve {
    #[doc = " Version (2b), length of the options fields (6b), OAM packet (1b),\n critical options present (1b), reserved 0 (6b)."]
    pub ver_opt_len_o_c_rsvd0: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual Network Identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_geneve_mask: rte_flow_item_geneve;
}
#[doc = " @deprecated\n @see rte_flow_item_vxlan\n\n RTE_FLOW_ITEM_TYPE_VXLAN_GPE (draft-ietf-nvo3-vxlan-gpe-05).\n\n Matches a VXLAN-GPE header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vxlan_gpe {
    pub __bindgen_anon_1: rte_flow_item_vxlan_gpe__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vxlan_gpe__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vxlan_gpe__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vxlan_gpe_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vxlan_gpe__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Normally 0x0c (I and P flags)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x0000."]
    pub rsvd0: [u8; 2usize],
    #[doc = "< Protocol type."]
    pub protocol: u8,
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_vxlan_gpe_mask: rte_flow_item_vxlan_gpe;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4\n\n Matches an ARP header for Ethernet/IPv4."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_arp_eth_ipv4 {
    pub __bindgen_anon_1: rte_flow_item_arp_eth_ipv4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_arp_eth_ipv4__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_arp_eth_ipv4__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< ARP header definition."]
    pub hdr: rte_arp_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_arp_eth_ipv4__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Hardware type, normally 1."]
    pub hrd: rte_be16_t,
    #[doc = "< Protocol type, normally 0x0800."]
    pub pro: rte_be16_t,
    #[doc = "< Hardware address length, normally 6."]
    pub hln: u8,
    #[doc = "< Protocol address length, normally 4."]
    pub pln: u8,
    #[doc = "< Opcode (1 for request, 2 for reply)."]
    pub op: rte_be16_t,
    #[doc = "< Sender hardware address."]
    pub sha: rte_ether_addr,
    #[doc = "< Sender IPv4 address."]
    pub spa: rte_be32_t,
    #[doc = "< Target hardware address."]
    pub tha: rte_ether_addr,
    #[doc = "< Target IPv4 address."]
    pub tpa: rte_be32_t,
}
unsafe extern "C" {
    pub static rte_flow_item_arp_eth_ipv4_mask: rte_flow_item_arp_eth_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_EXT\n\n Matches the presence of any IPv6 extension header.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_IPV6\n - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv6_ext {
    #[doc = "< Next header."]
    pub next_hdr: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_ipv6_ext_mask: rte_flow_item_ipv6_ext;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT\n\n Matches the presence of IPv6 fragment extension header.\n\n Preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_IPV6\n - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv6_frag_ext {
    pub hdr: rte_ipv6_fragment_ext,
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6\n\n Matches any ICMPv6 header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6 {
    #[doc = "< ICMPv6 type."]
    pub type_: u8,
    #[doc = "< ICMPv6 code."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: u16,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_mask: rte_flow_item_icmp6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REQUEST\n RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REPLY\n\n Matches an ICMPv6 echo request or reply."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_echo {
    pub hdr: rte_icmp_echo_hdr,
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n\n Matches an ICMPv6 neighbor discovery solicitation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_ns {
    #[doc = "< ICMPv6 type, normally 135."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = "< Reserved, normally 0."]
    pub reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: rte_ipv6_addr,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_ns_mask: rte_flow_item_icmp6_nd_ns;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n\n Matches an ICMPv6 neighbor discovery advertisement."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_na {
    #[doc = "< ICMPv6 type, normally 136."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = " Route flag (1b), solicited flag (1b), override flag (1b),\n reserved (29b)."]
    pub rso_reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: rte_ipv6_addr,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_na_mask: rte_flow_item_icmp6_nd_na;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT\n\n Matches the presence of any ICMPv6 neighbor discovery option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt {
    #[doc = "< ND option type."]
    pub type_: u8,
    #[doc = "< ND option length."]
    pub length: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_mask: rte_flow_item_icmp6_nd_opt;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH\n\n Matches an ICMPv6 neighbor discovery source Ethernet link-layer address\n option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt_sla_eth {
    #[doc = "< ND option type, normally 1."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Source Ethernet LLA."]
    pub sla: rte_ether_addr,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_sla_eth_mask: rte_flow_item_icmp6_nd_opt_sla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH\n\n Matches an ICMPv6 neighbor discovery target Ethernet link-layer address\n option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt_tla_eth {
    #[doc = "< ND option type, normally 2."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Target Ethernet LLA."]
    pub tla: rte_ether_addr,
}
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_tla_eth_mask: rte_flow_item_icmp6_nd_opt_tla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_META\n\n Matches a specified metadata value. On egress, metadata can be set\n either by mbuf dynamic metadata field with RTE_MBUF_DYNFLAG_TX_METADATA flag\n or RTE_FLOW_ACTION_TYPE_SET_META. On ingress, RTE_FLOW_ACTION_TYPE_SET_META\n sets metadata for a packet and the metadata will be reported via mbuf\n metadata dynamic field with RTE_MBUF_DYNFLAG_RX_METADATA flag. The dynamic\n mbuf field must be registered in advance by\n rte_flow_dynf_metadata_register()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_meta {
    pub data: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_meta_mask: rte_flow_item_meta;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP_PSC.\n\n Matches a GTP PDU extension header with type 0x85."]
#[repr(C)]
pub struct rte_flow_item_gtp_psc {
    #[doc = "< gtp psc generic hdr."]
    pub hdr: rte_gtp_psc_generic_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_gtp_psc_mask: rte_flow_item_gtp_psc;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE.\n\n Matches a PPPoE header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_pppoe {
    #[doc = " Version (4b), type (4b)."]
    pub version_type: u8,
    #[doc = "< Message type."]
    pub code: u8,
    #[doc = "< Session identifier."]
    pub session_id: rte_be16_t,
    #[doc = "< Payload length."]
    pub length: rte_be16_t,
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID.\n\n Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_PPPOE\n - RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_pppoe_proto_id {
    #[doc = "< PPP protocol identifier."]
    pub proto_id: rte_be16_t,
}
unsafe extern "C" {
    pub static rte_flow_item_pppoe_proto_id_mask: rte_flow_item_pppoe_proto_id;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_TAG\n\n Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_tag_mask: rte_flow_item_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_L2TPV3OIP.\n\n Matches a L2TPv3 over IP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_l2tpv3oip {
    #[doc = "< Session ID."]
    pub session_id: rte_be32_t,
}
unsafe extern "C" {
    pub static rte_flow_item_l2tpv3oip_mask: rte_flow_item_l2tpv3oip;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_MARK\n\n Matches an arbitrary integer value which was set using the ``MARK`` action\n in a previously matched rule.\n\n This item can only be specified once as a match criteria as the ``MARK``\n action can only be specified once in a flow action.\n\n This value is arbitrary and application-defined. Maximum allowed value\n depends on the underlying implementation.\n\n Depending on the underlying implementation the MARK item may be supported on\n the physical device, with virtual groups in the PMD or not at all."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_mark {
    #[doc = "< Integer value to match against."]
    pub id: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_mark_mask: rte_flow_item_mark;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_NSH\n\n Match network service header (NSH), RFC 8300"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_nsh {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_flow_item_nsh {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn oam_pkt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oam_pkt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oam_pkt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_oam_pkt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ttl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ttl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ttl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mdtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mdtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mdtype_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mdtype_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn next_proto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_proto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_proto_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_proto_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_spi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spi_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_spi_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sindex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sindex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sindex_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sindex_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        oam_pkt: u32,
        reserved: u32,
        ttl: u32,
        length: u32,
        reserved1: u32,
        mdtype: u32,
        next_proto: u32,
        spi: u32,
        sindex: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let oam_pkt: u32 = unsafe { ::std::mem::transmute(oam_pkt) };
            oam_pkt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let mdtype: u32 = unsafe { ::std::mem::transmute(mdtype) };
            mdtype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let next_proto: u32 = unsafe { ::std::mem::transmute(next_proto) };
            next_proto as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let spi: u32 = unsafe { ::std::mem::transmute(spi) };
            spi as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let sindex: u32 = unsafe { ::std::mem::transmute(sindex) };
            sindex as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_nsh_mask: rte_flow_item_nsh;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_IGMP\n\n Match Internet Group Management Protocol (IGMP), RFC 2236"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_igmp {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub group_addr: u32,
}
impl rte_flow_item_igmp {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_resp_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_resp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_resp_time_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_resp_time_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn checksum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_checksum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn checksum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_checksum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u32,
        max_resp_time: u32,
        checksum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let max_resp_time: u32 = unsafe { ::std::mem::transmute(max_resp_time) };
            max_resp_time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let checksum: u32 = unsafe { ::std::mem::transmute(checksum) };
            checksum as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_igmp_mask: rte_flow_item_igmp;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_AH\n\n Match IP Authentication Header (AH), RFC 4302"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ah {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub spi: u32,
    pub seq_num: u32,
}
impl rte_flow_item_ah {
    #[inline]
    pub fn next_hdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_hdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_hdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_hdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn payload_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_payload_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn payload_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_payload_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_hdr: u32,
        payload_len: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let next_hdr: u32 = unsafe { ::std::mem::transmute(next_hdr) };
            next_hdr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let payload_len: u32 = unsafe { ::std::mem::transmute(payload_len) };
            payload_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_ah_mask: rte_flow_item_ah;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_PFCP\n\n Match PFCP Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_pfcp {
    pub s_field: u8,
    pub msg_type: u8,
    pub msg_len: rte_be16_t,
    pub seid: rte_be64_t,
}
unsafe extern "C" {
    pub static rte_flow_item_pfcp_mask: rte_flow_item_pfcp;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_ECPRI\n\n Match eCPRI Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ecpri {
    pub hdr: rte_ecpri_combined_msg_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_ecpri_mask: rte_flow_item_ecpri;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE_OPT\n\n Matches a GENEVE Variable Length Option"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_geneve_opt {
    pub option_class: rte_be16_t,
    pub option_type: u8,
    pub option_len: u8,
    pub data: *mut u32,
}
unsafe extern "C" {
    pub static rte_flow_item_geneve_opt_mask: rte_flow_item_geneve_opt;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_INTEGRITY\n\n Match on packet integrity check result."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_integrity {
    #[doc = " Tunnel encapsulation level the item should apply to.\n @see rte_flow_action_rss"]
    pub level: u32,
    pub __bindgen_anon_1: rte_flow_item_integrity__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_integrity__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1,
    pub value: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl rte_flow_item_integrity__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn packet_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_packet_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_packet_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l2_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l2_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l3_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l4_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l2_crc_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l2_crc_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_crc_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_crc_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipv4_csum_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ipv4_csum_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipv4_csum_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ipv4_csum_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_csum_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l4_csum_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_csum_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_csum_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len_ok(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len_ok(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_ok_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_ok_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        packet_ok: u64,
        l2_ok: u64,
        l3_ok: u64,
        l4_ok: u64,
        l2_crc_ok: u64,
        ipv4_csum_ok: u64,
        l4_csum_ok: u64,
        l3_len_ok: u64,
        reserved: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let packet_ok: u64 = unsafe { ::std::mem::transmute(packet_ok) };
            packet_ok as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let l2_ok: u64 = unsafe { ::std::mem::transmute(l2_ok) };
            l2_ok as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let l3_ok: u64 = unsafe { ::std::mem::transmute(l3_ok) };
            l3_ok as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let l4_ok: u64 = unsafe { ::std::mem::transmute(l4_ok) };
            l4_ok as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let l2_crc_ok: u64 = unsafe { ::std::mem::transmute(l2_crc_ok) };
            l2_crc_ok as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ipv4_csum_ok: u64 = unsafe { ::std::mem::transmute(ipv4_csum_ok) };
            ipv4_csum_ok as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let l4_csum_ok: u64 = unsafe { ::std::mem::transmute(l4_csum_ok) };
            l4_csum_ok as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let l3_len_ok: u64 = unsafe { ::std::mem::transmute(l3_len_ok) };
            l3_len_ok as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_integrity_mask: rte_flow_item_integrity;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_CONNTRACK\n\n Matches the state of a packet after it passed the connection tracking\n examination. The state is a bitmap of one RTE_FLOW_CONNTRACK_PKT_STATE*\n or a reasonable combination of these bits."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_conntrack {
    pub flags: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_conntrack_mask: rte_flow_item_conntrack;
}
#[doc = " Provides an ethdev port ID for use with the following items:\n RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR,\n RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
unsafe extern "C" {
    pub static rte_flow_item_ethdev_mask: rte_flow_item_ethdev;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_L2TPV2\n\n Matches L2TPv2 Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_l2tpv2 {
    pub hdr: rte_l2tpv2_combined_msg_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_l2tpv2_mask: rte_flow_item_l2tpv2;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_PPP\n\n Matches PPP Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ppp {
    pub hdr: rte_ppp_hdr,
}
unsafe extern "C" {
    pub static rte_flow_item_ppp_mask: rte_flow_item_ppp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IB_BTH.\n\n Matches an InfiniBand base transport header in RoCE packet."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ib_bth {
    #[doc = "< InfiniBand base transport header definition."]
    pub hdr: rte_ib_bth,
}
unsafe extern "C" {
    pub static rte_flow_item_ib_bth_mask: rte_flow_item_ib_bth;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ITEM_TYPE_RANDOM\n\n Matches a random value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_random {
    pub value: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_random_mask: rte_flow_item_random;
}
#[doc = " Matching pattern item definition.\n\n A pattern is formed by stacking items starting from the lowest protocol\n layer to match. This stacking restriction does not apply to meta items\n which can be placed anywhere in the stack without affecting the meaning\n of the resulting pattern.\n\n Patterns are terminated by END items.\n\n The spec field should be a valid pointer to a structure of the related\n item type. It may remain unspecified (NULL) in many cases to request\n broad (nonspecific) matching. In such cases, last and mask must also be\n set to NULL.\n\n Optionally, last can point to a structure of the same type to define an\n inclusive range. This is mostly supported by integer and address fields,\n may cause errors otherwise. Fields that do not support ranges must be set\n to 0 or to the same value as the corresponding fields in spec.\n\n Only the fields defined to nonzero values in the default masks (see\n rte_flow_item_{name}_mask constants) are considered relevant by\n default. This can be overridden by providing a mask structure of the\n same type with applicable bits set to one. It can also be used to\n partially filter out specific fields (e.g. as an alternate mean to match\n ranges of IP addresses).\n\n Mask is a simple bit-mask applied before interpreting the contents of\n spec and last, which may yield unexpected results if not used\n carefully. For example, if for an IPv4 address field, spec provides\n 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the\n effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_FLEX\n\n Matches a specified set of fields within the network protocol\n header. Each field is presented as set of bits with specified width, and\n bit offset from the header beginning.\n\n The pattern is concatenation of bit fields configured at item creation\n by rte_flow_flex_item_create(). At configuration the fields are presented\n by sample_data array.\n\n This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex {
    #[doc = "< Opaque item handle."]
    pub handle: *mut rte_flow_item_flex_handle,
    #[doc = "< Pattern length in bytes."]
    pub length: u32,
    #[doc = "< Combined bitfields pattern to match."]
    pub pattern: *const u8,
}
#[doc = " Dummy field, used for byte boundary alignment in pattern.\n Pattern mask and data are ignored in the match. All configuration\n parameters besides field size are ignored."]
pub const rte_flow_item_flex_field_mode_FIELD_MODE_DUMMY: rte_flow_item_flex_field_mode = 0;
#[doc = " Fixed offset field. The bit offset from header beginning\n is permanent and defined by field_base parameter."]
pub const rte_flow_item_flex_field_mode_FIELD_MODE_FIXED: rte_flow_item_flex_field_mode = 1;
#[doc = " The field bit offset is extracted from other header field (indirect\n offset field). The resulting field offset to match is calculated as:\n\n    field_base + (*offset_base & offset_mask) << offset_shift"]
pub const rte_flow_item_flex_field_mode_FIELD_MODE_OFFSET: rte_flow_item_flex_field_mode = 2;
#[doc = " The field bit offset is extracted from other header field (indirect\n offset field), the latter is considered as bitmask containing some\n number of one bits, the resulting field offset to match is\n calculated as:\n\n    field_base + bitcount(*offset_base & offset_mask) << offset_shift"]
pub const rte_flow_item_flex_field_mode_FIELD_MODE_BITMASK: rte_flow_item_flex_field_mode = 3;
#[doc = " Field bit offset calculation mode."]
pub type rte_flow_item_flex_field_mode = ::std::os::raw::c_uint;
#[doc = " The protocol header can be present in the packet only once.\n No multiple flex item flow inclusions (for inner/outer) are allowed.\n No any relations with tunnel protocols are imposed. The drivers\n can optimize hardware resource usage to handle match on single flex\n item of specific type."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_SINGLE: rte_flow_item_flex_tunnel_mode =
    0;
#[doc = " Flex item presents outer header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_OUTER: rte_flow_item_flex_tunnel_mode = 1;
#[doc = " Flex item presents inner header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_INNER: rte_flow_item_flex_tunnel_mode = 2;
#[doc = " Flex item presents either inner or outer header. The driver\n handles as many multiple inners as hardware supports."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_MULTI: rte_flow_item_flex_tunnel_mode = 3;
#[doc = " Flex item presents tunnel protocol header."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_TUNNEL: rte_flow_item_flex_tunnel_mode =
    4;
#[doc = " Flex item field tunnel mode"]
pub type rte_flow_item_flex_tunnel_mode = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex_field {
    #[doc = " Defines how match field offset is calculated over the packet."]
    pub field_mode: rte_flow_item_flex_field_mode,
    #[doc = "< Field size in bits."]
    pub field_size: u32,
    #[doc = "< Field offset in bits."]
    pub field_base: i32,
    #[doc = "< Indirect offset field offset in bits."]
    pub offset_base: u32,
    #[doc = "< Indirect offset field bit mask."]
    pub offset_mask: u32,
    #[doc = "< Indirect offset multiply factor."]
    pub offset_shift: i32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_item_flex_field {
    #[inline]
    pub fn field_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_field_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn field_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_field_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(field_id: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let field_id: u32 = unsafe { ::std::mem::transmute(field_id) };
            field_id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex_link {
    #[doc = " Preceding/following header. The item type must be always provided.\n For preceding one item must specify the header value/mask to match\n for the link be taken and start the flex item header parsing."]
    pub item: rte_flow_item,
    #[doc = " Next field value to match to continue with one of the configured\n next protocols."]
    pub next: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex_conf {
    #[doc = " Specifies the flex item and tunnel relations and tells the PMD\n whether flex item can be used for inner, outer or both headers,\n or whether flex item presents the tunnel protocol itself."]
    pub tunnel: rte_flow_item_flex_tunnel_mode,
    #[doc = " The next header offset, it presents the network header size covered\n by the flex item and can be obtained with all supported offset\n calculating methods (fixed, dedicated field, bitmask, etc)."]
    pub next_header: rte_flow_item_flex_field,
    #[doc = " Specifies the next protocol field to match with link next protocol\n values and continue packet parsing with matching link."]
    pub next_protocol: rte_flow_item_flex_field,
    #[doc = " The fields will be sampled and presented for explicit match\n with pattern in the rte_flow_flex_item. There can be multiple\n fields descriptors, the number should be specified by nb_samples."]
    pub sample_data: *mut rte_flow_item_flex_field,
    #[doc = " Number of field descriptors in the sample_data array."]
    pub nb_samples: u32,
    #[doc = " Input link defines the flex item relation with preceding\n header. It specified the preceding item type and provides pattern\n to match. The flex item will continue parsing and will provide the\n data to flow match in case if there is the match with one of input\n links."]
    pub input_link: *mut rte_flow_item_flex_link,
    #[doc = " Number of link descriptors in the input link array."]
    pub nb_inputs: u32,
    #[doc = " Output link defines the next protocol field value to match and\n the following protocol header to continue packet parsing. Also\n defines the tunnel-related behaviour."]
    pub output_link: *mut rte_flow_item_flex_link,
    #[doc = " Number of link descriptors in the output link array."]
    pub nb_outputs: u32,
}
#[doc = " RTE_FLOW_ITEM_TYPE_METER_COLOR.\n\n Matches Color Marker set by a Meter."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_meter_color {
    #[doc = "< Meter color marker."]
    pub color: rte_color,
}
unsafe extern "C" {
    pub static rte_flow_item_meter_color_mask: rte_flow_item_meter_color;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_AGGR_AFFINITY\n\n For multiple ports aggregated to a single DPDK port,\n match the aggregated port receiving the packets."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_aggr_affinity {
    #[doc = " An aggregated port receiving the packets.\n Numbering starts from 1.\n Number of aggregated ports is reported by rte_eth_dev_count_aggr_ports()."]
    pub affinity: u8,
}
unsafe extern "C" {
    pub static rte_flow_item_aggr_affinity_mask: rte_flow_item_aggr_affinity;
}
#[doc = " RTE_FLOW_ITEM_TYPE_TX_QUEUE\n\n Tx queue number.\n\n @see struct rte_flow_item_tx_queue"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_tx_queue {
    #[doc = " Tx queue number of packet being transmitted."]
    pub tx_queue: u16,
}
unsafe extern "C" {
    pub static rte_flow_item_tx_queue_mask: rte_flow_item_tx_queue;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PTYPE\n\n Matches the packet type as defined in rte_mbuf_ptype."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ptype {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
}
unsafe extern "C" {
    pub static rte_flow_item_ptype_mask: rte_flow_item_ptype;
}
#[doc = "< Start of a packet."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_START: rte_flow_field_id = 0;
#[doc = "< Destination MAC Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_MAC_DST: rte_flow_field_id = 1;
#[doc = "< Source MAC Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_MAC_SRC: rte_flow_field_id = 2;
#[doc = "< VLAN Tag Identifier."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_VLAN_TYPE: rte_flow_field_id = 3;
#[doc = "< VLAN Identifier."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_VLAN_ID: rte_flow_field_id = 4;
#[doc = "< EtherType."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_MAC_TYPE: rte_flow_field_id = 5;
#[doc = "< IPv4 DSCP."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_DSCP: rte_flow_field_id = 6;
#[doc = "< IPv4 Time To Live."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_TTL: rte_flow_field_id = 7;
#[doc = "< IPv4 Source Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_SRC: rte_flow_field_id = 8;
#[doc = "< IPv4 Destination Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_DST: rte_flow_field_id = 9;
#[doc = "< IPv6 DSCP."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_DSCP: rte_flow_field_id = 10;
#[doc = "< IPv6 Hop Limit."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_HOPLIMIT: rte_flow_field_id = 11;
#[doc = "< IPv6 Source Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_SRC: rte_flow_field_id = 12;
#[doc = "< IPv6 Destination Address."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_DST: rte_flow_field_id = 13;
#[doc = "< TCP Source Port Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_PORT_SRC: rte_flow_field_id = 14;
#[doc = "< TCP Destination Port Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_PORT_DST: rte_flow_field_id = 15;
#[doc = "< TCP Sequence Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_SEQ_NUM: rte_flow_field_id = 16;
#[doc = "< TCP Acknowledgment Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_ACK_NUM: rte_flow_field_id = 17;
#[doc = "< TCP Flags."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_FLAGS: rte_flow_field_id = 18;
#[doc = "< UDP Source Port Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_UDP_PORT_SRC: rte_flow_field_id = 19;
#[doc = "< UDP Destination Port Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_UDP_PORT_DST: rte_flow_field_id = 20;
#[doc = "< VXLAN Network Identifier."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_VXLAN_VNI: rte_flow_field_id = 21;
#[doc = "< GENEVE Network Identifier."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GENEVE_VNI: rte_flow_field_id = 22;
#[doc = "< GTP Tunnel Endpoint Identifier."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GTP_TEID: rte_flow_field_id = 23;
#[doc = "< Tag value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TAG: rte_flow_field_id = 24;
#[doc = "< Mark value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_MARK: rte_flow_field_id = 25;
#[doc = "< Metadata value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_META: rte_flow_field_id = 26;
#[doc = "< Memory pointer."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_POINTER: rte_flow_field_id = 27;
#[doc = "< Immediate value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_VALUE: rte_flow_field_id = 28;
#[doc = "< IPv4 ECN."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_ECN: rte_flow_field_id = 29;
#[doc = "< IPv6 ECN."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_ECN: rte_flow_field_id = 30;
#[doc = "< GTP QFI."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GTP_PSC_QFI: rte_flow_field_id = 31;
#[doc = "< Meter color marker."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_METER_COLOR: rte_flow_field_id = 32;
#[doc = "< IPv6 next header."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_PROTO: rte_flow_field_id = 33;
#[doc = "< Flex item."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_FLEX_ITEM: rte_flow_field_id = 34;
#[doc = "< Hash result."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_HASH_RESULT: rte_flow_field_id = 35;
#[doc = "< GENEVE option type."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GENEVE_OPT_TYPE: rte_flow_field_id = 36;
#[doc = "< GENEVE option class."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GENEVE_OPT_CLASS: rte_flow_field_id = 37;
#[doc = "< GENEVE option data."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_GENEVE_OPT_DATA: rte_flow_field_id = 38;
#[doc = "< MPLS header."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_MPLS: rte_flow_field_id = 39;
#[doc = "< TCP data offset."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_TCP_DATA_OFFSET: rte_flow_field_id = 40;
#[doc = "< IPv4 IHL."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_IHL: rte_flow_field_id = 41;
#[doc = "< IPv4 total length."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_TOTAL_LEN: rte_flow_field_id = 42;
#[doc = "< IPv6 payload length."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_PAYLOAD_LEN: rte_flow_field_id = 43;
#[doc = "< IPv4 next protocol."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV4_PROTO: rte_flow_field_id = 44;
#[doc = "< IPv6 flow label."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_FLOW_LABEL: rte_flow_field_id = 45;
#[doc = "< IPv6 traffic class."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_IPV6_TRAFFIC_CLASS: rte_flow_field_id = 46;
#[doc = "< ESP SPI."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_ESP_SPI: rte_flow_field_id = 47;
#[doc = "< ESP Sequence Number."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_ESP_SEQ_NUM: rte_flow_field_id = 48;
#[doc = "< ESP next protocol value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_ESP_PROTO: rte_flow_field_id = 49;
#[doc = "< Random value."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_RANDOM: rte_flow_field_id = 50;
#[doc = "< VXLAN last reserved byte."]
pub const rte_flow_field_id_RTE_FLOW_FIELD_VXLAN_LAST_RSVD: rte_flow_field_id = 51;
#[doc = " Packet header field IDs, used by RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n and RTE_FLOW_ITEM_TYPE_COMPARE."]
pub type rte_flow_field_id = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Packet header field descriptions, used by RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n and RTE_FLOW_ITEM_TYPE_COMPARE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_field_data {
    #[doc = "< Field or memory type ID."]
    pub field: rte_flow_field_id,
    pub __bindgen_anon_1: rte_flow_field_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_field_data__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_field_data__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Immediate value for RTE_FLOW_FIELD_VALUE, presented in the\n same byte order and length as in relevant rte_flow_item_xxx.\n The immediate source bitfield offset is inherited from\n the destination's one."]
    pub value: [u8; 16usize],
    #[doc = " Memory address for RTE_FLOW_FIELD_POINTER, memory layout\n should be the same as for relevant field in the\n rte_flow_item_xxx structure."]
    pub pvalue: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_field_data__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Number of bits to skip from a field."]
    pub offset: u32,
}
#[doc = " Encapsulation level and tag index or flex item handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub flex_handle: *mut rte_flow_item_flex_handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Packet encapsulation level containing\n the field to modify.\n\n - @p 0 requests the default behavior.\n   Depending on the packet type, it\n   can mean outermost, innermost or\n   anything in between.\n\n   It basically stands for the\n   innermost encapsulation level.\n   Modification can be performed\n   according to PMD and device\n   capabilities.\n\n - @p 1 requests modification to be\n   performed on the outermost packet\n   encapsulation level.\n\n - @p 2 and subsequent values request\n   modification to be performed on\n   the specified inner packet\n   encapsulation level, from\n   outermost to innermost (lower to\n   higher values).\n\n Values other than @p 0 are not\n necessarily supported.\n\n @note that for MPLS field,\n encapsulation level also include\n tunnel since MPLS may appear in\n outer, inner or tunnel."]
    pub level: u8,
    pub __bindgen_anon_1:
        rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { # [doc = " Tag index array inside\n encapsulation level.\n Used for VLAN, MPLS or TAG types."] pub tag_index : u8 , pub __bindgen_anon_1 : rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[doc = " Geneve option identifier.\n Relevant only for\n RTE_FLOW_FIELD_GENEVE_OPT_XXXX\n modification type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_field_data__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    #[doc = " Geneve option type."]
    pub type_: u8,
    #[doc = " Geneve option class."]
    pub class_id: rte_be16_t,
}
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_EQ: rte_flow_item_compare_op = 0;
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_NE: rte_flow_item_compare_op = 1;
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_LT: rte_flow_item_compare_op = 2;
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_LE: rte_flow_item_compare_op = 3;
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_GT: rte_flow_item_compare_op = 4;
pub const rte_flow_item_compare_op_RTE_FLOW_ITEM_COMPARE_GE: rte_flow_item_compare_op = 5;
#[doc = " Expected operation types for compare item."]
pub type rte_flow_item_compare_op = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ITEM_TYPE_COMPARE\n\n Matches the packet with compare result.\n\n The operation means a compare with b result."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_compare {
    pub operation: rte_flow_item_compare_op,
    pub a: rte_flow_field_data,
    pub b: rte_flow_field_data,
    pub width: u32,
}
#[doc = " End marker for action lists. Prevents further processing of\n actions, thereby ending the list.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_END: rte_flow_action_type = 0;
#[doc = " Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VOID: rte_flow_action_type = 1;
#[doc = " Leaves traffic up for additional processing by subsequent flow\n rules; makes a flow rule non-terminating.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PASSTHRU: rte_flow_action_type = 2;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n See struct rte_flow_action_jump."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP: rte_flow_action_type = 3;
#[doc = " Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and\n RTE_MBUF_F_RX_FDIR_ID mbuf flags.\n\n See struct rte_flow_action_mark.\n\n One should negotiate mark delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_MARK"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MARK: rte_flow_action_type = 4;
#[doc = " Flags packets. Similar to MARK without a specific value; only\n sets the RTE_MBUF_F_RX_FDIR mbuf flag.\n\n No associated configuration structure.\n\n One should negotiate flag delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_FLAG"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_FLAG: rte_flow_action_type = 5;
#[doc = " Assigns packets to a given queue index.\n\n See struct rte_flow_action_queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUEUE: rte_flow_action_type = 6;
#[doc = " Drops packets.\n\n PASSTHRU overrides this action if both are specified.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DROP: rte_flow_action_type = 7;
#[doc = " Enables counters for this flow rule.\n\n These counters can be retrieved and reset through rte_flow_query() or\n rte_flow_action_handle_query() if the action provided via handle,\n see struct rte_flow_query_count.\n\n See struct rte_flow_action_count."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_COUNT: rte_flow_action_type = 8;
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets\n to spread them among several queues according to the provided\n parameters.\n\n See struct rte_flow_action_rss."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RSS: rte_flow_action_type = 9;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to the physical function (PF) of the\n current device.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PF: rte_flow_action_type = 10;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given virtual function of the\n current device.\n\n See struct rte_flow_action_vf."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VF: rte_flow_action_type = 11;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given DPDK port ID.\n\n See struct rte_flow_action_port_id."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_ID: rte_flow_action_type = 12;
#[doc = " Traffic metering and policing (MTR).\n\n See struct rte_flow_action_meter.\n See file rte_mtr.h for MTR object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER: rte_flow_action_type = 13;
#[doc = " Redirects packets to security engine of current device for security\n processing as specified by security session.\n\n See struct rte_flow_action_security."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SECURITY: rte_flow_action_type = 14;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by\n the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: rte_flow_action_type = 15;
#[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined\n by the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: rte_flow_action_type = 16;
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_vlan."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: rte_flow_action_type = 17;
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_vid."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: rte_flow_action_type = 18;
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_pcp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: rte_flow_action_type = 19;
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined\n by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_pop_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: rte_flow_action_type = 20;
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: rte_flow_action_type = 21;
#[doc = " Encapsulate flow in VXLAN tunnel as defined in\n rte_flow_action_vxlan_encap action structure.\n\n See struct rte_flow_action_vxlan_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: rte_flow_action_type = 22;
#[doc = " Decapsulate outer most VXLAN tunnel from matched flow.\n\n If flow pattern does not define a valid VXLAN tunnel (as specified by\n RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: rte_flow_action_type = 23;
#[doc = " Encapsulate flow in NVGRE tunnel defined in the\n rte_flow_action_nvgre_encap action structure.\n\n See struct rte_flow_action_nvgre_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: rte_flow_action_type = 24;
#[doc = " Decapsulate outer most NVGRE tunnel from matched flow.\n\n If flow pattern does not define a valid NVGRE tunnel (as specified by\n RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: rte_flow_action_type = 25;
#[doc = " Add outer header whose template is provided in its data buffer\n\n See struct rte_flow_action_raw_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_ENCAP: rte_flow_action_type = 26;
#[doc = " Remove outer header whose template is provided in its data buffer.\n\n See struct rte_flow_action_raw_decap"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_DECAP: rte_flow_action_type = 27;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 source address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: rte_flow_action_type = 28;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 destination address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: rte_flow_action_type = 29;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 source address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: rte_flow_action_type = 30;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 destination address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: rte_flow_action_type = 31;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify source port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_SRC: rte_flow_action_type = 32;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify destination port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_DST: rte_flow_action_type = 33;
#[doc = " Swap the source and destination MAC addresses in the outermost\n Ethernet header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MAC_SWAP: rte_flow_action_type = 34;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease TTL value directly\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TTL: rte_flow_action_type = 35;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set TTL value\n\n See struct rte_flow_action_set_ttl"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TTL: rte_flow_action_type = 36;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set source MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: rte_flow_action_type = 37;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set destination MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_DST: rte_flow_action_type = 38;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase sequence number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: rte_flow_action_type = 39;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease sequence number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: rte_flow_action_type = 40;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: rte_flow_action_type = 41;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: rte_flow_action_type = 42;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set Tag.\n\n Tag is for internal flow usage only and\n is not delivered to the application.\n\n See struct rte_flow_action_set_tag."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TAG: rte_flow_action_type = 43;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set metadata on ingress or egress path.\n\n See struct rte_flow_action_set_meta."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_META: rte_flow_action_type = 44;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP: rte_flow_action_type = 45;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP: rte_flow_action_type = 46;
#[doc = " Report as aged flow if timeout passed without any matching on the\n flow.\n\n See struct rte_flow_action_age.\n See function rte_flow_get_q_aged_flows\n See function rte_flow_get_aged_flows\n see enum RTE_ETH_EVENT_FLOW_AGED\n See struct rte_flow_query_age\n See struct rte_flow_update_age"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_AGE: rte_flow_action_type = 47;
#[doc = " The matching packets will be duplicated with specified ratio and\n applied with own set of actions with a fate action.\n\n See struct rte_flow_action_sample."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SAMPLE: rte_flow_action_type = 48;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_INDIRECT\n\n Describe action shared across multiple flow rules.\n\n Allow multiple rules reference the same action by handle (see\n struct rte_flow_shared_action)."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SHARED: rte_flow_action_type = 49;
#[doc = " Modify a packet header field, tag, mark or metadata.\n\n Allow the modification of an arbitrary header field via\n set, add and sub operations or copying its content into\n tag, meta or mark for future processing.\n\n See struct rte_flow_action_modify_field."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MODIFY_FIELD: rte_flow_action_type = 50;
#[doc = " An action handle is referenced in a rule through an indirect action.\n\n The same action handle may be used in multiple rules for the same\n or different ethdev ports."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT: rte_flow_action_type = 51;
#[doc = " [META]\n\n Enable tracking a TCP connection state.\n\n @see struct rte_flow_action_conntrack."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_CONNTRACK: rte_flow_action_type = 52;
#[doc = " Color the packet to reflect the meter color result.\n Set the meter color in the mbuf to the selected color.\n\n See struct rte_flow_action_meter_color."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_COLOR: rte_flow_action_type = 53;
#[doc = " At embedded switch level, sends matching traffic to the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR: rte_flow_action_type = 54;
#[doc = " At embedded switch level, send matching traffic to\n the entity represented by the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT: rte_flow_action_type = 55;
#[doc = " Traffic metering and marking (MTR).\n\n @see struct rte_flow_action_meter_mark\n See file rte_mtr.h for MTR profile object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_MARK: rte_flow_action_type = 56;
#[doc = " Send packets to the kernel, without going to userspace at all.\n The packets will be received by the kernel driver sharing\n the same device as the DPDK port on which this action is configured.\n This action mostly suits bifurcated driver model.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SEND_TO_KERNEL: rte_flow_action_type = 57;
#[doc = " Apply the quota verdict (PASS or BLOCK) to a flow.\n\n @see struct rte_flow_action_quota\n @see struct rte_flow_query_quota\n @see struct rte_flow_update_quota"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUOTA: rte_flow_action_type = 58;
#[doc = " Skip congestion management configuration.\n\n Using rte_eth_cman_config_set(), the application\n can configure ethdev Rx queue's congestion mechanism.\n This flow action allows to skip the congestion configuration\n applied to the given ethdev Rx queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SKIP_CMAN: rte_flow_action_type = 59;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH\n\n Push IPv6 extension into IPv6 packet.\n\n @see struct rte_flow_action_ipv6_ext_push."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH: rte_flow_action_type = 60;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE\n\n Remove IPv6 extension from IPv6 packet whose type\n is provided in its configuration buffer.\n\n @see struct rte_flow_action_ipv6_ext_remove."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE: rte_flow_action_type = 61;
#[doc = " Action handle to reference flow actions list.\n\n @see struct rte_flow_action_indirect_list"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT_LIST: rte_flow_action_type = 62;
#[doc = " Program action. These actions are defined by the program currently\n loaded on the device. For example, these actions are applicable to\n devices that can be programmed through the P4 language.\n\n @see struct rte_flow_action_prog."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PROG: rte_flow_action_type = 63;
#[doc = " NAT64 translation of IPv4/IPv6 headers.\n\n @see struct rte_flow_action_nat64"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NAT64: rte_flow_action_type = 64;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX,\n\n Redirects packets to a particular index in a flow table.\n\n @see struct rte_flow_action_jump_to_table_index."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX: rte_flow_action_type = 65;
#[doc = " Action types.\n\n Each possible action is represented by a type.\n An action can have an associated configuration object.\n Several actions combined in a list can be assigned\n to a flow rule and are performed in order.\n\n They fall in three categories:\n\n - Actions that modify the fate of matching traffic, for instance by\n   dropping or assigning it a specific destination.\n\n - Actions that modify matching traffic contents or its properties. This\n   includes adding/removing encapsulation, encryption, compression and\n   marks.\n\n - Actions related to the flow rule itself, such as updating counters or\n   making it non-terminating.\n\n Flow rules being terminating by default, not specifying any action of the\n fate kind results in undefined behavior. This applies to both ingress and\n egress.\n\n PASSTHRU, when supported, makes a flow rule non-terminating."]
pub type rte_flow_action_type = ::std::os::raw::c_uint;
#[doc = "< Count packets."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_PACKET: rte_flow_quota_mode = 1;
#[doc = "< Count packet bytes starting from L2."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_L2: rte_flow_quota_mode = 2;
#[doc = "< Count packet bytes starting from L3."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_L3: rte_flow_quota_mode = 3;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n QUOTA operational mode.\n\n @see struct rte_flow_action_quota"]
pub type rte_flow_quota_mode = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create QUOTA action.\n\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_quota {
    #[doc = "< Quota operational mode."]
    pub mode: rte_flow_quota_mode,
    #[doc = "< Quota value."]
    pub quota: i64,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query indirect QUOTA action.\n\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_query_quota {
    #[doc = "< Quota value."]
    pub quota: i64,
}
#[doc = "< Set new quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_SET: rte_flow_update_quota_op = 0;
#[doc = "< Increase quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_ADD: rte_flow_update_quota_op = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Indirect QUOTA update operations.\n\n @see struct rte_flow_update_quota"]
pub type rte_flow_update_quota_op = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n @see RTE_FLOW_ACTION_TYPE_QUOTA\n\n Update indirect QUOTA action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_update_quota {
    #[doc = "< Update operation."]
    pub op: rte_flow_update_quota_op,
    #[doc = "< Quota value."]
    pub quota: i64,
}
#[doc = " RTE_FLOW_ACTION_TYPE_MARK\n\n Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and\n RTE_MBUF_F_RX_FDIR_ID mbuf flags.\n\n This value is arbitrary and application-defined. Maximum allowed value\n depends on the underlying implementation. It is returned in the\n hash.fdir.hi mbuf field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_mark {
    #[doc = "< Integer value to return with packets."]
    pub id: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n In a hierarchy of groups, which can be used to represent physical or logical\n flow tables on the device, this action allows the action to be a redirect to\n a group on that device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_jump {
    pub group: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_QUEUE\n\n Assign packets to a given queue index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_queue {
    #[doc = "< Queue index to use."]
    pub index: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_AGE\n\n Report flow as aged-out if timeout passed without any matching\n on the flow. RTE_ETH_EVENT_FLOW_AGED event is triggered when a\n port detects new aged-out flows.\n\n The flow context and the flow handle will be reported by the either\n rte_flow_get_aged_flows or rte_flow_get_q_aged_flows APIs."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_age {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " The user flow context, NULL means the rte_flow pointer."]
    pub context: *mut ::std::os::raw::c_void,
}
impl rte_flow_action_age {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_AGE (query)\n\n Query structure to retrieve the aging status information of a\n shared AGE action, or a flow rule using the AGE action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_query_age {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_query_age {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sec_since_last_hit_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sec_since_last_hit_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sec_since_last_hit_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sec_since_last_hit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sec_since_last_hit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sec_since_last_hit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        aged: u32,
        sec_since_last_hit_valid: u32,
        sec_since_last_hit: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let aged: u32 = unsafe { ::std::mem::transmute(aged) };
            aged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sec_since_last_hit_valid: u32 =
                unsafe { ::std::mem::transmute(sec_since_last_hit_valid) };
            sec_since_last_hit_valid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let sec_since_last_hit: u32 = unsafe { ::std::mem::transmute(sec_since_last_hit) };
            sec_since_last_hit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_AGE\n\n Update indirect AGE action attributes:\n  - Timeout can be updated including stop/start action:\n     +-------------+-------------+------------------------------+\n     | Old Timeout | New Timeout | Updating                     |\n     +=============+=============+==============================+\n     | 0           | positive    | Start aging with new value   |\n     +-------------+-------------+------------------------------+\n     | positive    | 0           | Stop aging\t\t\t  |\n     +-------------+-------------+------------------------------+\n     | positive    | positive    | Change timeout to new value  |\n     +-------------+-------------+------------------------------+\n  - sec_since_last_hit can be reset."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_update_age {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_update_age {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timeout_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timeout_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn touch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn touch_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_touch_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        timeout_valid: u32,
        timeout: u32,
        touch: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let timeout_valid: u32 = unsafe { ::std::mem::transmute(timeout_valid) };
            timeout_valid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let touch: u32 = unsafe { ::std::mem::transmute(touch) };
            touch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_COUNT\n\n Adds a counter action to a matched flow.\n\n If more than one count action is specified in a single flow rule, then each\n action must specify a unique ID.\n\n Counters can be retrieved and reset through ``rte_flow_query()``, see\n ``struct rte_flow_query_count``.\n\n For ports within the same switch domain then the counter ID namespace extends\n to all ports within that switch domain."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_count {
    #[doc = "< Counter ID."]
    pub id: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT (query)\n\n Query structure to retrieve and reset flow rule counters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_query_count {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Number of hits for this rule [out]."]
    pub hits: u64,
    #[doc = "< Number of bytes through this rule [out]."]
    pub bytes: u64,
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hits_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hits_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_RSS\n\n Similar to QUEUE, except RSS is additionally performed on packets to\n spread them among several queues according to the provided parameters.\n\n Unlike global RSS settings used by other DPDK APIs, unsetting the\n @p types field does not disable RSS in a flow rule. Doing so instead\n requests safe unspecified \"best-effort\" settings from the underlying PMD,\n which depending on the flow rule, may result in anything ranging from\n empty (single queue) to all-inclusive RSS.\n\n Note: RSS hash result is stored in the hash.rss mbuf field which overlaps\n hash.fdir.lo. Since the MARK action sets the hash.fdir.hi field only,\n both can be requested simultaneously."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_rss {
    #[doc = "< RSS hash function to apply."]
    pub func: rte_eth_hash_function,
    #[doc = " Packet encapsulation level RSS hash @p types apply to.\n\n - @p 0 requests the default behavior. Depending on the packet\n   type, it can mean outermost, innermost, anything in between or\n   even no RSS.\n\n   It basically stands for the innermost encapsulation level RSS\n   can be performed on according to PMD and device capabilities.\n\n - @p 1 requests RSS to be performed on the outermost packet\n   encapsulation level.\n\n - @p 2 and subsequent values request RSS to be performed on the\n   specified inner packet encapsulation level, from outermost to\n   innermost (lower to higher values).\n\n Values other than @p 0 are not necessarily supported.\n\n Requesting a specific RSS level on unrecognized traffic results\n in undefined behavior. For predictable results, it is recommended\n to make the flow rule pattern match packet headers up to the\n requested encapsulation level so that only matching traffic goes\n through."]
    pub level: u32,
    #[doc = "< Specific RSS hash types (see RTE_ETH_RSS_*)."]
    pub types: u64,
    #[doc = "< Hash key length in bytes."]
    pub key_len: u32,
    #[doc = "< Number of entries in @p queue."]
    pub queue_num: u32,
    #[doc = "< Hash key."]
    pub key: *const u8,
    #[doc = "< Queue indices to use."]
    pub queue: *const u16,
}
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n RTE_FLOW_ACTION_TYPE_VF\n\n Directs matching traffic to a given virtual function of the current\n device.\n\n Packets matched by a VF pattern item can be redirected to their original\n VF ID instead of the specified one. This parameter may not be available\n and is not guaranteed to work properly if the VF part is matched by a\n prior flow rule or if packets are not addressed to a VF in the first\n place."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_vf {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< VF ID."]
    pub id: u32,
}
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn original_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_original_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n RTE_FLOW_ACTION_TYPE_PORT_ID\n\n Directs matching traffic to a given DPDK port ID.\n\n @see RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_port_id {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
impl rte_flow_action_port_id {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn original_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_original_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER\n\n Traffic metering and policing (MTR).\n\n Packets matched by items of this type can be either dropped or passed to the\n next item with their color set by the MTR object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_meter {
    #[doc = "< MTR object ID created with rte_mtr_create()."]
    pub mtr_id: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SECURITY\n\n Perform the security action on flows matched by the pattern items\n according to the configuration of the security session.\n\n This action modifies the payload of matched flows. For INLINE_CRYPTO, the\n security protocol headers and IV are fully provided by the application as\n specified in the flow pattern. The payload of matching packets is\n encrypted on egress, and decrypted and authenticated on ingress.\n For INLINE_PROTOCOL, the security protocol is fully offloaded to HW,\n providing full encapsulation and decapsulation of packets in security\n protocols. The flow pattern specifies both the outer security header fields\n and the inner packet fields. The security session specified in the action\n must match the pattern parameters.\n\n The security session specified in the action must be created on the same\n port as the flow action that is being specified.\n\n The ingress/egress flow attribute should match that specified in the\n security session if the security session supports the definition of the\n direction.\n\n Multiple flows can be configured to use the same security session.\n\n The NULL value is allowed for security session. If security session is NULL,\n then SPI field in ESP flow item and IP addresses in flow items 'IPv4' and\n 'IPv6' will be allowed to be a range. The rule thus created can enable\n security processing on multiple flows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_security {
    #[doc = "< Pointer to security session structure."]
    pub security_session: *mut ::std::os::raw::c_void,
}
#[doc = "< IPv6 to IPv4 headers translation."]
pub const rte_flow_nat64_type_RTE_FLOW_NAT64_6TO4: rte_flow_nat64_type = 0;
#[doc = "< IPv4 to IPv6 headers translation."]
pub const rte_flow_nat64_type_RTE_FLOW_NAT64_4TO6: rte_flow_nat64_type = 1;
#[doc = " NAT64 translation type for IP headers."]
pub type rte_flow_nat64_type = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ACTION_TYPE_NAT64\n\n Specify the NAT64 translation type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_nat64 {
    pub type_: rte_flow_nat64_type,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN\n\n Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_of_push_vlan {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID\n\n Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as defined by\n the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_vid {
    #[doc = "< VLAN ID."]
    pub vlan_vid: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP\n\n Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as defined by\n the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_pcp {
    #[doc = "< VLAN priority."]
    pub vlan_pcp: u8,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_POP_MPLS\n\n Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_of_pop_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS\n\n Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_of_push_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP\n\n VXLAN tunnel end-point encapsulation data definition\n\n The tunnel definition is provided through the flow item pattern, the\n provided pattern must conform to RFC7348 for the tunnel specified. The flow\n definition must be provided in order from the RTE_FLOW_ITEM_TYPE_ETH\n definition up the end item which is specified by RTE_FLOW_ITEM_TYPE_END.\n\n The mask field allows user to specify which fields in the flow item\n definitions can be ignored and which have valid data and can be used\n verbatim.\n\n Note: the last field is not used in the definition of a tunnel and can be\n ignored.\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP include:\n\n - ETH / IPV4 / UDP / VXLAN / END\n - ETH / IPV6 / UDP / VXLAN / END\n - ETH / VLAN / IPV4 / UDP / VXLAN / END"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_vxlan_encap {
    #[doc = " Encapsulating vxlan tunnel definition\n (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP\n\n NVGRE tunnel end-point encapsulation data definition\n\n The tunnel definition is provided through the flow item pattern  the\n provided pattern must conform with RFC7637. The flow definition must be\n provided in order from the RTE_FLOW_ITEM_TYPE_ETH definition up the end item\n which is specified by RTE_FLOW_ITEM_TYPE_END.\n\n The mask field allows user to specify which fields in the flow item\n definitions can be ignored and which have valid data and can be used\n verbatim.\n\n Note: the last field is not used in the definition of a tunnel and can be\n ignored.\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP include:\n\n - ETH / IPV4 / NVGRE / END\n - ETH / VLAN / IPV6 / NVGRE / END"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_nvgre_encap {
    #[doc = " Encapsulating nvgre tunnel definition\n (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_RAW_ENCAP\n\n Raw tunnel end-point encapsulation data definition.\n\n The data holds the headers definitions to be applied on the packet.\n The data must start with ETH header up to the tunnel item header itself.\n When used right after RAW_DECAP (for decapsulating L3 tunnel type for\n example MPLSoGRE) the data will just hold layer 2 header.\n\n The preserve parameter holds which bits in the packet the PMD is not allowed\n to change, this parameter can also be NULL and then the PMD is allowed\n to update any field.\n\n size holds the number of bytes in @p data and @p preserve."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_raw_encap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Bit-mask of @p data to preserve on output."]
    pub preserve: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_RAW_DECAP\n\n Raw tunnel end-point decapsulation data definition.\n\n The data holds the headers definitions to be removed from the packet.\n The data must start with ETH header up to the tunnel item header itself.\n When used right before RAW_DECAP (for encapsulating L3 tunnel type for\n example MPLSoGRE) the data will just hold layer 2 header.\n\n size holds the number of bytes in @p data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_raw_decap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC\n RTE_FLOW_ACTION_TYPE_SET_IPV4_DST\n\n Allows modification of IPv4 source (RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC)\n and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV4_DST) in the\n specified outermost IPv4 header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_ipv4 {
    pub ipv4_addr: rte_be32_t,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC\n RTE_FLOW_ACTION_TYPE_SET_IPV6_DST\n\n Allows modification of IPv6 source (RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC)\n and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV6_DST) in the\n specified outermost IPv6 header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_ipv6 {
    pub ipv6_addr: rte_ipv6_addr,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH include:\n\n - IPV6_EXT TYPE / IPV6_EXT_HEADER_IN_TYPE / END\n\n The data must be added as the last IPv6 extension."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_ipv6_ext_push {
    #[doc = "< IPv6 extension header data."]
    pub data: *mut u8,
    #[doc = "< Size (in bytes) of @p data."]
    pub size: usize,
    #[doc = "< Type of IPv6 extension."]
    pub type_: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE include:\n\n - IPV6_EXT TYPE / END"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_ipv6_ext_remove {
    #[doc = "< Type of IPv6 extension."]
    pub type_: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_TP_SRC\n RTE_FLOW_ACTION_TYPE_SET_TP_DST\n\n Allows modification of source (RTE_FLOW_ACTION_TYPE_SET_TP_SRC)\n and destination (RTE_FLOW_ACTION_TYPE_SET_TP_DST) port numbers\n in the specified outermost TCP/UDP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_tp {
    pub port: rte_be16_t,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TTL\n\n Set the TTL value directly for IPv4 or IPv6"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_ttl {
    pub ttl_value: u8,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_MAC\n\n Set MAC address from the matched flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_mac {
    pub mac_addr: [u8; 6usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_TAG\n\n Set a tag which is a transient data used during flow matching. This is not\n delivered to application. Multiple tags are supported by specifying index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_tag {
    pub data: u32,
    pub mask: u32,
    pub index: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_META\n\n Set metadata. Metadata set by mbuf metadata dynamic field with\n RTE_MBUF_DYNFLAG_TX_METADATA flag on egress will be overridden by this\n action. On ingress, the metadata will be carried by mbuf metadata dynamic\n field with RTE_MBUF_DYNFLAG_RX_METADATA flag if set.  The dynamic mbuf field\n must be registered in advance by rte_flow_dynf_metadata_register().\n\n Altering partial bits is supported with mask. For bits which have never\n been set, unpredictable value will be seen depending on driver\n implementation. For loopback/hairpin packet, metadata set on Rx/Tx may\n or may not be propagated to the other path depending on HW capability.\n\n RTE_FLOW_ITEM_TYPE_META matches metadata."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_meta {
    pub data: u32,
    pub mask: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP\n RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP\n\n Set the DSCP value for IPv4/IPv6 header.\n DSCP in low 6 bits, rest ignored."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_set_dscp {
    pub dscp: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_INDIRECT\n\n Opaque type returned after successfully creating an indirect action object.\n The definition of the object handle is different per driver or\n per direct action type.\n\n This handle can be used to manage and query the related direct action:\n - referenced in single flow rule or across multiple flow rules\n   over multiple ports\n - update action object configuration\n - query action object data\n - destroy action object"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_handle {
    _unused: [u8; 0],
}
#[doc = " SYN-ACK packet was seen."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_SYN_RECV: rte_flow_conntrack_state = 0;
#[doc = " 3-way handshake was done."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_ESTABLISHED: rte_flow_conntrack_state =
    1;
#[doc = " First FIN packet was received to close the connection."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_FIN_WAIT: rte_flow_conntrack_state = 2;
#[doc = " First FIN was ACKed."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_CLOSE_WAIT: rte_flow_conntrack_state =
    3;
#[doc = " Second FIN was received, waiting for the last ACK."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_LAST_ACK: rte_flow_conntrack_state = 4;
#[doc = " Second FIN was ACKed, connection was closed."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_TIME_WAIT: rte_flow_conntrack_state = 5;
#[doc = " The state of a TCP connection."]
pub type rte_flow_conntrack_state = ::std::os::raw::c_uint;
#[doc = "< No Flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_NONE:
    rte_flow_conntrack_tcp_last_index = 0;
#[doc = "< With SYN flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_SYN:
    rte_flow_conntrack_tcp_last_index = 1;
#[doc = "< With SYNACK flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_SYNACK:
    rte_flow_conntrack_tcp_last_index = 2;
#[doc = "< With FIN flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_FIN:
    rte_flow_conntrack_tcp_last_index = 4;
#[doc = "< With ACK flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_ACK:
    rte_flow_conntrack_tcp_last_index = 8;
#[doc = "< With RST flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_RST:
    rte_flow_conntrack_tcp_last_index = 16;
#[doc = " The last passed TCP packet flags of a connection."]
pub type rte_flow_conntrack_tcp_last_index = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n Configuration parameters for each direction of a TCP connection.\n All fields should be in host byte order.\n If needed, driver should convert all fields to network byte order\n if HW needs them in that way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tcp_dir_param {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Maximal value of sequence + payload length in sent\n packets (next ACK from the opposite direction)."]
    pub sent_end: u32,
    #[doc = " Maximal value of (ACK + window size) in received packet + length\n over sent packet (maximal sequence could be sent)."]
    pub reply_end: u32,
    #[doc = " Maximal value of actual window size in sent packets."]
    pub max_win: u32,
    #[doc = " Maximal value of ACK in sent packets."]
    pub max_ack: u32,
}
impl rte_flow_tcp_dir_param {
    #[inline]
    pub fn scale(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn close_initiated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_initiated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn close_initiated_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_close_initiated_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_ack_seen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_ack_seen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_ack_seen_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_ack_seen_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn data_unacked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_unacked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_unacked_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_data_unacked_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scale: u32,
        close_initiated: u32,
        last_ack_seen: u32,
        data_unacked: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let scale: u32 = unsafe { ::std::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let close_initiated: u32 = unsafe { ::std::mem::transmute(close_initiated) };
            close_initiated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_ack_seen: u32 = unsafe { ::std::mem::transmute(last_ack_seen) };
            last_ack_seen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let data_unacked: u32 = unsafe { ::std::mem::transmute(data_unacked) };
            data_unacked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_CONNTRACK\n\n Configuration and initial state for the connection tracking module.\n This structure could be used for both setting and query.\n All fields should be in host byte order."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_conntrack {
    #[doc = " The peer port number, can be the same port."]
    pub peer_port: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The current state of this connection."]
    pub state: rte_flow_conntrack_state,
    #[doc = " Scaling factor for maximal allowed ACK window."]
    pub max_ack_window: u8,
    #[doc = " Maximal allowed number of retransmission times."]
    pub retransmission_limit: u8,
    #[doc = " TCP parameters of the original direction."]
    pub original_dir: rte_flow_tcp_dir_param,
    #[doc = " TCP parameters of the reply direction."]
    pub reply_dir: rte_flow_tcp_dir_param,
    #[doc = " The window value of the last packet passed this conntrack."]
    pub last_window: u16,
    pub last_index: rte_flow_conntrack_tcp_last_index,
    #[doc = " The sequence of the last packet passed this conntrack."]
    pub last_seq: u32,
    #[doc = " The acknowledgment of the last packet passed this conntrack."]
    pub last_ack: u32,
    #[doc = " The total value ACK + payload length of the last packet\n passed this conntrack."]
    pub last_end: u32,
}
impl rte_flow_action_conntrack {
    #[inline]
    pub fn is_original_dir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_original_dir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_original_dir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_original_dir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn live_connection(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_live_connection(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn live_connection_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_live_connection_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn selective_ack(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selective_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selective_ack_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_selective_ack_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn challenge_ack_passed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_challenge_ack_passed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn challenge_ack_passed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_challenge_ack_passed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn liberal_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_liberal_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn liberal_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_liberal_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_original_dir: u32,
        enable: u32,
        live_connection: u32,
        selective_ack: u32,
        challenge_ack_passed: u32,
        last_direction: u32,
        liberal_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_original_dir: u32 = unsafe { ::std::mem::transmute(is_original_dir) };
            is_original_dir as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable: u32 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let live_connection: u32 = unsafe { ::std::mem::transmute(live_connection) };
            live_connection as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let selective_ack: u32 = unsafe { ::std::mem::transmute(selective_ack) };
            selective_ack as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let challenge_ack_passed: u32 = unsafe { ::std::mem::transmute(challenge_ack_passed) };
            challenge_ack_passed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_direction: u32 = unsafe { ::std::mem::transmute(last_direction) };
            last_direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let liberal_mode: u32 = unsafe { ::std::mem::transmute(liberal_mode) };
            liberal_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_CONNTRACK\n\n Wrapper structure for the context update interface.\n Ports cannot support updating, and the only valid solution is to\n destroy the old context and create a new one instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_modify_conntrack {
    #[doc = " New connection tracking parameters to be updated."]
    pub new_ct: rte_flow_action_conntrack,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_modify_conntrack {
    #[inline]
    pub fn direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        direction: u32,
        state: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_METER_COLOR\n\n The meter color should be set in the packet meta-data\n (i.e. struct rte_mbuf::sched::color)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_meter_color {
    #[doc = "< Packet color."]
    pub color: rte_color,
}
#[doc = " Provides an ethdev port ID for use with the following actions:\n RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR,\n RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
#[doc = "< Set a new value."]
pub const rte_flow_modify_op_RTE_FLOW_MODIFY_SET: rte_flow_modify_op = 0;
#[doc = "< Add a value to a field."]
pub const rte_flow_modify_op_RTE_FLOW_MODIFY_ADD: rte_flow_modify_op = 1;
#[doc = "< Subtract a value from a field."]
pub const rte_flow_modify_op_RTE_FLOW_MODIFY_SUB: rte_flow_modify_op = 2;
#[doc = " Operation types for MODIFY_FIELD action."]
pub type rte_flow_modify_op = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify a destination header field according to the specified\n operation. Another field of the packet can be used as a source as well\n as tag, mark, metadata, immediate value or a pointer to it."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_modify_field {
    #[doc = "< Operation to perform."]
    pub operation: rte_flow_modify_op,
    #[doc = "< Destination field."]
    pub dst: rte_flow_field_data,
    #[doc = "< Source field."]
    pub src: rte_flow_field_data,
    #[doc = "< Number of bits to use from a source field."]
    pub width: u32,
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER_MARK\n\n Traffic metering and marking (MTR).\n\n Meters a packet stream and marks its packets either\n green, yellow, or red according to the specified profile.\n The policy is optional and may be specified for defining\n subsequent actions based on a color assigned by MTR.\n Alternatively, the METER_COLOR item may be used for this."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_meter_mark {
    pub profile: *mut rte_flow_meter_profile,
    pub policy: *mut rte_flow_meter_policy,
    #[doc = " Metering mode: 0 - Color-Blind, 1 - Color-Aware."]
    pub color_mode: ::std::os::raw::c_int,
    #[doc = " Metering state: 0 - Disabled, 1 - Enabled."]
    pub state: ::std::os::raw::c_int,
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER_MARK\n\n Wrapper structure for the context update interface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_update_meter_mark {
    #[doc = " New meter_mark parameters to be updated."]
    pub meter_mark: rte_flow_action_meter_mark,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl rte_flow_update_meter_mark {
    #[inline]
    pub fn profile_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_profile_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn profile_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_profile_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn policy_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_policy_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn policy_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_policy_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color_mode_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_mode_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_mode_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_color_mode_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile_valid: u32,
        policy_valid: u32,
        color_mode_valid: u32,
        state_valid: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let profile_valid: u32 = unsafe { ::std::mem::transmute(profile_valid) };
            profile_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let policy_valid: u32 = unsafe { ::std::mem::transmute(policy_valid) };
            policy_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let color_mode_valid: u32 = unsafe { ::std::mem::transmute(color_mode_valid) };
            color_mode_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_valid: u32 = unsafe { ::std::mem::transmute(state_valid) };
            state_valid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @see RTE_FLOW_ACTION_TYPE_METER_MARK\n @see RTE_FLOW_ACTION_TYPE_INDIRECT_LIST\n\n Update flow mutable context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_indirect_update_flow_meter_mark {
    #[doc = " Updated init color applied to packet"]
    pub init_color: rte_color,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Program action argument configuration parameters.\n\n For each action argument, its *size* must be non-zero and its *value* must\n point to a valid array of *size* bytes specified in network byte order.\n\n @see struct rte_flow_action_prog"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_prog_argument {
    #[doc = " Argument name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Argument size in bytes."]
    pub size: u32,
    #[doc = " Argument value."]
    pub value: *const u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n RTE_FLOW_ACTION_TYPE_PROG\n\n Program action configuration parameters.\n\n Each action can have zero or more arguments. When *args_num* is non-zero, the\n *args* parameter must point to a valid array of *args_num* elements.\n\n @see RTE_FLOW_ACTION_TYPE_PROG"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_prog {
    #[doc = " Action name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Number of action arguments."]
    pub args_num: u32,
    #[doc = " Action arguments array."]
    pub args: *const rte_flow_action_prog_argument,
}
unsafe extern "C" {
    pub static mut rte_flow_dynf_metadata_offs: i32;
}
unsafe extern "C" {
    pub static mut rte_flow_dynf_metadata_mask: u64;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX\n\n Redirects packets to a particular index in a flow table.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_jump_to_table_index {
    pub table: *mut rte_flow_template_table,
    pub index: u32,
}
#[doc = " Definition of a single action.\n\n A list of actions is terminated by a END action.\n\n For simple actions without a configuration object, conf remains NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[doc = " Opaque type returned after successfully creating a flow.\n\n This handle can be used to manage and query the related flow (e.g. to\n destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = " Opaque type for Meter profile object returned by MTR API.\n\n This handle can be used to create Meter actions instead of profile ID."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_meter_profile {
    _unused: [u8; 0],
}
#[doc = " Opaque type for Meter policy object returned by MTR API.\n\n This handle can be used to create Meter actions instead of policy ID."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_meter_policy {
    _unused: [u8; 0],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SAMPLE\n\n Adds a sample action to a matched flow.\n\n The matching packets will be duplicated with specified ratio and applied\n with own set of actions with a fate action, the sampled packet could be\n redirected to queue or port. All the packets continue processing on the\n default flow path.\n\n When the sample ratio is set to 1 then the packets will be 100% mirrored.\n Additional action list be supported to add for sampled or mirrored packets."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_sample {
    #[doc = "< packets sampled equals to '1/ratio'."]
    pub ratio: u32,
    #[doc = " sub-action list specific for the sampling hit cases."]
    pub actions: *const rte_flow_action,
}
#[doc = "< No error."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_NONE: rte_flow_error_type = 0;
#[doc = "< Cause unspecified."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_UNSPECIFIED: rte_flow_error_type = 1;
#[doc = "< Flow rule (handle)."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_HANDLE: rte_flow_error_type = 2;
#[doc = "< Group field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_GROUP: rte_flow_error_type = 3;
#[doc = "< Priority field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: rte_flow_error_type = 4;
#[doc = "< Ingress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: rte_flow_error_type = 5;
#[doc = "< Egress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: rte_flow_error_type = 6;
#[doc = "< Transfer field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: rte_flow_error_type = 7;
#[doc = "< Attributes structure."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR: rte_flow_error_type = 8;
#[doc = "< Pattern length."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_NUM: rte_flow_error_type = 9;
#[doc = "< Item specification."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_SPEC: rte_flow_error_type = 10;
#[doc = "< Item specification range."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_LAST: rte_flow_error_type = 11;
#[doc = "< Item specification mask."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_MASK: rte_flow_error_type = 12;
#[doc = "< Specific pattern item."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM: rte_flow_error_type = 13;
#[doc = "< Number of actions."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_NUM: rte_flow_error_type = 14;
#[doc = "< Action configuration."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_CONF: rte_flow_error_type = 15;
#[doc = "< Specific action."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION: rte_flow_error_type = 16;
#[doc = "< Current device state."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_STATE: rte_flow_error_type = 17;
#[doc = " Verbose error types.\n\n Most of them provide the type of the object referenced by struct\n rte_flow_error.cause."]
pub type rte_flow_error_type = ::std::os::raw::c_uint;
#[doc = " Verbose error structure definition.\n\n This object is normally allocated by applications and set by PMDs, the\n message points to a constant string which does not need to be freed by\n the application, however its pointer can be considered valid only as long\n as its associated DPDK port remains configured. Closing the underlying\n device or unloading the PMD invalidates it.\n\n Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_error {
    #[doc = "< Cause field and error types."]
    pub type_: rte_flow_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
#[doc = " Complete flow rule description.\n\n This object type is used when converting a flow rule description.\n\n @see RTE_FLOW_CONV_OP_RULE\n @see rte_flow_conv()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_conv_rule {
    pub __bindgen_anon_1: rte_flow_conv_rule__bindgen_ty_1,
    pub __bindgen_anon_2: rte_flow_conv_rule__bindgen_ty_2,
    pub __bindgen_anon_3: rte_flow_conv_rule__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_1 {
    #[doc = "< RO attributes."]
    pub attr_ro: *const rte_flow_attr,
    #[doc = "< Attributes."]
    pub attr: *mut rte_flow_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_2 {
    #[doc = "< RO pattern."]
    pub pattern_ro: *const rte_flow_item,
    #[doc = "< Pattern items."]
    pub pattern: *mut rte_flow_item,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_3 {
    #[doc = "< RO actions."]
    pub actions_ro: *const rte_flow_action,
    #[doc = "< List of actions."]
    pub actions: *mut rte_flow_action,
}
#[doc = " No operation to perform.\n\n rte_flow_conv() simply returns 0."]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_NONE: rte_flow_conv_op = 0;
#[doc = " Convert attributes structure.\n\n This is a basic copy of an attributes structure.\n\n - @p src type:\n   @code const struct rte_flow_attr * @endcode\n - @p dst type:\n   @code struct rte_flow_attr * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ATTR: rte_flow_conv_op = 1;
#[doc = " Convert a single item.\n\n Duplicates @p spec, @p last and @p mask but not outside objects.\n\n - @p src type:\n   @code const struct rte_flow_item * @endcode\n - @p dst type:\n   @code struct rte_flow_item * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM: rte_flow_conv_op = 2;
#[doc = " Convert a single item mask.\n\n Duplicates only @p mask.\n\n - @p src type:\n   @code const struct rte_flow_item * @endcode\n - @p dst type:\n   @code struct rte_flow_item * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM_MASK: rte_flow_conv_op = 3;
#[doc = " Convert a single action.\n\n Duplicates @p conf but not outside objects.\n\n - @p src type:\n   @code const struct rte_flow_action * @endcode\n - @p dst type:\n   @code struct rte_flow_action * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION: rte_flow_conv_op = 4;
#[doc = " Convert an entire pattern.\n\n Duplicates all pattern items at once with the same constraints as\n RTE_FLOW_CONV_OP_ITEM.\n\n - @p src type:\n   @code const struct rte_flow_item * @endcode\n - @p dst type:\n   @code struct rte_flow_item * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_PATTERN: rte_flow_conv_op = 5;
#[doc = " Convert a list of actions.\n\n Duplicates the entire list of actions at once with the same\n constraints as RTE_FLOW_CONV_OP_ACTION.\n\n - @p src type:\n   @code const struct rte_flow_action * @endcode\n - @p dst type:\n   @code struct rte_flow_action * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTIONS: rte_flow_conv_op = 6;
#[doc = " Convert a complete flow rule description.\n\n Comprises attributes, pattern and actions together at once with\n the usual constraints.\n\n - @p src type:\n   @code const struct rte_flow_conv_rule * @endcode\n - @p dst type:\n   @code struct rte_flow_conv_rule * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_RULE: rte_flow_conv_op = 7;
#[doc = " Convert item type to its name string.\n\n Writes a NUL-terminated string to @p dst. Like snprintf(), the\n returned value excludes the terminator which is always written\n nonetheless.\n\n - @p src type:\n   @code (const void *)enum rte_flow_item_type @endcode\n - @p dst type:\n   @code char * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM_NAME: rte_flow_conv_op = 8;
#[doc = " Convert action type to its name string.\n\n Writes a NUL-terminated string to @p dst. Like snprintf(), the\n returned value excludes the terminator which is always written\n nonetheless.\n\n - @p src type:\n   @code (const void *)enum rte_flow_action_type @endcode\n - @p dst type:\n   @code char * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION_NAME: rte_flow_conv_op = 9;
#[doc = " Convert item type to pointer to item name.\n\n Retrieves item name pointer from its type. The string itself is\n not copied; instead, a unique pointer to an internal static\n constant storage is written to @p dst.\n\n - @p src type:\n   @code (const void *)enum rte_flow_item_type @endcode\n - @p dst type:\n   @code const char ** @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM_NAME_PTR: rte_flow_conv_op = 10;
#[doc = " Convert action type to pointer to action name.\n\n Retrieves action name pointer from its type. The string itself is\n not copied; instead, a unique pointer to an internal static\n constant storage is written to @p dst.\n\n - @p src type:\n   @code (const void *)enum rte_flow_action_type @endcode\n - @p dst type:\n   @code const char ** @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION_NAME_PTR: rte_flow_conv_op = 11;
#[doc = " Conversion operations for flow API objects.\n\n @see rte_flow_conv()"]
pub type rte_flow_conv_op = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Dump hardware internal representation information of\n rte flow to file.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] flow\n   The pointer of flow rule to dump. Dump all rules if NULL.\n @param[in] file\n   A pointer to a file for output.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   0 on success, a negative value otherwise."]
    pub fn rte_flow_dev_dump(
        port_id: u16,
        flow: *mut rte_flow,
        file: *mut FILE,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register mbuf dynamic field and flag for metadata.\n\n This function must be called prior to use SET_META action in order to\n register the dynamic mbuf field. Otherwise, the data cannot be delivered to\n application.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_dynf_metadata_register() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check whether a flow rule can be created on a given port.\n\n The flow rule is validated for correctness and whether it could be accepted\n by the device given sufficient resources. The rule is checked against the\n current device mode and queue configuration. The flow rule may also\n optionally be validated against existing flow rules and device resources.\n This function has no effect on the target device.\n\n The returned value is guaranteed to remain valid only as long as no\n successful calls to rte_flow_create() or rte_flow_destroy() are made in\n the meantime and no device parameter affecting flow rules in any way are\n modified, due to possible collisions or resource limitations (although in\n such cases EINVAL should not be returned).\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] attr\n   Flow rule attributes.\n @param[in] pattern\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 if flow rule is valid and can be created. A negative errno value\n   otherwise (rte_errno is also set), the following errors are defined:\n\n   -ENOSYS: underlying device does not support this functionality.\n\n   -EIO: underlying device is removed.\n\n   -EINVAL: unknown or invalid rule specification.\n\n   -ENOTSUP: valid but unsupported rule specification (e.g. partial\n   bit-masks are unsupported).\n\n   -EEXIST: collision with an existing rule. Only returned if device\n   supports flow rule collision checking and there was a flow rule\n   collision. Not receiving this return code is no guarantee that creating\n   the rule will not fail due to a collision.\n\n   -ENOMEM: not enough memory to execute the function, or if the device\n   supports resource validation, resource limitation on the device.\n\n   -EBUSY: action cannot be performed due to busy device resources, may\n   succeed if the affected queues or even the entire port are in a stopped\n   state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop())."]
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a flow rule on a given port.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] attr\n   Flow rule attributes.\n @param[in] pattern\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set\n   to the positive version of one of the error codes defined for\n   rte_flow_validate()."]
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    #[doc = " Destroy a flow rule on a given port.\n\n Failure to destroy a flow rule handle may occur when other flow rules\n depend on it, and destroying it would result in an inconsistent state.\n\n This function is only guaranteed to succeed if handles are destroyed in\n reverse order of their creation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param flow\n   Flow rule handle to destroy.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update a flow rule with new actions on a given port.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param flow\n   Flow rule handle to update.\n @param[in] actions\n   Associated actions (list terminated by the END action).\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_actions_update(
        port_id: u16,
        flow: *mut rte_flow,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy all flow rules associated with a port.\n\n In the unlikely event of failure, handles are still considered destroyed\n and no longer valid but the port must be assumed to be in an inconsistent\n state.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query an existing flow rule.\n\n This function allows retrieving flow-specific data such as counters.\n Data is gathered by special actions which must be present in the flow\n rule definition.\n\n \\see RTE_FLOW_ACTION_TYPE_COUNT\n\n @param port_id\n   Port identifier of Ethernet device.\n @param flow\n   Flow rule handle to query.\n @param action\n   Action definition as defined in original flow rule.\n @param[in, out] data\n   Pointer to storage for the associated query data type.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_query(
        port_id: u16,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Restrict ingress traffic to the defined flow rules.\n\n Isolated mode guarantees that all ingress traffic comes from defined flow\n rules only (current and future).\n When enabled with a bifurcated driver,\n non-matched packets are routed to the kernel driver interface.\n When disabled (the default),\n there may be some default rules routing traffic to the DPDK port.\n\n Besides making ingress more deterministic, it allows PMDs to safely reuse\n resources otherwise assigned to handle the remaining traffic, such as\n global RSS configuration settings, VLAN filters, MAC address entries,\n legacy filter API rules and so on in order to expand the set of possible\n flow rule types.\n\n Calling this function as soon as possible after device initialization,\n ideally before the first call to rte_eth_dev_configure(), is recommended\n to avoid possible failures due to conflicting settings.\n\n Once effective, leaving isolated mode may not be possible depending on\n PMD implementation.\n\n Additionally, the following functionality has no effect on the underlying\n port and may return errors such as ENOTSUP (\"not supported\"):\n\n - Toggling promiscuous mode.\n - Toggling allmulticast mode.\n - Configuring MAC addresses.\n - Configuring multicast addresses.\n - Configuring VLAN filters.\n - Configuring Rx filters through the legacy API (e.g. FDIR).\n - Configuring global RSS settings.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param set\n   Nonzero to enter isolated mode, attempt to leave it otherwise.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_isolate(
        port_id: u16,
        set: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize flow error structure.\n\n @param[out] error\n   Pointer to flow error structure (may be NULL).\n @param code\n   Related error code (rte_errno).\n @param type\n   Cause field and error types.\n @param cause\n   Object responsible for the error.\n @param message\n   Human-readable error message.\n\n @return\n   Negative error code (errno value) and rte_errno is set."]
    pub fn rte_flow_error_set(
        error: *mut rte_flow_error,
        code: ::std::os::raw::c_int,
        type_: rte_flow_error_type,
        cause: *const ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @deprecated\n @see rte_flow_copy()"]
#[repr(C)]
pub struct rte_flow_desc {
    #[doc = "< Allocated space including data[]."]
    pub size: usize,
    #[doc = "< Attributes."]
    pub attr: rte_flow_attr,
    #[doc = "< Items."]
    pub items: *mut rte_flow_item,
    #[doc = "< Actions."]
    pub actions: *mut rte_flow_action,
    #[doc = "< Storage for items/actions."]
    pub data: __IncompleteArrayField<u8>,
}
unsafe extern "C" {
    #[doc = " @deprecated\n Copy an rte_flow rule description.\n\n This interface is kept for compatibility with older applications but is\n implemented as a wrapper to rte_flow_conv(). It is deprecated due to its\n lack of flexibility and reliance on a type unusable with C++ programs\n (struct rte_flow_desc).\n\n @param[in] fd\n   Flow rule description.\n @param[in] len\n   Total size of allocated data for the flow description.\n @param[in] attr\n   Flow rule attributes.\n @param[in] items\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n\n @return\n   If len is greater or equal to the size of the flow, the total size of the\n   flow description and its data.\n   If len is lower than the size of the flow, the number of bytes that would\n   have been written to desc had it been sufficient. Nothing is written."]
    pub fn rte_flow_copy(
        fd: *mut rte_flow_desc,
        len: usize,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Flow object conversion helper.\n\n This function performs conversion of various flow API objects to a\n pre-allocated destination buffer. See enum rte_flow_conv_op for possible\n operations and details about each of them.\n\n Since destination buffer must be large enough, it works in a manner\n reminiscent of snprintf():\n\n - If @p size is 0, @p dst may be a NULL pointer, otherwise @p dst must be\n   non-NULL.\n - If positive, the returned value represents the number of bytes needed\n   to store the conversion of @p src to @p dst according to @p op\n   regardless of the @p size parameter.\n - Since no more than @p size bytes can be written to @p dst, output is\n   truncated and may be inconsistent when the returned value is larger\n   than that.\n - In case of conversion error, a negative error code is returned and\n   @p dst contents are unspecified.\n\n @param op\n   Operation to perform, related to the object type of @p dst.\n @param[out] dst\n   Destination buffer address. Must be suitably aligned by the caller.\n @param size\n   Destination buffer size in bytes.\n @param[in] src\n   Source object to copy. Depending on @p op, its type may differ from\n   that of @p dst.\n @param[out] error\n   Perform verbose error reporting if not NULL. Initialized in case of\n   error only.\n\n @return\n   The number of bytes required to convert @p src to @p dst on success, a\n   negative errno value otherwise and rte_errno is set.\n\n @see rte_flow_conv_op"]
    pub fn rte_flow_conv(
        op: rte_flow_conv_op,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        src: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get aged-out flows of a given port.\n\n RTE_ETH_EVENT_FLOW_AGED event will be triggered when at least one new aged\n out flow was detected after the last call to rte_flow_get_aged_flows.\n This function can be called to get the aged flows asynchronously from the\n event callback or synchronously regardless the event.\n This is not safe to call rte_flow_get_aged_flows function with other flow\n functions from multiple threads simultaneously.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in, out] contexts\n   The address of an array of pointers to the aged-out flows contexts.\n @param[in] nb_contexts\n   The length of context array pointers.\n @param[out] error\n   Perform verbose error reporting if not NULL. Initialized in case of\n   error only.\n\n @return\n   if nb_contexts is 0, return the amount of all aged contexts.\n   if nb_contexts is not 0 , return the amount of aged flows reported\n   in the context array, otherwise negative errno value.\n\n @see rte_flow_action_age\n @see RTE_ETH_EVENT_FLOW_AGED"]
    pub fn rte_flow_get_aged_flows(
        port_id: u16,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get aged-out flows of a given port on the given flow queue.\n\n If application configure port attribute with RTE_FLOW_PORT_FLAG_STRICT_QUEUE,\n there is no RTE_ETH_EVENT_FLOW_AGED event and this function must be called to\n get the aged flows synchronously.\n\n If application configure port attribute without\n RTE_FLOW_PORT_FLAG_STRICT_QUEUE, RTE_ETH_EVENT_FLOW_AGED event will be\n triggered at least one new aged out flow was detected on any flow queue after\n the last call to rte_flow_get_q_aged_flows.\n In addition, the @p queue_id will be ignored.\n This function can be called to get the aged flows asynchronously from the\n event callback or synchronously regardless the event.\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue to query. Ignored when RTE_FLOW_PORT_FLAG_STRICT_QUEUE not set.\n @param[in, out] contexts\n   The address of an array of pointers to the aged-out flows contexts.\n @param[in] nb_contexts\n   The length of context array pointers.\n @param[out] error\n   Perform verbose error reporting if not NULL. Initialized in case of\n   error only.\n\n @return\n   if nb_contexts is 0, return the amount of all aged contexts.\n   if nb_contexts is not 0 , return the amount of aged flows reported\n   in the context array, otherwise negative errno value.\n\n @see rte_flow_action_age\n @see RTE_ETH_EVENT_FLOW_AGED\n @see rte_flow_port_flag"]
    pub fn rte_flow_get_q_aged_flows(
        port_id: u16,
        queue_id: u32,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Specify indirect action object configuration"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_indir_action_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_indir_action_conf {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create an indirect action object that can be used in flow rules\n via its handle.\n The created object handle has single state and configuration\n across all the flow rules using it.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] conf\n   Action configuration for the indirect action object creation.\n @param[in] action\n   Specific configuration of the indirect action object.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set\n   to one of the error codes defined:\n   - (ENODEV) if *port_id* invalid.\n   - (ENOSYS) if underlying device does not support this functionality.\n   - (EIO) if underlying device is removed.\n   - (EINVAL) if *action* invalid.\n   - (ENOTSUP) if *action* valid but unsupported."]
    pub fn rte_flow_action_handle_create(
        port_id: u16,
        conf: *const rte_flow_indir_action_conf,
        action: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_handle;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destroy indirect action by handle.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] handle\n   Handle for the indirect action object to be destroyed.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-ENOENT) if action pointed by *action* handle was not found.\n   - (-EBUSY) if action pointed by *action* handle still used by some rules\n   rte_errno is also set."]
    pub fn rte_flow_action_handle_destroy(
        port_id: u16,
        handle: *mut rte_flow_action_handle,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Update in-place the action configuration and / or state pointed\n by action *handle* with the configuration provided as *update* argument.\n The update of the action configuration effects all flow rules reusing\n the action via *handle*.\n The update general pointer provides the ability of partial updating.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] handle\n   Handle for the indirect action object to be updated.\n @param[in] update\n   Update profile specification used to modify the action pointed by handle.\n   *update* could be with the same type of the immediate action corresponding\n   to the *handle* argument when creating, or a wrapper structure includes\n   action configuration to be updated and bit fields to indicate the member\n   of fields inside the action to update.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-EINVAL) if *update* invalid.\n   - (-ENOTSUP) if *update* valid but unsupported.\n   - (-ENOENT) if indirect action object pointed by *handle* was not found.\n   rte_errno is also set."]
    pub fn rte_flow_action_handle_update(
        port_id: u16,
        handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query the direct action by corresponding indirect action object handle.\n\n Retrieve action-specific data such as counters.\n Data is gathered by special action which may be present/referenced in\n more than one flow rule definition.\n\n @see RTE_FLOW_ACTION_TYPE_COUNT\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] handle\n   Handle for the action object to query.\n @param[in, out] data\n   Pointer to storage for the associated query data type.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_action_handle_query(
        port_id: u16,
        handle: *const rte_flow_action_handle,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tunnel {
    #[doc = " Tunnel type, for example RTE_FLOW_ITEM_TYPE_VXLAN,\n RTE_FLOW_ITEM_TYPE_NVGRE etc."]
    pub type_: rte_flow_item_type,
    #[doc = "< Tunnel identification."]
    pub tun_id: u64,
    pub __bindgen_anon_1: rte_flow_tunnel__bindgen_ty_1,
    #[doc = "< Tunnel port source."]
    pub tp_src: rte_be16_t,
    #[doc = "< Tunnel port destination."]
    pub tp_dst: rte_be16_t,
    #[doc = "< Tunnel flags."]
    pub tun_flags: u16,
    #[doc = "< True for valid IPv6 fields. Otherwise IPv4."]
    pub is_ipv6: bool,
    #[doc = "< TOS for IPv4, TC for IPv6."]
    pub tos: u8,
    #[doc = "< TTL for IPv4, HL for IPv6."]
    pub ttl: u8,
    #[doc = "< Flow Label for IPv6."]
    pub label: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_tunnel__bindgen_ty_1 {
    pub ipv4: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< IPv4 source address."]
    pub src_addr: rte_be32_t,
    #[doc = "< IPv4 destination address."]
    pub dst_addr: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< IPv6 source address."]
    pub src_addr: rte_ipv6_addr,
    #[doc = "< IPv6 destination address."]
    pub dst_addr: rte_ipv6_addr,
}
#[doc = " Restore information structure to communicate the current packet processing\n state when some of the processing pipeline is done in hardware and should\n continue in software."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_restore_info {
    #[doc = " Bitwise flags (RTE_FLOW_RESTORE_INFO_*) to indicate validation of\n other fields in struct rte_flow_restore_info."]
    pub flags: u64,
    #[doc = "< Group ID where packed missed"]
    pub group_id: u32,
    #[doc = "< Tunnel information."]
    pub tunnel: rte_flow_tunnel,
}
unsafe extern "C" {
    #[doc = " Allocate an array of actions to be used in rte_flow_create, to implement\n tunnel-decap-set for the given tunnel.\n Sample usage:\n   actions vxlan_decap / tunnel-decap-set(tunnel properties) /\n            jump group 0 / end\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] tunnel\n   Tunnel properties.\n @param[out] actions\n   Array of actions to be allocated by the PMD. This array should be\n   concatenated with the actions array provided to rte_flow_create.\n @param[out] num_of_actions\n   Number of actions allocated.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_decap_set(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        actions: *mut *mut rte_flow_action,
        num_of_actions: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate an array of items to be used in rte_flow_create, to implement\n tunnel-match for the given tunnel.\n Sample usage:\n   pattern tunnel-match(tunnel properties) / outer-header-matches /\n           inner-header-matches / end\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] tunnel\n   Tunnel properties.\n @param[out] items\n   Array of items to be allocated by the PMD. This array should be\n   concatenated with the items array provided to rte_flow_create.\n @param[out] num_of_items\n   Number of items allocated.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_match(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        items: *mut *mut rte_flow_item,
        num_of_items: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " On reception of a mbuf from HW, a call to rte_flow_get_restore_info() may be\n required to retrieve some metadata.\n This function returns the associated mbuf ol_flags.\n\n Note: the dynamic flag is registered during a call to\n rte_eth_rx_metadata_negotiate() with RTE_ETH_RX_METADATA_TUNNEL_ID.\n\n @return\n   The offload flag indicating rte_flow_get_restore_info() must be called."]
    pub fn rte_flow_restore_info_dynflag() -> u64;
}
unsafe extern "C" {
    #[doc = " If a mbuf contains the rte_flow_restore_info_dynflag() flag in ol_flags,\n populate the current packet processing state.\n\n One should negotiate tunnel metadata delivery from the NIC to the HW.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_TUNNEL_ID\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] m\n   Mbuf struct.\n @param[out] info\n   Restore information. Upon success contains the HW state.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_get_restore_info(
        port_id: u16,
        m: *mut rte_mbuf,
        info: *mut rte_flow_restore_info,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release the action array as allocated by rte_flow_tunnel_decap_set.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] actions\n   Array of actions to be released.\n @param[in] num_of_actions\n   Number of elements in actions array.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_action_decap_release(
        port_id: u16,
        actions: *mut rte_flow_action,
        num_of_actions: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release the item array as allocated by rte_flow_tunnel_match.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] items\n   Array of items to be released.\n @param[in] num_of_items\n   Number of elements in item array.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_item_release(
        port_id: u16,
        items: *mut rte_flow_item,
        num_of_items: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a proxy port to manage \"transfer\" flows.\n\n Managing \"transfer\" flows requires that the user communicate them\n via a port which has the privilege to control the embedded switch.\n For some vendors, all ports in a given switching domain have\n this privilege. For other vendors, it's only one port.\n\n This API indicates such a privileged port (a \"proxy\")\n for a given port in the same switching domain.\n\n @note\n   If the PMD serving @p port_id doesn't have the corresponding method\n   implemented, the API will return @p port_id via @p proxy_port_id.\n\n @param port_id\n   Indicates the port to get a \"proxy\" for\n @param[out] proxy_port_id\n   Indicates the \"proxy\" port\n @param[out] error\n   If not NULL, allows the PMD to provide verbose report in case of error\n\n @return\n   0 on success, a negative error code otherwise"]
    pub fn rte_flow_pick_transfer_proxy(
        port_id: u16,
        proxy_port_id: *mut u16,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create the flex item with specified configuration over\n the Ethernet device.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] conf\n   Item configuration.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   Non-NULL opaque pointer on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_flex_item_create(
        port_id: u16,
        conf: *const rte_flow_item_flex_conf,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_item_flex_handle;
}
unsafe extern "C" {
    #[doc = " Release the flex item on the specified Ethernet device.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] handle\n   Handle of the item existing on the specified device.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flex_item_release(
        port_id: u16,
        handle: *const rte_flow_item_flex_handle,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Information about flow engine resources.\n The zero value means a resource is not supported."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_port_info {
    #[doc = " Maximum number of queues for asynchronous operations."]
    pub max_nb_queues: u32,
    #[doc = " Maximum number of counters.\n @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub max_nb_counters: u32,
    #[doc = " Maximum number of aging objects.\n @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub max_nb_aging_objects: u32,
    #[doc = " Maximum number traffic meters.\n @see RTE_FLOW_ACTION_TYPE_METER"]
    pub max_nb_meters: u32,
    #[doc = " Maximum number connection trackings.\n @see RTE_FLOW_ACTION_TYPE_CONNTRACK"]
    pub max_nb_conn_tracks: u32,
    #[doc = " Maximum number of quota actions.\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
    pub max_nb_quotas: u32,
    #[doc = " Port supported flags (RTE_FLOW_PORT_FLAG_*)."]
    pub supported_flags: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Information about flow engine asynchronous queues.\n The value only valid if @p port_attr.max_nb_queues is not zero."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_queue_info {
    #[doc = " Maximum number of operations a queue can hold."]
    pub max_size: u32,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get information about flow engine resources.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[out] port_info\n   A pointer to a structure of type *rte_flow_port_info*\n   to be filled with the resources information of the port.\n @param[out] queue_info\n   A pointer to a structure of type *rte_flow_queue_info*\n   to be filled with the asynchronous queues information.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_info_get(
        port_id: u16,
        port_info: *mut rte_flow_port_info,
        queue_info: *mut rte_flow_queue_info,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine resources settings.\n The zero value means on demand resource allocations only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_port_attr {
    #[doc = " Number of counters to configure.\n @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub nb_counters: u32,
    #[doc = " Number of aging objects to configure.\n @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub nb_aging_objects: u32,
    #[doc = " Number of traffic meters to configure.\n @see RTE_FLOW_ACTION_TYPE_METER"]
    pub nb_meters: u32,
    #[doc = " Number of connection trackings to configure.\n @see RTE_FLOW_ACTION_TYPE_CONNTRACK"]
    pub nb_conn_tracks: u32,
    #[doc = " Port to base shared objects on."]
    pub host_port_id: u16,
    #[doc = " Maximum number of quota actions.\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
    pub nb_quotas: u32,
    #[doc = " Port flags (RTE_FLOW_PORT_FLAG_*)."]
    pub flags: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine asynchronous queues settings.\n The value means default value picked by PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_queue_attr {
    #[doc = " Number of flow rule operations a queue can hold."]
    pub size: u32,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Configure the port's flow API engine.\n\n This API can only be invoked before the application\n starts using the rest of the flow library functions.\n\n The API can be invoked multiple times to change the settings.\n The port, however, may reject changes and keep the old config.\n\n Parameters in configuration attributes must not exceed\n numbers of resources returned by the rte_flow_info_get API.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] port_attr\n   Port configuration attributes.\n @param[in] nb_queue\n   Number of flow queues to be configured.\n @param[in] queue_attr\n   Array that holds attributes for each flow queue.\n   Number of elements is set in @p port_attr.nb_queues.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_configure(
        port_id: u16,
        port_attr: *const rte_flow_port_attr,
        nb_queue: u16,
        queue_attr: *mut *const rte_flow_queue_attr,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of pattern template.\n This handle can be used to manage the created pattern template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_pattern_template {
    _unused: [u8; 0],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow pattern template attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_pattern_template_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_pattern_template_attr {
    #[inline]
    pub fn relaxed_matching(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_matching(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_matching_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_matching_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relaxed_matching: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relaxed_matching: u32 = unsafe { ::std::mem::transmute(relaxed_matching) };
            relaxed_matching as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create flow pattern template.\n\n The pattern template defines common matching fields without values.\n For example, matching on 5 tuple TCP flow, the template will be\n eth(null) + IPv4(source + dest) + TCP(s_port + d_port),\n while values for each rule will be set during the flow rule creation.\n The number and order of items in the template must be the same\n at the rule creation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] template_attr\n   Pattern template attributes.\n @param[in] pattern\n   Pattern specification (list terminated by the END pattern item).\n   The spec member of an item is not used unless the end member is used.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_pattern_template_create(
        port_id: u16,
        template_attr: *const rte_flow_pattern_template_attr,
        pattern: *const rte_flow_item,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_pattern_template;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destroy flow pattern template.\n\n This function may be called only when\n there are no more tables referencing this template.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] pattern_template\n   Handle of the template to be destroyed.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_pattern_template_destroy(
        port_id: u16,
        pattern_template: *mut rte_flow_pattern_template,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of actions template.\n This handle can be used to manage the created actions template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_actions_template {
    _unused: [u8; 0],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow actions template attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_actions_template_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_actions_template_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create flow actions template.\n\n The actions template holds a list of action types without values.\n For example, the template to change TCP ports is TCP(s_port + d_port),\n while values for each rule will be set during the flow rule creation.\n The number and order of actions in the template must be the same\n at the rule creation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] template_attr\n   Template attributes.\n @param[in] actions\n   Associated actions (list terminated by the END action).\n   The spec member is only used if @p masks spec is non-zero.\n @param[in] masks\n   List of actions that marks which of the action's member is constant.\n   A mask has the same format as the corresponding action.\n   If the action field in @p masks is not 0,\n   the corresponding value in an action from @p actions will be the part\n   of the template and used in all flow rules.\n   The order of actions in @p masks is the same as in @p actions.\n   In case of indirect actions present in @p actions,\n   the actual action type should be present in @p mask.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_actions_template_create(
        port_id: u16,
        template_attr: *const rte_flow_actions_template_attr,
        actions: *const rte_flow_action,
        masks: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_actions_template;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destroy flow actions template.\n\n This function may be called only when\n there are no more tables referencing this template.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] actions_template\n   Handle to the template to be destroyed.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_actions_template_destroy(
        port_id: u16,
        actions_template: *mut rte_flow_actions_template,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type returned after successful creation of a template table.\n This handle can be used to manage the created template table."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_template_table {
    _unused: [u8; 0],
}
#[doc = " Pattern-based insertion."]
pub const rte_flow_table_insertion_type_RTE_FLOW_TABLE_INSERTION_TYPE_PATTERN:
    rte_flow_table_insertion_type = 0;
#[doc = " Index-based insertion."]
pub const rte_flow_table_insertion_type_RTE_FLOW_TABLE_INSERTION_TYPE_INDEX:
    rte_flow_table_insertion_type = 1;
#[doc = " Index-based insertion with pattern."]
pub const rte_flow_table_insertion_type_RTE_FLOW_TABLE_INSERTION_TYPE_INDEX_WITH_PATTERN:
    rte_flow_table_insertion_type = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Template table flow rules insertion type."]
pub type rte_flow_table_insertion_type = ::std::os::raw::c_uint;
#[doc = " Default hash calculation."]
pub const rte_flow_table_hash_func_RTE_FLOW_TABLE_HASH_FUNC_DEFAULT: rte_flow_table_hash_func = 0;
#[doc = " Linear hash calculation."]
pub const rte_flow_table_hash_func_RTE_FLOW_TABLE_HASH_FUNC_LINEAR: rte_flow_table_hash_func = 1;
#[doc = " 32-bit checksum hash calculation."]
pub const rte_flow_table_hash_func_RTE_FLOW_TABLE_HASH_FUNC_CRC32: rte_flow_table_hash_func = 2;
#[doc = " 16-bit checksum hash calculation."]
pub const rte_flow_table_hash_func_RTE_FLOW_TABLE_HASH_FUNC_CRC16: rte_flow_table_hash_func = 3;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Template table hash index calculation function."]
pub type rte_flow_table_hash_func = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Table attributes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_template_table_attr {
    #[doc = " Flow attributes to be used in each rule generated from this table."]
    pub flow_attr: rte_flow_attr,
    #[doc = " Maximum number of flow rules that this table holds."]
    pub nb_flows: u32,
    #[doc = " Optional hint flags for driver optimization.\n The effect may vary in the different drivers.\n The functionality must not rely on the hints.\n Value is composed with RTE_FLOW_TABLE_SPECIALIZE_* based on application\n design choices.\n Misused hints may mislead the driver, it may result in an undefined behavior."]
    pub specialize: u32,
    #[doc = " Insertion type for flow rules."]
    pub insertion_type: rte_flow_table_insertion_type,
    #[doc = " Hash calculation function for the packet matching."]
    pub hash_func: rte_flow_table_hash_func,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query whether a table can be resized.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param tbl_attr\n   Template table.\n\n @return\n   True if the table can be resized."]
    pub fn rte_flow_template_table_resizable(
        port_id: u16,
        tbl_attr: *const rte_flow_template_table_attr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create flow template table.\n\n A template table consists of multiple pattern templates and actions\n templates associated with a single set of rule attributes (group ID,\n priority and traffic direction).\n\n Each rule is free to use any combination of pattern and actions templates\n and specify particular values for items and actions it would like to change.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] table_attr\n   Template table attributes.\n @param[in] pattern_templates\n   Array of pattern templates to be used in this table.\n @param[in] nb_pattern_templates\n   The number of pattern templates in the pattern_templates array.\n @param[in] actions_templates\n   Array of actions templates to be used in this table.\n @param[in] nb_actions_templates\n   The number of actions templates in the actions_templates array.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_template_table_create(
        port_id: u16,
        table_attr: *const rte_flow_template_table_attr,
        pattern_templates: *mut *mut rte_flow_pattern_template,
        nb_pattern_templates: u8,
        actions_templates: *mut *mut rte_flow_actions_template,
        nb_actions_templates: u8,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_template_table;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destroy flow template table.\n\n This function may be called only when\n there are no more flow rules referencing this table.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] template_table\n   Handle to the table to be destroyed.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_template_table_destroy(
        port_id: u16,
        template_table: *mut rte_flow_template_table,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Set group miss actions.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param group_id\n   Identifier of a group to set miss actions for.\n @param attr\n   Group attributes.\n @param actions\n   List of group miss actions.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_group_set_miss_actions(
        port_id: u16,
        group_id: u32,
        attr: *const rte_flow_group_attr,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Asynchronous operation attributes."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_flow_op_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_flow_op_attr {
    #[inline]
    pub fn postpone(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_postpone(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn postpone_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_postpone_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(postpone: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let postpone: u32 = unsafe { ::std::mem::transmute(postpone) };
            postpone as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue rule creation operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue used to insert the rule.\n @param[in] op_attr\n   Rule creation operation attributes.\n @param[in] template_table\n   Template table to select templates from.\n @param[in] pattern\n   List of pattern items to be used.\n   The list order should match the order in the pattern template.\n   The spec is the only relevant member of the item that is being used.\n @param[in] pattern_template_index\n   Pattern template index in the table.\n @param[in] actions\n   List of actions to be used.\n   The list order should match the order in the actions template.\n @param[in] actions_template_index\n   Actions template index in the table.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set.\n   The rule handle doesn't mean that the rule has been populated.\n   Only completion result indicates that if there was success or failure."]
    pub fn rte_flow_async_create(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        template_table: *mut rte_flow_template_table,
        pattern: *const rte_flow_item,
        pattern_template_index: u8,
        actions: *const rte_flow_action,
        actions_template_index: u8,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue rule creation operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue used to insert the rule.\n @param[in] op_attr\n   Rule creation operation attributes.\n @param[in] template_table\n   Template table to select templates from.\n @param[in] rule_index\n   Rule index in the table.\n @param[in] actions\n   List of actions to be used.\n   The list order should match the order in the actions template.\n @param[in] actions_template_index\n   Actions template index in the table.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set.\n   The rule handle doesn't mean that the rule has been populated.\n   Only completion result indicates that if there was success or failure."]
    pub fn rte_flow_async_create_by_index(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        template_table: *mut rte_flow_template_table,
        rule_index: u32,
        actions: *const rte_flow_action,
        actions_template_index: u8,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue rule creation by index with pattern operation.\n Packets are only matched if there is a rule inserted at the index.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue used to insert the rule.\n @param[in] op_attr\n   Rule creation operation attributes.\n @param[in] template_table\n   Template table to select templates from.\n @param[in] rule_index\n   Rule index in the table.\n   Inserting a rule to already occupied index results in undefined behavior.\n @param[in] pattern\n   List of pattern items to be used.\n   The list order should match the order in the pattern template.\n   The spec is the only relevant member of the item that is being used.\n @param[in] pattern_template_index\n   Pattern template index in the table.\n @param[in] actions\n   List of actions to be used.\n   The list order should match the order in the actions template.\n @param[in] actions_template_index\n   Actions template index in the table.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Handle on success, NULL otherwise and rte_errno is set.\n   The rule handle doesn't mean that the rule has been populated.\n   Only completion result indicates that if there was success or failure."]
    pub fn rte_flow_async_create_by_index_with_pattern(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        template_table: *mut rte_flow_template_table,
        rule_index: u32,
        pattern: *const rte_flow_item,
        pattern_template_index: u8,
        actions: *const rte_flow_action,
        actions_template_index: u8,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue rule destruction operation.\n\n This function enqueues a destruction operation on the queue.\n Application should assume that after calling this function\n the rule handle is not valid anymore.\n Completion indicates the full removal of the rule from the HW.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue which is used to destroy the rule.\n   This must match the queue on which the rule was created.\n @param[in] op_attr\n   Rule destruction operation attributes.\n @param[in] flow\n   Flow handle to be destroyed.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_destroy(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        flow: *mut rte_flow,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue rule update operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue used to insert the rule.\n @param[in] op_attr\n   Rule creation operation attributes.\n @param[in] flow\n   Flow rule to be updated.\n @param[in] actions\n   List of actions to be used.\n   The list order should match the order in the actions template.\n @param[in] actions_template_index\n   Actions template index in the table.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_actions_update(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        flow: *mut rte_flow,
        actions: *const rte_flow_action,
        actions_template_index: u8,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Push all internally stored rules to the HW.\n Postponed rules are rules that were inserted with the postpone flag set.\n Can be used to notify the HW about batch of rules prepared by the SW to\n reduce the number of communications between the HW and SW.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue to be pushed.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_push(
        port_id: u16,
        queue_id: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The operation was completed successfully."]
pub const rte_flow_op_status_RTE_FLOW_OP_SUCCESS: rte_flow_op_status = 0;
#[doc = " The operation was not completed successfully."]
pub const rte_flow_op_status_RTE_FLOW_OP_ERROR: rte_flow_op_status = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Asynchronous operation status."]
pub type rte_flow_op_status = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Asynchronous operation result."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_op_result {
    #[doc = " Returns the status of the operation that this completion signals."]
    pub status: rte_flow_op_status,
    #[doc = " The user data that will be returned on the completion events."]
    pub user_data: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Pull a rte flow operation.\n The application must invoke this function in order to complete\n the flow rule offloading and to retrieve the flow rule operation status.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue which is used to pull the operation.\n @param[out] res\n   Array of results that will be set.\n @param[in] n_res\n   Maximum number of results that can be returned.\n   This value is equal to the size of the res array.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   Number of results that were pulled,\n   a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_pull(
        port_id: u16,
        queue_id: u32,
        res: *mut rte_flow_op_result,
        n_res: u16,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue indirect action creation operation.\n @see rte_flow_action_handle_create\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to create the rule.\n @param[in] op_attr\n   Indirect action creation operation attributes.\n @param[in] indir_action_conf\n   Action configuration for the indirect action object creation.\n @param[in] action\n   Specific configuration of the indirect action object.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_create(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        indir_action_conf: *const rte_flow_indir_action_conf,
        action: *const rte_flow_action,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_handle;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue indirect action destruction operation.\n The destroy queue must be the same\n as the queue on which the action was created.\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to destroy the rule.\n @param[in] op_attr\n   Indirect action destruction operation attributes.\n @param[in] action_handle\n   Handle for the indirect action object to be destroyed.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_destroy(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        action_handle: *mut rte_flow_action_handle,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue indirect action update operation.\n @see rte_flow_action_handle_create\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to update the rule.\n @param[in] op_attr\n   Indirect action update operation attributes.\n @param[in] action_handle\n   Handle for the indirect action object to be updated.\n @param[in] update\n   Update profile specification used to modify the action pointed by handle.\n   *update* could be with the same type of the immediate action corresponding\n   to the *handle* argument when creating, or a wrapper structure includes\n   action configuration to be updated and bit fields to indicate the member\n   of fields inside the action to update.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_update(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        action_handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue indirect action query operation.\n\n Retrieve action-specific data such as counters.\n Data is gathered by special action which may be present/referenced in\n more than one flow rule definition.\n Data will be available only when completion event returns.\n\n @see rte_flow_async_action_handle_query\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to query the action.\n @param[in] op_attr\n   Indirect action update operation attributes.\n @param[in] action_handle\n   Handle for the action object to query.\n @param[in, out] data\n   Pointer to storage for the associated query data type.\n   The out data will be available only when completion event returns\n   from rte_flow_pull.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_async_action_handle_query(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        action_handle: *const rte_flow_action_handle,
        data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Query before update."]
pub const rte_flow_query_update_mode_RTE_FLOW_QU_QUERY_FIRST: rte_flow_query_update_mode = 1;
#[doc = "< Query after  update."]
pub const rte_flow_query_update_mode_RTE_FLOW_QU_UPDATE_FIRST: rte_flow_query_update_mode = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query and update operational mode.\n\n @see rte_flow_action_handle_query_update()\n @see rte_flow_async_action_handle_query_update()"]
pub type rte_flow_query_update_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query and/or update indirect flow action.\n If both query and update not NULL, the function atomically\n queries and updates indirect action. Query and update are carried in order\n specified in the mode parameter.\n If ether query or update is NULL, the function executes\n complementing operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param handle\n   Handle for the indirect action object to be updated.\n @param update\n   If not NULL, update profile specification used to modify the action\n   pointed by handle.\n @param query\n   If not NULL pointer to storage for the associated query data type.\n @param mode\n   Operational mode.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n 0 on success, a negative errno value otherwise and rte_errno is set.\n - (-ENODEV) if *port_id* invalid.\n - (-ENOTSUP) if underlying device does not support this functionality.\n - (-EINVAL) if *handle* or *mode* invalid or\n             both *query* and *update* are NULL."]
    pub fn rte_flow_action_handle_query_update(
        port_id: u16,
        handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        query: *mut ::std::os::raw::c_void,
        mode: rte_flow_query_update_mode,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue async indirect flow action query and/or update\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue which is used to update the rule.\n @param attr\n   Indirect action update operation attributes.\n @param handle\n   Handle for the indirect action object to be updated.\n @param update\n   If not NULL, update profile specification used to modify the action\n   pointed by handle.\n @param query\n   If not NULL, pointer to storage for the associated query data type.\n   Query result returned on async completion event.\n @param mode\n   Operational mode.\n @param user_data\n   The user data that will be returned on async completion event.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set.\n - (-ENODEV) if *port_id* invalid.\n - (-ENOTSUP) if underlying device does not support this functionality.\n - (-EINVAL) if *handle* or *mode* invalid or\n             both *update* and *query* are NULL."]
    pub fn rte_flow_async_action_handle_query_update(
        port_id: u16,
        queue_id: u32,
        attr: *const rte_flow_op_attr,
        handle: *mut rte_flow_action_handle,
        update: *const ::std::os::raw::c_void,
        query: *mut ::std::os::raw::c_void,
        mode: rte_flow_query_update_mode,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_list_handle {
    _unused: [u8; 0],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Configure INDIRECT_LIST flow action.\n\n @see RTE_FLOW_ACTION_TYPE_INDIRECT_LIST"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_indirect_list {
    #[doc = " Indirect action list handle"]
    pub handle: *mut rte_flow_action_list_handle,
    #[doc = " Flow mutable configuration array.\n NULL if the handle has no flow mutable configuration update.\n Otherwise, if the handle was created with list A1 / A2 .. An / END\n size of conf is n.\n conf[i] points to flow mutable update of Ai in the handle\n actions list or NULL if Ai has no update."]
    pub conf: *mut *const ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create an indirect flow action object from flow actions list.\n The object is identified by a unique handle.\n The handle has single state and configuration\n across all the flow rules using it.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] conf\n   Action configuration for the indirect action list creation.\n @param[in] actions\n   Specific configuration of the indirect action lists.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set\n   to one of the error codes defined:\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-EINVAL) if *actions* list invalid.\n   - (-ENOTSUP) if *action* list element valid but unsupported."]
    pub fn rte_flow_action_list_handle_create(
        port_id: u16,
        conf: *const rte_flow_indir_action_conf,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_list_handle;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Async function call to create an indirect flow action object\n from flow actions list.\n The object is identified by a unique handle.\n The handle has single state and configuration\n across all the flow rules using it.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to update the rule.\n @param[in] attr\n   Indirect action update operation attributes.\n @param[in] conf\n   Action configuration for the indirect action list creation.\n @param[in] actions\n   Specific configuration of the indirect action list.\n @param[in] user_data\n   The user data that will be returned on async completion event.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set\n   to one of the error codes defined:\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-EINVAL) if *actions* list invalid.\n   - (-ENOTSUP) if *action* list element valid but unsupported."]
    pub fn rte_flow_async_action_list_handle_create(
        port_id: u16,
        queue_id: u32,
        attr: *const rte_flow_op_attr,
        conf: *const rte_flow_indir_action_conf,
        actions: *const rte_flow_action,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_list_handle;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destroy indirect actions list by handle.\n\n @param[in] port_id\n    The port identifier of the Ethernet device.\n @param[in] handle\n   Handle for the indirect actions list to be destroyed.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-ENOENT) if actions list pointed by *action* handle was not found.\n   - (-EBUSY) if actions list pointed by *action* handle still used"]
    pub fn rte_flow_action_list_handle_destroy(
        port_id: u16,
        handle: *mut rte_flow_action_list_handle,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue indirect action list destruction operation.\n The destroy queue must be the same\n as the queue on which the action was created.\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] queue_id\n   Flow queue which is used to destroy the rule.\n @param[in] op_attr\n   Indirect action destruction operation attributes.\n @param[in] handle\n   Handle for the indirect action object to be destroyed.\n @param[in] user_data\n   The user data that will be returned on the completion events.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOSYS) if underlying device does not support this functionality.\n   - (-EIO) if underlying device is removed.\n   - (-ENOENT) if actions list pointed by *action* handle was not found.\n   - (-EBUSY) if actions list pointed by *action* handle still used"]
    pub fn rte_flow_async_action_list_handle_destroy(
        port_id: u16,
        queue_id: u32,
        op_attr: *const rte_flow_op_attr,
        handle: *mut rte_flow_action_list_handle,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query and/or update indirect flow actions list.\n If both query and update not NULL, the function atomically\n queries and updates indirect action. Query and update are carried in order\n specified in the mode parameter.\n If ether query or update is NULL, the function executes\n complementing operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param handle\n   Handle for the indirect actions list object to be updated.\n @param update\n   If the action list handle was created from n actions A1 / A2 ... An / END\n   non-NULL update parameter is an array [U1, U2, ... Un] where Ui points to\n   Ai update context or NULL if Ai should not be updated.\n @param query\n   If the action list handle was created from n actions A1 / A2 ... An / END\n   non-NULL query parameter is an array [Q1, Q2, ... Qn] where Qi points to\n   Ai query context or NULL if Ai should not be queried.\n @param mode\n   Operational mode.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n - (-ENODEV) if *port_id* invalid.\n - (-ENOTSUP) if underlying device does not support this functionality.\n - (-EINVAL) if *handle* or *mode* invalid or\n             both *query* and *update* are NULL."]
    pub fn rte_flow_action_list_handle_query_update(
        port_id: u16,
        handle: *const rte_flow_action_list_handle,
        update: *mut *const ::std::os::raw::c_void,
        query: *mut *mut ::std::os::raw::c_void,
        mode: rte_flow_query_update_mode,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Enqueue async indirect flow actions list query and/or update\n If both query and update not NULL, the function atomically\n queries and updates indirect action. Query and update are carried in order\n specified in the mode parameter.\n If ether query or update is NULL, the function executes\n complementing operation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue_id\n   Flow queue which is used to update the rule.\n @param attr\n   Indirect action update operation attributes.\n @param handle\n   Handle for the indirect actions list object to be updated.\n @param update\n   If the action list handle was created from n actions A1 / A2 ... An / END\n   non-NULL update parameter is an array [U1, U2, ... Un] where Ui points to\n   Ai update context or NULL if Ai should not be updated.\n @param query\n   If the action list handle was created from n actions A1 / A2 ... An / END\n   non-NULL query parameter is an array [Q1, Q2, ... Qn] where Qi points to\n   Ai query context or NULL if Ai should not be queried.\n   Query result returned on async completion event.\n @param mode\n   Operational mode.\n @param user_data\n   The user data that will be returned on async completion event.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n - (-ENODEV) if *port_id* invalid.\n - (-ENOTSUP) if underlying device does not support this functionality.\n - (-EINVAL) if *handle* or *mode* invalid or\n             both *update* and *query* are NULL."]
    pub fn rte_flow_async_action_list_handle_query_update(
        port_id: u16,
        queue_id: u32,
        attr: *const rte_flow_op_attr,
        handle: *const rte_flow_action_list_handle,
        update: *mut *const ::std::os::raw::c_void,
        query: *mut *mut ::std::os::raw::c_void,
        mode: rte_flow_query_update_mode,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Calculate the hash for a given pattern in a given table as\n calculated by the HW.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param table\n   The table the SW wishes to simulate.\n @param pattern\n   The values to be used in the hash calculation.\n @param pattern_template_index\n   The pattern index in the table to be used for the calculation.\n @param hash\n   Used to return the calculated hash.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOTSUP) if underlying device does not support this functionality."]
    pub fn rte_flow_calc_table_hash(
        port_id: u16,
        table: *const rte_flow_template_table,
        pattern: *const rte_flow_item,
        pattern_template_index: u8,
        hash: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Calculate hash placed in UDP source port field."]
pub const rte_flow_encap_hash_field_RTE_FLOW_ENCAP_HASH_FIELD_SRC_PORT: rte_flow_encap_hash_field =
    0;
#[doc = " Calculate hash placed in NVGRE flow ID field."]
pub const rte_flow_encap_hash_field_RTE_FLOW_ENCAP_HASH_FIELD_NVGRE_FLOW_ID:
    rte_flow_encap_hash_field = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Destination field type for the hash calculation, when encap action is used.\n The encap field implies the size, meaning XXX_SRC_PORT hash len is 2 bytes,\n while XXX_NVGRE_FLOW_ID hash len is 1 byte.\n\n @see function rte_flow_calc_encap_hash"]
pub type rte_flow_encap_hash_field = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Simulate HW hash calculation that is done when an encap action is being used.\n This hash can be stored in tunnel outer header to improve packet distribution.\n\n @param[in] port_id\n   Port identifier of Ethernet device.\n @param[in] pattern\n   The values to be used in the hash calculation.\n @param[in] dest_field\n   Type of destination field for hash calculation.\n @param[in] hash_len\n   The length of the hash pointer in bytes. Should be according to dest_field.\n @param[out] hash\n   Used to return the calculated hash. It will be written in network order,\n   so hash[0] is the MSB.\n   The number of bytes is based on the destination field type.\n @param[out] error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOTSUP) if underlying device does not support this functionality.\n   - (-EINVAL) if *pattern* doesn't hold enough information to calculate the hash\n               or the dest is not supported."]
    pub fn rte_flow_calc_encap_hash(
        port_id: u16,
        pattern: *const rte_flow_item,
        dest_field: rte_flow_encap_hash_field,
        hash_len: u8,
        hash: *mut u8,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Update template table for new flow rules capacity.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param table\n   Template table to modify.\n @param nb_rules\n   New flow rules capacity.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOTSUP) if underlying device does not support this functionality.\n   - (-EINVAL) if *table* is not resizable or\n               *table* resize to *nb_rules* is not supported or\n               unrecoverable *table* error."]
    pub fn rte_flow_template_table_resize(
        port_id: u16,
        table: *mut rte_flow_template_table,
        nb_rules: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Update *rule* for the new *table* configuration after table resize.\n Must be called for each *rule* created before *table* resize.\n If called for *rule* created after *table* resize returns success.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param queue\n   Flow queue for async operation.\n @param attr\n   Async operation attributes.\n @param rule\n   Flow rule to update.\n @param user_data\n   The user data that will be returned on async completion event.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOTSUP) if underlying device does not support this functionality.\n   - (-EINVAL) if *table* was not resized.\n               If *rule* cannot be updated after *table* resize,\n               unrecoverable *table* error."]
    pub fn rte_flow_async_update_resized(
        port_id: u16,
        queue: u32,
        attr: *const rte_flow_op_attr,
        rule: *mut rte_flow,
        user_data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Resume normal operational mode after table was resized and\n table rules were updated for the new table configuration.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param table\n   Template table that undergoing resize operation.\n @param error\n   Perform verbose error reporting if not NULL.\n   PMDs initialize this structure in case of error only.\n\n @return\n   - (0) if success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-ENOTSUP) if underlying device does not support this functionality.\n   - (-EBUSY) if not all *table* rules were updated.\n   - (-EINVAL) if *table* cannot complete table resize,\n               unrecoverable error."]
    pub fn rte_flow_template_table_resize_complete(
        port_id: u16,
        table: *mut rte_flow_template_table,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to define the ntuple filter entry\n to support RTE_ETH_FILTER_NTUPLE data representation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP.\nThe packet matched above ntuple fields and contain\nany set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,\nused when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_UNKNOWN: rte_eth_input_set_field = 0;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_SRC_MAC: rte_eth_input_set_field = 1;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_DST_MAC: rte_eth_input_set_field = 2;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_OUTER_VLAN: rte_eth_input_set_field = 3;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_INNER_VLAN: rte_eth_input_set_field = 4;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_ETHERTYPE: rte_eth_input_set_field = 5;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP4: rte_eth_input_set_field = 129;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP4: rte_eth_input_set_field = 130;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP6: rte_eth_input_set_field = 131;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP6: rte_eth_input_set_field = 132;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TOS: rte_eth_input_set_field = 133;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_PROTO: rte_eth_input_set_field = 134;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_TC: rte_eth_input_set_field = 135;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: rte_eth_input_set_field =
    136;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TTL: rte_eth_input_set_field = 137;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: rte_eth_input_set_field =
    138;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: rte_eth_input_set_field = 257;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: rte_eth_input_set_field = 258;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: rte_eth_input_set_field = 259;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: rte_eth_input_set_field = 260;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: rte_eth_input_set_field = 261;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: rte_eth_input_set_field = 262;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG:
    rte_eth_input_set_field = 263;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC:
    rte_eth_input_set_field = 385;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC:
    rte_eth_input_set_field = 386;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: rte_eth_input_set_field =
    387;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: rte_eth_input_set_field =
    388;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: rte_eth_input_set_field = 389;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: rte_eth_input_set_field =
    641;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: rte_eth_input_set_field =
    642;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: rte_eth_input_set_field =
    643;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: rte_eth_input_set_field =
    644;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: rte_eth_input_set_field =
    645;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: rte_eth_input_set_field =
    646;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: rte_eth_input_set_field =
    647;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: rte_eth_input_set_field =
    648;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_DEFAULT: rte_eth_input_set_field = 65533;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_NONE: rte_eth_input_set_field = 65534;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_MAX: rte_eth_input_set_field = 65535;
#[doc = " Input set fields for Flow Director and Hash filters"]
pub type rte_eth_input_set_field = ::std::os::raw::c_uint;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_UNKNOWN: rte_filter_input_set_op = 0;
#[doc = "< select input set"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_SELECT: rte_filter_input_set_op = 1;
#[doc = "< add input set entry"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_ADD: rte_filter_input_set_op = 2;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_MAX: rte_filter_input_set_op = 3;
#[doc = " Filters input set operations"]
pub type rte_filter_input_set_op = ::std::os::raw::c_uint;
#[doc = " A structure used to define the input set configuration for\n flow director and hash filters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_UNKNOWN: rte_eth_fdir_tunnel_type = 0;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_NVGRE: rte_eth_fdir_tunnel_type = 1;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_VXLAN: rte_eth_fdir_tunnel_type = 2;
#[doc = " Tunnel type for flow director."]
pub type rte_eth_fdir_tunnel_type = ::std::os::raw::c_uint;
#[doc = " A structure used to define the input for tunnel flow, now it's VxLAN or\n NVGRE"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[doc = " An union contains the inputs for all types of flow\n Items in flows need to be in big endian"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
}
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_ACCEPT: rte_eth_fdir_behavior = 0;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_REJECT: rte_eth_fdir_behavior = 1;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_PASSTHRU: rte_eth_fdir_behavior = 2;
#[doc = " Behavior will be taken if FDIR match"]
pub type rte_eth_fdir_behavior = ::std::os::raw::c_uint;
#[doc = "< Report nothing."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_NO_REPORT_STATUS: rte_eth_fdir_status = 0;
#[doc = "< Only report FD ID."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID: rte_eth_fdir_status = 1;
#[doc = "< Report FD ID and 4 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID_FLEX_4: rte_eth_fdir_status = 2;
#[doc = "< Report 8 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_FLEX_8: rte_eth_fdir_status = 3;
#[doc = " Flow director report status\n It defines what will be reported if FDIR entry is matched."]
pub type rte_eth_fdir_status = ::std::os::raw::c_uint;
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[doc = " A structure used to define the flow director filter entry."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[doc = "  A structure used to configure FDIR masks that are used by the device\n  to match the various fields of Rx packet headers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit mask for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the\nfirst byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,\n0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_UNKNOWN: rte_eth_payload_type = 0;
pub const rte_eth_payload_type_RTE_ETH_RAW_PAYLOAD: rte_eth_payload_type = 1;
pub const rte_eth_payload_type_RTE_ETH_L2_PAYLOAD: rte_eth_payload_type = 2;
pub const rte_eth_payload_type_RTE_ETH_L3_PAYLOAD: rte_eth_payload_type = 3;
pub const rte_eth_payload_type_RTE_ETH_L4_PAYLOAD: rte_eth_payload_type = 4;
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_MAX: rte_eth_payload_type = 8;
#[doc = " Payload type"]
pub type rte_eth_payload_type = ::std::os::raw::c_uint;
#[doc = " A structure used to select bytes extracted from the protocol layers to\n flexible payload for filter"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[doc = " A structure used to define FDIR masks for flexible payload\n for each flow type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[doc = " A structure used to define all flexible payload related setting\n include flex payload and flex mask"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 24usize],
}
#[doc = "< Disable FDIR support."]
pub const rte_fdir_mode_RTE_FDIR_MODE_NONE: rte_fdir_mode = 0;
#[doc = "< Enable FDIR signature filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_SIGNATURE: rte_fdir_mode = 1;
#[doc = "< Enable FDIR perfect filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT: rte_fdir_mode = 2;
#[doc = "< Enable FDIR filter mode - MAC VLAN."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_MAC_VLAN: rte_fdir_mode = 3;
#[doc = "< Enable FDIR filter mode - tunnel."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_TUNNEL: rte_fdir_mode = 4;
#[doc = "  Flow Director setting modes: none, signature or perfect."]
pub type rte_fdir_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to get the information of flow director filter.\n It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation.\n It includes the mode, flexible payload configuration information,\n capabilities and supported flow types, flexible payload characters.\n It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u64; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex\npayload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments.\nEach segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that\nsrc_offset[i] in struct rte_eth_flex_payload_cfg should be less\nthan this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a\nmultiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[doc = " A structure used to define the statistics of flow director.\n It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[doc = " UDP tunneling configuration.\n\n Used to configure the classifier of a device,\n associating an UDP port with a type of tunnel.\n\n Some NICs may need such configuration to properly parse a tunnel\n with any standard or custom UDP port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. @see rte_eth_tunnel_type"]
    pub prot_type: u8,
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port.\n Depending upon the Rx multi-queue mode, extra advanced\n configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be\nused. RTE_ETH_LINK_SPEED_FIXED disables link\nautonegotiation, and a unique speed shall be\nset. Otherwise, the bitmap defines the set of\nspeeds to be advertised. If the special value\nRTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds\nsupported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port Rx configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port Tx configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value\nis 0, meaning the loopback mode is disabled.\nRead the datasheet of given Ethernet controller\nfor details. The possible values of this field\nare defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port Rx filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port Tx DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC\nis needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    #[doc = " Port VMDq+DCB configuration."]
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    #[doc = " Port DCB Rx configuration."]
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    #[doc = " Port VMDq Rx configuration."]
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    #[doc = " Port VMDq+DCB Tx configuration."]
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    #[doc = " Port DCB Tx configuration."]
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    #[doc = " Port VMDq Tx configuration."]
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[doc = " Preferred Rx/Tx port parameters.\n There are separate instances of this structure for transmission\n and reception respectively."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain ID"]
    pub domain_id: u16,
    #[doc = " Mapping to the devices physical switch port as enumerated from the\n perspective of the embedded interconnect/switch. For SR-IOV enabled\n device this may correspond to the VF_ID of each virtual function,\n but each driver should explicitly define the mapping of switch\n port identifier to that physical interconnect/switch"]
    pub port_id: u16,
    #[doc = " Shared Rx queue sub-domain boundary. Only ports in same Rx domain\n and switch domain can share Rx queue. Valid only if device advertised\n RTE_ETH_DEV_CAPA_RXQ_SHARE capability."]
    pub rx_domain: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pools_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pools_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_align_log2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_align_log2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< not a representor."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_NONE: rte_eth_representor_type = 0;
#[doc = "< representor of Virtual Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_VF: rte_eth_representor_type = 1;
#[doc = "< representor of Sub Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_SF: rte_eth_representor_type = 2;
#[doc = "< representor of Physical Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_PF: rte_eth_representor_type = 3;
#[doc = " Ethernet device representor port type."]
pub type rte_eth_representor_type = ::std::os::raw::c_uint;
#[doc = " No error handling modes are supported."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_NONE: rte_eth_err_handle_mode = 0;
#[doc = " Passive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_INTR_RESET event,\n and the application invokes @see rte_eth_dev_reset to recover the port."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: rte_eth_err_handle_mode = 1;
#[doc = " Proactive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_ERR_RECOVERING event,\n do recovery internally, and finally reports the recovery result event\n (@see RTE_ETH_EVENT_RECOVERY_*)."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: rte_eth_err_handle_mode = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this enumeration may change without prior notice.\n\n Ethernet device error handling mode."]
pub type rte_eth_err_handle_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to retrieve the contextual information of\n an Ethernet device, such as the controlling driver of the\n device, etc..."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Generic device information"]
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none.\nUse if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = " Minimum Rx buffer size per descriptor supported by HW."]
    pub min_rx_bufsize: u32,
    #[doc = " Maximum Rx buffer size per descriptor supported by HW.\n The value is not enforced, information only to application to\n optimize mbuf size.\n Its value is UINT32_MAX when not specified by the driver."]
    pub max_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of Rx pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of Rx queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of Tx queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    #[doc = " Maximum number of hash MAC addresses for MTA and UTA."]
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    #[doc = " All Rx offload capabilities including all per-queue ones"]
    pub rx_offload_capa: u64,
    #[doc = " All Tx offload capabilities including all per-queue ones"]
    pub tx_offload_capa: u64,
    #[doc = " Device per-queue Rx offload capabilities."]
    pub rx_queue_offload_capa: u64,
    #[doc = " Device per-queue Tx offload capabilities."]
    pub tx_queue_offload_capa: u64,
    #[doc = " Device redirection table size, the total number of entries."]
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    #[doc = " RSS hash algorithms capabilities */\n/** Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default Rx configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default Tx configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDq pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDq pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDq pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< Rx descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Tx descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (RTE_ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of Rx queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues."]
    pub nb_tx_queues: u16,
    #[doc = " Maximum number of Rx mempools supported per Rx queue.\n\n Value greater than 0 means that the driver supports Rx queue\n mempools specification via rx_conf->rx_mempools."]
    pub max_rx_mempools: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a\n embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = " Supported error handling mode."]
    pub err_handle_mode: rte_eth_err_handle_mode,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " Ethernet device Rx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets Rx supported."]
    pub scattered_rx: u8,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    #[doc = "< hardware receive buffer size."]
    pub rx_buf_size: u16,
    #[doc = " Available Rx descriptors threshold defined as percentage\n of Rx queue size. If number of available descriptors is lower,\n the event RTE_ETH_EVENT_RX_AVAIL_THESH is generated.\n Value 0 means that the threshold monitoring is disabled."]
    pub avail_thresh: u8,
}
#[doc = " Ethernet device Tx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx queue information structure for recycling mbufs.\n Used to retrieve Rx queue information when Tx queue reusing mbufs and moving\n them into Rx mbuf ring."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_recycle_rxq_info {
    #[doc = "< mbuf ring of Rx queue."]
    pub mbuf_ring: *mut *mut rte_mbuf,
    #[doc = "< mempool of Rx queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< head of Rx queue refilling mbufs."]
    pub refill_head: *mut u16,
    #[doc = "< tail of Rx queue receiving pkts."]
    pub receive_tail: *mut u16,
    #[doc = "< configured number of mbuf ring size."]
    pub mbuf_ring_size: u16,
    #[doc = " Requirement on mbuf refilling batch size of Rx mbuf ring.\n For some PMD drivers, the number of Rx mbuf ring refilling mbufs\n should be aligned with mbuf ring size, in order to simplify\n ring wrapping around.\n Value 0 means that PMD drivers have no requirement for this."]
    pub refill_requirement: u16,
}
#[doc = " Ethernet device Rx/Tx queue packet burst mode information structure.\n Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[doc = " An Ethernet device extended statistic structure\n\n This structure is used by rte_eth_xstats_get() to provide\n statistics that are not provided in the generic *rte_eth_stats*\n structure.\n It maps a name ID, corresponding to an index in the array returned\n by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[doc = " A name element for extended statistics.\n\n An array of this structure is returned by rte_eth_xstats_get_names().\n It lists the names of extended statistics for a PMD. The *rte_eth_xstat*\n structure references these names by their array index.\n\n The xstats should follow a common naming scheme.\n Some names are standardized in rte_stats_strings.\n Examples:\n     - rx_missed_errors\n     - tx_q3_bytes\n     - tx_size_128_to_255_packets"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " A structure used to get the information of queue and\n TC mapping on both Tx and Rx paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " A structure used to get the information of DCB.\n It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< Tx BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " Rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[doc = "< FEC is off"]
pub const rte_eth_fec_mode_RTE_ETH_FEC_NOFEC: rte_eth_fec_mode = 0;
#[doc = "< FEC autonegotiation modes"]
pub const rte_eth_fec_mode_RTE_ETH_FEC_AUTO: rte_eth_fec_mode = 1;
#[doc = "< FEC using common algorithm"]
pub const rte_eth_fec_mode_RTE_ETH_FEC_BASER: rte_eth_fec_mode = 2;
#[doc = "< FEC using RS algorithm"]
pub const rte_eth_fec_mode_RTE_ETH_FEC_RS: rte_eth_fec_mode = 3;
#[doc = "< FEC using LLRS algorithm"]
pub const rte_eth_fec_mode_RTE_ETH_FEC_LLRS: rte_eth_fec_mode = 4;
#[doc = " This enum indicates the possible Forward Error Correction (FEC) modes\n of an ethdev port."]
pub type rte_eth_fec_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fec_capa {
    #[doc = "< Link speed (see RTE_ETH_SPEED_NUM_*)"]
    pub speed: u32,
    #[doc = "< FEC capabilities bitmask"]
    pub capa: u32,
}
#[doc = " Function type used for Rx packet processing packet callbacks.\n\n The callback function is called on Rx with a burst of packets that have\n been received on the given port and queue.\n\n @param port_id\n   The Ethernet port on which Rx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to receive the packets.\n @param pkts\n   The burst of packets that have just been received.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param max_pkts\n   The max number of packets that can be stored in the \"pkts\" array.\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for Tx packet processing packet callbacks.\n\n The callback function is called on Tx with a burst of packets immediately\n before the packets are put onto the hardware queue for transmission.\n\n @param port_id\n   The Ethernet port on which Tx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to transmit the packets.\n @param pkts\n   The burst of packets that are about to be transmitted.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Device is unused before being probed."]
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
#[doc = " Device is attached when allocated in probing."]
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
#[doc = " Device is in removed state when plug-out is detected."]
pub const rte_eth_dev_state_RTE_ETH_DEV_REMOVED: rte_eth_dev_state = 2;
#[doc = " Possible states of an ethdev port."]
pub type rte_eth_dev_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< Rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
unsafe extern "C" {
    #[doc = " Iterates over valid ethdev ports owned by a specific owner.\n\n @param port_id\n   The ID of the next possible valid owned port.\n @param\towner_id\n  The owner identifier.\n  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports.\n @return\n   Next valid port ID owned by owner_id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " Iterates over valid ethdev ports.\n\n @param port_id\n   The ID of the next possible valid port.\n @return\n   Next valid port ID, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
unsafe extern "C" {
    #[doc = " Iterates over ethdev ports of a specified device.\n\n @param port_id_start\n   The ID of the next possible valid port.\n @param parent\n   The generic device behind the ports to iterate.\n @return\n   Next port ID of the device, possibly port_id_start,\n   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_of(port_id_start: u16, parent: *const rte_device) -> u16;
}
unsafe extern "C" {
    #[doc = " Iterates over sibling ethdev ports (i.e. sharing the same rte_device).\n\n @param port_id_start\n   The ID of the next possible valid sibling port.\n @param ref_port_id\n   The ID of a reference port to compare rte_device with.\n @return\n   Next sibling port ID, possibly port_id_start or ref_port_id itself,\n   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_sibling(port_id_start: u16, ref_port_id: u16) -> u16;
}
unsafe extern "C" {
    #[doc = " Get a new unique owner identifier.\n An owner identifier is used to owns Ethernet devices by only one DPDK entity\n to avoid multiple management of device by different entities.\n\n @param\towner_id\n   Owner identifier pointer.\n @return\n   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set an Ethernet device owner.\n\n @param\tport_id\n  The identifier of the port to own.\n @param\towner\n  The owner pointer.\n @return\n  Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_set(
        port_id: u16,
        owner: *const rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unset Ethernet device owner to make the device ownerless.\n\n @param\tport_id\n  The identifier of port to make ownerless.\n @param\towner_id\n  The owner identifier.\n @return\n  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove owner from all Ethernet devices owned by a specific owner.\n\n @param\towner_id\n  The owner identifier.\n @return\n  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_delete(owner_id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the owner of an Ethernet device.\n\n @param\tport_id\n  The port identifier.\n @param\towner\n  The owner structure pointer to fill.\n @return\n  0 on success, negative errno value on error.."]
    pub fn rte_eth_dev_owner_get(
        port_id: u16,
        owner: *mut rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of ports which are usable for the application.\n\n These devices must be iterated by using the macro\n ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``\n to deal with non-contiguous ranges of devices.\n\n @return\n   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
unsafe extern "C" {
    #[doc = " Get the total number of ports which are allocated.\n\n Some devices may not be available for the application.\n\n @return\n   The total count of Ethernet devices."]
    pub fn rte_eth_dev_count_total() -> u16;
}
unsafe extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in\n the bitmap link_speeds of the struct rte_eth_conf\n\n @param speed\n   Numerical speed value in Mbps\n @param duplex\n   RTE_ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)\n @return\n   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
unsafe extern "C" {
    #[doc = " Get RTE_ETH_RX_OFFLOAD_* flag name.\n\n @param offload\n   Offload flag.\n @return\n   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get RTE_ETH_TX_OFFLOAD_* flag name.\n\n @param offload\n   Offload flag.\n @return\n   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get RTE_ETH_DEV_CAPA_* flag name.\n\n @param capability\n   Capability flag.\n @return\n   Capability name or 'UNKNOWN' if the flag cannot be recognized."]
    pub fn rte_eth_dev_capability_name(capability: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Configure an Ethernet device.\n This function must be invoked first before any other function in the\n Ethernet API. This function can also be re-invoked when a device is in the\n stopped state.\n\n @param port_id\n   The port identifier of the Ethernet device to configure.\n @param nb_rx_queue\n   The number of receive queues to set up for the Ethernet device.\n @param nb_tx_queue\n   The number of transmit queues to set up for the Ethernet device.\n @param eth_conf\n   The pointer to the configuration data to be used for the Ethernet device.\n   The *rte_eth_conf* structure includes:\n     -  the hardware offload features to activate, with dedicated fields for\n        each statically configurable offload hardware feature provided by\n        Ethernet devices, such as IP checksum or VLAN tag stripping for\n        example.\n        The Rx offload bitfield API is obsolete and will be deprecated.\n        Applications should set the ignore_bitfield_offloads bit on *rxmode*\n        structure and use offloads field to set per-port offloads instead.\n     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within\n        the [rt]x_offload_capa returned from rte_eth_dev_info_get().\n        Any type of device supported offloading set in the input argument\n        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled\n        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()\n     -  the Receive Side Scaling (RSS) configuration when using multiple Rx\n        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf\n        must be within the flow_type_rss_offloads provided by drivers via\n        rte_eth_dev_info_get() API.\n\n   Embedding all configuration information in a single data structure\n   is the more flexible method that allows the addition of new features\n   without changing the syntax of the API.\n @return\n   - 0: Success, device configured.\n   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if an Ethernet device was physically removed.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   1 when the Ethernet device is removed, otherwise 0."]
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device.\n\n The function allocates a contiguous block of memory for *nb_rx_desc*\n receive descriptors from a memory zone associated with *socket_id*\n and initializes each receive descriptor with a network buffer allocated\n from the memory pool *mb_pool*.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue to set up.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_rx_desc\n   The number of receive descriptors to allocate for the receive ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the receive descriptors of the ring.\n @param rx_conf\n   The pointer to the configuration data to be used for the receive queue.\n   NULL value is allowed, in which case default Rx configuration\n   will be used.\n   The *rx_conf* structure contains an *rx_thresh* structure with the values\n   of the Prefetch, Host, and Write-Back threshold registers of the receive\n   ring.\n   In addition it contains the hardware offloads features to activate using\n   the RTE_ETH_RX_OFFLOAD_* flags.\n   If an offloading set in rx_conf->offloads\n   hasn't been set in the input argument eth_conf->rxmode.offloads\n   to rte_eth_dev_configure(), it is a new added offloading, it must be\n   per-queue type and it is enabled for the queue.\n   No need to repeat any bit in rx_conf->offloads which has already been\n   enabled in rte_eth_dev_configure() at port level. An offloading enabled\n   at port level can't be disabled at queue level.\n   The configuration structure also contains the pointer to the array\n   of the receiving buffer segment descriptions, see rx_seg and rx_nseg\n   fields, this extended configuration might be used by split offloads like\n   RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT. If mb_pool is not NULL,\n   the extended configuration fields must be set to NULL and zero.\n @param mb_pool\n   The pointer to the memory pool from which to allocate *rte_mbuf* network\n   memory buffers to populate each descriptor of the receive ring. There are\n   two options to provide Rx buffer configuration:\n   - single pool:\n     mb_pool is not NULL, rx_conf.rx_nseg is 0.\n   - multiple segments description:\n     mb_pool is NULL, rx_conf.rx_seg is not NULL, rx_conf.rx_nseg is not 0.\n     Taken only if flag RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT is set in offloads.\n\n @return\n   - 0: Success, receive queue correctly set up.\n   - -EIO: if device is removed.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The memory pool pointer is null or the size of network buffers\n      which can be allocated from this memory pool does not fit the various\n      buffer sizes allowed by the device controller.\n   - -ENOMEM: Unable to allocate the receive ring descriptors or to\n      allocate network memory buffers from the memory pool when\n      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Allocate and set up a hairpin receive queue for an Ethernet device.\n\n The function set up the selected queue to be used in hairpin.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue to set up.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_rx_desc\n   The number of receive descriptors to allocate for the receive ring.\n   0 means the PMD will use default value.\n @param conf\n   The pointer to the hairpin configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_rx_hairpin_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue to set up.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_tx_desc\n   The number of transmit descriptors to allocate for the transmit ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the transmit descriptors of the ring.\n @param tx_conf\n   The pointer to the configuration data to be used for the transmit queue.\n   NULL value is allowed, in which case default Tx configuration\n   will be used.\n   The *tx_conf* structure contains the following data:\n   - The *tx_thresh* structure with the values of the Prefetch, Host, and\n     Write-Back threshold registers of the transmit ring.\n     When setting Write-Back threshold to the value greater then zero,\n     *tx_rs_thresh* value should be explicitly set to one.\n   - The *tx_free_thresh* value indicates the [minimum] number of network\n     buffers that must be pending in the transmit ring to trigger their\n     [implicit] freeing by the driver transmit function.\n   - The *tx_rs_thresh* value indicates the [minimum] number of transmit\n     descriptors that must be pending in the transmit ring before setting the\n     RS bit on a descriptor by the driver transmit function.\n     The *tx_rs_thresh* value should be less or equal then\n     *tx_free_thresh* value, and both of them should be less then\n     *nb_tx_desc* - 3.\n   - The *offloads* member contains Tx offloads to be enabled.\n     If an offloading set in tx_conf->offloads\n     hasn't been set in the input argument eth_conf->txmode.offloads\n     to rte_eth_dev_configure(), it is a new added offloading, it must be\n     per-queue type and it is enabled for the queue.\n     No need to repeat any bit in tx_conf->offloads which has already been\n     enabled in rte_eth_dev_configure() at port level. An offloading enabled\n     at port level can't be disabled at queue level.\n\n     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces\n     the transmit function to use default values.\n @return\n   - 0: Success, the transmit queue is correctly set up.\n   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Allocate and set up a transmit hairpin queue for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue to set up.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_tx_desc\n   The number of transmit descriptors to allocate for the transmit ring.\n   0 to set default PMD value.\n @param conf\n   The hairpin configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_tx_hairpin_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Get all the hairpin peer Rx / Tx ports of the current port.\n The caller should ensure that the array is large enough to save the ports\n list.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param peer_ports\n   Pointer to the array to store the peer ports list.\n @param len\n   Length of the array to store the port identifiers.\n @param direction\n   Current port to peer port direction\n   positive - current used as Tx to get all peer Rx ports.\n   zero - current used as Rx to get all peer Tx ports.\n\n @return\n   - (0 or positive) actual peer ports number.\n   - (-EINVAL) if bad parameter.\n   - (-ENODEV) if *port_id* invalid\n   - (-ENOTSUP) if hardware doesn't support.\n   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_get_peer_ports(
        port_id: u16,
        peer_ports: *mut u16,
        len: usize,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Bind all hairpin Tx queues of one port to the Rx queues of the peer port.\n It is only allowed to call this function after all hairpin queues are\n configured properly and the devices are in started state.\n\n @param tx_port\n   The identifier of the Tx port.\n @param rx_port\n   The identifier of peer Rx port.\n   RTE_MAX_ETHPORTS is allowed for the traversal of all devices.\n   Rx port ID could have the same value as Tx port ID.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if Tx port ID is invalid.\n   - (-EBUSY) if device is not in started state.\n   - (-ENOTSUP) if hardware doesn't support.\n   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_bind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Unbind all hairpin Tx queues of one port from the Rx queues of the peer port.\n This should be called before closing the Tx or Rx devices, if the bind\n function is called before.\n After unbinding the hairpin ports pair, it is allowed to bind them again.\n Changing queues configuration should be after stopping the device(s).\n\n @param tx_port\n   The identifier of the Tx port.\n @param rx_port\n   The identifier of peer Rx port.\n   RTE_MAX_ETHPORTS is allowed for traversal of all devices.\n   Rx port ID could have the same value as Tx port ID.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if Tx port ID is invalid.\n   - (-EBUSY) if device is in stopped state.\n   - (-ENOTSUP) if hardware doesn't support.\n   - Others detailed errors from PMDs."]
    pub fn rte_eth_hairpin_unbind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n  Get the number of aggregated ports of the DPDK port (specified with port_id).\n  It is used when multiple ports are aggregated into a single one.\n\n  For the regular physical port doesn't have aggregated ports,\n  the number of aggregated ports is reported as 0.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (>=0) the number of aggregated port if success."]
    pub fn rte_eth_dev_count_aggr_ports(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n  Map a Tx queue with an aggregated port of the DPDK port (specified with port_id).\n  When multiple ports are aggregated into a single one,\n  it allows to choose which port to use for Tx via a queue.\n\n  The application should use rte_eth_dev_map_aggr_tx_affinity()\n  after rte_eth_dev_configure(), rte_eth_tx_queue_setup(), and\n  before rte_eth_dev_start().\n\n @param port_id\n   The identifier of the port used in rte_eth_tx_burst().\n @param tx_queue_id\n   The index of the transmit queue used in rte_eth_tx_burst().\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param affinity\n   The number of the aggregated port.\n   Value 0 means no affinity and traffic could be routed to any aggregated port.\n   The first aggregated port is number 1 and so on.\n   The maximum number is given by rte_eth_dev_count_aggr_ports().\n\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_map_aggr_tx_affinity(
        port_id: u16,
        tx_queue_id: u16,
        affinity: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected\n\n @param port_id\n   The port identifier of the Ethernet device\n @return\n   - The NUMA socket ID which the Ethernet device is connected to.\n   - -1 (which translates to SOCKET_ID_ANY) if the socket could not be\n     determined. rte_errno is then set to:\n     - EINVAL is the port_id is invalid,\n     - 0 is the socket could not be determined,"]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if port_id of device is attached\n\n @param port_id\n   The port identifier of the Ethernet device\n @return\n   - 0 if port is out of range or not attached\n   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice.\n\n Check if Rx queue is valid.\n If the queue has been setup, it is considered valid.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue.\n @return\n   - -ENODEV: if port_id is invalid.\n   - -EINVAL: if queue_id is out of range or queue has not been setup.\n   - 0 if Rx queue is valid."]
    pub fn rte_eth_rx_queue_is_valid(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice.\n\n Check if Tx queue is valid.\n If the queue has been setup, it is considered valid.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the transmit queue.\n @return\n   - -ENODEV: if port_id is invalid.\n   - -EINVAL: if queue_id is out of range or queue has not been setup.\n   - 0 if Tx queue is valid."]
    pub fn rte_eth_tx_queue_is_valid(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start specified Rx queue of a port. It is used when rx_deferred_start\n flag of the specified queue is true.\n\n @param port_id\n   The port identifier of the Ethernet device\n @param rx_queue_id\n   The index of the Rx queue to update the ring.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the receive queue is started.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop specified Rx queue of a port\n\n @param port_id\n   The port identifier of the Ethernet device\n @param rx_queue_id\n   The index of the Rx queue to update the ring.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the receive queue is stopped.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start Tx for specified queue of a port. It is used when tx_deferred_start\n flag of the specified queue is true.\n\n @param port_id\n   The port identifier of the Ethernet device\n @param tx_queue_id\n   The index of the Tx queue to update the ring.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the transmit queue is started.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop specified Tx queue of a port\n\n @param port_id\n   The port identifier of the Ethernet device\n @param tx_queue_id\n   The index of the Tx queue to update the ring.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the transmit queue is stopped.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start an Ethernet device.\n\n The device start step is the last one and consists of setting the configured\n offload features and in starting the transmit and the receive units of the\n device.\n\n Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before\n PMD port start callback function is invoked.\n\n All device queues (except form deferred start queues) status should be\n `RTE_ETH_QUEUE_STATE_STARTED` after start.\n\n On success, all basic functions exported by the Ethernet API (link status,\n receive/transmit, and so on) can be invoked.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device started.\n   - -EAGAIN: If start operation must be retried.\n   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to\n rte_eth_dev_start()\n\n All device queues status should be `RTE_ETH_QUEUE_STATE_STOPPED` after stop.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device stopped.\n   - -EBUSY: If stopping the port is not allowed in current state.\n   - <0: Error code of the driver device stop function."]
    pub fn rte_eth_dev_stop(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Link up an Ethernet device.\n\n Set device link up will re-enable the device Rx/Tx\n functionality after it is previously set device linked down.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device linked up.\n   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Link down an Ethernet device.\n The device Rx/Tx functionality will be disabled if success,\n and it can be re-enabled with a call to\n rte_eth_dev_set_link_up()\n\n @param port_id\n   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!\n The function frees all port resources.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - Zero if the port is closed successfully.\n   - Negative if something went wrong."]
    pub fn rte_eth_dev_close(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset a Ethernet device and keep its port ID.\n\n When a port has to be reset passively, the DPDK application can invoke\n this function. For example when a PF is reset, all its VFs should also\n be reset. Normally a DPDK application can invoke this function when\n RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start\n a port reset in other circumstances.\n\n When this function is called, it first stops the port and then calls the\n PMD specific dev_uninit( ) and dev_init( ) to return the port to initial\n state, in which no Tx and Rx queues are setup, as if the port has been\n reset and not started. The port keeps the port ID it had before the\n function call.\n\n After calling rte_eth_dev_reset( ), the application should use\n rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),\n rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )\n to reconfigure the device as appropriate.\n\n Note: To avoid unexpected behavior, the application should stop calling\n Tx and Rx functions before calling rte_eth_dev_reset( ). For thread\n safety, all these controlling functions should be called from the same\n thread.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-ENOTSUP) if hardware doesn't support this function.\n   - (-EPERM) if not ran from the primary process.\n   - (-EIO) if re-initialisation failed or device is removed.\n   - (-ENOMEM) if the reset failed due to OOM.\n   - (-EAGAIN) if the reset temporarily failed and should be retried later."]
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_enable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_disable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (1) if promiscuous is enabled\n   - (0) if promiscuous is disabled.\n   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for allmulticast_enable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for allmulticast_disable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (1) if allmulticast is enabled\n   - (0) if allmulticast is disabled.\n   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),\n the negotiation (auto/fixed), and if available, the speed (Mbps).\n\n It might need to wait up to 9 seconds.\n @see rte_eth_link_get_nowait.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param link\n   Link information written back.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if the function is not supported in PMD.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),\n the negotiation (auto/fixed), and if available, the speed (Mbps).\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param link\n   Link information written back.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if the function is not supported in PMD.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n The function converts a link_speed to a string. It handles all special\n values like unknown or none speed.\n\n @param link_speed\n   link_speed of rte_eth_link struct\n @return\n   Link speed in textual format. It's pointer to immutable memory.\n   No free is required."]
    pub fn rte_eth_link_speed_to_str(link_speed: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n The function converts a rte_eth_link struct representing a link status to\n a string.\n\n @param str\n   A pointer to a string to be filled with textual representation of\n   device status. At least RTE_ETH_LINK_MAX_STR_LEN bytes should be allocated to\n   store default link status text.\n @param len\n   Length of available memory at 'str' string.\n @param eth_link\n   Link status returned by rte_eth_link_get function\n @return\n   Number of bytes written to str array or -EINVAL if bad parameter."]
    pub fn rte_eth_link_to_str(
        str_: *mut ::std::os::raw::c_char,
        len: usize,
        eth_link: *const rte_eth_link,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Get Active lanes.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param lanes\n   Driver updates lanes with the number of active lanes.\n   On a supported NIC on link up, lanes will be a non-zero value irrespective whether the\n   link is Autonegotiated or Fixed speed. No information is displayed for error.\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n     that operation.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_speed_lanes_get(port_id: u16, lanes: *mut u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Set speed lanes supported by the NIC.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param speed_lanes\n   A non-zero number of speed lanes, that will be applied to the ethernet PHY\n   along with the fixed speed configuration. Driver returns error if the user\n   lanes is not in speeds capability list.\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n     that operation.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if *lanes* count not in speeds capability list."]
    pub fn rte_eth_speed_lanes_set(port_id: u16, speed_lanes: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Get speed lanes supported by the NIC.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param speed_lanes_capa\n   An array of supported speed and its supported lanes.\n @param num\n   Size of the speed_lanes_capa array. The size is equal to the supported speeds list size.\n   Value of num is derived by calling this api with speed_lanes_capa=NULL and num=0\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n     that operation.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if *speed_lanes* invalid"]
    pub fn rte_eth_speed_lanes_get_capability(
        port_id: u16,
        speed_lanes_capa: *mut rte_eth_speed_lanes_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param stats\n   A pointer to a structure of type *rte_eth_stats* to be filled with\n   the values of device counters for the following set of statistics:\n   - *ipackets* with the total of successfully received packets.\n   - *opackets* with the total of successfully transmitted packets.\n   - *ibytes*   with the total of successfully received bytes.\n   - *obytes*   with the total of successfully transmitted bytes.\n   - *ierrors*  with the total of erroneous received packets.\n   - *oerrors*  with the total of failed transmitted packets.\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if device notified to reset stats.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (<0): Error code of the driver stats reset function."]
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device.\n\n There is an assumption that 'xstat_names' and 'xstats' arrays are matched\n by array index:\n  xstats_names[i].name => xstats[i].value\n\n And the array index is same with id field of 'struct rte_eth_xstat':\n  xstats[i].id == i\n\n This assumption makes key-value pair matching less flexible but simpler.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats_names\n   An rte_eth_xstat_name array of at least *size* elements to\n   be filled. If set to NULL, the function returns the required number\n   of elements.\n @param size\n   The size of the xstats_names array (number of elements).\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port ID)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device.\n\n There is an assumption that 'xstat_names' and 'xstats' arrays are matched\n by array index:\n  xstats_names[i].name => xstats[i].value\n\n And the array index is same with id field of 'struct rte_eth_xstat':\n  xstats[i].id == i\n\n This assumption makes key-value pair matching less flexible but simpler.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats\n   A pointer to a table of structure of type *rte_eth_xstat*\n   to be filled with device statistics ids and values.\n   This parameter can be set to NULL if and only if n is 0.\n @param n\n   The size of the xstats array (number of elements).\n   If lower than the required number of elements, the function returns\n   the required number of elements.\n   If equal to zero, the xstats must be NULL, the function returns the\n   required number of elements.\n @return\n   - A positive value lower or equal to n: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than n: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port ID)."]
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats_names\n   Array to be filled in with names of requested device statistics.\n   Must not be NULL if @p ids are specified (not NULL).\n @param size\n   Number of elements in @p xstats_names array (if not NULL) and in\n   @p ids array (if not NULL). Must be 0 if both array pointers are NULL.\n @param ids\n   IDs array given by app to retrieve specific statistics. May be NULL to\n   retrieve names of all available statistics or, if @p xstats_names is\n   NULL as well, just the number of available statistics.\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: success. The given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param ids\n   IDs array given by app to retrieve specific statistics. May be NULL to\n   retrieve all available statistics or, if @p values is NULL as well,\n   just the number of available statistics.\n @param values\n   Array to be filled in with requested device statistics.\n   Must not be NULL if ids are specified (not NULL).\n @param size\n   Number of elements in @p values array (if not NULL) and in @p ids\n   array (if not NULL). Must be 0 if both array pointers are NULL.\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: success: The given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the ID of a statistic from its name.\n\n This function searches for the statistics using string compares, and\n as such should not be used on the fast-path. For fast-path retrieval of\n specific statistics, store the ID as provided in *id* from this function,\n and pass the ID to rte_eth_xstats_get()\n\n @param port_id The port to look up statistics from\n @param xstat_name The name of the statistic to return\n @param[out] id A pointer to an app-supplied uint64_t which should be\n                set to the ID of the stat if the stat exists.\n @return\n    0 on success\n    -ENODEV for invalid port_id,\n    -EIO if device is removed,\n    -EINVAL if the xstat_name doesn't exist in port_id\n    -ENOMEM if bad parameter."]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable the xstat counter of the given id.\n\n @param port_id The port to look up statistics from\n @param id The ID of the counter to enable\n @param on_off The state to set the counter to.\n @return\n    - (0) on success\n    - (-EEXIST) counter already enabled\n    - (-ENOTSUP) enable/disable is not implemented\n    - (-EINVAL) xstat id is invalid\n    - (-EPERM) enabling this counter is not permitted\n    - (-ENOSPC) no resources"]
    pub fn rte_eth_xstats_set_counter(
        port_id: u16,
        id: u64,
        on_off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query the state of the xstat counter.\n\n @param port_id The port to look up statistics from\n @param id The ID of the counter to query\n @return\n    - (0) xstat is enabled\n    - (1) xstat is disabled\n    - (-ENOTSUP) enable/disabling is not implemented\n    - (-EINVAL) xstat id is invalid"]
    pub fn rte_eth_xstats_query_state(port_id: u16, id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if device notified to reset extended stats.\n   - (-ENOTSUP) if pmd doesn't support both\n     extended stats and basic stats reset.\n   - (-ENODEV) if *port_id* invalid.\n   - (<0): Error code of the driver xstats reset function."]
    pub fn rte_eth_xstats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue\n  statistics counter.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param stat_idx\n   The per-queue packet statistics functionality number that the transmit\n   queue is to be assigned.\n   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].\n   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256.\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue\n  statistics counter.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param stat_idx\n   The per-queue packet statistics functionality number that the receive\n   queue is to be assigned.\n   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].\n   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256.\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   A pointer to a structure of type *ether_addr* to be filled with\n   the Ethernet address of the Ethernet device.\n @return\n   - (0) if successful\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_macaddr_get(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Retrieve the Ethernet addresses of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param ma\n   A pointer to an array of structures of type *ether_addr* to be filled with\n   the Ethernet addresses of the Ethernet device.\n @param num\n   Number of elements in the @p ma array.\n   Note that  rte_eth_dev_info::max_mac_addrs can be used to retrieve\n   max number of Ethernet addresses for given port.\n @return\n   - number of retrieved addresses if successful\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_macaddrs_get(
        port_id: u16,
        ma: *mut rte_ether_addr,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device.\n\n This function returns the Ethernet device information based\n on the values stored internally in the device specific data.\n For example: number of queues, descriptor limits, device\n capabilities and offload flags.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dev_info\n   A pointer to a structure of type *rte_eth_dev_info* to be filled with\n   the contextual information of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for dev_infos_get() does not exist for the device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the configuration of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dev_conf\n   Location for Ethernet device configuration to be filled in.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_conf_get(port_id: u16, dev_conf: *mut rte_eth_conf)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the firmware version of a device.\n\n @param port_id\n   The port identifier of the device.\n @param fw_version\n   A pointer to a string array storing the firmware version of a device,\n   the string includes terminating null. This pointer is allocated by caller.\n @param fw_size\n   The size of the string array pointed by fw_version, which should be\n   large enough to store firmware version of the device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if operation is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter.\n   - (>0) if *fw_size* is not enough to store firmware version, return\n          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device.\n\n When a packet type is announced as supported, it *must* be recognized by\n the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN\n and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following\n packet types for these packets:\n - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4\n - Ether/VLAN/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4\n - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER\n - Ether/VLAN/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN\n\n When a packet is received by a PMD, the most precise type must be\n returned among the ones supported. However a PMD is allowed to set\n packet type that is not in the supported list, at the condition that it\n is more precise. Therefore, a PMD announcing no supported packet types\n can still set a matching packet type in a received packet.\n\n @note\n   Better to invoke this API after the device is already started or Rx burst\n   function is decided, to obtain correct supported ptypes.\n @note\n   if a given PMD does not report what ptypes it supports, then the supported\n   ptype count is reported as 0.\n @param port_id\n   The port identifier of the Ethernet device.\n @param ptype_mask\n   A hint of what kind of packet type which the caller is interested in.\n @param ptypes\n   An array pointer to store adequate packet types, allocated by caller.\n @param num\n  Size of the array pointed by param ptypes.\n @return\n   - (>=0) Number of supported ptypes. If the number of types exceeds num,\n           only num entries will be filled into the ptypes array, but the full\n           count of supported ptypes will be returned.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Inform Ethernet device about reduced range of packet types to handle.\n\n Application can use this function to set only specific ptypes that it's\n interested. This information can be used by the PMD to optimize Rx path.\n\n The function accepts an array `set_ptypes` allocated by the caller to\n store the packet types set by the driver, the last element of the array\n is set to RTE_PTYPE_UNKNOWN. The size of the `set_ptype` array should be\n `rte_eth_dev_get_supported_ptypes() + 1` else it might only be filled\n partially.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param ptype_mask\n   The ptype family that application is interested in should be bitwise OR of\n   RTE_PTYPE_*_MASK or 0.\n @param set_ptypes\n   An array pointer to store set packet types, allocated by caller. The\n   function marks the end of array with RTE_PTYPE_UNKNOWN.\n @param num\n   Size of the array pointed by param ptypes.\n   Should be rte_eth_dev_get_supported_ptypes() + 1 to accommodate the\n   set ptypes.\n @return\n   - (0) if Success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if *ptype_mask* is invalid (or) set_ptypes is NULL and\n     num > 0."]
    pub fn rte_eth_dev_set_ptypes(
        port_id: u16,
        ptype_mask: u32,
        set_ptypes: *mut u32,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mtu\n   A pointer to a uint16_t where the retrieved MTU is to be stored.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Change the MTU of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mtu\n   A uint16_t for the MTU to be applied.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if operation is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if *mtu* invalid, validation of mtu can occur within\n     rte_eth_dev_set_mtu if dev_infos_get is supported by the device or\n     when the mtu is set using dev->dev_ops->mtu_set.\n   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received\n VLAN packets tagged with a given VLAN Tag Identifier.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param vlan_id\n   The VLAN Tag Identifier whose filtering must be enabled or disabled.\n @param on\n   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*.\n   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-ENOSYS) if VLAN filtering on *port_id* disabled.\n   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(
        port_id: u16,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a Rx queue of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param on\n   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port.\n   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN stripping not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to\n the VLAN header.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param vlan_type\n   The VLAN type.\n @param tag_type\n   The Tag Protocol ID\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN TPID setup is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param offload_mask\n   The VLAN Offload bit mask can be mixed use with \"OR\"\n       RTE_ETH_VLAN_STRIP_OFFLOAD\n       RTE_ETH_VLAN_FILTER_OFFLOAD\n       RTE_ETH_VLAN_EXTEND_OFFLOAD\n       RTE_ETH_QINQ_STRIP_OFFLOAD\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u16,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (>0) if successful. Bit mask to indicate\n       RTE_ETH_VLAN_STRIP_OFFLOAD\n       RTE_ETH_VLAN_FILTER_OFFLOAD\n       RTE_ETH_VLAN_EXTEND_OFFLOAD\n       RTE_ETH_QINQ_STRIP_OFFLOAD\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set port based Tx VLAN insertion on or off.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param pvid\n  Port based Tx VLAN identifier together with user priority.\n @param on\n  Turn on or off the port based Tx VLAN insertion.\n\n @return\n   - (0) if successful.\n   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u16,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Set Rx queue available descriptors threshold.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param queue_id\n  The index of the receive queue.\n @param avail_thresh\n  The available descriptors threshold is percentage of Rx queue size\n  which describes the availability of Rx queue for hardware.\n  If the Rx queue availability is below it,\n  the event RTE_ETH_EVENT_RX_AVAIL_THRESH is triggered.\n  [1-99] to set a new available descriptors threshold.\n  0 to disable threshold monitoring.\n\n @return\n   - 0 if successful.\n   - (-ENODEV) if @p port_id is invalid.\n   - (-EINVAL) if bad parameter.\n   - (-ENOTSUP) if available Rx descriptors threshold is not supported.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_rx_avail_thresh_set(
        port_id: u16,
        queue_id: u16,
        avail_thresh: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Find Rx queue with RTE_ETH_EVENT_RX_AVAIL_THRESH event pending.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param[inout] queue_id\n  On input starting Rx queue index to search from.\n  If the queue_id is bigger than maximum queue ID of the port,\n  search is started from 0. So that application can keep calling\n  this function to handle all pending events with a simple increment\n  of queue_id on the next call.\n  On output if return value is 1, Rx queue index with the event pending.\n @param[out] avail_thresh\n  Location for available descriptors threshold of the found Rx queue.\n\n @return\n   - 1 if an Rx queue with pending event is found.\n   - 0 if no Rx queue with pending event is found.\n   - (-ENODEV) if @p port_id is invalid.\n   - (-EINVAL) if bad parameter (e.g. @p queue_id is NULL).\n   - (-ENOTSUP) if operation is not supported.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_rx_avail_thresh_query(
        port_id: u16,
        queue_id: *mut u16,
        avail_thresh: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Structure used to buffer packets for future Tx\n Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered Tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    #[doc = " Pending packets to be sent on explicit flush or when full"]
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
unsafe extern "C" {
    #[doc = " Initialize default values for buffered transmitting\n\n @param buffer\n   Tx buffer to be initialized.\n @param size\n   Buffer size\n @return\n   0 if no error"]
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent\n\n Register a specific callback to be called when an attempt is made to send\n all packets buffered on an Ethernet port, but not all packets can\n successfully be sent. The callback registered here will be called only\n from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs.\n The default callback configured for each queue by default just frees the\n packets back to the calling mempool. If additional behaviour is required,\n for example, to count dropped packets, or to retry transmission of packets\n which cannot be sent, this function should be used to register a suitable\n callback function to implement the desired behaviour.\n The example callback \"rte_eth_tx_buffer_count_callback()\" is also\n provided as reference.\n\n @param buffer\n   The port identifier of the Ethernet device.\n @param callback\n   The function to be used as the callback.\n @param userdata\n   Arbitrary parameter to be passed to the callback function\n @return\n   0 on success, or -EINVAL if bad parameter"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets.\n\n This function can be passed to rte_eth_tx_buffer_set_err_callback() to\n adjust the default behavior when buffered packets cannot be sent. This\n function drops any unsent packets silently and is used by Tx buffered\n operations as default behavior.\n\n NOTE: this function should not be called directly, instead it should be used\n       as a callback for packet buffering.\n\n NOTE: when configuring this function as a callback with\n       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter\n       should point to an uint64_t value.\n\n @param pkts\n   The previously buffered packets which could not be sent\n @param unsent\n   The number of unsent packets in the pkts array\n @param userdata\n   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets.\n\n This function can be passed to rte_eth_tx_buffer_set_err_callback() to\n adjust the default behavior when buffered packets cannot be sent. This\n function drops any unsent packets, but also updates a user-supplied counter\n to track the overall number of packets dropped. The counter should be an\n uint64_t variable.\n\n NOTE: this function should not be called directly, instead it should be used\n       as a callback for packet buffering.\n\n NOTE: when configuring this function as a callback with\n       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter\n       should point to an uint64_t value.\n\n @param pkts\n   The previously buffered packets which could not be sent\n @param unsent\n   The number of unsent packets in the pkts array\n @param userdata\n   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The\n driver will only free the mbuf if it is no longer in use. It is the\n application's responsibility to ensure rte_eth_tx_buffer_flush(..) is\n called if needed.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the transmit queue through which output packets must be\n   sent.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param free_cnt\n   Maximum number of packets to free. Use 0 to indicate all possible packets\n   should be freed. Note that a packet may be using multiple mbufs.\n @return\n   Failure: < 0\n     -ENODEV: Invalid interface\n     -EIO: device is removed\n     -ENOTSUP: Driver does not support function\n   Success: >= 0\n     0-n: Number of packets freed. More packets may still remain in ring that\n     are in use."]
    pub fn rte_eth_tx_done_cleanup(
        port_id: u16,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Notifies unknown MACsec subevent."]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_UNKNOWN:
    rte_eth_event_macsec_subtype = 0;
#[doc = " Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events\n\tValidation check: SecTag.TCI.V = 1"]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_V_EQ1:
    rte_eth_event_macsec_subtype = 1;
#[doc = " Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events\n\tValidation check: SecTag.TCI.E = 0 && SecTag.TCI.C = 1"]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_E_EQ0_C_EQ1:
    rte_eth_event_macsec_subtype = 2;
#[doc = " Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events\n\tValidation check: SecTag.SL >= 'd48"]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SL_GTE48:
    rte_eth_event_macsec_subtype = 3;
#[doc = " Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events\n\tValidation check: SecTag.TCI.ES = 1 && SecTag.TCI.SC = 1"]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_ES_EQ1_SC_EQ1:
    rte_eth_event_macsec_subtype = 4;
#[doc = " Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events\n\tValidation check: SecTag.TCI.SC = 1 && SecTag.TCI.SCB = 1"]
pub const rte_eth_event_macsec_subtype_RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SC_EQ1_SCB_EQ1:
    rte_eth_event_macsec_subtype = 5;
#[doc = " Subtypes for MACsec offload event (@ref RTE_ETH_EVENT_MACSEC)\n raised by Ethernet device."]
pub type rte_eth_event_macsec_subtype = ::std::os::raw::c_uint;
#[doc = " Notifies unknown MACsec event."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_UNKNOWN: rte_eth_event_macsec_type = 0;
#[doc = " Notifies Sectag validation failure events."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR: rte_eth_event_macsec_type =
    1;
#[doc = " Notifies Rx SA hard expiry events."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_RX_SA_PN_HARD_EXP:
    rte_eth_event_macsec_type = 2;
#[doc = " Notifies Rx SA soft expiry events."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP:
    rte_eth_event_macsec_type = 3;
#[doc = " Notifies Tx SA hard expiry events."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_TX_SA_PN_HARD_EXP:
    rte_eth_event_macsec_type = 4;
#[doc = " Notifies Tx SA soft events."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_TX_SA_PN_SOFT_EXP:
    rte_eth_event_macsec_type = 5;
#[doc = " Notifies Invalid SA event."]
pub const rte_eth_event_macsec_type_RTE_ETH_EVENT_MACSEC_SA_NOT_VALID: rte_eth_event_macsec_type =
    6;
#[doc = " Event types for MACsec offload event (@ref RTE_ETH_EVENT_MACSEC)\n raised by eth device."]
pub type rte_eth_event_macsec_type = ::std::os::raw::c_uint;
#[doc = " Descriptor for @ref RTE_ETH_EVENT_MACSEC event.\n Used by ethdev to send extra information of the MACsec offload event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_event_macsec_desc {
    #[doc = " Type of RTE_ETH_EVENT_MACSEC_* event."]
    pub type_: rte_eth_event_macsec_type,
    #[doc = " Type of RTE_ETH_SUBEVENT_MACSEC_* subevent."]
    pub subtype: rte_eth_event_macsec_subtype,
    #[doc = " Event specific metadata.\n\n For the following events, *userdata* registered\n with the *rte_security_session* would be returned\n as metadata.\n\n @see struct rte_security_session_conf"]
    pub metadata: u64,
}
#[doc = "  PMD specific error start"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_PMD_ERROR_START:
    rte_eth_event_ipsec_subtype = -256;
#[doc = "  PMD specific error end"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_PMD_ERROR_END:
    rte_eth_event_ipsec_subtype = -1;
#[doc = " Unknown event type"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_UNKNOWN: rte_eth_event_ipsec_subtype = 0;
#[doc = " Sequence number overflow"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW:
    rte_eth_event_ipsec_subtype = 1;
#[doc = " Soft time expiry of SA"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY:
    rte_eth_event_ipsec_subtype = 2;
#[doc = " Soft byte expiry of SA determined by\n @ref rte_security_ipsec_lifetime::bytes_soft_limit"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY:
    rte_eth_event_ipsec_subtype = 3;
#[doc = " Soft packet expiry of SA determined by\n @ref rte_security_ipsec_lifetime::packets_soft_limit"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_PKT_EXPIRY:
    rte_eth_event_ipsec_subtype = 4;
#[doc = " Hard byte expiry of SA determined by\n @ref rte_security_ipsec_lifetime::bytes_hard_limit"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_BYTE_HARD_EXPIRY:
    rte_eth_event_ipsec_subtype = 5;
#[doc = " Hard packet expiry of SA determined by\n @ref rte_security_ipsec_lifetime::packets_hard_limit"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_PKT_HARD_EXPIRY:
    rte_eth_event_ipsec_subtype = 6;
#[doc = " Max value of this enum"]
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_MAX: rte_eth_event_ipsec_subtype = 7;
#[doc = " Subtypes for IPsec offload event(@ref RTE_ETH_EVENT_IPSEC) raised by\n eth device."]
pub type rte_eth_event_ipsec_subtype = ::std::os::raw::c_int;
#[doc = " Descriptor for @ref RTE_ETH_EVENT_IPSEC event. Used by eth dev to send extra\n information of the IPsec offload event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_event_ipsec_desc {
    #[doc = " Type of RTE_ETH_EVENT_IPSEC_* event"]
    pub subtype: rte_eth_event_ipsec_subtype,
    #[doc = " Event specific metadata.\n\n For the following events, *userdata* registered\n with the *rte_security_session* would be returned\n as metadata,\n\n - @ref RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW\n - @ref RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY\n - @ref RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY\n - @ref RTE_ETH_EVENT_IPSEC_SA_PKT_EXPIRY\n - @ref RTE_ETH_EVENT_IPSEC_SA_BYTE_HARD_EXPIRY\n - @ref RTE_ETH_EVENT_IPSEC_SA_PKT_HARD_EXPIRY\n\n @see struct rte_security_session_conf\n"]
    pub metadata: u64,
}
#[doc = "< unknown event type"]
pub const rte_eth_event_type_RTE_ETH_EVENT_UNKNOWN: rte_eth_event_type = 0;
#[doc = "< lsc interrupt event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_LSC: rte_eth_event_type = 1;
#[doc = " queue state event (enabled/disabled)"]
pub const rte_eth_event_type_RTE_ETH_EVENT_QUEUE_STATE: rte_eth_event_type = 2;
#[doc = " reset interrupt event, sent to VF on PF reset"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RESET: rte_eth_event_type = 3;
#[doc = "< message from the VF received by PF"]
pub const rte_eth_event_type_RTE_ETH_EVENT_VF_MBOX: rte_eth_event_type = 4;
#[doc = "< MACsec offload related event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MACSEC: rte_eth_event_type = 5;
#[doc = "< device removal event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RMV: rte_eth_event_type = 6;
#[doc = " The port is being probed, i.e. allocated and not yet available.\n It is too early to check validity, query infos, and configure\n the port. But some functions, like rte_eth_dev_socket_id() and\n rte_eth_dev_owner_*() are available to the application."]
pub const rte_eth_event_type_RTE_ETH_EVENT_NEW: rte_eth_event_type = 7;
#[doc = "< port is released"]
pub const rte_eth_event_type_RTE_ETH_EVENT_DESTROY: rte_eth_event_type = 8;
#[doc = "< IPsec offload related event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_IPSEC: rte_eth_event_type = 9;
#[doc = "< New aged-out flows is detected"]
pub const rte_eth_event_type_RTE_ETH_EVENT_FLOW_AGED: rte_eth_event_type = 10;
#[doc = " Number of available Rx descriptors is smaller than the threshold.\n @see rte_eth_rx_avail_thresh_set()"]
pub const rte_eth_event_type_RTE_ETH_EVENT_RX_AVAIL_THRESH: rte_eth_event_type = 11;
#[doc = " Port recovering from a hardware or firmware error.\n If PMD supports proactive error recovery,\n it should trigger this event to notify application\n that it detected an error and the recovery is being started.\n Upon receiving the event, the application should not invoke any control path API\n (such as rte_eth_dev_configure/rte_eth_dev_stop...) until receiving\n RTE_ETH_EVENT_RECOVERY_SUCCESS or RTE_ETH_EVENT_RECOVERY_FAILED event.\n The PMD will set the data path pointers to dummy functions,\n and re-set the data path pointers to non-dummy functions\n before reporting RTE_ETH_EVENT_RECOVERY_SUCCESS event.\n It means that the application cannot send or receive any packets\n during this period.\n @note Before the PMD reports the recovery result,\n the PMD may report the RTE_ETH_EVENT_ERR_RECOVERING event again,\n because a larger error may occur during the recovery."]
pub const rte_eth_event_type_RTE_ETH_EVENT_ERR_RECOVERING: rte_eth_event_type = 12;
#[doc = " Port recovers successfully from the error.\n The PMD already re-configured the port,\n and the effect is the same as a restart operation.\n a) The following operation will be retained: (alphabetically)\n    - DCB configuration\n    - FEC configuration\n    - Flow control configuration\n    - LRO configuration\n    - LSC configuration\n    - MTU\n    - MAC address (default and those supplied by MAC address array)\n    - Promiscuous and allmulticast mode\n    - PTP configuration\n    - Queue (Rx/Tx) settings\n    - Queue statistics mappings\n    - RSS configuration by rte_eth_dev_rss_xxx() family\n    - Rx checksum configuration\n    - Rx interrupt settings\n    - Traffic management configuration\n    - VLAN configuration (including filtering, tpid, strip, pvid)\n    - VMDq configuration\n b) The following configuration maybe retained\n    or not depending on the device capabilities:\n    - flow rules\n      (@see RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP)\n    - shared flow objects\n      (@see RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP)\n c) Any other configuration will not be stored\n    and will need to be re-configured."]
pub const rte_eth_event_type_RTE_ETH_EVENT_RECOVERY_SUCCESS: rte_eth_event_type = 13;
#[doc = " Port recovery failed.\n It means that the port should not be usable anymore.\n The application should close the port."]
pub const rte_eth_event_type_RTE_ETH_EVENT_RECOVERY_FAILED: rte_eth_event_type = 14;
#[doc = "< max value of this enum"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MAX: rte_eth_event_type = 15;
#[doc = " The eth device event type for interrupt, and maybe others in the future."]
pub type rte_eth_event_type = ::std::os::raw::c_uint;
#[doc = " User application callback to be registered for interrupts.\n\n Note: there is no guarantee in the DPDK drivers that a callback won't be\n       called in the middle of other parts of the ethdev API. For example,\n       imagine that thread A calls rte_eth_dev_start() and as part of this\n       call, a RTE_ETH_EVENT_INTR_RESET event gets generated and the\n       associated callback is ran on thread A. In that example, if the\n       application protects its internal data using locks before calling\n       rte_eth_dev_start(), and the callback takes a same lock, a deadlock\n       occurs. Because of this, it is highly recommended NOT to take locks in\n       those callbacks."]
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register a callback function for port event.\n\n @param port_id\n  Port ID.\n  RTE_ETH_ALL means register the event for all port ids.\n @param event\n  Event interested.\n @param cb_fn\n  User supplied callback function to be called.\n @param cb_arg\n  Pointer to the parameters for the registered callback.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister a callback function for port event.\n\n @param port_id\n  Port ID.\n  RTE_ETH_ALL means unregister the event for all port ids.\n @param event\n  Event interested.\n @param cb_fn\n  User supplied callback function to be called.\n @param cb_arg\n  Pointer to the parameters for the registered callback. -1 means to\n  remove all for the same callback address and same event.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " When there is no Rx packet coming in Rx Queue for a long time, we can\n sleep lcore related to Rx Queue for power saving, and enable Rx interrupt\n to be triggered when Rx packet arrives.\n\n The rte_eth_dev_rx_intr_enable() function enables Rx queue\n interrupt on specific Rx queue of a port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " When lcore wakes up from Rx interrupt indicating packet coming, disable Rx\n interrupt and returns to polling mode.\n\n The rte_eth_dev_rx_intr_disable() function disables Rx queue\n interrupt on specific Rx queue of a port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Rx Interrupt control per port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param epfd\n   Epoll instance fd which the intr vector associated to.\n   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.\n @param op\n   The operation be performed for the vector.\n   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.\n @param data\n   User raw data.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Rx Interrupt control per queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param epfd\n   Epoll instance fd which the intr vector associated to.\n   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.\n @param op\n   The operation be performed for the vector.\n   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.\n @param data\n   User raw data.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get interrupt fd per Rx queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (>=0) the interrupt fd associated to the requested Rx queue if\n           successful.\n   - (-1) on error."]
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Turn on the LED on the Ethernet device.\n This function turns on the LED on the Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Turn off the LED on the Ethernet device.\n This function turns off the LED on the Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Get Forward Error Correction(FEC) capability.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param speed_fec_capa\n   speed_fec_capa is out only with per-speed capabilities.\n   If set to NULL, the function returns the required number\n   of required array entries.\n @param num\n   a number of elements in an speed_fec_capa array.\n\n @return\n   - A non-negative value lower or equal to num: success. The return value\n     is the number of entries filled in the fec capa array.\n   - A non-negative value higher than num: error, the given fec capa array\n     is too small. The return value corresponds to the num that should\n     be given to succeed. The entries in fec capa array are not valid and\n     shall not be used by the caller.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n     that operation.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if *num* or *speed_fec_capa* invalid"]
    pub fn rte_eth_fec_get_capability(
        port_id: u16,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Get current Forward Error Correction(FEC) mode.\n If link is down and AUTO is enabled, AUTO is returned, otherwise,\n configured FEC mode is returned.\n If link is up, current FEC mode is returned.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fec_capa\n   A bitmask with the current FEC mode.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n     that operation.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_get(port_id: u16, fec_capa: *mut u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Set Forward Error Correction(FEC) mode.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fec_capa\n   A bitmask of allowed FEC modes.\n   If only the AUTO bit is set, the decision on which FEC\n   mode to use will be made by HW/FW or driver.\n   If the AUTO bit is set with some FEC modes, only specified\n   FEC modes can be set.\n   If AUTO bit is clear, specify FEC mode to be used\n   (only one valid mode per speed may be set).\n @return\n   - (0) if successful.\n   - (-EINVAL) if the FEC mode is not valid.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support.\n   - (-EIO) if device is removed.\n   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_set(port_id: u16, fec_capa: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get current status of the Ethernet link flow control for Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fc_conf\n   The pointer to the structure where to store the flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support flow control.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EIO)  if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the Ethernet link flow control for Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fc_conf\n   The pointer to the structure of the flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support flow control mode.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if bad parameter\n   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the Ethernet priority flow control under DCB environment\n for Ethernet device.\n\n @param port_id\n The port identifier of the Ethernet device.\n @param pfc_conf\n The pointer to the structure of the priority flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support priority flow control mode.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if bad parameter\n   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u16,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a MAC address to the set used for filtering incoming packets.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   The MAC address to add.\n @param pool\n   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is\n   not enabled, this should be set to 0.\n @return\n   - (0) if successfully added or *mac_addr* was already added.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port* is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOSPC) if no more MAC addresses can be added.\n   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_add(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the information for queue based PFC.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param pfc_queue_info\n   A pointer to a structure of type *rte_eth_pfc_queue_info* to be filled with\n   the information about queue based PFC.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for priority_flow_ctrl_queue_info_get does not exist.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_priority_flow_ctrl_queue_info_get(
        port_id: u16,
        pfc_queue_info: *mut rte_eth_pfc_queue_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Configure the queue based priority flow control for a given queue\n for Ethernet device.\n\n @note When an ethdev port switches to queue based PFC mode, the\n unconfigured queues shall be configured by the driver with\n default values such as lower priority value for TC etc.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param pfc_queue_conf\n   The pointer to the structure of the priority flow control parameters\n   for the queue.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support queue based PFC mode.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if bad parameter\n   - (-EIO)     if flow control setup queue failure"]
    pub fn rte_eth_dev_priority_flow_ctrl_queue_configure(
        port_id: u16,
        pfc_queue_conf: *mut rte_eth_pfc_queue_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a MAC address from the internal array of addresses.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   MAC address to remove.\n @return\n   - (0) if successful, or *mac_addr* didn't exist.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port* invalid.\n   - (-EADDRINUSE) if attempting to remove the default MAC address.\n   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_remove(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the default MAC address.\n It replaces the address at index 0 of the MAC address list.\n If the address was already in the MAC address list,\n please remove it first.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   New default MAC address.\n @return\n   - (0) if successful, or *mac_addr* didn't exist.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port* invalid.\n   - (-EINVAL) if MAC address is invalid.\n   - (-EEXIST) if MAC address was already in the address list."]
    pub fn rte_eth_dev_default_mac_addr_set(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param reta_conf\n   RETA to update.\n @param reta_size\n   Redirection table size. The table size can be queried by\n   rte_eth_dev_info_get().\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param reta_conf\n   RETA to query. For each requested reta entry, corresponding bit\n   in mask must be set.\n @param reta_size\n   Redirection table size. The table size can be queried by\n   rte_eth_dev_info_get().\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Updates unicast hash table for receiving packet with the given destination\n MAC address, and the packet is routed to all VFs for which the Rx mode is\n accept packets that match the unicast hash table.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param addr\n   Unicast MAC address.\n @param on\n    1 - Set an unicast hash bit for receiving packets with the MAC address.\n    0 - Clear an unicast hash bit.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_hash_table_set(
        port_id: u16,
        addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Updates all unicast hash bitmaps for receiving packet with any Unicast\n Ethernet MAC addresses,the packet is routed to all VFs for which the Rx\n mode is accept packets that match the unicast hash table.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param on\n    1 - Set all unicast hash bitmaps for receiving all the Ethernet\n         MAC addresses\n    0 - Clear all unicast hash bitmaps\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the rate limitation for a queue on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_idx\n   The queue ID.\n @param tx_rate\n   The Tx rate in Mbps. Allocated from the total port link speed.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u16,
        queue_idx: u16,
        tx_rate: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configuration of Receive Side Scaling hash computation of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rss_conf\n   The new configuration to use for RSS hash computation on the port.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve current configuration of Receive Side Scaling hash computation\n of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rss_conf\n   Where to store the current RSS hash configuration of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support RSS.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice.\n\n  Get the name of RSS hash algorithm.\n\n @param rss_algo\n   Hash algorithm.\n\n @return\n   Hash algorithm name or 'UNKNOWN' if the rss_algo cannot be recognized."]
    pub fn rte_eth_dev_rss_algo_name(
        rss_algo: rte_eth_hash_function,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice.\n\n Get RSS hash algorithm by its name.\n\n @param name\n   RSS hash algorithm.\n\n @param algo\n   Return the RSS hash algorithm found, @see rte_eth_hash_function.\n\n @return\n   - (0) if successful.\n   - (-EINVAL) if not found."]
    pub fn rte_eth_find_rss_algo(
        name: *const ::std::os::raw::c_char,
        algo: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add UDP tunneling port for a type of tunnel.\n\n Some NICs may require such configuration to properly parse a tunnel\n with any standard or custom UDP port.\n The packets with this UDP port will be parsed for this type of tunnel.\n The device parser will also check the rest of the tunnel headers\n before classifying the packet.\n\n With some devices, this API will affect packet classification, i.e.:\n     - mbuf.packet_type reported on Rx\n     - rte_flow rules with tunnel items\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tunnel_udp\n   UDP tunneling configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete UDP tunneling port for a type of tunnel.\n\n The packets with this UDP port will not be classified as this type of tunnel\n anymore if the device use such mapping for tunnel packet classification.\n\n @see rte_eth_dev_udp_tunnel_port_add\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tunnel_udp\n   UDP tunneling configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get DCB information on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dcb_info\n   DCB information.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u16,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Add a callback to be called on packet Rx on a given port and queue.\n\n This API configures a function to be called for each burst of\n packets received on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_rx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue. Inter-thread synchronization\n   of any user data changes is the responsibility of the user.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Add a callback that must be called first on packet Rx on a given port\n and queue.\n\n This API configures a first function to be called for each burst of\n packets received on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_rx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue. Inter-thread synchronization\n   of any user data changes is the responsibility of the user.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Add a callback to be called on packet Tx on a given port and queue.\n\n This API configures a function to be called for each burst of\n packets sent on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_tx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue. Inter-thread synchronization\n   of any user data changes is the responsibility of the user.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Remove an Rx packet callback from a given port and queue.\n\n This function is used to removed callbacks that were added to a NIC port\n queue using rte_eth_add_rx_callback().\n\n Note: the callback is removed from the callback list but it isn't freed\n since the it may still be in use. The memory for the callback can be\n subsequently freed back by the application by calling rte_free():\n\n - Immediately - if the port is stopped, or the user knows that no\n   callbacks are in flight e.g. if called from the thread doing Rx/Tx\n   on that queue.\n\n - After a short delay - where the delay is sufficient to allow any\n   in-flight callbacks to complete. Alternately, the RCU mechanism can be\n   used to detect when data plane threads have ceased referencing the\n   callback memory.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device from which the callback is to be removed.\n @param user_cb\n   User supplied callback created via rte_eth_add_rx_callback().\n\n @return\n   - 0: Success. Callback was removed.\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: Callback support is not available.\n   - -EINVAL:  The queue_id is out of range, or the callback\n               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a Tx packet callback from a given port and queue.\n\n This function is used to removed callbacks that were added to a NIC port\n queue using rte_eth_add_tx_callback().\n\n Note: the callback is removed from the callback list but it isn't freed\n since the it may still be in use. The memory for the callback can be\n subsequently freed back by the application by calling rte_free():\n\n - Immediately - if the port is stopped, or the user knows that no\n   callbacks are in flight e.g. if called from the thread doing Rx/Tx\n   on that queue.\n\n - After a short delay - where the delay is sufficient to allow any\n   in-flight callbacks to complete. Alternately, the RCU mechanism can be\n   used to detect when data plane threads have ceased referencing the\n   callback memory.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device from which the callback is to be removed.\n @param user_cb\n   User supplied callback created via rte_eth_add_tx_callback().\n\n @return\n   - 0: Success. Callback was removed.\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: Callback support is not available.\n   - -EINVAL:  The queue_id is out of range, or the callback\n               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about given port's Rx queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Rx queue on the Ethernet device for which information\n   will be retrieved.\n @param qinfo\n   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with\n   the information of the Ethernet device.\n\n @return\n   - 0: Success\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The queue_id is out of range, or the queue\n               is hairpin queue."]
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about given port's Tx queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Tx queue on the Ethernet device for which information\n   will be retrieved.\n @param qinfo\n   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with\n   the information of the Ethernet device.\n\n @return\n   - 0: Success\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The queue_id is out of range, or the queue\n               is hairpin queue."]
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Retrieve information about given ports's Rx queue for recycling mbufs.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Rx queue on the Ethernet devicefor which information\n   will be retrieved.\n @param recycle_rxq_info\n   A pointer to a structure of type *rte_eth_recycle_rxq_info* to be filled.\n\n @return\n   - 0: Success\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_recycle_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about the Rx packet burst mode.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Rx queue on the Ethernet device for which information\n   will be retrieved.\n @param mode\n   A pointer to a structure of type *rte_eth_burst_mode* to be filled\n   with the information of the packet burst mode.\n\n @return\n   - 0: Success\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_rx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about the Tx packet burst mode.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Tx queue on the Ethernet device for which information\n   will be retrieved.\n @param mode\n   A pointer to a structure of type *rte_eth_burst_mode* to be filled\n   with the information of the packet burst mode.\n\n @return\n   - 0: Success\n   - -ENODEV:  If *port_id* is invalid.\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_tx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the monitor condition for a given receive queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Rx queue on the Ethernet device for which information\n   will be retrieved.\n @param pmc\n   The pointer to power-optimized monitoring condition structure.\n\n @return\n   - 0: Success.\n   -ENOTSUP: Operation not supported.\n   -EINVAL: Invalid parameters.\n   -ENODEV: Invalid port ID."]
    pub fn rte_eth_get_monitor_addr(
        port_id: u16,
        queue_id: u16,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the filtered device registers (values and names) and\n register attributes (number of registers and register size)\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   Pointer to rte_dev_reg_info structure to fill in.\n   - If info->filter is NULL, return info for all registers (seen as filter\n     none).\n   - If info->filter is not NULL, return error if the driver does not support\n     filter. Fill the length field with filtered register number.\n   - If info->data is NULL, the function fills in the width and length fields.\n   - If info->data is not NULL, ethdev considers there are enough spaces to\n     store the registers, and the values of registers with the filter string\n     as the module name are put into the buffer pointed at by info->data.\n   - If info->names is not NULL, drivers should fill it or the ethdev fills it\n     with default names.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info_ext(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve device registers and register attributes (number of registers and\n register size)\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   Pointer to rte_dev_reg_info structure to fill in. If info->data is\n   NULL the function fills in the width and length fields. If non-NULL\n   the registers are put into the buffer pointed at by the data field.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve size of device EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (>=0) EEPROM size if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve EEPROM and EEPROM attribute\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes buffer for return EEPROM data and\n   EEPROM attributes to be filled.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Program EEPROM with provided data\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes EEPROM data for programming and\n   EEPROM attributes to be filled\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_set_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the type and size of plugin module EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param modinfo\n   The type and size of plugin module EEPROM.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_info(
        port_id: u16,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the data of plugin module EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes the plugin module EEPROM attributes, and the\n   buffer for return plugin module EEPROM data.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the list of multicast addresses to filter on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mc_addr_set\n   The array of multicast addresses to set. Equal to NULL when the function\n   is invoked to flush the set of filtered addresses.\n @param nb_mc_addr\n   The number of multicast addresses in the *mc_addr_set* array. Equal to 0\n   when the function is invoked to flush the set of filtered addresses.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering.\n   - (-ENOSPC) if *port_id* has not enough multicast filtering resources.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable IEEE1588/802.1AS timestamping for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable IEEE1588/802.1AS timestamping for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read an IEEE1588/802.1AS Rx timestamp from an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param timestamp\n   Pointer to the timestamp struct.\n @param flags\n   Device specific flags. Used to pass the Rx timesync register index to\n   i40e. Unused in igb/ixgbe, pass 0 instead.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read an IEEE1588/802.1AS Tx timestamp from an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param timestamp\n   Pointer to the timestamp struct.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adjust the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param delta\n   The adjustment in nanoseconds.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adjust the clock frequency on an Ethernet device.\n\n Adjusts the base frequency by a specified percentage of ppm (parts per\n million). This is usually used in conjunction with other Ethdev timesync\n functions to synchronize the device time using the IEEE1588/802.1AS\n protocol.\n\n The clock is subject to frequency deviation and rate of change drift due to\n the environment. The upper layer APP calculates the frequency compensation\n value of the slave clock relative to the master clock via a servo algorithm\n and adjusts the device clock frequency via \"rte_eth_timesync_adjust_freq()\".\n Commonly used servo algorithms are pi/linreg/ntpshm, for implementation\n see: https://github.com/nxp-archive/openil_linuxptp.git.\n\n The adjustment value obtained by the servo algorithm is usually in\n ppb (parts per billion). For consistency with the kernel driver .adjfine,\n the tuning values are in ppm. Note that 1 ppb is approximately 65.536 scaled\n ppm, see Linux kernel upstream commit 1060707e3809 (ptp: introduce helpers\n to adjust by scaled parts per million).\n\n In addition, the device reference frequency is usually also the stepping\n threshold for the servo algorithm, and the frequency up and down adjustment\n range is limited by the device. The device clock frequency should be\n adjusted with \"rte_eth_timesync_adjust_freq()\" every time the clock is\n synchronised. Also use rte_eth_timesync_adjust_time() to update the device\n clock only if the absolute value of the master/slave clock offset is greater than\n or equal to the step threshold.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param ppm\n  Parts per million with 16-bit fractional field\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_freq(port_id: u16, ppm: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read the time from the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param time\n   Pointer to the timespec struct that holds the time.\n\n @return\n   - 0: Success.\n   - -EINVAL: Bad parameter."]
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the time of the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param time\n   Pointer to the timespec struct that holds the time.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_write_time(
        port_id: u16,
        time: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Read the current clock counter of an Ethernet device\n\n This returns the current raw clock value of an Ethernet device. It is\n a raw amount of ticks, with no given time reference.\n The value returned here is from the same clock than the one\n filling timestamp field of Rx packets when using hardware timestamp\n offload. Therefore it can be used to compute a precise conversion of\n the device clock to the real time.\n\n E.g, a simple heuristic to derivate the frequency would be:\n uint64_t start, end;\n rte_eth_read_clock(port, start);\n rte_delay_ms(100);\n rte_eth_read_clock(port, end);\n double freq = (end - start) * 10;\n\n Compute a common reference with:\n uint64_t base_time_sec = current_time();\n uint64_t base_clock;\n rte_eth_read_clock(port, base_clock);\n\n Then, convert the raw mbuf timestamp with:\n base_time_sec + (double)(*timestamp_dynfield(mbuf) - base_clock) / freq;\n\n This simple example will not provide a very good accuracy. One must\n at least measure multiple times the frequency and do a regression.\n To avoid deviation from the system time, the common reference can\n be repeated from time to time. The integer division can also be\n converted by a multiplication and a shift for better performance.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param clock\n   Pointer to the uint64_t that holds the raw clock value.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -ENOTSUP: The function is not supported by the Ethernet driver.\n   - -EINVAL: if bad parameter."]
    pub fn rte_eth_read_clock(port_id: u16, clock: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the port ID from device name.\n The device name should be specified as below:\n - PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0\n - SoC device name, for example- fsl-gmac0\n - vdev dpdk name, for example- net_[pcap0|null0|tap0]\n\n @param name\n   PCI address or name of the device.\n @param port_id\n   Pointer to port identifier of the device.\n @return\n   - (0) if successful and port_id is filled.\n   - (-ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the device name from port ID.\n The device name is specified as below:\n - PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0\n - SoC device name, for example- fsl-gmac0\n - vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]\n\n @param port_id\n   Port identifier of the device.\n @param name\n   Buffer of size RTE_ETH_NAME_MAX_LEN to store the name.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-EINVAL) on failure."]
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u16,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check that numbers of Rx and Tx descriptors satisfy descriptors limits from\n the Ethernet device information, otherwise adjust them to boundaries.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param nb_rx_desc\n   A pointer to a uint16_t where the number of receive\n   descriptors stored.\n @param nb_tx_desc\n   A pointer to a uint16_t where the number of transmit\n   descriptors stored.\n @return\n   - (0) if successful.\n   - (-ENOTSUP, -ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test if a port supports specific mempool ops.\n\n @param port_id\n   Port identifier of the Ethernet device.\n @param [in] pool\n   The name of the pool operations to test.\n @return\n   - 0: best mempool ops choice for this port.\n   - 1: mempool ops are supported for this port.\n   - -ENOTSUP: mempool ops not supported for this port.\n   - -ENODEV: Invalid port Identifier.\n   - -EINVAL: Pool param is null."]
    pub fn rte_eth_dev_pool_ops_supported(
        port_id: u16,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the security context for the Ethernet device.\n\n @param port_id\n   Port identifier of the Ethernet device\n @return\n   - NULL on error.\n   - pointer to security context on success."]
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Query the device hairpin capabilities.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param cap\n   Pointer to a structure that will hold the hairpin capabilities.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_hairpin_capability_get(
        port_id: u16,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor ID range entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_representor_range {
    #[doc = "< Representor type"]
    pub type_: rte_eth_representor_type,
    #[doc = "< Controller index"]
    pub controller: ::std::os::raw::c_int,
    #[doc = "< Physical function index"]
    pub pf: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_eth_representor_range__bindgen_ty_1,
    #[doc = "< Representor ID start index"]
    pub id_base: u32,
    #[doc = "< Representor ID end index"]
    pub id_end: u32,
    #[doc = "< Representor name"]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_representor_range__bindgen_ty_1 {
    #[doc = "< VF start index"]
    pub vf: ::std::os::raw::c_int,
    #[doc = "< SF start index"]
    pub sf: ::std::os::raw::c_int,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor information"]
#[repr(C)]
pub struct rte_eth_representor_info {
    #[doc = "< Controller ID of caller device."]
    pub controller: u16,
    #[doc = "< Physical function ID of caller device."]
    pub pf: u16,
    #[doc = "< Size of the ranges array."]
    pub nb_ranges_alloc: u32,
    #[doc = "< Number of initialized ranges."]
    pub nb_ranges: u32,
    #[doc = "< Representor ID range."]
    pub ranges: __IncompleteArrayField<rte_eth_representor_range>,
}
unsafe extern "C" {
    #[doc = " Retrieve the representor info of the device.\n\n Get device representor info to be able to calculate a unique\n representor ID. @see rte_eth_representor_id_get helper.\n\n @param port_id\n   The port identifier of the device.\n @param info\n   A pointer to a representor info structure.\n   NULL to return number of range entries and allocate memory\n   for next call to store detail.\n   The number of ranges that were written into this structure\n   will be placed into its nb_ranges field. This number cannot be\n   larger than the nb_ranges_alloc that by the user before calling\n   this function. It can be smaller than the value returned by the\n   function, however.\n @return\n   - (-ENOTSUP) if operation is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (>=0) number of available representor range entries."]
    pub fn rte_eth_representor_info_get(
        port_id: u16,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD.\n\n Invoke this API before the first rte_eth_dev_configure() invocation\n to let the PMD make preparations that are inconvenient to do later.\n\n The negotiation process is as follows:\n\n - the application requests features intending to use at least some of them;\n - the PMD responds with the guaranteed subset of the requested feature set;\n - the application can retry negotiation with another set of features;\n - the application can pass zero to clear the negotiation result;\n - the last negotiated result takes effect upon\n   the ethdev configure and start.\n\n @note\n   The PMD is supposed to first consider enabling the requested feature set\n   in its entirety. Only if it fails to do so, does it have the right to\n   respond with a smaller set of the originally requested features.\n\n @note\n   Return code (-ENOTSUP) does not necessarily mean that the requested\n   features are unsupported. In this case, the application should just\n   assume that these features can be used without prior negotiations.\n\n @param port_id\n   Port (ethdev) identifier\n\n @param[inout] features\n   Feature selection buffer\n\n @return\n   - (-EBUSY) if the port can't handle this in its current state;\n   - (-ENOTSUP) if the method itself is not supported by the PMD;\n   - (-ENODEV) if *port_id* is invalid;\n   - (-EINVAL) if *features* is NULL;\n   - (-EIO) if the device is removed;\n   - (0) on success"]
    pub fn rte_eth_rx_metadata_negotiate(port_id: u16, features: *mut u64)
        -> ::std::os::raw::c_int;
}
#[doc = " A structure used to get/set IP reassembly configuration. It is also used\n to get the maximum capability values that a PMD can support.\n\n If rte_eth_ip_reassembly_capability_get() returns 0, IP reassembly can be\n enabled using rte_eth_ip_reassembly_conf_set() and params values lower than\n capability params can be set in the PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ip_reassembly_params {
    #[doc = " Maximum time in ms which PMD can wait for other fragments."]
    pub timeout_ms: u32,
    #[doc = " Maximum number of fragments that can be reassembled."]
    pub max_frags: u16,
    #[doc = " Flags to enable reassembly of packet types -\n RTE_ETH_DEV_REASSEMBLY_F_xxx."]
    pub flags: u16,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Get IP reassembly capabilities supported by the PMD. This is the first API\n to be called for enabling the IP reassembly offload feature. PMD will return\n the maximum values of parameters that PMD can support and user can call\n rte_eth_ip_reassembly_conf_set() with param values lower than capability.\n\n @param port_id\n   The port identifier of the device.\n @param capa\n   A pointer to rte_eth_ip_reassembly_params structure.\n @return\n   - (-ENOTSUP) if offload configuration is not supported by device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if device is not configured or *capa* passed is NULL.\n   - (0) on success."]
    pub fn rte_eth_ip_reassembly_capability_get(
        port_id: u16,
        capa: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Get IP reassembly configuration parameters currently set in PMD.\n The API will return error if the configuration is not already\n set using rte_eth_ip_reassembly_conf_set() before calling this API or if\n the device is not configured.\n\n @param port_id\n   The port identifier of the device.\n @param conf\n   A pointer to rte_eth_ip_reassembly_params structure.\n @return\n   - (-ENOTSUP) if offload configuration is not supported by device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if device is not configured or if *conf* passed is NULL or if\n              configuration is not set using rte_eth_ip_reassembly_conf_set().\n   - (0) on success."]
    pub fn rte_eth_ip_reassembly_conf_get(
        port_id: u16,
        conf: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Set IP reassembly configuration parameters if the PMD supports IP reassembly\n offload. User should first call rte_eth_ip_reassembly_capability_get() to\n check the maximum values supported by the PMD before setting the\n configuration. The use of this API is mandatory to enable this feature and\n should be called before rte_eth_dev_start().\n\n In datapath, PMD cannot guarantee that IP reassembly is always successful.\n Hence, PMD shall register mbuf dynamic field and dynamic flag using\n rte_eth_ip_reassembly_dynfield_register() to denote incomplete IP reassembly.\n If dynfield is not successfully registered, error will be returned and\n IP reassembly offload cannot be used.\n\n @param port_id\n   The port identifier of the device.\n @param conf\n   A pointer to rte_eth_ip_reassembly_params structure.\n @return\n   - (-ENOTSUP) if offload configuration is not supported by device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if device is not configured or if device is already started or\n               if *conf* passed is NULL or if mbuf dynfield is not registered\n               successfully by the PMD.\n   - (0) on success."]
    pub fn rte_eth_ip_reassembly_conf_set(
        port_id: u16,
        conf: *const rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int;
}
#[doc = " In case of IP reassembly offload failure, packet will be updated with\n dynamic flag - RTE_MBUF_DYNFLAG_IP_REASSEMBLY_INCOMPLETE_NAME and packets\n will be returned without alteration.\n The application can retrieve the attached fragments using mbuf dynamic field\n RTE_MBUF_DYNFIELD_IP_REASSEMBLY_NAME."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ip_reassembly_dynfield_t {
    #[doc = " Next fragment packet. Application should fetch dynamic field of\n each fragment until a NULL is received and nb_frags is 0."]
    pub next_frag: *mut rte_mbuf,
    #[doc = " Time spent(in ms) by HW in waiting for further fragments."]
    pub time_spent: u16,
    #[doc = " Number of more fragments attached in mbuf dynamic fields."]
    pub nb_frags: u16,
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Dump private info from device to a file. Provided data and the order depends\n on the PMD.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param file\n   A pointer to a file for output.\n @return\n   - (0) on success.\n   - (-ENODEV) if *port_id* is invalid.\n   - (-EINVAL) if null file.\n   - (-ENOTSUP) if the device does not support this function.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_priv_dump(port_id: u16, file: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Dump ethdev Rx descriptor info to a file.\n\n This API is used for debugging, not a dataplane API.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   A Rx queue identifier on this port.\n @param offset\n  The offset of the descriptor starting from tail. (0 is the next\n  packet to be received by the driver).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_rx_descriptor_dump(
        port_id: u16,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Dump ethdev Tx descriptor info to a file.\n\n This API is used for debugging, not a dataplane API.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   A Tx queue identifier on this port.\n @param offset\n  The offset of the descriptor starting from tail. (0 is the place where\n  the next packet will be send).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_tx_descriptor_dump(
        port_id: u16,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Congestion management based on Rx queue depth"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE: rte_eth_cman_obj = 1;
#[doc = " Congestion management based on mempool depth associated with Rx queue\n @see rte_eth_rx_queue_setup()"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL: rte_eth_cman_obj = 2;
#[doc = " Enumerate list of ethdev congestion management objects"]
pub type rte_eth_cman_obj = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to retrieve information of ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_info {
    #[doc = " Set of supported congestion management modes\n @see enum rte_cman_mode"]
    pub modes_supported: u64,
    #[doc = " Set of supported congestion management objects\n @see enum rte_eth_cman_obj"]
    pub objs_supported: u64,
    #[doc = " Reserved for future fields. Always returned as 0 when\n rte_eth_cman_info_get() is invoked"]
    pub rsvd: [u8; 8usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to configure the ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_config {
    #[doc = " Congestion management object"]
    pub obj: rte_eth_cman_obj,
    #[doc = " Congestion management mode"]
    pub mode: rte_cman_mode,
    pub obj_param: rte_eth_cman_config__bindgen_ty_1,
    pub mode_param: rte_eth_cman_config__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_1 {
    #[doc = " Rx queue to configure congestion management.\n\n Valid when object is RTE_ETH_CMAN_OBJ_RX_QUEUE or\n RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL."]
    pub rx_queue: u16,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_obj_params: [u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_2 {
    #[doc = " RED configuration parameters.\n\n Valid when mode is RTE_CMAN_RED."]
    pub red: rte_cman_red_params,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_mode_params: [u8; 4usize],
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Retrieve the information for ethdev congestion management\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   A pointer to a structure of type *rte_eth_cman_info* to be filled with\n   the information about congestion management.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for cman_info_get does not exist.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_cman_info_get(
        port_id: u16,
        info: *mut rte_eth_cman_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Initialize the ethdev congestion management configuration structure with default values.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param config\n   A pointer to a structure of type *rte_eth_cman_config* to be initialized\n   with default value.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for cman_config_init does not exist.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_cman_config_init(
        port_id: u16,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Configure ethdev congestion management\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param config\n   A pointer to a structure of type *rte_eth_cman_config* to be configured.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for cman_config_set does not exist.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_cman_config_set(
        port_id: u16,
        config: *const rte_eth_cman_config,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Retrieve the applied ethdev congestion management parameters for the given port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param config\n   A pointer to a structure of type *rte_eth_cman_config* to retrieve\n   congestion management parameters for the given object.\n   Application must fill all parameters except mode_param parameter in\n   struct rte_eth_cman_config.\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for cman_config_get does not exist.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_cman_config_get(
        port_id: u16,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @file\n\n RTE Ethernet Device internal header.\n\n This header contains internal data types. But they are still part of the\n public API because they are used by inline functions in the published API.\n\n Applications should not use these directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    _unused: [u8; 0],
}
#[doc = " @internal Retrieve input packets from a receive queue of an Ethernet device."]
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Send output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Prepare output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Get number of used descriptors on a receive queue."]
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void) -> u32>;
#[doc = " @internal Check the status of a Rx descriptor"]
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get number of used descriptors on a transmit queue."]
pub type eth_tx_queue_count_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Check the status of a Tx descriptor"]
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Copy used mbufs from Tx mbuf ring into Rx mbuf ring"]
pub type eth_recycle_tx_mbufs_reuse_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ) -> u16,
>;
#[doc = " @internal Refill Rx descriptors with the recycling mbufs"]
pub type eth_recycle_rx_descriptors_refill_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, nb: u16)>;
#[doc = " @internal\n Structure used to hold opaque pointers to internal ethdev Rx/Tx\n queues data.\n The main purpose to expose these pointers at all - allow compiler\n to fetch this data for fast-path ethdev inline functions in advance."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ethdev_qdata {
    #[doc = " points to array of internal queue data pointers"]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = " points to array of queue callback data pointers"]
    pub clbk: *mut *mut ::std::os::raw::c_void,
}
#[doc = " @internal\n fast-path ethdev functions and related data are hold in a flat array.\n One entry per ethdev.\n On 64-bit systems contents of this structure occupy exactly two 64B lines.\n On 32-bit systems contents of this structure fits into one 64B line."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_fp_ops {
    #[doc = "@{*/\n/**\n Rx fast-path functions and related data.\n 64-bit systems: occupies first 64B line\n/\n/** Rx queues data."]
    pub rxq: rte_ethdev_qdata,
    #[doc = " PMD receive function."]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = " Get the number of used Rx descriptors."]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = " Check the status of a Rx descriptor."]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = " Refill Rx descriptors with the recycling mbufs."]
    pub recycle_rx_descriptors_refill: eth_recycle_rx_descriptors_refill_t,
    pub reserved1: [usize; 2usize],
    #[doc = "@{*/\n/**\n Tx fast-path functions and related data.\n 64-bit systems: occupies second 64B line\n/\n/** Tx queues data."]
    pub txq: rte_ethdev_qdata,
    #[doc = " PMD transmit function."]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = " PMD transmit prepare function."]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = " Check the status of a Tx descriptor."]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = " Copy used mbufs from Tx mbuf ring into Rx."]
    pub recycle_tx_mbufs_reuse: eth_recycle_tx_mbufs_reuse_t,
    #[doc = " Get the number of used Tx descriptors."]
    pub tx_queue_count: eth_tx_queue_count_t,
    pub reserved2: [usize; 1usize],
}
unsafe extern "C" {
    pub static mut rte_eth_fp_ops: [rte_eth_fp_ops; 32usize];
}
unsafe extern "C" {
    #[doc = " @internal\n Helper routine for rte_eth_rx_burst().\n Should be called at exit from PMD's rte_eth_rx_bulk implementation.\n Does necessary post-processing - invokes Rx callbacks if any, etc.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param queue_id\n  The index of the receive queue from which to retrieve input packets.\n @param rx_pkts\n   The address of an array of pointers to *rte_mbuf* structures that\n   have been retrieved from the device.\n @param nb_rx\n   The number of packets that were retrieved from the device.\n @param nb_pkts\n   The number of elements in @p rx_pkts array.\n @param opaque\n   Opaque pointer of Rx queue callback related data.\n\n @return\n  The number of packets effectively supplied to the @p rx_pkts array."]
    pub fn rte_eth_call_rx_callbacks(
        port_id: u16,
        queue_id: u16,
        rx_pkts: *mut *mut rte_mbuf,
        nb_rx: u16,
        nb_pkts: u16,
        opaque: *mut ::std::os::raw::c_void,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = " @internal\n Helper routine for rte_eth_tx_burst().\n Should be called before entry PMD's rte_eth_tx_bulk implementation.\n Does necessary pre-processing - invokes Tx callbacks if any, etc.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the transmit queue through which output packets must be\n   sent.\n @param tx_pkts\n   The address of an array of *nb_pkts* pointers to *rte_mbuf* structures\n   which contain the output packets.\n @param nb_pkts\n   The maximum number of packets to transmit.\n @return\n   The number of output packets to transmit."]
    pub fn rte_eth_call_tx_callbacks(
        port_id: u16,
        queue_id: u16,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        opaque: *mut ::std::os::raw::c_void,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Get supported header protocols to split on Rx.\n\n When a packet type is announced to be split,\n it *must* be supported by the PMD.\n For instance, if eth-ipv4, eth-ipv4-udp is announced,\n the PMD must return the following packet types for these packets:\n - Ether/IPv4             -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4\n - Ether/IPv4/UDP         -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4 | RTE_PTYPE_L4_UDP\n\n @param port_id\n   The port identifier of the device.\n @param[out] ptypes\n   An array pointer to store supported protocol headers, allocated by caller.\n   These ptypes are composed with RTE_PTYPE_*.\n @param num\n   Size of the array pointed by param ptypes.\n @return\n   - (>=0) Number of supported ptypes. If the number of types exceeds num,\n           only num entries will be filled into the ptypes array,\n           but the full count of supported ptypes will be returned.\n   - (-ENOTSUP) if header protocol is not supported by device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_buffer_split_get_supported_hdr_ptypes(
        port_id: u16,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rust_get_port_eth_device(port_id: u16) -> *mut rte_eth_dev;
}
unsafe extern "C" {
    pub fn rust_get_port_fp_ops(port_id: u16) -> *mut rte_eth_fp_ops;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[doc = "< class handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = "< Opaque item handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex_handle {
    pub _address: u8,
}
