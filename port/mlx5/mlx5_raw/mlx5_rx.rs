/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }}
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }}
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }}
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }}
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[doc = " Thread id descriptor."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_t {
    #[doc = "< thread identifier"]
    pub opaque_id: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data\n together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[doc = "< multi-thread safe (default mode)"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
#[doc = "< single thread only"]
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
#[doc = "< multi-thread relaxed tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
#[doc = "< multi-thread head/tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
#[doc = " prod/cons sync types"]
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[doc = " structures to hold a pair of head/tail values and other metadata.\n Depending on sync_type format of that structure might be different,\n but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure.\n\n The producer and the consumer have a head and a tail index. The particularity\n of these index is that they are not between 0 and size(ring)-1. These indexes\n are between 0 and 2^32 -1, and we mask their value when we access the ring[]\n field. Thanks to this assumption, we can do subtractions between 2 index\n values in a modulo-32bit base: that's why the overflow of the indexes is not\n a problem."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
pub type rte_xmm_t = rte_xmm;
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n layout for the first cache line for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(8))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[doc = " Bitmap data structure"]
#[repr(C)]
pub struct rte_bitmap {
    #[doc = "< Bitmap array1"]
    pub array1: *mut u64,
    #[doc = "< Bitmap array2"]
    pub array2: *mut u64,
    #[doc = "< Number of 64-bit slabs in array1 that are actually used"]
    pub array1_size: u32,
    #[doc = "< Number of 64-bit slabs in array2"]
    pub array2_size: u32,
    #[doc = "< Bitmap scan: Index of current array1 slab"]
    pub index1: u32,
    #[doc = "< Bitmap scan: Offset of current bit within current array1 slab"]
    pub offset1: u32,
    #[doc = "< Bitmap scan: Index of current array2 slab"]
    pub index2: u32,
    #[doc = "< Bitmap scan: Go/stop condition for current array2 cache line"]
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub const ibv_node_type_IBV_NODE_UNKNOWN: ibv_node_type = -1;
pub const ibv_node_type_IBV_NODE_CA: ibv_node_type = 1;
pub const ibv_node_type_IBV_NODE_SWITCH: ibv_node_type = 2;
pub const ibv_node_type_IBV_NODE_ROUTER: ibv_node_type = 3;
pub const ibv_node_type_IBV_NODE_RNIC: ibv_node_type = 4;
pub const ibv_node_type_IBV_NODE_USNIC: ibv_node_type = 5;
pub const ibv_node_type_IBV_NODE_USNIC_UDP: ibv_node_type = 6;
pub const ibv_node_type_IBV_NODE_UNSPECIFIED: ibv_node_type = 7;
pub type ibv_node_type = ::std::os::raw::c_int;
pub const ibv_transport_type_IBV_TRANSPORT_UNKNOWN: ibv_transport_type = -1;
pub const ibv_transport_type_IBV_TRANSPORT_IB: ibv_transport_type = 0;
pub const ibv_transport_type_IBV_TRANSPORT_IWARP: ibv_transport_type = 1;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC: ibv_transport_type = 2;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC_UDP: ibv_transport_type = 3;
pub const ibv_transport_type_IBV_TRANSPORT_UNSPECIFIED: ibv_transport_type = 4;
pub type ibv_transport_type = ::std::os::raw::c_int;
pub const ibv_atomic_cap_IBV_ATOMIC_NONE: ibv_atomic_cap = 0;
pub const ibv_atomic_cap_IBV_ATOMIC_HCA: ibv_atomic_cap = 1;
pub const ibv_atomic_cap_IBV_ATOMIC_GLOB: ibv_atomic_cap = 2;
pub type ibv_atomic_cap = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
pub const ibv_wc_status_IBV_WC_SUCCESS: ibv_wc_status = 0;
pub const ibv_wc_status_IBV_WC_LOC_LEN_ERR: ibv_wc_status = 1;
pub const ibv_wc_status_IBV_WC_LOC_QP_OP_ERR: ibv_wc_status = 2;
pub const ibv_wc_status_IBV_WC_LOC_EEC_OP_ERR: ibv_wc_status = 3;
pub const ibv_wc_status_IBV_WC_LOC_PROT_ERR: ibv_wc_status = 4;
pub const ibv_wc_status_IBV_WC_WR_FLUSH_ERR: ibv_wc_status = 5;
pub const ibv_wc_status_IBV_WC_MW_BIND_ERR: ibv_wc_status = 6;
pub const ibv_wc_status_IBV_WC_BAD_RESP_ERR: ibv_wc_status = 7;
pub const ibv_wc_status_IBV_WC_LOC_ACCESS_ERR: ibv_wc_status = 8;
pub const ibv_wc_status_IBV_WC_REM_INV_REQ_ERR: ibv_wc_status = 9;
pub const ibv_wc_status_IBV_WC_REM_ACCESS_ERR: ibv_wc_status = 10;
pub const ibv_wc_status_IBV_WC_REM_OP_ERR: ibv_wc_status = 11;
pub const ibv_wc_status_IBV_WC_RETRY_EXC_ERR: ibv_wc_status = 12;
pub const ibv_wc_status_IBV_WC_RNR_RETRY_EXC_ERR: ibv_wc_status = 13;
pub const ibv_wc_status_IBV_WC_LOC_RDD_VIOL_ERR: ibv_wc_status = 14;
pub const ibv_wc_status_IBV_WC_REM_INV_RD_REQ_ERR: ibv_wc_status = 15;
pub const ibv_wc_status_IBV_WC_REM_ABORT_ERR: ibv_wc_status = 16;
pub const ibv_wc_status_IBV_WC_INV_EECN_ERR: ibv_wc_status = 17;
pub const ibv_wc_status_IBV_WC_INV_EEC_STATE_ERR: ibv_wc_status = 18;
pub const ibv_wc_status_IBV_WC_FATAL_ERR: ibv_wc_status = 19;
pub const ibv_wc_status_IBV_WC_RESP_TIMEOUT_ERR: ibv_wc_status = 20;
pub const ibv_wc_status_IBV_WC_GENERAL_ERR: ibv_wc_status = 21;
pub const ibv_wc_status_IBV_WC_TM_ERR: ibv_wc_status = 22;
pub const ibv_wc_status_IBV_WC_TM_RNDV_INCOMPLETE: ibv_wc_status = 23;
pub type ibv_wc_status = ::std::os::raw::c_uint;
pub const ibv_wc_opcode_IBV_WC_SEND: ibv_wc_opcode = 0;
pub const ibv_wc_opcode_IBV_WC_RDMA_WRITE: ibv_wc_opcode = 1;
pub const ibv_wc_opcode_IBV_WC_RDMA_READ: ibv_wc_opcode = 2;
pub const ibv_wc_opcode_IBV_WC_COMP_SWAP: ibv_wc_opcode = 3;
pub const ibv_wc_opcode_IBV_WC_FETCH_ADD: ibv_wc_opcode = 4;
pub const ibv_wc_opcode_IBV_WC_BIND_MW: ibv_wc_opcode = 5;
pub const ibv_wc_opcode_IBV_WC_LOCAL_INV: ibv_wc_opcode = 6;
pub const ibv_wc_opcode_IBV_WC_TSO: ibv_wc_opcode = 7;
pub const ibv_wc_opcode_IBV_WC_FLUSH: ibv_wc_opcode = 8;
pub const ibv_wc_opcode_IBV_WC_ATOMIC_WRITE: ibv_wc_opcode = 9;
pub const ibv_wc_opcode_IBV_WC_RECV: ibv_wc_opcode = 128;
pub const ibv_wc_opcode_IBV_WC_RECV_RDMA_WITH_IMM: ibv_wc_opcode = 129;
pub const ibv_wc_opcode_IBV_WC_TM_ADD: ibv_wc_opcode = 130;
pub const ibv_wc_opcode_IBV_WC_TM_DEL: ibv_wc_opcode = 131;
pub const ibv_wc_opcode_IBV_WC_TM_SYNC: ibv_wc_opcode = 132;
pub const ibv_wc_opcode_IBV_WC_TM_RECV: ibv_wc_opcode = 133;
pub const ibv_wc_opcode_IBV_WC_TM_NO_TAG: ibv_wc_opcode = 134;
pub const ibv_wc_opcode_IBV_WC_DRIVER1: ibv_wc_opcode = 135;
pub const ibv_wc_opcode_IBV_WC_DRIVER2: ibv_wc_opcode = 136;
pub const ibv_wc_opcode_IBV_WC_DRIVER3: ibv_wc_opcode = 137;
pub type ibv_wc_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status,
    pub opcode: ibv_wc_opcode,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
pub const ibv_mw_type_IBV_MW_TYPE_1: ibv_mw_type = 1;
pub const ibv_mw_type_IBV_MW_TYPE_2: ibv_mw_type = 2;
pub type ibv_mw_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type,
}
pub const ibv_qp_type_IBV_QPT_RC: ibv_qp_type = 2;
pub const ibv_qp_type_IBV_QPT_UC: ibv_qp_type = 3;
pub const ibv_qp_type_IBV_QPT_UD: ibv_qp_type = 4;
pub const ibv_qp_type_IBV_QPT_RAW_PACKET: ibv_qp_type = 8;
pub const ibv_qp_type_IBV_QPT_XRC_SEND: ibv_qp_type = 9;
pub const ibv_qp_type_IBV_QPT_XRC_RECV: ibv_qp_type = 10;
pub const ibv_qp_type_IBV_QPT_DRIVER: ibv_qp_type = 255;
pub type ibv_qp_type = ::std::os::raw::c_uint;
pub const ibv_qp_state_IBV_QPS_RESET: ibv_qp_state = 0;
pub const ibv_qp_state_IBV_QPS_INIT: ibv_qp_state = 1;
pub const ibv_qp_state_IBV_QPS_RTR: ibv_qp_state = 2;
pub const ibv_qp_state_IBV_QPS_RTS: ibv_qp_state = 3;
pub const ibv_qp_state_IBV_QPS_SQD: ibv_qp_state = 4;
pub const ibv_qp_state_IBV_QPS_SQE: ibv_qp_state = 5;
pub const ibv_qp_state_IBV_QPS_ERR: ibv_qp_state = 6;
pub const ibv_qp_state_IBV_QPS_UNKNOWN: ibv_qp_state = 7;
pub type ibv_qp_state = ::std::os::raw::c_uint;
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE: ibv_wr_opcode = 0;
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE_WITH_IMM: ibv_wr_opcode = 1;
pub const ibv_wr_opcode_IBV_WR_SEND: ibv_wr_opcode = 2;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_IMM: ibv_wr_opcode = 3;
pub const ibv_wr_opcode_IBV_WR_RDMA_READ: ibv_wr_opcode = 4;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_CMP_AND_SWP: ibv_wr_opcode = 5;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_FETCH_AND_ADD: ibv_wr_opcode = 6;
pub const ibv_wr_opcode_IBV_WR_LOCAL_INV: ibv_wr_opcode = 7;
pub const ibv_wr_opcode_IBV_WR_BIND_MW: ibv_wr_opcode = 8;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_INV: ibv_wr_opcode = 9;
pub const ibv_wr_opcode_IBV_WR_TSO: ibv_wr_opcode = 10;
pub const ibv_wr_opcode_IBV_WR_DRIVER1: ibv_wr_opcode = 11;
pub const ibv_wr_opcode_IBV_WR_FLUSH: ibv_wr_opcode = 14;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_WRITE: ibv_wr_opcode = 15;
pub type ibv_wr_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state,
    pub qp_type: ibv_qp_type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_id {
    pub name: [::std::os::raw::c_char; 64usize],
    pub port_id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub mkey: *mut mlx5_devx_obj,
}
#[doc = " mr operations typedef"]
pub type mlx5_reg_mr_t = ::std::option::Option<
    unsafe extern "C" fn(
        pd: *mut ::std::os::raw::c_void,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        pmd_mr: *mut mlx5_pmd_mr,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_dereg_mr_t = ::std::option::Option<unsafe extern "C" fn(pmd_mr: *mut mlx5_pmd_mr)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr {
    #[doc = "< Pointer to the prev/next entry."]
    pub mr: mlx5_mr__bindgen_ty_1,
    pub pmd_mr: mlx5_pmd_mr,
    pub msl: *const rte_memseg_list,
    pub ms_base_idx: ::std::os::raw::c_int,
    pub ms_n: ::std::os::raw::c_int,
    pub ms_bmp_n: u32,
    pub ms_bmp: *mut rte_bitmap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr__bindgen_ty_1 {
    pub le_next: *mut mlx5_mr,
    pub le_prev: *mut *mut mlx5_mr,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mr_cache_entry {
    pub start: usize,
    pub end: usize,
    pub lkey: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_btree {
    pub len: u32,
    pub size: u32,
    pub table: *mut [mr_cache_entry; 0usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_ctrl {
    pub dev_gen_ptr: *mut u32,
    pub cur_gen: u32,
    pub mru: u16,
    pub head: u16,
    pub cache: [mr_cache_entry; 8usize],
    pub cache_bh: mlx5_mr_btree,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_list {
    pub lh_first: *mut mlx5_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg_list {
    pub lh_first: *mut mlx5_mempool_reg,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_share_cache {
    pub dev_gen: u32,
    pub rwlock: rte_rwlock_t,
    pub mprwlock: rte_rwlock_t,
    pub cache: mlx5_mr_btree,
    pub mr_list: mlx5_mr_list,
    pub mr_free_list: mlx5_mr_list,
    pub mempool_reg_list: mlx5_mempool_reg_list,
    pub reg_mr_cb: mlx5_reg_mr_t,
    pub dereg_mr_cb: mlx5_dereg_mr_t,
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_mprq_buf {
    pub mp: *mut rte_mempool,
    pub refcnt: u16,
    pub shinfos: __IncompleteArrayField<rte_mbuf_ext_shared_info>,
}
#[doc = " A structure describing an ID for a PCI driver. Each driver provides a\n table of these IDs for each device that it supports."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_id {
    #[doc = "< Class ID or RTE_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or RTE_PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or RTE_PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or RTE_PCI_ANY_ID."]
    pub subsystem_vendor_id: u16,
    #[doc = "< Subsystem device ID or RTE_PCI_ANY_ID."]
    pub subsystem_device_id: u16,
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
#[doc = " Ethernet address:\n A universally administered address is uniquely assigned to a device by its\n manufacturer. The first three octets (in transmission order) contain the\n Organizationally Unique Identifier (OUI). The following three (MAC-48 and\n EUI-48) octets are assigned by that organization with the only constraint\n of uniqueness.\n A locally administered address is assigned to a device by a network\n administrator and does not contain OUIs.\n See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bus {
    _unused: [u8; 0],
}
pub const rte_dev_policy_RTE_DEV_ALLOWED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLOCKED: rte_dev_policy = 1;
#[doc = " Device policies."]
pub type rte_dev_policy = ::std::os::raw::c_uint;
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Device bus specific information"]
    pub bus_info: *const ::std::os::raw::c_char,
    #[doc = "< Driver assigned after probing"]
    pub driver: *const rte_driver,
    #[doc = "< Bus handle assigned on scan"]
    pub bus: *const rte_bus,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Arguments for latest probing"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[doc = " Congestion based on Random Early Detection.\n\n https://en.wikipedia.org/wiki/Random_early_detection\n http://www.aciri.org/floyd/papers/red/red.html\n @see struct rte_cman_red_params"]
pub const rte_cman_mode_RTE_CMAN_RED: rte_cman_mode = 1;
#[doc = " Congestion management modes"]
pub type rte_cman_mode = ::std::os::raw::c_uint;
#[doc = " RED based congestion management configuration parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_cman_red_params {
    #[doc = " Minimum threshold (min_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub min_th: u8,
    #[doc = " Maximum threshold (max_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub max_th: u8,
    #[doc = " Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv)"]
    pub maxp_inv: u16,
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    _unused: [u8; 0],
}
pub const rte_devtype_RTE_DEVTYPE_ALLOWED: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLOCKED: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
#[doc = " Type of generic device"]
pub type rte_devtype = ::std::os::raw::c_uint;
#[doc = " Structure that stores a device given by the user with its arguments\n\n A user device is a physical or a virtual device given by the user to\n the DPDK application at startup through command line arguments.\n\n The structure stores the configuration of the device, its PCI\n identifier if it's a PCI device or the driver name if it's a virtual\n device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< raw string including bus, class and driver parts."]
    pub data: *mut ::std::os::raw::c_char,
}
#[doc = " Next in list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = "< legacy name."]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< driver-related part of device string."]
    pub drv_str: *const ::std::os::raw::c_char,
}
#[doc = " Callback definition for monitoring conditions. Callbacks with this signature\n will be used by `rte_power_monitor()` to check if the entering of power\n optimized state should be aborted.\n\n @param val\n   The value read from memory.\n @param opaque\n   Callback-specific data.\n\n @return\n   0 if entering of power optimized state should proceed\n   -1 if entering of power optimized state should be aborted"]
pub type rte_power_monitor_clb_t = ::std::option::Option<
    unsafe extern "C" fn(val: u64, opaque: *const u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_power_monitor_cond {
    #[doc = "< Address to monitor for changes"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (in bytes) that will be read from the\n   monitored memory location (`addr`). Can be 1, 2,\n   4, or 8. Supplying any other value will result in\n   an error."]
    pub size: u8,
    #[doc = "< Callback to be used to check if\n   entering power optimized state should\n   be aborted."]
    pub fn_: rte_power_monitor_clb_t,
    pub opaque: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_reg_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
    #[doc = " Name of target module, filter for target subset of registers.\n This field could affects register selection for data/length/names."]
    pub filter: *const ::std::os::raw::c_char,
    #[doc = "< Registers name saver"]
    pub names: *mut rte_eth_reg_name,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return EEPROM"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start EEPROM address for access"]
    pub offset: u32,
    #[doc = "< Length of EEPROM region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[doc = " Placeholder for accessing plugin module EEPROM"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module EEPROM"]
    pub type_: u32,
    #[doc = "< Length of plugin module EEPROM"]
    pub eeprom_len: u32,
}
#[doc = " A structure used to retrieve statistics for an Ethernet port.\n Not all statistics fields in struct rte_eth_stats are supported\n by any type of network interface card (NIC). If any statistics\n field is not supported, its value is 0.\n All byte-related statistics do not include Ethernet FCS regardless\n of whether these bytes have been delivered to the application\n (see RTE_ETH_RX_OFFLOAD_KEEP_CRC)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    #[doc = " Total of Rx packets dropped by the HW,\n because there are no available buffer (i.e. Rx queues are full)."]
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of Rx mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = " Total number of queue Rx packets."]
    pub q_ipackets: [u64; 16usize],
    #[doc = " Total number of queue Tx packets."]
    pub q_opackets: [u64; 16usize],
    #[doc = " Total number of successfully received queue bytes."]
    pub q_ibytes: [u64; 16usize],
    #[doc = " Total number of successfully transmitted queue bytes."]
    pub q_obytes: [u64; 16usize],
    #[doc = " Total number of queue packets received that are dropped."]
    pub q_errors: [u64; 16usize],
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link {
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_link__bindgen_ty_1 {
    #[doc = "< used for atomic64 read/write"]
    pub val64: u64,
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< RTE_ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_duplex_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_duplex_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_autoneg_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_autoneg_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_status_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to get and set lanes capabilities per link speed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_speed_lanes_capa {
    pub speed: u32,
    pub capa: u32,
}
#[doc = " A structure used to configure the ring threshold registers of an Rx/Tx\n queue for an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[doc = " None of DCB, RSS or VMDq mode"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For Rx side, only RSS is on"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For Rx side,only DCB is on."]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDq, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDq+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDq and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route\n  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = ::std::os::raw::c_uint;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For Tx side,only DCB is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For Tx side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit\n packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Rx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Requested MTU."]
    pub mtu: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = " Per-port Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.\n Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = ::std::os::raw::c_uint;
#[doc = " A structure used to describe a VLAN filter.\n If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[doc = " DEFAULT means driver decides which hash algorithm to pick."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT:
    rte_eth_hash_function = 4;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 5;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature\n of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = " In rte_eth_dev_rss_hash_conf_get(), the *rss_key_len* should be\n greater than or equal to the *hash_key_size* which get from\n rte_eth_dev_info_get() API. And the *rss_key* should contain at least\n *hash_key_size* bytes. If not meet these requirements, the query\n result is unreliable even if the operation returns success.\n\n In rte_eth_dev_rss_hash_update() or rte_eth_dev_configure(), if\n *rss_key* is not NULL, the *rss_key_len* indicates the length of the\n *rss_key* in bytes and it should be equal to *hash_key_size*.\n If *rss_key* is NULL, drivers are free to use a random or a default key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = " Indicates the type of packets or the specific part of packets to\n which RSS hashing is to be applied."]
    pub rss_hf: u64,
    #[doc = "< Hash algorithm."]
    pub algorithm: rte_eth_hash_function,
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the\n Receive Side Scaling (RSS) feature of an Ethernet port. To configure\n more than 64 entries supported by hardware, an array of this structure\n is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    #[doc = " Mask bits indicate which entries need to be updated/queried."]
    pub mask: u64,
    #[doc = " Group of 64 redirection table entries."]
    pub reta: [u16; 64usize],
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes\n in DCB configurations"]
pub type rte_eth_nb_tcs = ::std::os::raw::c_uint;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools\n in VMDq configurations."]
pub type rte_eth_nb_pools = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[doc = " A structure used to configure the VMDq+DCB feature\n of an Ethernet port.\n\n Using this feature, packets are routed to a pool of queues, based\n on the VLAN ID in the VLAN tag, and then to a specific queue within\n that pool, using the user priority VLAN tag field.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    #[doc = " Selects a queue in a pool"]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the VMDq feature of an Ethernet port when\n not combined with the DCB feature.\n\n Using this feature, packets are routed to a pool of queues. By default,\n the pool selection is based on the MAC address, the VLAN ID in the\n VLAN tag as specified in the pool_map array.\n Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool\n selection using only the MAC address. MAC address to pool mapping is done\n using the rte_eth_dev_mac_addr_add function, with the pool parameter\n corresponding to the pool ID.\n\n Queue selection within the selected pool will be done using RSS when\n it is enabled or revert to the first queue of the pool if not.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from RTE_ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the Tx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< Tx multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_tagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_tagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_untagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_untagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_pvid_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_pvid_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A structure used to configure an Rx packet segment to split.\n\n If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,\n the PMD will split the received packets into multiple segments\n according to the specification in the description array:\n\n - The first network buffer will be allocated from the memory pool,\n   specified in the first array element, the second buffer, from the\n   pool in the second element, and so on.\n\n - The proto_hdrs in the elements define the split position of\n   received packets.\n\n - The offsets from the segment description elements specify\n   the data offset from the buffer beginning except the first mbuf.\n   The first segment offset is added with RTE_PKTMBUF_HEADROOM.\n\n - The lengths in the elements define the maximal data amount\n   being received to each segment. The receiving starts with filling\n   up the first mbuf data buffer up to specified length. If the\n   there are data remaining (packet is longer than buffer in the first\n   mbuf) the following data will be pushed to the next segment\n   up to its own length, and so on.\n\n - If the length in the segment description element is zero\n   the actual buffer size will be deduced from the appropriate\n   memory pool properties.\n\n - If there is not enough elements to describe the buffer for entire\n   packet of maximal length the following parameters will be used\n   for the all remaining segments:\n     - pool from the last valid element\n     - the buffer size from this pool\n     - zero offset\n\n - Length based buffer split:\n     - mp, length, offset should be configured.\n     - The proto_hdr field must be 0.\n\n - Protocol header based buffer split:\n     - mp, offset, proto_hdr should be configured.\n     - The length field must be 0.\n     - The proto_hdr field in the last segment should be 0.\n\n - When protocol header split is enabled, NIC may receive packets\n   which do not match all the protocol headers within the Rx segments.\n   At this point, NIC will have two possible split behaviors according to\n   matching results, one is exact match, another is longest match.\n   The split result of NIC must belong to one of them.\n   The exact match means NIC only do split when the packets exactly match all\n   the protocol headers in the segments.\n   Otherwise, the whole packet will be put into the last valid mempool.\n   The longest match means NIC will do split until packets mismatch\n   the protocol header in the segments.\n   The rest will be put into the last valid pool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = " proto_hdr defines a bit mask of the protocol sequence as RTE_PTYPE_*.\n The last RTE_PTYPE* in the mask indicates the split position.\n\n If one protocol header is defined to split packets into two segments,\n for non-tunneling packets, the complete protocol sequence should be defined.\n For tunneling packets, for simplicity, only the tunnel and inner part of\n complete protocol sequence is required.\n If several protocol headers are defined to split packets into multi-segments,\n the repeated parts of adjacent segments should be omitted."]
    pub proto_hdr: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[doc = " A structure used to configure an Rx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< Rx ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of Rx descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Share group index in Rx domain and switch domain.\n Non-zero value to enable Rx queue share, zero value disable share.\n PMD is responsible for Rx queue consistency checks to avoid member\n port's configuration contradict to each other."]
    pub share_group: u16,
    #[doc = "< Shared Rx queue ID in group"]
    pub share_qid: u16,
    #[doc = " Per-queue Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_queue_offload_capa or rx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet.\n Array elements are properties for consecutive Rx segments.\n\n The supported capabilities of receiving segmentation is reported\n in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = " Array of mempools to allocate Rx buffers from.\n\n This provides support for multiple mbuf pools per Rx queue.\n The capability is reported in device info via positive\n max_rx_mempools.\n\n It could be useful for more efficient usage of memory when an\n application creates different mempools to steer the specific\n size of the packet.\n\n If many mempools are specified, packets received using Rx\n burst may belong to any provided mempool. From ethdev user point\n of view it is undefined how PMD/NIC chooses mempool for a packet.\n\n If Rx scatter is enabled, a packet may be delivered using a chain\n of mbufs obtained from single mempool or multiple mempools based\n on the NIC implementation."]
    pub rx_mempools: *mut *mut rte_mempool,
    pub rx_nmempool: u16,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " A structure used to configure a Tx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< Tx ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing Tx buffers if there are\nless free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_queue_offload_capa or tx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the Tx or Rx hairpin queue capabilities."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_queue_cap {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_eth_hairpin_queue_cap {
    #[inline]
    pub fn locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        locked_device_memory: u32,
        rte_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let locked_device_memory: u32 = unsafe { ::std::mem::transmute(locked_device_memory) };
            locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rte_memory: u32 = unsafe { ::std::mem::transmute(rte_memory) };
            rte_memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
    #[doc = "< Rx hairpin queue capabilities."]
    pub rx_cap: rte_eth_hairpin_queue_cap,
    #[doc = "< Tx hairpin queue capabilities."]
    pub tx_cap: rte_eth_hairpin_queue_cap,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure hairpin binding."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_conf {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
impl rte_eth_hairpin_conf {
    #[inline]
    pub fn peer_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_peer_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn peer_count_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_peer_count_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_explicit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_explicit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_explicit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_explicit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn manual_bind(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manual_bind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn manual_bind_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_manual_bind_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn force_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_force_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        peer_count: u32,
        tx_explicit: u32,
        manual_bind: u32,
        use_locked_device_memory: u32,
        use_rte_memory: u32,
        force_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let peer_count: u32 = unsafe { ::std::mem::transmute(peer_count) };
            peer_count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_explicit: u32 = unsafe { ::std::mem::transmute(tx_explicit) };
            tx_explicit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let manual_bind: u32 = unsafe { ::std::mem::transmute(manual_bind) };
            manual_bind as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let use_locked_device_memory: u32 =
                unsafe { ::std::mem::transmute(use_locked_device_memory) };
            use_locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let use_rte_memory: u32 = unsafe { ::std::mem::transmute(use_rte_memory) };
            use_rte_memory as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let force_memory: u32 = unsafe { ::std::mem::transmute(force_memory) };
            force_memory as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet.\n\n - For TSO packet this is the total number of data descriptors allowed\n   by device.\n\n @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU.\n\n - For non-TSO packet, this is the maximum allowed number of segments\n   in a single transmit packet.\n\n - For TSO packet each segment within the TSO may span up to this\n   value.\n\n @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_ETH_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< Rx pause frame, enable flowctrl on Tx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< Tx pause frame, enable flowctrl on Rx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure Ethernet flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[doc = " A structure used to configure Ethernet priority flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to retrieve information of queue based PFC."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_info {
    #[doc = " Maximum supported traffic class as per PFC (802.1Qbb) specification."]
    pub tc_max: u8,
    #[doc = " PFC queue mode capabilities."]
    pub mode_capa: rte_eth_fc_mode,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure Ethernet priority flow control parameters for\n ethdev queues.\n\n rte_eth_pfc_queue_conf::rx_pause structure shall be used to configure given\n tx_qid with corresponding tc. When ethdev device receives PFC frame with\n rte_eth_pfc_queue_conf::rx_pause::tc, traffic will be paused on\n rte_eth_pfc_queue_conf::rx_pause::tx_qid for that tc.\n\n rte_eth_pfc_queue_conf::tx_pause structure shall be used to configure given\n rx_qid. When rx_qid is congested, PFC frames are generated with\n rte_eth_pfc_queue_conf::rx_pause::tc and\n rte_eth_pfc_queue_conf::rx_pause::pause_time to the peer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf {
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    pub rx_pause: rte_eth_pfc_queue_conf__bindgen_ty_1,
    pub tx_pause: rte_eth_pfc_queue_conf__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_1 {
    #[doc = "< Tx queue ID"]
    pub tx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_2 {
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Rx queue ID"]
    pub rx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[doc = "< Green"]
pub const rte_color_RTE_COLOR_GREEN: rte_color = 0;
#[doc = "< Yellow"]
pub const rte_color_RTE_COLOR_YELLOW: rte_color = 1;
#[doc = "< Red"]
pub const rte_color_RTE_COLOR_RED: rte_color = 2;
#[doc = "< Number of colors"]
pub const rte_color_RTE_COLORS: rte_color = 3;
#[doc = " Color"]
pub type rte_color = ::std::os::raw::c_uint;
#[doc = " Flow rule attributes.\n\n Priorities are set on a per rule based within groups.\n\n Lower values denote higher priority, the highest priority for a flow rule\n is 0, so that a flow that matches for than one rule, the rule with the\n lowest priority value will always be matched.\n\n Although optional, applications are encouraged to group similar rules as\n much as possible to fully take advantage of hardware capabilities\n (e.g. optimized matching) and work around limitations (e.g. a single\n pattern type possibly allowed in a given group). Applications should be\n aware that groups are not linked by default, and that they must be\n explicitly linked by the application using the JUMP action.\n\n Priority levels are arbitrary and up to the application, they\n do not need to be contiguous nor start from 0, however the maximum number\n varies between devices and may be affected by existing flow rules.\n\n If a packet is matched by several rules of a given group for a given\n priority level, the outcome is undefined. It can take any path, may be\n duplicated or even cause unrecoverable errors.\n\n Note that support for more than a single group and priority level is not\n guaranteed.\n\n At vNIC / ethdev level, flow rules can apply to inbound and / or outbound\n traffic (ingress / egress), with respect to the vNIC / ethdev in question.\n At embedded switch level, flow rules apply to all traffic seen by it\n unless fitting meta items are used to set concrete traffic source(s).\n\n Several pattern items and actions are valid and can be used in both\n directions. Those valid for only one direction are described as such.\n\n At least one direction must be specified.\n\n Specifying both directions at once for a given rule is not recommended\n but may be valid in a few cases."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_attr {
    #[doc = " A group is a superset of multiple rules.\n The default group is 0 and is processed for all packets.\n Rules in other groups are processed only if the group is chained\n by a jump action from a previously matched rule.\n It means the group hierarchy is made by the flow rules,\n and the group 0 is the hierarchy root.\n Note there is no automatic dead loop protection.\n @see rte_flow_action_jump"]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " [META]\n\n End marker for item lists. Prevents further processing of items,\n thereby ending the pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_END: rte_flow_item_type = 0;
#[doc = " [META]\n\n Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VOID: rte_flow_item_type = 1;
#[doc = " [META]\n\n Inverted matching, i.e. process packets that do not match the\n pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INVERT: rte_flow_item_type = 2;
#[doc = " Matches any protocol in place of the current layer, a single ANY\n may also stand for several protocol layers.\n\n See struct rte_flow_item_any."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ANY: rte_flow_item_type = 3;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT\n\n [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n given DPDK port ID.\n\n See struct rte_flow_item_port_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_ID: rte_flow_item_type = 4;
#[doc = " Matches a byte string of a given length at a given offset.\n\n See struct rte_flow_item_raw."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RAW: rte_flow_item_type = 5;
#[doc = " Matches an Ethernet header.\n\n See struct rte_flow_item_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ETH: rte_flow_item_type = 6;
#[doc = " Matches an 802.1Q/ad VLAN tag.\n\n See struct rte_flow_item_vlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VLAN: rte_flow_item_type = 7;
#[doc = " Matches an IPv4 header.\n\n See struct rte_flow_item_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV4: rte_flow_item_type = 8;
#[doc = " Matches an IPv6 header.\n\n See struct rte_flow_item_ipv6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6: rte_flow_item_type = 9;
#[doc = " Matches an ICMP header.\n\n See struct rte_flow_item_icmp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP: rte_flow_item_type = 10;
#[doc = " Matches a UDP header.\n\n See struct rte_flow_item_udp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_UDP: rte_flow_item_type = 11;
#[doc = " Matches a TCP header.\n\n See struct rte_flow_item_tcp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TCP: rte_flow_item_type = 12;
#[doc = " Matches a SCTP header.\n\n See struct rte_flow_item_sctp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_SCTP: rte_flow_item_type = 13;
#[doc = " Matches a VXLAN header.\n\n See struct rte_flow_item_vxlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN: rte_flow_item_type = 14;
#[doc = " Matches a E_TAG header.\n\n See struct rte_flow_item_e_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_E_TAG: rte_flow_item_type = 15;
#[doc = " Matches a NVGRE header.\n\n See struct rte_flow_item_nvgre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NVGRE: rte_flow_item_type = 16;
#[doc = " Matches a MPLS header.\n\n See struct rte_flow_item_mpls."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MPLS: rte_flow_item_type = 17;
#[doc = " Matches a GRE header.\n\n See struct rte_flow_item_gre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE: rte_flow_item_type = 18;
#[doc = " [META]\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy matching option.\n Usually a fuzzy matching is fast but the cost is accuracy.\n\n See struct rte_flow_item_fuzzy."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FUZZY: rte_flow_item_type = 19;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP: rte_flow_item_type = 20;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-C packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPC: rte_flow_item_type = 21;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-U packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPU: rte_flow_item_type = 22;
#[doc = " Matches a ESP header.\n\n See struct rte_flow_item_esp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ESP: rte_flow_item_type = 23;
#[doc = " Matches a GENEVE header.\n\n See struct rte_flow_item_geneve."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE: rte_flow_item_type = 24;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_VXLAN\n\n Matches a VXLAN-GPE header.\n\n See struct rte_flow_item_vxlan_gpe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN_GPE: rte_flow_item_type = 25;
#[doc = " Matches an ARP header for Ethernet/IPv4.\n\n See struct rte_flow_item_arp_eth_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: rte_flow_item_type = 26;
#[doc = " Matches the presence of any IPv6 extension header.\n\n See struct rte_flow_item_ipv6_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_EXT: rte_flow_item_type = 27;
#[doc = " Matches any ICMPv6 header.\n\n See struct rte_flow_item_icmp6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6: rte_flow_item_type = 28;
#[doc = " Matches an ICMPv6 neighbor discovery solicitation.\n\n See struct rte_flow_item_icmp6_nd_ns."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: rte_flow_item_type = 29;
#[doc = " Matches an ICMPv6 neighbor discovery advertisement.\n\n See struct rte_flow_item_icmp6_nd_na."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: rte_flow_item_type = 30;
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option.\n\n See struct rte_flow_item_icmp6_nd_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: rte_flow_item_type = 31;
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: rte_flow_item_type = 32;
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: rte_flow_item_type = 33;
#[doc = " Matches specified mark field.\n\n See struct rte_flow_item_mark."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MARK: rte_flow_item_type = 34;
#[doc = " [META]\n\n Matches a metadata value.\n\n See struct rte_flow_item_meta."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_META: rte_flow_item_type = 35;
#[doc = " Matches a GRE optional key field.\n\n The value should a big-endian 32bit integer.\n\n When this item present the K bit is implicitly matched as \"1\"\n in the default mask.\n\n @p spec/mask type:\n @code rte_be32_t * @endcode"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_KEY: rte_flow_item_type = 36;
#[doc = " Matches a GTP extension header: PDU session container.\n\n Configure flow for GTP packets with extension header type 0x85.\n\n See struct rte_flow_item_gtp_psc."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP_PSC: rte_flow_item_type = 37;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE session packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOES: rte_flow_item_type = 38;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE discovery packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOED: rte_flow_item_type = 39;
#[doc = " Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n See struct rte_flow_item_pppoe_proto_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: rte_flow_item_type = 40;
#[doc = " Matches Network service header (NSH).\n See struct rte_flow_item_nsh.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NSH: rte_flow_item_type = 41;
#[doc = " Matches Internet Group Management Protocol (IGMP).\n See struct rte_flow_item_igmp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IGMP: rte_flow_item_type = 42;
#[doc = " Matches IP Authentication Header (AH).\n See struct rte_flow_item_ah.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AH: rte_flow_item_type = 43;
#[doc = " Matches a HIGIG header.\n see struct rte_flow_item_higig2_hdr."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_HIGIG2: rte_flow_item_type = 44;
#[doc = " [META]\n\n Matches a tag value.\n\n See struct rte_flow_item_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TAG: rte_flow_item_type = 45;
#[doc = " Matches a L2TPv3 over IP header.\n\n Configure flow for L2TPv3 over IP packets.\n\n See struct rte_flow_item_l2tpv3oip."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV3OIP: rte_flow_item_type = 46;
#[doc = " Matches PFCP Header.\n See struct rte_flow_item_pfcp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PFCP: rte_flow_item_type = 47;
#[doc = " Matches eCPRI Header.\n\n Configure flow for eCPRI over ETH or UDP packets.\n\n See struct rte_flow_item_ecpri."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ECPRI: rte_flow_item_type = 48;
#[doc = " Matches the presence of IPv6 fragment extension header.\n\n See struct rte_flow_item_ipv6_frag_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT: rte_flow_item_type = 49;
#[doc = " Matches Geneve Variable Length Option\n\n See struct rte_flow_item_geneve_opt"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE_OPT: rte_flow_item_type = 50;
#[doc = " [META]\n\n Matches on packet integrity.\n For some devices application needs to enable integration checks in HW\n before using this item.\n\n @see struct rte_flow_item_integrity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INTEGRITY: rte_flow_item_type = 51;
#[doc = " [META]\n\n Matches conntrack state.\n\n @see struct rte_flow_item_conntrack."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_CONNTRACK: rte_flow_item_type = 52;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR: rte_flow_item_type = 53;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from\n the entity represented by the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT: rte_flow_item_type = 54;
#[doc = " Matches a configured set of fields at runtime calculated offsets\n over the generic network header with variable length and\n flexible pattern\n\n @see struct rte_flow_item_flex."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FLEX: rte_flow_item_type = 55;
#[doc = " Matches L2TPv2 Header.\n\n See struct rte_flow_item_l2tpv2."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV2: rte_flow_item_type = 56;
#[doc = " Matches PPP Header.\n\n See struct rte_flow_item_ppp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPP: rte_flow_item_type = 57;
#[doc = " Matches GRE optional fields.\n\n See struct rte_flow_item_gre_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_OPTION: rte_flow_item_type = 58;
#[doc = " Matches MACsec Ethernet Header.\n\n See struct rte_flow_item_macsec."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MACSEC: rte_flow_item_type = 59;
#[doc = " Matches Meter Color Marker.\n\n See struct rte_flow_item_meter_color."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_METER_COLOR: rte_flow_item_type = 60;
#[doc = " Matches the presence of IPv6 routing extension header.\n\n @see struct rte_flow_item_ipv6_routing_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_ROUTING_EXT: rte_flow_item_type = 61;
#[doc = " Matches an ICMPv6 echo request.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REQUEST: rte_flow_item_type = 62;
#[doc = " Matches an ICMPv6 echo reply.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REPLY: rte_flow_item_type = 63;
#[doc = " Match Quota state\n\n @see struct rte_flow_item_quota"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_QUOTA: rte_flow_item_type = 64;
#[doc = " Matches on the aggregated port of the received packet.\n Used in case multiple ports are aggregated to the a DPDK port.\n First port is number 1.\n\n @see struct rte_flow_item_aggr_affinity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AGGR_AFFINITY: rte_flow_item_type = 65;
#[doc = " Match Tx queue number.\n This is valid only for egress rules.\n\n @see struct rte_flow_item_tx_queue"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TX_QUEUE: rte_flow_item_type = 66;
#[doc = " Matches an InfiniBand base transport header in RoCE packet.\n\n @see struct rte_flow_item_ib_bth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IB_BTH: rte_flow_item_type = 67;
#[doc = " Matches the packet type as defined in rte_mbuf_ptype.\n\n See struct rte_flow_item_ptype.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PTYPE: rte_flow_item_type = 68;
#[doc = " [META]\n\n Matches a random value.\n\n This value is not based on the packet data/headers.\n The application shouldn't assume that this value is kept\n during the lifetime of the packet.\n\n @see struct rte_flow_item_random."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RANDOM: rte_flow_item_type = 69;
#[doc = " Match packet with various comparison types.\n\n See struct rte_flow_item_compare."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_COMPARE: rte_flow_item_type = 70;
#[doc = " Matching pattern item types.\n\n Pattern items fall in two categories:\n\n - Matching protocol headers and packet data, usually associated with a\n   specification structure. These must be stacked in the same order as the\n   protocol layers to match inside packets, starting from the lowest.\n\n - Matching meta-data or affecting pattern processing, often without a\n   specification structure. Since they do not match packet contents, their\n   position in the list is usually not relevant.\n\n See the description of individual types for more information. Those\n marked with [META] fall into the second category."]
pub type rte_flow_item_type = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_TAG\n\n Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
#[doc = " Provides an ethdev port ID for use with the following items:\n RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR,\n RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
#[doc = " Matching pattern item definition.\n\n A pattern is formed by stacking items starting from the lowest protocol\n layer to match. This stacking restriction does not apply to meta items\n which can be placed anywhere in the stack without affecting the meaning\n of the resulting pattern.\n\n Patterns are terminated by END items.\n\n The spec field should be a valid pointer to a structure of the related\n item type. It may remain unspecified (NULL) in many cases to request\n broad (nonspecific) matching. In such cases, last and mask must also be\n set to NULL.\n\n Optionally, last can point to a structure of the same type to define an\n inclusive range. This is mostly supported by integer and address fields,\n may cause errors otherwise. Fields that do not support ranges must be set\n to 0 or to the same value as the corresponding fields in spec.\n\n Only the fields defined to nonzero values in the default masks (see\n rte_flow_item_{name}_mask constants) are considered relevant by\n default. This can be overridden by providing a mask structure of the\n same type with applicable bits set to one. It can also be used to\n partially filter out specific fields (e.g. as an alternate mean to match\n ranges of IP addresses).\n\n Mask is a simple bit-mask applied before interpreting the contents of\n spec and last, which may yield unexpected results if not used\n carefully. For example, if for an IPv4 address field, spec provides\n 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the\n effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[doc = " The protocol header can be present in the packet only once.\n No multiple flex item flow inclusions (for inner/outer) are allowed.\n No any relations with tunnel protocols are imposed. The drivers\n can optimize hardware resource usage to handle match on single flex\n item of specific type."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_SINGLE: rte_flow_item_flex_tunnel_mode =
    0;
#[doc = " Flex item presents outer header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_OUTER: rte_flow_item_flex_tunnel_mode = 1;
#[doc = " Flex item presents inner header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_INNER: rte_flow_item_flex_tunnel_mode = 2;
#[doc = " Flex item presents either inner or outer header. The driver\n handles as many multiple inners as hardware supports."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_MULTI: rte_flow_item_flex_tunnel_mode = 3;
#[doc = " Flex item presents tunnel protocol header."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_TUNNEL: rte_flow_item_flex_tunnel_mode =
    4;
#[doc = " Flex item field tunnel mode"]
pub type rte_flow_item_flex_tunnel_mode = ::std::os::raw::c_uint;
#[doc = " End marker for action lists. Prevents further processing of\n actions, thereby ending the list.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_END: rte_flow_action_type = 0;
#[doc = " Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VOID: rte_flow_action_type = 1;
#[doc = " Leaves traffic up for additional processing by subsequent flow\n rules; makes a flow rule non-terminating.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PASSTHRU: rte_flow_action_type = 2;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n See struct rte_flow_action_jump."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP: rte_flow_action_type = 3;
#[doc = " Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and\n RTE_MBUF_F_RX_FDIR_ID mbuf flags.\n\n See struct rte_flow_action_mark.\n\n One should negotiate mark delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_MARK"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MARK: rte_flow_action_type = 4;
#[doc = " Flags packets. Similar to MARK without a specific value; only\n sets the RTE_MBUF_F_RX_FDIR mbuf flag.\n\n No associated configuration structure.\n\n One should negotiate flag delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_FLAG"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_FLAG: rte_flow_action_type = 5;
#[doc = " Assigns packets to a given queue index.\n\n See struct rte_flow_action_queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUEUE: rte_flow_action_type = 6;
#[doc = " Drops packets.\n\n PASSTHRU overrides this action if both are specified.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DROP: rte_flow_action_type = 7;
#[doc = " Enables counters for this flow rule.\n\n These counters can be retrieved and reset through rte_flow_query() or\n rte_flow_action_handle_query() if the action provided via handle,\n see struct rte_flow_query_count.\n\n See struct rte_flow_action_count."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_COUNT: rte_flow_action_type = 8;
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets\n to spread them among several queues according to the provided\n parameters.\n\n See struct rte_flow_action_rss."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RSS: rte_flow_action_type = 9;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to the physical function (PF) of the\n current device.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PF: rte_flow_action_type = 10;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given virtual function of the\n current device.\n\n See struct rte_flow_action_vf."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VF: rte_flow_action_type = 11;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given DPDK port ID.\n\n See struct rte_flow_action_port_id."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_ID: rte_flow_action_type = 12;
#[doc = " Traffic metering and policing (MTR).\n\n See struct rte_flow_action_meter.\n See file rte_mtr.h for MTR object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER: rte_flow_action_type = 13;
#[doc = " Redirects packets to security engine of current device for security\n processing as specified by security session.\n\n See struct rte_flow_action_security."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SECURITY: rte_flow_action_type = 14;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by\n the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: rte_flow_action_type = 15;
#[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined\n by the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: rte_flow_action_type = 16;
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_vlan."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: rte_flow_action_type = 17;
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_vid."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: rte_flow_action_type = 18;
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_pcp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: rte_flow_action_type = 19;
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined\n by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_pop_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: rte_flow_action_type = 20;
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: rte_flow_action_type = 21;
#[doc = " Encapsulate flow in VXLAN tunnel as defined in\n rte_flow_action_vxlan_encap action structure.\n\n See struct rte_flow_action_vxlan_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: rte_flow_action_type = 22;
#[doc = " Decapsulate outer most VXLAN tunnel from matched flow.\n\n If flow pattern does not define a valid VXLAN tunnel (as specified by\n RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: rte_flow_action_type = 23;
#[doc = " Encapsulate flow in NVGRE tunnel defined in the\n rte_flow_action_nvgre_encap action structure.\n\n See struct rte_flow_action_nvgre_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: rte_flow_action_type = 24;
#[doc = " Decapsulate outer most NVGRE tunnel from matched flow.\n\n If flow pattern does not define a valid NVGRE tunnel (as specified by\n RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: rte_flow_action_type = 25;
#[doc = " Add outer header whose template is provided in its data buffer\n\n See struct rte_flow_action_raw_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_ENCAP: rte_flow_action_type = 26;
#[doc = " Remove outer header whose template is provided in its data buffer.\n\n See struct rte_flow_action_raw_decap"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_DECAP: rte_flow_action_type = 27;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 source address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: rte_flow_action_type = 28;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 destination address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: rte_flow_action_type = 29;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 source address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: rte_flow_action_type = 30;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 destination address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: rte_flow_action_type = 31;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify source port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_SRC: rte_flow_action_type = 32;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify destination port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_DST: rte_flow_action_type = 33;
#[doc = " Swap the source and destination MAC addresses in the outermost\n Ethernet header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MAC_SWAP: rte_flow_action_type = 34;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease TTL value directly\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TTL: rte_flow_action_type = 35;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set TTL value\n\n See struct rte_flow_action_set_ttl"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TTL: rte_flow_action_type = 36;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set source MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: rte_flow_action_type = 37;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set destination MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_DST: rte_flow_action_type = 38;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase sequence number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: rte_flow_action_type = 39;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease sequence number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: rte_flow_action_type = 40;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: rte_flow_action_type = 41;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: rte_flow_action_type = 42;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set Tag.\n\n Tag is for internal flow usage only and\n is not delivered to the application.\n\n See struct rte_flow_action_set_tag."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TAG: rte_flow_action_type = 43;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set metadata on ingress or egress path.\n\n See struct rte_flow_action_set_meta."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_META: rte_flow_action_type = 44;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP: rte_flow_action_type = 45;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP: rte_flow_action_type = 46;
#[doc = " Report as aged flow if timeout passed without any matching on the\n flow.\n\n See struct rte_flow_action_age.\n See function rte_flow_get_q_aged_flows\n See function rte_flow_get_aged_flows\n see enum RTE_ETH_EVENT_FLOW_AGED\n See struct rte_flow_query_age\n See struct rte_flow_update_age"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_AGE: rte_flow_action_type = 47;
#[doc = " The matching packets will be duplicated with specified ratio and\n applied with own set of actions with a fate action.\n\n See struct rte_flow_action_sample."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SAMPLE: rte_flow_action_type = 48;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_INDIRECT\n\n Describe action shared across multiple flow rules.\n\n Allow multiple rules reference the same action by handle (see\n struct rte_flow_shared_action)."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SHARED: rte_flow_action_type = 49;
#[doc = " Modify a packet header field, tag, mark or metadata.\n\n Allow the modification of an arbitrary header field via\n set, add and sub operations or copying its content into\n tag, meta or mark for future processing.\n\n See struct rte_flow_action_modify_field."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MODIFY_FIELD: rte_flow_action_type = 50;
#[doc = " An action handle is referenced in a rule through an indirect action.\n\n The same action handle may be used in multiple rules for the same\n or different ethdev ports."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT: rte_flow_action_type = 51;
#[doc = " [META]\n\n Enable tracking a TCP connection state.\n\n @see struct rte_flow_action_conntrack."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_CONNTRACK: rte_flow_action_type = 52;
#[doc = " Color the packet to reflect the meter color result.\n Set the meter color in the mbuf to the selected color.\n\n See struct rte_flow_action_meter_color."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_COLOR: rte_flow_action_type = 53;
#[doc = " At embedded switch level, sends matching traffic to the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR: rte_flow_action_type = 54;
#[doc = " At embedded switch level, send matching traffic to\n the entity represented by the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT: rte_flow_action_type = 55;
#[doc = " Traffic metering and marking (MTR).\n\n @see struct rte_flow_action_meter_mark\n See file rte_mtr.h for MTR profile object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_MARK: rte_flow_action_type = 56;
#[doc = " Send packets to the kernel, without going to userspace at all.\n The packets will be received by the kernel driver sharing\n the same device as the DPDK port on which this action is configured.\n This action mostly suits bifurcated driver model.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SEND_TO_KERNEL: rte_flow_action_type = 57;
#[doc = " Apply the quota verdict (PASS or BLOCK) to a flow.\n\n @see struct rte_flow_action_quota\n @see struct rte_flow_query_quota\n @see struct rte_flow_update_quota"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUOTA: rte_flow_action_type = 58;
#[doc = " Skip congestion management configuration.\n\n Using rte_eth_cman_config_set(), the application\n can configure ethdev Rx queue's congestion mechanism.\n This flow action allows to skip the congestion configuration\n applied to the given ethdev Rx queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SKIP_CMAN: rte_flow_action_type = 59;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH\n\n Push IPv6 extension into IPv6 packet.\n\n @see struct rte_flow_action_ipv6_ext_push."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH: rte_flow_action_type = 60;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE\n\n Remove IPv6 extension from IPv6 packet whose type\n is provided in its configuration buffer.\n\n @see struct rte_flow_action_ipv6_ext_remove."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE: rte_flow_action_type = 61;
#[doc = " Action handle to reference flow actions list.\n\n @see struct rte_flow_action_indirect_list"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT_LIST: rte_flow_action_type = 62;
#[doc = " Program action. These actions are defined by the program currently\n loaded on the device. For example, these actions are applicable to\n devices that can be programmed through the P4 language.\n\n @see struct rte_flow_action_prog."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PROG: rte_flow_action_type = 63;
#[doc = " NAT64 translation of IPv4/IPv6 headers.\n\n @see struct rte_flow_action_nat64"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NAT64: rte_flow_action_type = 64;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX,\n\n Redirects packets to a particular index in a flow table.\n\n @see struct rte_flow_action_jump_to_table_index."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX: rte_flow_action_type = 65;
#[doc = " Action types.\n\n Each possible action is represented by a type.\n An action can have an associated configuration object.\n Several actions combined in a list can be assigned\n to a flow rule and are performed in order.\n\n They fall in three categories:\n\n - Actions that modify the fate of matching traffic, for instance by\n   dropping or assigning it a specific destination.\n\n - Actions that modify matching traffic contents or its properties. This\n   includes adding/removing encapsulation, encryption, compression and\n   marks.\n\n - Actions related to the flow rule itself, such as updating counters or\n   making it non-terminating.\n\n Flow rules being terminating by default, not specifying any action of the\n fate kind results in undefined behavior. This applies to both ingress and\n egress.\n\n PASSTHRU, when supported, makes a flow rule non-terminating."]
pub type rte_flow_action_type = ::std::os::raw::c_uint;
#[doc = "< Set new quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_SET: rte_flow_update_quota_op = 0;
#[doc = "< Increase quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_ADD: rte_flow_update_quota_op = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Indirect QUOTA update operations.\n\n @see struct rte_flow_update_quota"]
pub type rte_flow_update_quota_op = ::std::os::raw::c_uint;
#[doc = " Definition of a single action.\n\n A list of actions is terminated by a END action.\n\n For simple actions without a configuration object, conf remains NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[doc = " Opaque type returned after successfully creating a flow.\n\n This handle can be used to manage and query the related flow (e.g. to\n destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine resources settings.\n The zero value means on demand resource allocations only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_port_attr {
    #[doc = " Number of counters to configure.\n @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub nb_counters: u32,
    #[doc = " Number of aging objects to configure.\n @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub nb_aging_objects: u32,
    #[doc = " Number of traffic meters to configure.\n @see RTE_FLOW_ACTION_TYPE_METER"]
    pub nb_meters: u32,
    #[doc = " Number of connection trackings to configure.\n @see RTE_FLOW_ACTION_TYPE_CONNTRACK"]
    pub nb_conn_tracks: u32,
    #[doc = " Port to base shared objects on."]
    pub host_port_id: u16,
    #[doc = " Maximum number of quota actions.\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
    pub nb_quotas: u32,
    #[doc = " Port flags (RTE_FLOW_PORT_FLAG_*)."]
    pub flags: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine asynchronous queues settings.\n The value means default value picked by PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_queue_attr {
    #[doc = " Number of flow rule operations a queue can hold."]
    pub size: u32,
}
#[doc = " Opaque type returned after successful creation of pattern template.\n This handle can be used to manage the created pattern template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_pattern_template {
    _unused: [u8; 0],
}
#[doc = " Opaque type returned after successful creation of actions template.\n This handle can be used to manage the created actions template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_actions_template {
    _unused: [u8; 0],
}
#[doc = " Opaque type returned after successful creation of a template table.\n This handle can be used to manage the created template table."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_template_table {
    _unused: [u8; 0],
}
#[doc = " UDP tunneling configuration.\n\n Used to configure the classifier of a device,\n associating an UDP port with a type of tunnel.\n\n Some NICs may need such configuration to properly parse a tunnel\n with any standard or custom UDP port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. @see rte_eth_tunnel_type"]
    pub prot_type: u8,
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port.\n Depending upon the Rx multi-queue mode, extra advanced\n configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be\nused. RTE_ETH_LINK_SPEED_FIXED disables link\nautonegotiation, and a unique speed shall be\nset. Otherwise, the bitmap defines the set of\nspeeds to be advertised. If the special value\nRTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds\nsupported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port Rx configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port Tx configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value\nis 0, meaning the loopback mode is disabled.\nRead the datasheet of given Ethernet controller\nfor details. The possible values of this field\nare defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port Rx filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port Tx DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC\nis needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    #[doc = " Port VMDq+DCB configuration."]
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    #[doc = " Port DCB Rx configuration."]
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    #[doc = " Port VMDq Rx configuration."]
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    #[doc = " Port VMDq+DCB Tx configuration."]
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    #[doc = " Port DCB Tx configuration."]
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    #[doc = " Port VMDq Tx configuration."]
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[doc = " Preferred Rx/Tx port parameters.\n There are separate instances of this structure for transmission\n and reception respectively."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain ID"]
    pub domain_id: u16,
    #[doc = " Mapping to the devices physical switch port as enumerated from the\n perspective of the embedded interconnect/switch. For SR-IOV enabled\n device this may correspond to the VF_ID of each virtual function,\n but each driver should explicitly define the mapping of switch\n port identifier to that physical interconnect/switch"]
    pub port_id: u16,
    #[doc = " Shared Rx queue sub-domain boundary. Only ports in same Rx domain\n and switch domain can share Rx queue. Valid only if device advertised\n RTE_ETH_DEV_CAPA_RXQ_SHARE capability."]
    pub rx_domain: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pools_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pools_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_align_log2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_align_log2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< not a representor."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_NONE: rte_eth_representor_type = 0;
#[doc = "< representor of Virtual Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_VF: rte_eth_representor_type = 1;
#[doc = "< representor of Sub Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_SF: rte_eth_representor_type = 2;
#[doc = "< representor of Physical Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_PF: rte_eth_representor_type = 3;
#[doc = " Ethernet device representor port type."]
pub type rte_eth_representor_type = ::std::os::raw::c_uint;
#[doc = " No error handling modes are supported."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_NONE: rte_eth_err_handle_mode = 0;
#[doc = " Passive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_INTR_RESET event,\n and the application invokes @see rte_eth_dev_reset to recover the port."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: rte_eth_err_handle_mode = 1;
#[doc = " Proactive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_ERR_RECOVERING event,\n do recovery internally, and finally reports the recovery result event\n (@see RTE_ETH_EVENT_RECOVERY_*)."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: rte_eth_err_handle_mode = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this enumeration may change without prior notice.\n\n Ethernet device error handling mode."]
pub type rte_eth_err_handle_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to retrieve the contextual information of\n an Ethernet device, such as the controlling driver of the\n device, etc..."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Generic device information"]
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none.\nUse if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = " Minimum Rx buffer size per descriptor supported by HW."]
    pub min_rx_bufsize: u32,
    #[doc = " Maximum Rx buffer size per descriptor supported by HW.\n The value is not enforced, information only to application to\n optimize mbuf size.\n Its value is UINT32_MAX when not specified by the driver."]
    pub max_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of Rx pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of Rx queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of Tx queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    #[doc = " Maximum number of hash MAC addresses for MTA and UTA."]
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    #[doc = " All Rx offload capabilities including all per-queue ones"]
    pub rx_offload_capa: u64,
    #[doc = " All Tx offload capabilities including all per-queue ones"]
    pub tx_offload_capa: u64,
    #[doc = " Device per-queue Rx offload capabilities."]
    pub rx_queue_offload_capa: u64,
    #[doc = " Device per-queue Tx offload capabilities."]
    pub tx_queue_offload_capa: u64,
    #[doc = " Device redirection table size, the total number of entries."]
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    #[doc = " RSS hash algorithms capabilities */\n/** Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default Rx configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default Tx configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDq pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDq pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDq pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< Rx descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Tx descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (RTE_ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of Rx queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues."]
    pub nb_tx_queues: u16,
    #[doc = " Maximum number of Rx mempools supported per Rx queue.\n\n Value greater than 0 means that the driver supports Rx queue\n mempools specification via rx_conf->rx_mempools."]
    pub max_rx_mempools: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a\n embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = " Supported error handling mode."]
    pub err_handle_mode: rte_eth_err_handle_mode,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " Ethernet device Rx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets Rx supported."]
    pub scattered_rx: u8,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    #[doc = "< hardware receive buffer size."]
    pub rx_buf_size: u16,
    #[doc = " Available Rx descriptors threshold defined as percentage\n of Rx queue size. If number of available descriptors is lower,\n the event RTE_ETH_EVENT_RX_AVAIL_THESH is generated.\n Value 0 means that the threshold monitoring is disabled."]
    pub avail_thresh: u8,
}
#[doc = " Ethernet device Tx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx queue information structure for recycling mbufs.\n Used to retrieve Rx queue information when Tx queue reusing mbufs and moving\n them into Rx mbuf ring."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_recycle_rxq_info {
    #[doc = "< mbuf ring of Rx queue."]
    pub mbuf_ring: *mut *mut rte_mbuf,
    #[doc = "< mempool of Rx queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< head of Rx queue refilling mbufs."]
    pub refill_head: *mut u16,
    #[doc = "< tail of Rx queue receiving pkts."]
    pub receive_tail: *mut u16,
    #[doc = "< configured number of mbuf ring size."]
    pub mbuf_ring_size: u16,
    #[doc = " Requirement on mbuf refilling batch size of Rx mbuf ring.\n For some PMD drivers, the number of Rx mbuf ring refilling mbufs\n should be aligned with mbuf ring size, in order to simplify\n ring wrapping around.\n Value 0 means that PMD drivers have no requirement for this."]
    pub refill_requirement: u16,
}
#[doc = " Ethernet device Rx/Tx queue packet burst mode information structure.\n Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[doc = " An Ethernet device extended statistic structure\n\n This structure is used by rte_eth_xstats_get() to provide\n statistics that are not provided in the generic *rte_eth_stats*\n structure.\n It maps a name ID, corresponding to an index in the array returned\n by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[doc = " A name element for extended statistics.\n\n An array of this structure is returned by rte_eth_xstats_get_names().\n It lists the names of extended statistics for a PMD. The *rte_eth_xstat*\n structure references these names by their array index.\n\n The xstats should follow a common naming scheme.\n Some names are standardized in rte_stats_strings.\n Examples:\n     - rx_missed_errors\n     - tx_q3_bytes\n     - tx_size_128_to_255_packets"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " A structure used to get the information of queue and\n TC mapping on both Tx and Rx paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " A structure used to get the information of DCB.\n It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< Tx BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " Rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fec_capa {
    #[doc = "< Link speed (see RTE_ETH_SPEED_NUM_*)"]
    pub speed: u32,
    #[doc = "< FEC capabilities bitmask"]
    pub capa: u32,
}
#[doc = " Function type used for Rx packet processing packet callbacks.\n\n The callback function is called on Rx with a burst of packets that have\n been received on the given port and queue.\n\n @param port_id\n   The Ethernet port on which Rx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to receive the packets.\n @param pkts\n   The burst of packets that have just been received.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param max_pkts\n   The max number of packets that can be stored in the \"pkts\" array.\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for Tx packet processing packet callbacks.\n\n The callback function is called on Tx with a burst of packets immediately\n before the packets are put onto the hardware queue for transmission.\n\n @param port_id\n   The Ethernet port on which Tx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to transmit the packets.\n @param pkts\n   The burst of packets that are about to be transmitted.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Device is unused before being probed."]
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
#[doc = " Device is attached when allocated in probing."]
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
#[doc = " Device is in removed state when plug-out is detected."]
pub const rte_eth_dev_state_RTE_ETH_DEV_REMOVED: rte_eth_dev_state = 2;
#[doc = " Possible states of an ethdev port."]
pub type rte_eth_dev_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< Rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor ID range entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_representor_range {
    #[doc = "< Representor type"]
    pub type_: rte_eth_representor_type,
    #[doc = "< Controller index"]
    pub controller: ::std::os::raw::c_int,
    #[doc = "< Physical function index"]
    pub pf: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_eth_representor_range__bindgen_ty_1,
    #[doc = "< Representor ID start index"]
    pub id_base: u32,
    #[doc = "< Representor ID end index"]
    pub id_end: u32,
    #[doc = "< Representor name"]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_representor_range__bindgen_ty_1 {
    #[doc = "< VF start index"]
    pub vf: ::std::os::raw::c_int,
    #[doc = "< SF start index"]
    pub sf: ::std::os::raw::c_int,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor information"]
#[repr(C)]
pub struct rte_eth_representor_info {
    #[doc = "< Controller ID of caller device."]
    pub controller: u16,
    #[doc = "< Physical function ID of caller device."]
    pub pf: u16,
    #[doc = "< Size of the ranges array."]
    pub nb_ranges_alloc: u32,
    #[doc = "< Number of initialized ranges."]
    pub nb_ranges: u32,
    #[doc = "< Representor ID range."]
    pub ranges: __IncompleteArrayField<rte_eth_representor_range>,
}
#[doc = " A structure used to get/set IP reassembly configuration. It is also used\n to get the maximum capability values that a PMD can support.\n\n If rte_eth_ip_reassembly_capability_get() returns 0, IP reassembly can be\n enabled using rte_eth_ip_reassembly_conf_set() and params values lower than\n capability params can be set in the PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ip_reassembly_params {
    #[doc = " Maximum time in ms which PMD can wait for other fragments."]
    pub timeout_ms: u32,
    #[doc = " Maximum number of fragments that can be reassembled."]
    pub max_frags: u16,
    #[doc = " Flags to enable reassembly of packet types -\n RTE_ETH_DEV_REASSEMBLY_F_xxx."]
    pub flags: u16,
}
#[doc = " Congestion management based on Rx queue depth"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE: rte_eth_cman_obj = 1;
#[doc = " Congestion management based on mempool depth associated with Rx queue\n @see rte_eth_rx_queue_setup()"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL: rte_eth_cman_obj = 2;
#[doc = " Enumerate list of ethdev congestion management objects"]
pub type rte_eth_cman_obj = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to retrieve information of ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_info {
    #[doc = " Set of supported congestion management modes\n @see enum rte_cman_mode"]
    pub modes_supported: u64,
    #[doc = " Set of supported congestion management objects\n @see enum rte_eth_cman_obj"]
    pub objs_supported: u64,
    #[doc = " Reserved for future fields. Always returned as 0 when\n rte_eth_cman_info_get() is invoked"]
    pub rsvd: [u8; 8usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to configure the ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_config {
    #[doc = " Congestion management object"]
    pub obj: rte_eth_cman_obj,
    #[doc = " Congestion management mode"]
    pub mode: rte_cman_mode,
    pub obj_param: rte_eth_cman_config__bindgen_ty_1,
    pub mode_param: rte_eth_cman_config__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_1 {
    #[doc = " Rx queue to configure congestion management.\n\n Valid when object is RTE_ETH_CMAN_OBJ_RX_QUEUE or\n RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL."]
    pub rx_queue: u16,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_obj_params: [u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_2 {
    #[doc = " RED configuration parameters.\n\n Valid when mode is RTE_CMAN_RED."]
    pub red: rte_cman_red_params,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_mode_params: [u8; 4usize],
}
#[doc = " @file\n\n RTE Ethernet Device internal header.\n\n This header contains internal data types. But they are still part of the\n public API because they are used by inline functions in the published API.\n\n Applications should not use these directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[doc = " @internal Retrieve input packets from a receive queue of an Ethernet device."]
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Send output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Prepare output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Get number of used descriptors on a receive queue."]
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void) -> u32>;
#[doc = " @internal Check the status of a Rx descriptor"]
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get number of used descriptors on a transmit queue."]
pub type eth_tx_queue_count_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Check the status of a Tx descriptor"]
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Copy used mbufs from Tx mbuf ring into Rx mbuf ring"]
pub type eth_recycle_tx_mbufs_reuse_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ) -> u16,
>;
#[doc = " @internal Refill Rx descriptors with the recycling mbufs"]
pub type eth_recycle_rx_descriptors_refill_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, nb: u16)>;
#[doc = " @internal\n Structure used to hold information about the callbacks to be called for a\n queue on Rx and Tx."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
}
#[doc = " @internal\n The generic data structure associated with each Ethernet device.\n\n Pointers to burst-oriented packet receive and transmit functions are\n located at the beginning of the structure, along with the pointer to\n where all the data elements for the particular device are stored in shared\n memory. This split allows the function pointer and driver data to be per-\n process, while the actual configuration data for the device is shared."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    #[doc = "< Pointer to PMD receive function"]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = "< Pointer to PMD transmit function"]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = " Pointer to PMD transmit prepare function"]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = " Get the number of used Rx descriptors"]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = " Check the status of a Rx descriptor"]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = " Get the number of used Tx descriptors"]
    pub tx_queue_count: eth_tx_queue_count_t,
    #[doc = " Check the status of a Tx descriptor"]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = " Pointer to PMD transmit mbufs reuse function"]
    pub recycle_tx_mbufs_reuse: eth_recycle_tx_mbufs_reuse_t,
    #[doc = " Pointer to PMD receive descriptors refill function"]
    pub recycle_rx_descriptors_refill: eth_recycle_rx_descriptors_refill_t,
    #[doc = " Device data that is shared between primary and secondary processes"]
    pub data: *mut rte_eth_dev_data,
    #[doc = "< Pointer to per-process device data"]
    pub process_private: *mut ::std::os::raw::c_void,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *const eth_dev_ops,
    #[doc = " Fast path flow API functions exported by PMD"]
    pub flow_fp_ops: *mut rte_flow_fp_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = " User application callbacks for NIC interrupts"]
    pub link_intr_cbs: rte_eth_dev_cb_list,
    #[doc = " User-supplied functions called from rx_burst to post-process\n received packets before passing them to the user"]
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = " User-supplied functions called from tx_burst to pre-process\n received packets before passing them to the driver for transmission"]
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = "< Flag indicating the port state"]
    pub state: rte_eth_dev_state,
    #[doc = "< Context for security ops"]
    pub security_ctx: *mut ::std::os::raw::c_void,
}
#[doc = " @internal\n The data part, with no function pointers, associated with each Ethernet\n device. This structure is safe to place in shared memory to be common\n among different processes in a multi-process configuration."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Array of pointers to Rx queues"]
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Array of pointers to Tx queues"]
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Number of Rx queues"]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues"]
    pub nb_tx_queues: u16,
    #[doc = "< SRIOV data"]
    pub sriov: rte_eth_dev_sriov,
    #[doc = " PMD-specific private data. @see rte_eth_dev_release_port()"]
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Link-level information & status"]
    pub dev_link: rte_eth_link,
    #[doc = "< Configuration applied to device"]
    pub dev_conf: rte_eth_conf,
    #[doc = "< Maximum Transmission Unit"]
    pub mtu: u16,
    #[doc = " Common Rx buffer size handled by all queues"]
    pub min_rx_buf_size: u32,
    #[doc = "< Rx ring mbuf allocation failures"]
    pub rx_mbuf_alloc_failed: u64,
    #[doc = " Device Ethernet link addresses.\n All entries are unique.\n The first entry (index zero) is the default address."]
    pub mac_addrs: *mut rte_ether_addr,
    #[doc = " Bitmap associating MAC addresses to pools"]
    pub mac_pool_sel: [u64; 128usize],
    #[doc = " Device Ethernet MAC addresses of hash filtering.\n @see rte_eth_dev_release_port()"]
    pub hash_mac_addrs: *mut rte_ether_addr,
    #[doc = "< Device [external] port identifier"]
    pub port_id: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub rx_queue_state: [u8; 1024usize],
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub tx_queue_state: [u8; 1024usize],
    #[doc = "< Capabilities"]
    pub dev_flags: u32,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = " VLAN filter configuration"]
    pub vlan_filter_conf: rte_vlan_filter_conf,
    #[doc = "< The port owner"]
    pub owner: rte_eth_dev_owner,
    #[doc = " Switch-specific identifier.\n Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub representor_id: u16,
    #[doc = " Port ID of the backing device.\n This device will be used to query representor info and calculate\n representor IDs. Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub backer_port_id: u16,
    #[doc = "< rte_flow ops mutex"]
    pub flow_ops_mutex: pthread_mutex_t,
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn promiscuous_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_promiscuous_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scattered_rx_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_scattered_rx_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn all_multicast_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_all_multicast_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_started_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dev_started_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lro_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dev_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_configured_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dev_configured_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_configured_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flow_configured_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
        dev_configured: u8,
        flow_configured: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dev_configured: u8 = unsafe { ::std::mem::transmute(dev_configured) };
            dev_configured as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let flow_configured: u8 = unsafe { ::std::mem::transmute(flow_configured) };
            flow_configured as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @internal Ethernet device configuration."]
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to start a configured Ethernet device."]
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to stop a configured Ethernet device."]
pub type eth_dev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link up a configured Ethernet device."]
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link down a configured Ethernet device."]
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to close a configured Ethernet device."]
pub type eth_dev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to reset a configured Ethernet device."]
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to detect an Ethernet device removal."]
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Function used to enable the Rx promiscuous mode of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, promiscuous mode is enabled.\n @retval -ENOTSUP\n   Promiscuous mode is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to enable promiscuous mode failed because of timeout.\n @retval -EAGAIN\n   Failed to enable promiscuous mode."]
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Function used to disable the Rx promiscuous mode of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, promiscuous mode is disabled.\n @retval -ENOTSUP\n   Promiscuous mode disabling is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to disable promiscuous mode failed because of timeout.\n @retval -EAGAIN\n   Failed to disable promiscuous mode."]
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Enable the receipt of all multicast packets by an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, all-multicast mode is enabled.\n @retval -ENOTSUP\n   All-multicast mode is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to enable all-multicast mode failed because of timeout.\n @retval -EAGAIN\n   Failed to enable all-multicast mode."]
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Disable the receipt of all multicast packets by an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, all-multicast mode is disabled.\n @retval -ENOTSUP\n   All-multicast mode disabling is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to disable all-multicast mode failed because of timeout.\n @retval -EAGAIN\n   Failed to disable all-multicast mode."]
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Get link speed, duplex mode and state (up/down) of an Ethernet device."]
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get number of current active lanes\n\n @param dev\n   ethdev handle of port.\n @param speed_lanes\n   Number of active lanes that the link has trained up. This information\n   is displayed for Autonegotiated or Fixed speed trained link.\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, get speed_lanes data success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed."]
pub type eth_speed_lanes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, speed_lanes: *mut u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set speed lanes supported by the NIC. This configuration is applicable only when\n fix speed is already configured and or will be configured. This api requires the\n port be stopped, since driver has to re-configure PHY with fixed speed and lanes.\n If no lanes are configured prior or after \"port config X speed Y duplex Z\", the\n driver will choose the default lane for that speed to bring up the link.\n\n @param dev\n   ethdev handle of port.\n @param speed_lanes\n   Non-negative number of lanes\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, set lanes success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   Unsupported number of lanes for fixed speed requested.\n @retval -EIO\n   Device is removed."]
pub type eth_speed_lanes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, speed_lanes: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get supported link speed lanes capability. The driver returns number of lanes\n supported per speed in the form of lanes capability bitmap per speed.\n\n @param speed_lanes_capa\n   A pointer to num of rte_eth_speed_lanes_capa struct array which carries the\n   bit map of lanes supported per speed. The number of supported speeds is the\n   size of this speed_lanes_capa table. In link up condition, only active supported\n   speeds lanes bitmap information will be displayed. In link down condition, all\n   the supported speeds and its supported lanes bitmap would be fetched and displayed.\n\n   This api is overloaded to fetch the size of the speed_lanes_capa array if\n   testpmd calls the driver with speed_lanes_capa = NULL and num = 0\n\n @param num\n   Number of elements in a speed_speed_lanes_capa array. This num is equal to the\n   number of supported speeds by the controller. This value will vary in link up\n   and link down condition. num is updated by the driver if speed_lanes_capa is NULL.\n\n @return\n   Negative errno value on error, positive value on success.\n\n @retval positive value\n   A non-negative value lower or equal to num: success. The return value\n   is the number of entries filled in the speed lanes array.\n   A non-negative value higher than num: error, the given speed lanes capa array\n   is too small. The return value corresponds to the num that should\n   be given to succeed. The entries in the speed lanes capa array are not valid\n   and shall not be used by the caller.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   *num* or *speed_lanes_capa* invalid."]
pub type eth_speed_lanes_get_capability_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        speed_lanes_capa: *mut rte_eth_speed_lanes_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get global I/O statistics of an Ethernet device."]
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        igb_stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Reset global I/O statistics of an Ethernet device to 0.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, statistics has been reset.\n @retval -ENOTSUP\n   Resetting statistics is not supported.\n @retval -EINVAL\n   Resetting statistics is not valid.\n @retval -ENOMEM\n   Not enough memory to get the stats."]
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get extended stats of an Ethernet device."]
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n @param ids\n   IDs array to retrieve specific statistics. Must not be NULL.\n @param values\n   A pointer to a table to be filled with device statistics values.\n   Must not be NULL.\n @param n\n   Element count in @p ids and @p values.\n\n @return\n   - A number of filled in stats.\n   - A negative value on error."]
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Reset extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, statistics has been reset.\n @retval -ENOTSUP\n   Resetting statistics is not supported.\n @retval -EINVAL\n   Resetting statistics is not valid.\n @retval -ENOMEM\n   Not enough memory to get the stats."]
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get names of extended stats of an Ethernet device."]
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get names of extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n @param ids\n   IDs array to retrieve specific statistics. Must not be NULL.\n @param xstats_names\n   An rte_eth_xstat_name array of at least @p size elements to be filled.\n   Must not be NULL.\n @param size\n   Element count in @p ids and @p xstats_names.\n\n @return\n   - A number of filled in stats.\n   - A negative value on error."]
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Enable an xstat of an Ethernet device."]
pub type eth_xstats_enable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Disable an xstat of an Ethernet device."]
pub type eth_xstats_disable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query the state of an xstat the can be enabled and disabled in runtime."]
pub type eth_xstats_query_state_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set a queue statistics mapping for a Tx/Rx queue of an Ethernet device."]
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get specific information of an Ethernet device."]
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Function used to get supported ptypes of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @param no_of_elements\n   number of ptypes elements. Must be initialized to 0.\n\n @retval\n   Success, array of ptypes elements and valid no_of_elements > 0.\n   Failures, NULL."]
pub type eth_dev_supported_ptypes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, no_of_elements: *mut usize) -> *const u32,
>;
#[doc = " @internal\n Inform Ethernet device about reduced range of packet types to handle.\n\n @param dev\n   The Ethernet device identifier.\n @param ptype_mask\n   The ptype family that application is interested in should be bitwise OR of\n   RTE_PTYPE_*_MASK or 0.\n @return\n   - (0) if Success."]
pub type eth_dev_ptypes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ptype_mask: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Start Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Stop Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set up a receive queue of an Ethernet device."]
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup a transmit queue of an Ethernet device."]
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Enable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Disable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Release memory resources allocated by given Rx/Tx queue."]
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16)>;
#[doc = " @internal Get firmware information of an Ethernet device."]
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Force mbufs to be from Tx ring."]
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type eth_recycle_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ),
>;
pub type eth_burst_mode_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set MTU."]
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Filtering of a VLAN Tag Identifier by an Ethernet device."]
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set the outer/inner VLAN-TPID by an Ethernet device."]
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set VLAN offload function by an Ethernet device."]
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set port based Tx VLAN insertion by an Ethernet device."]
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal VLAN stripping enable/disable by an queue of Ethernet device."]
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
#[doc = " @internal Get current flow control parameter on an Ethernet device."]
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup flow control parameter on an Ethernet device."]
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup priority flow control parameter on an Ethernet device."]
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get info for queue based PFC on an Ethernet device."]
pub type priority_flow_ctrl_queue_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_info: *mut rte_eth_pfc_queue_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Configure queue based PFC parameter on an Ethernet device."]
pub type priority_flow_ctrl_queue_config_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_conf: *mut rte_eth_pfc_queue_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS redirection table on an Ethernet device."]
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query RSS redirection table on an Ethernet device."]
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS hash configuration of an Ethernet device."]
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get current RSS hash configuration of an Ethernet device."]
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Turn on SW controllable LED on an Ethernet device."]
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Turn off SW controllable LED on an Ethernet device."]
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Remove MAC address from receive address register."]
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a Unicast Hash bitmap."]
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set all Unicast Hash bitmap."]
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set queue Tx rate."]
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Add tunneling UDP port."]
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Delete tunneling UDP port."]
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal set the list of multicast addresses on an Ethernet device."]
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to enable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to disable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to read an Rx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to read a Tx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to adjust the device clock."]
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to adjust the clock frequency."]
pub type eth_timesync_adjust_freq = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get the current value of the device clock."]
pub type eth_read_clock = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve registers."]
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve EEPROM size."]
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Retrieve EEPROM data."]
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Program EEPROM data."]
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve type and size of plugin module EEPROM."]
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve plugin module EEPROM data."]
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_ops {
    _unused: [u8; 0],
}
#[doc = " @internal\n Get flow operations.\n\n If the flow API is not supported for the specified device,\n the driver can return NULL."]
pub type eth_flow_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut *const rte_flow_ops,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Management (TM) operations on an Ethernet device."]
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Metering and Policing (MTR) operations."]
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get DCB information on an Ethernet device."]
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Test if a port supports specific mempool ops."]
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get the hairpin capabilities.\n\n @param dev\n   ethdev handle of port.\n @param cap\n   returns the hairpin capabilities from the device.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported."]
pub type eth_hairpin_cap_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Setup Rx hairpin queue.\n\n @param dev\n   ethdev handle of port.\n @param rx_queue_id\n   the selected Rx queue index.\n @param nb_rx_desc\n   the requested number of descriptors for this queue. 0 - use PMD default.\n @param conf\n   the Rx hairpin configuration structure.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -ENOMEM\n   Unable to allocate resources."]
pub type eth_rx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Setup Tx hairpin queue.\n\n @param dev\n   ethdev handle of port.\n @param tx_queue_id\n   the selected Tx queue index.\n @param nb_tx_desc\n   the requested number of descriptors for this queue. 0 - use PMD default.\n @param conf\n   the Tx hairpin configuration structure.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -ENOMEM\n   Unable to allocate resources."]
pub type eth_tx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get Forward Error Correction(FEC) capability.\n\n @param dev\n   ethdev handle of port.\n @param speed_fec_capa\n   speed_fec_capa is out only with per-speed capabilities.\n @param num\n   a number of elements in an speed_fec_capa array.\n\n @return\n   Negative errno value on error, positive value on success.\n\n @retval positive value\n   A non-negative value lower or equal to num: success. The return value\n   is the number of entries filled in the fec capa array.\n   A non-negative value higher than num: error, the given fec capa array\n   is too small. The return value corresponds to the num that should\n   be given to succeed. The entries in the fec capa array are not valid\n   and shall not be used by the caller.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed.\n @retval -EINVAL\n   *num* or *speed_fec_capa* invalid."]
pub type eth_fec_get_capability_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get Forward Error Correction(FEC) mode.\n\n @param dev\n   ethdev handle of port.\n @param fec_capa\n   a bitmask of enabled FEC modes. If AUTO bit is set, other\n   bits specify FEC modes which may be negotiated. If AUTO\n   bit is clear, specify FEC modes to be used (only one valid\n   mode per speed may be set).\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, get FEC success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed."]
pub type eth_fec_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: *mut u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set Forward Error Correction(FEC) mode.\n\n @param dev\n   ethdev handle of port.\n @param fec_capa\n   bitmask of allowed FEC modes. It must be only one\n   if AUTO is disabled. If AUTO is enabled, other\n   bits specify FEC modes which may be negotiated.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, set FEC success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   Unsupported FEC mode requested.\n @retval -EIO\n   Device is removed."]
pub type eth_fec_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get all hairpin Tx/Rx peer ports of the current device, if any.\n\n @param dev\n   ethdev handle of port.\n @param peer_ports\n   array to save the ports list.\n @param len\n   array length.\n @param direction\n   value to decide the current to peer direction\n   positive - used as Tx to get all peer Rx ports.\n   zero - used as Rx to get all peer Tx ports.\n\n @return\n   Negative errno value on error, 0 or positive on success.\n\n @retval 0\n   Success, no peer ports.\n @retval >0\n   Actual number of the peer ports.\n @retval -ENOTSUP\n   Get peer ports API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid."]
pub type hairpin_get_peer_ports_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_ports: *mut u16,
        len: usize,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Bind all hairpin Tx queues of one port to the Rx queues of the peer port.\n\n @param dev\n   ethdev handle of port.\n @param rx_port\n   the peer Rx port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, bind successfully.\n @retval -ENOTSUP\n   Bind API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -EBUSY\n   Device is not started."]
pub type eth_hairpin_bind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Unbind all hairpin Tx queues of one port from the Rx queues of the peer port.\n\n @param dev\n   ethdev handle of port.\n @param rx_port\n   the peer Rx port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, unbind successfully.\n @retval -ENOTSUP\n   Bind API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -EBUSY\n   Device is already stopped."]
pub type eth_hairpin_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update and fetch peer queue information."]
pub type eth_hairpin_queue_peer_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_queue: u16,
        current_info: *mut rte_hairpin_peer_info,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Bind peer queue to the current queue with fetched information."]
pub type eth_hairpin_queue_peer_bind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Unbind peer queue from the current queue."]
pub type eth_hairpin_queue_peer_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get address of memory location whose contents will change whenever there is\n new data to be received on an Rx queue.\n\n @param rxq\n   Ethdev queue pointer.\n @param pmc\n   The pointer to power-optimized monitoring condition structure.\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success\n @retval -EINVAL\n   Invalid parameters"]
pub type eth_get_monitor_addr_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get representor info to be able to calculate the unique representor ID.\n\n Caller should pass NULL as pointer of info to get number of entries,\n allocate info buffer according to returned entry number, then call\n again with buffer to get real info.\n\n To calculate the representor ID, caller should iterate each entry,\n match controller index, pf index, vf or sf start index and range,\n then calculate representor ID from offset to vf/sf start index.\n @see rte_eth_representor_id_get.\n\n @param dev\n   Ethdev handle of port.\n @param [out] info\n   Pointer to memory to save device representor info.\n @return\n   Negative errno value on error, number of info entries otherwise."]
pub type eth_representor_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[inout] features\n   Feature selection buffer\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_rx_metadata_negotiate_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, features: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get IP reassembly offload capability of a PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[out] conf\n   IP reassembly capability supported by the PMD\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_capability_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        capa: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get IP reassembly offload configuration parameters set in PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[out] conf\n   Configuration parameters for IP reassembly.\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set configuration parameters for enabling IP reassembly offload in hardware.\n\n @param dev\n   Port (ethdev) handle\n\n @param[in] conf\n   Configuration parameters for IP reassembly.\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *const rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get supported header protocols of a PMD to split.\n\n @param dev\n   Ethdev handle of port.\n\n @return\n   An array pointer to store supported protocol headers."]
pub type eth_buffer_split_supported_hdr_ptypes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, no_of_elements: *mut usize) -> *const u32,
>;
#[doc = " @internal\n Dump private info from device to a file.\n\n @param dev\n   Port (ethdev) handle.\n @param file\n   A pointer to a file for output.\n\n @return\n   Negative value on error, 0 on success.\n\n @retval 0\n   Success\n @retval -EINVAL\n   Invalid file"]
pub type eth_dev_priv_dump_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, file: *mut FILE) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set Rx queue available descriptors threshold.\n @see rte_eth_rx_avail_thresh_set()\n\n Driver should round down number of descriptors on conversion from\n percentage."]
pub type eth_rx_queue_avail_thresh_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        avail_thresh: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query Rx queue available descriptors threshold event.\n @see rte_eth_rx_avail_thresh_query()"]
pub type eth_rx_queue_avail_thresh_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: *mut u16,
        avail_thresh: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get congestion management information."]
pub type eth_cman_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_cman_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Init congestion management structure with default values."]
pub type eth_cman_config_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Configure congestion management on a port."]
pub type eth_cman_config_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *const rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve congestion management configuration of a port."]
pub type eth_cman_config_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Dump Rx descriptor info to a file.\n\n It is used for debugging, not a dataplane API.\n\n @param dev\n   Port (ethdev) handle.\n @param queue_id\n   A Rx queue identifier on this port.\n @param offset\n   The offset of the descriptor starting from tail. (0 is the next\n   packet to be received by the driver).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   Negative errno value on error, zero on success."]
pub type eth_rx_descriptor_dump_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_eth_dev,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Dump Tx descriptor info to a file.\n\n This API is used for debugging, not a dataplane API.\n\n @param dev\n   Port (ethdev) handle.\n @param queue_id\n   A Tx queue identifier on this port.\n @param offset\n   The offset of the descriptor starting from tail. (0 is the place where\n   the next packet will be send).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   Negative errno value on error, zero on success."]
pub type eth_tx_descriptor_dump_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_eth_dev,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get the number of aggregated ports.\n\n @param dev\n   Port (ethdev) handle.\n\n @return\n   Negative errno value on error, 0 or positive on success.\n\n @retval >=0\n   The number of aggregated port if success."]
pub type eth_count_aggr_ports_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Map a Tx queue with an aggregated port of the DPDK port.\n\n @param dev\n   Port (ethdev) handle.\n @param tx_queue_id\n   The index of the transmit queue used in rte_eth_tx_burst().\n @param affinity\n   The number of the aggregated port.\n\n @return\n   Negative on error, 0 on success."]
pub type eth_map_aggr_tx_affinity_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        affinity: u8,
    ) -> ::std::os::raw::c_int,
>;
pub const rte_eth_dev_operation_RTE_ETH_START: rte_eth_dev_operation = 0;
#[doc = " @internal\n Defines types of operations which can be executed by the application."]
pub type rte_eth_dev_operation = ::std::os::raw::c_uint;
#[doc = " @internal\n Fetch from the driver what kind of configuration must be restored by ethdev layer,\n after certain operations are performed by the application (such as rte_eth_dev_start()).\n\n @param dev\n   Port (ethdev) handle.\n @param op\n   Type of operation executed by the application.\n\n @return\n   ORed restore flags indicating which configuration should be restored by ethdev.\n   0 if no restore is required by the driver."]
pub type eth_get_restore_flags_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, op: rte_eth_dev_operation) -> u64,
>;
#[doc = " @internal A structure containing the functions exported by an Ethernet driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eth_dev_ops {
    #[doc = "< Configure device"]
    pub dev_configure: eth_dev_configure_t,
    #[doc = "< Start device"]
    pub dev_start: eth_dev_start_t,
    #[doc = "< Stop device"]
    pub dev_stop: eth_dev_stop_t,
    #[doc = "< Device link up"]
    pub dev_set_link_up: eth_dev_set_link_up_t,
    #[doc = "< Device link down"]
    pub dev_set_link_down: eth_dev_set_link_down_t,
    #[doc = "< Close device"]
    pub dev_close: eth_dev_close_t,
    #[doc = "< Reset device"]
    pub dev_reset: eth_dev_reset_t,
    #[doc = "< Get device link state"]
    pub link_update: eth_link_update_t,
    #[doc = "< Get link speed active lanes"]
    pub speed_lanes_get: eth_speed_lanes_get_t,
    #[doc = "< Set link speeds supported lanes"]
    pub speed_lanes_set: eth_speed_lanes_set_t,
    #[doc = " Get link speed lanes capability"]
    pub speed_lanes_get_capa: eth_speed_lanes_get_capability_t,
    #[doc = " Check if the device was physically removed"]
    pub is_removed: eth_is_removed_t,
    #[doc = "< Promiscuous ON"]
    pub promiscuous_enable: eth_promiscuous_enable_t,
    #[doc = "< Promiscuous OFF"]
    pub promiscuous_disable: eth_promiscuous_disable_t,
    #[doc = "< Rx multicast ON"]
    pub allmulticast_enable: eth_allmulticast_enable_t,
    #[doc = "< Rx multicast OFF"]
    pub allmulticast_disable: eth_allmulticast_disable_t,
    #[doc = "< Remove MAC address"]
    pub mac_addr_remove: eth_mac_addr_remove_t,
    #[doc = "< Add a MAC address"]
    pub mac_addr_add: eth_mac_addr_add_t,
    #[doc = "< Set a MAC address"]
    pub mac_addr_set: eth_mac_addr_set_t,
    #[doc = " Set list of multicast addresses"]
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    #[doc = "< Set MTU"]
    pub mtu_set: mtu_set_t,
    #[doc = " Get generic device statistics"]
    pub stats_get: eth_stats_get_t,
    #[doc = " Reset generic device statistics"]
    pub stats_reset: eth_stats_reset_t,
    #[doc = " Get extended device statistics"]
    pub xstats_get: eth_xstats_get_t,
    #[doc = " Reset extended device statistics"]
    pub xstats_reset: eth_xstats_reset_t,
    #[doc = " Get names of extended statistics"]
    pub xstats_get_names: eth_xstats_get_names_t,
    #[doc = " Configure per queue stat counter mapping"]
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    #[doc = "< Get device info"]
    pub dev_infos_get: eth_dev_infos_get_t,
    #[doc = " Retrieve Rx queue information"]
    pub rxq_info_get: eth_rxq_info_get_t,
    #[doc = " Retrieve Tx queue information"]
    pub txq_info_get: eth_txq_info_get_t,
    #[doc = " Retrieve mbufs recycle Rx queue information"]
    pub recycle_rxq_info_get: eth_recycle_rxq_info_get_t,
    #[doc = "< Get Rx burst mode"]
    pub rx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get Tx burst mode"]
    pub tx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get firmware version"]
    pub fw_version_get: eth_fw_version_get_t,
    #[doc = " Get packet types supported and identified by device"]
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    #[doc = " Inform Ethernet device about reduced range of packet types to\n handle"]
    pub dev_ptypes_set: eth_dev_ptypes_set_t,
    #[doc = " Filter VLAN Setup"]
    pub vlan_filter_set: vlan_filter_set_t,
    #[doc = " Outer/Inner VLAN TPID Setup"]
    pub vlan_tpid_set: vlan_tpid_set_t,
    #[doc = " VLAN Stripping on queue"]
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    #[doc = " Set VLAN Offload"]
    pub vlan_offload_set: vlan_offload_set_t,
    #[doc = " Set port based Tx VLAN insertion"]
    pub vlan_pvid_set: vlan_pvid_set_t,
    #[doc = "< Start Rx for a queue"]
    pub rx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Rx for a queue"]
    pub rx_queue_stop: eth_queue_stop_t,
    #[doc = "< Start Tx for a queue"]
    pub tx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Tx for a queue"]
    pub tx_queue_stop: eth_queue_stop_t,
    #[doc = "< Set up device Rx queue"]
    pub rx_queue_setup: eth_rx_queue_setup_t,
    #[doc = "< Release Rx queue"]
    pub rx_queue_release: eth_queue_release_t,
    #[doc = " Enable Rx queue interrupt"]
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    #[doc = " Disable Rx queue interrupt"]
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    #[doc = "< Set up device Tx queue"]
    pub tx_queue_setup: eth_tx_queue_setup_t,
    #[doc = "< Release Tx queue"]
    pub tx_queue_release: eth_queue_release_t,
    #[doc = "< Free Tx ring mbufs"]
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    #[doc = "< Turn on LED"]
    pub dev_led_on: eth_dev_led_on_t,
    #[doc = "< Turn off LED"]
    pub dev_led_off: eth_dev_led_off_t,
    #[doc = "< Get flow control"]
    pub flow_ctrl_get: flow_ctrl_get_t,
    #[doc = "< Setup flow control"]
    pub flow_ctrl_set: flow_ctrl_set_t,
    #[doc = " Setup priority flow control"]
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    #[doc = " Priority flow control queue info get"]
    pub priority_flow_ctrl_queue_info_get: priority_flow_ctrl_queue_info_get_t,
    #[doc = " Priority flow control queue configure"]
    pub priority_flow_ctrl_queue_config: priority_flow_ctrl_queue_config_t,
    #[doc = " Set Unicast Table Array"]
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    #[doc = " Set Unicast hash bitmap"]
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    #[doc = " Add UDP tunnel port"]
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    #[doc = " Delete UDP tunnel port"]
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    #[doc = " Set queue rate limit"]
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    #[doc = " Configure RSS hash protocols and hashing key"]
    pub rss_hash_update: rss_hash_update_t,
    #[doc = " Get current RSS hash configuration"]
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    #[doc = " Update redirection table"]
    pub reta_update: reta_update_t,
    #[doc = " Query redirection table"]
    pub reta_query: reta_query_t,
    #[doc = "< Get registers"]
    pub get_reg: eth_get_reg_t,
    #[doc = "< Get EEPROM length"]
    pub get_eeprom_length: eth_get_eeprom_length_t,
    #[doc = "< Get EEPROM data"]
    pub get_eeprom: eth_get_eeprom_t,
    #[doc = "< Set EEPROM"]
    pub set_eeprom: eth_set_eeprom_t,
    #[doc = " Get plugin module EEPROM attribute"]
    pub get_module_info: eth_get_module_info_t,
    #[doc = " Get plugin module EEPROM data"]
    pub get_module_eeprom: eth_get_module_eeprom_t,
    #[doc = "< Get flow operations"]
    pub flow_ops_get: eth_flow_ops_get_t,
    #[doc = "< Get DCB information"]
    pub get_dcb_info: eth_get_dcb_info,
    #[doc = " Turn IEEE1588/802.1AS timestamping on"]
    pub timesync_enable: eth_timesync_enable_t,
    #[doc = " Turn IEEE1588/802.1AS timestamping off"]
    pub timesync_disable: eth_timesync_disable_t,
    #[doc = " Read the IEEE1588/802.1AS Rx timestamp"]
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    #[doc = " Read the IEEE1588/802.1AS Tx timestamp"]
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    #[doc = " Adjust the device clock"]
    pub timesync_adjust_time: eth_timesync_adjust_time,
    #[doc = " Adjust the clock frequency"]
    pub timesync_adjust_freq: eth_timesync_adjust_freq,
    #[doc = " Get the device clock time"]
    pub timesync_read_time: eth_timesync_read_time,
    #[doc = " Set the device clock time"]
    pub timesync_write_time: eth_timesync_write_time,
    pub read_clock: eth_read_clock,
    #[doc = " Get extended device statistic values by ID"]
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    #[doc = " Get name of extended device statistics by ID"]
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub xstats_enable: eth_xstats_enable_counter_t,
    pub xstats_disable: eth_xstats_disable_counter_t,
    pub xstats_query_state: eth_xstats_query_state_t,
    #[doc = " Get Traffic Management (TM) operations"]
    pub tm_ops_get: eth_tm_ops_get_t,
    #[doc = " Get Traffic Metering and Policing (MTR) operations"]
    pub mtr_ops_get: eth_mtr_ops_get_t,
    #[doc = " Test if a port supports specific mempool ops"]
    pub pool_ops_supported: eth_pool_ops_supported_t,
    #[doc = " Returns the hairpin capabilities"]
    pub hairpin_cap_get: eth_hairpin_cap_get_t,
    #[doc = " Set up device Rx hairpin queue"]
    pub rx_hairpin_queue_setup: eth_rx_hairpin_queue_setup_t,
    #[doc = " Set up device Tx hairpin queue"]
    pub tx_hairpin_queue_setup: eth_tx_hairpin_queue_setup_t,
    #[doc = " Get Forward Error Correction(FEC) capability"]
    pub fec_get_capability: eth_fec_get_capability_t,
    #[doc = " Get Forward Error Correction(FEC) mode"]
    pub fec_get: eth_fec_get_t,
    #[doc = " Set Forward Error Correction(FEC) mode"]
    pub fec_set: eth_fec_set_t,
    #[doc = " Get hairpin peer ports list"]
    pub hairpin_get_peer_ports: hairpin_get_peer_ports_t,
    #[doc = " Bind all hairpin Tx queues of device to the peer port Rx queues"]
    pub hairpin_bind: eth_hairpin_bind_t,
    #[doc = " Unbind all hairpin Tx queues from the peer port Rx queues"]
    pub hairpin_unbind: eth_hairpin_unbind_t,
    #[doc = " Pass the current queue info and get the peer queue info"]
    pub hairpin_queue_peer_update: eth_hairpin_queue_peer_update_t,
    #[doc = " Set up the connection between the pair of hairpin queues"]
    pub hairpin_queue_peer_bind: eth_hairpin_queue_peer_bind_t,
    #[doc = " Disconnect the hairpin queues of a pair from each other"]
    pub hairpin_queue_peer_unbind: eth_hairpin_queue_peer_unbind_t,
    #[doc = " Get power monitoring condition for Rx queue"]
    pub get_monitor_addr: eth_get_monitor_addr_t,
    #[doc = " Get representor info"]
    pub representor_info_get: eth_representor_info_get_t,
    #[doc = " Negotiate the NIC's ability to deliver specific\n kinds of metadata to the PMD"]
    pub rx_metadata_negotiate: eth_rx_metadata_negotiate_t,
    #[doc = " Get IP reassembly capability"]
    pub ip_reassembly_capability_get: eth_ip_reassembly_capability_get_t,
    #[doc = " Get IP reassembly configuration"]
    pub ip_reassembly_conf_get: eth_ip_reassembly_conf_get_t,
    #[doc = " Set IP reassembly configuration"]
    pub ip_reassembly_conf_set: eth_ip_reassembly_conf_set_t,
    #[doc = " Get supported header ptypes to split"]
    pub buffer_split_supported_hdr_ptypes_get: eth_buffer_split_supported_hdr_ptypes_get_t,
    #[doc = " Dump private info from device"]
    pub eth_dev_priv_dump: eth_dev_priv_dump_t,
    #[doc = " Set Rx queue available descriptors threshold"]
    pub rx_queue_avail_thresh_set: eth_rx_queue_avail_thresh_set_t,
    #[doc = " Query Rx queue available descriptors threshold event"]
    pub rx_queue_avail_thresh_query: eth_rx_queue_avail_thresh_query_t,
    #[doc = " Dump Rx descriptor info"]
    pub eth_rx_descriptor_dump: eth_rx_descriptor_dump_t,
    #[doc = " Dump Tx descriptor info"]
    pub eth_tx_descriptor_dump: eth_tx_descriptor_dump_t,
    #[doc = " Get congestion management information"]
    pub cman_info_get: eth_cman_info_get_t,
    #[doc = " Initialize congestion management structure with default values"]
    pub cman_config_init: eth_cman_config_init_t,
    #[doc = " Configure congestion management"]
    pub cman_config_set: eth_cman_config_set_t,
    #[doc = " Retrieve congestion management configuration"]
    pub cman_config_get: eth_cman_config_get_t,
    #[doc = " Get the number of aggregated ports"]
    pub count_aggr_ports: eth_count_aggr_ports_t,
    #[doc = " Map a Tx queue with an aggregated port of the DPDK port"]
    pub map_aggr_tx_affinity: eth_map_aggr_tx_affinity_t,
    #[doc = " Get configuration which ethdev should restore"]
    pub get_restore_flags: eth_get_restore_flags_t,
}
#[doc = " No traffic metering performed, the output color is the same as the\n input color for every input packet. The meter of the MTR object is\n working in pass-through mode, having same effect as meter disable.\n @see rte_mtr_meter_disable()"]
pub const rte_mtr_algorithm_RTE_MTR_NONE: rte_mtr_algorithm = 0;
#[doc = " Single Rate Three Color Marker (srTCM) - IETF RFC 2697."]
pub const rte_mtr_algorithm_RTE_MTR_SRTCM_RFC2697: rte_mtr_algorithm = 1;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 2698."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC2698: rte_mtr_algorithm = 2;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 4115."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC4115: rte_mtr_algorithm = 3;
#[doc = " Traffic metering algorithms"]
pub type rte_mtr_algorithm = ::std::os::raw::c_uint;
#[doc = " Meter profile"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile {
    #[doc = " Traffic metering algorithm."]
    pub alg: rte_mtr_algorithm,
    pub __bindgen_anon_1: rte_mtr_meter_profile__bindgen_ty_1,
    #[doc = " When zero, the byte mode is enabled for the current profile, so the\n *rate* and *size* fields are specified in bytes per second\n and bytes, respectively.\n When non-zero, the packet mode is enabled for the current profile,\n so the *rate* and *size* fields are specified in packets per second\n and packets, respectively."]
    pub packet_mode: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mtr_meter_profile__bindgen_ty_1 {
    pub srtcm_rfc2697: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1,
    pub trtcm_rfc2698: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2,
    pub trtcm_rfc4115: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Items only valid when *alg* is set to srTCM - RFC 2697."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 2698."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Peak Information Rate (PIR)\n (bytes per second or packets per second)."]
    pub pir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Peak Burst Size (PBS) (bytes or packets)."]
    pub pbs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 4115."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Excess Information Rate (EIR)\n (bytes per second or packets per second)."]
    pub eir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_cseg {
    pub opcode: u32,
    pub sq_ds: u32,
    pub flags: u32,
    pub misc: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg {
    pub bcount: u32,
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_dseg__bindgen_ty_1 {
    pub inline_data: [u8; 12usize],
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1 {
    pub lkey: u32,
    pub pbuf: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1 {
    pub swp_offs: u32,
    pub cs_flags: u8,
    pub swp_flags: u8,
    pub mss: u16,
    pub metadata: u32,
    pub inline_hdr_sz: u16,
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inline_data: u16,
    pub vlan_tag: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2 {
    pub offsets: u32,
    pub flags: u32,
    pub flow_metadata: u32,
    pub inline_hdr: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe {
    pub __bindgen_anon_1: mlx5_wqe__bindgen_ty_1,
    pub eseg: mlx5_wqe_eseg,
    pub __bindgen_anon_2: mlx5_wqe__bindgen_ty_2,
}
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_1 {
    pub cseg: mlx5_wqe_cseg,
    pub ctrl: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_2 {
    pub dseg: [mlx5_wqe_dseg; 2usize],
    pub data: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe {
    pub pkt_info: u8,
    pub rsvd0: u8,
    pub wqe_id: u16,
    pub lro_tcppsh_abort_dupack: u8,
    pub lro_min_ttl: u8,
    pub lro_tcp_win: u16,
    pub lro_ack_seq_num: u32,
    pub rx_hash_res: u32,
    pub rx_hash_type: u8,
    pub rsvd1: [u8; 3usize],
    pub csum: u16,
    pub rsvd2: [u8; 6usize],
    pub hdr_type_etc: u16,
    pub vlan_info: u16,
    pub lro_num_seg: u8,
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1,
    pub flow_table_metadata: u32,
    pub rsvd4: [u8; 4usize],
    pub byte_cnt: u32,
    pub timestamp: u64,
    pub sop_drop_qpn: u32,
    pub wqe_counter: u16,
    pub validity_iteration_count: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_cqe__bindgen_ty_1 {
    pub user_index_bytes: [u8; 3usize],
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe__bindgen_ty_1__bindgen_ty_1 {
    pub user_index_hi: u8,
    pub user_index_low: u16,
}
pub const modify_reg_REG_NON: modify_reg = 0;
pub const modify_reg_REG_A: modify_reg = 1;
pub const modify_reg_REG_B: modify_reg = 2;
pub const modify_reg_REG_C_0: modify_reg = 3;
pub const modify_reg_REG_C_1: modify_reg = 4;
pub const modify_reg_REG_C_2: modify_reg = 5;
pub const modify_reg_REG_C_3: modify_reg = 6;
pub const modify_reg_REG_C_4: modify_reg = 7;
pub const modify_reg_REG_C_5: modify_reg = 8;
pub const modify_reg_REG_C_6: modify_reg = 9;
pub const modify_reg_REG_C_7: modify_reg = 10;
pub const modify_reg_REG_C_8: modify_reg = 11;
pub const modify_reg_REG_C_9: modify_reg = 12;
pub const modify_reg_REG_C_10: modify_reg = 13;
pub const modify_reg_REG_C_11: modify_reg = 14;
pub type modify_reg = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd {
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_modification_cmd__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mlx5_modification_cmd__bindgen_ty_1 {
    pub data0: u32,
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn field(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_field(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn field_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_field_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn action_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_action_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn action_type_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_action_type_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        length: ::std::os::raw::c_uint,
        rsvd0: ::std::os::raw::c_uint,
        offset: ::std::os::raw::c_uint,
        rsvd1: ::std::os::raw::c_uint,
        field: ::std::os::raw::c_uint,
        action_type: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsvd0: u32 = unsafe { ::std::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let offset: u32 = unsafe { ::std::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let rsvd1: u32 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let field: u32 = unsafe { ::std::mem::transmute(field) };
            field as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let action_type: u32 = unsafe { ::std::mem::transmute(action_type) };
            action_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mlx5_modification_cmd__bindgen_ty_2 {
    pub data1: u32,
    pub data: [u8; 4usize],
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rsvd2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd2_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd2_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_offset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dst_offset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_offset_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_offset_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd3_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd3_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_field(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_dst_field(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_field_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_field_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd4(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd4(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd4_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd4_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsvd2: ::std::os::raw::c_uint,
        dst_offset: ::std::os::raw::c_uint,
        rsvd3: ::std::os::raw::c_uint,
        dst_field: ::std::os::raw::c_uint,
        rsvd4: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rsvd2: u32 = unsafe { ::std::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let dst_offset: u32 = unsafe { ::std::mem::transmute(dst_offset) };
            dst_offset as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let rsvd3: u32 = unsafe { ::std::mem::transmute(rsvd3) };
            rsvd3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let dst_field: u32 = unsafe { ::std::mem::transmute(dst_field) };
            dst_field as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rsvd4: u32 = unsafe { ::std::mem::transmute(rsvd4) };
            rsvd4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cseg {
    pub va_h: u32,
    pub va_l_r: u32,
    pub lkey: u32,
    pub operand_masks: u32,
    pub condition_0_data: u32,
    pub condition_0_mask: u32,
    pub condition_1_data: u32,
    pub condition_1_mask: u32,
    pub bitwise_data: u64,
    pub data_mask: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_dseg {
    pub v_bo_sc_bbog_mm: u32,
    pub reserved: u32,
    pub cbs_cir: u32,
    pub c_tokens: u32,
    pub ebs_eir: u32,
    pub e_tokens: u32,
    pub timestamp: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_dseg {
    pub __bindgen_anon_1: mlx5_aso_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_dseg__bindgen_ty_1 {
    pub data: [u8; 64usize],
    pub mtrs: [mlx5_aso_mtr_dseg; 2usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_wqe {
    pub general_cseg: mlx5_wqe_cseg,
    pub aso_cseg: mlx5_aso_cseg,
    pub aso_dseg: mlx5_aso_dseg,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_qos_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_max_flow_meter: u8,
    pub flow_meter_reg_c_ids: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_hca_qos_attr {
    #[inline]
    pub fn sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_old(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_old(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_old_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_old_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn packet_pacing(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_packet_pacing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_pacing_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_packet_pacing_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_rate_pp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_rate_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_rate_pp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_rate_pp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_aso_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_aso_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_aso_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_aso_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sup: u32,
        flow_meter_old: u32,
        packet_pacing: u32,
        wqe_rate_pp: u32,
        flow_meter: u32,
        flow_meter_aso_sup: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sup: u32 = unsafe { ::std::mem::transmute(sup) };
            sup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_meter_old: u32 = unsafe { ::std::mem::transmute(flow_meter_old) };
            flow_meter_old as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let packet_pacing: u32 = unsafe { ::std::mem::transmute(packet_pacing) };
            packet_pacing as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wqe_rate_pp: u32 = unsafe { ::std::mem::transmute(wqe_rate_pp) };
            wqe_rate_pp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let flow_meter: u32 = unsafe { ::std::mem::transmute(flow_meter) };
            flow_meter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flow_meter_aso_sup: u32 = unsafe { ::std::mem::transmute(flow_meter_aso_sup) };
            flow_meter_aso_sup as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_meter_aso_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_meter_aso_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_num_meter_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_num_meter_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_num_meter_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_num_meter_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        log_meter_aso_granularity: u32,
        log_meter_aso_max_alloc: u32,
        log_max_num_meter_aso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_meter_aso_granularity: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_granularity) };
            log_meter_aso_granularity as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let log_meter_aso_max_alloc: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_max_alloc) };
            log_meter_aso_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let log_max_num_meter_aso: u32 =
                unsafe { ::std::mem::transmute(log_max_num_meter_aso) };
            log_max_num_meter_aso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr {
    pub virtio_queue_type: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_num_virtio_queues: u32,
    pub umems: [mlx5_hca_vdpa_attr__bindgen_ty_1; 3usize],
    pub doorbell_bar_offset: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr__bindgen_ty_1 {
    pub a: u32,
    pub b: u32,
}
impl mlx5_hca_vdpa_attr {
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn desc_tunnel_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_desc_tunnel_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn desc_tunnel_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_desc_tunnel_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_frame_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_frame_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_frame_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_frame_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_version_1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_version_1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_version_1_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_version_1_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv6_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn event_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_event_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_stride(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_stride_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_stride_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_bar_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_bar_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_bar_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_bar_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn queue_counters_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_queue_counters_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn queue_counters_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_queue_counters_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vnet_modify_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vnet_modify_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vnet_modify_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vnet_modify_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_net_q_addr_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_net_q_addr_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_net_q_addr_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_net_q_addr_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_q_index_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_q_index_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_q_index_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_q_index_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid: u32,
        desc_tunnel_offload_type: u32,
        eth_frame_offload_type: u32,
        virtio_version_1_0: u32,
        tso_ipv4: u32,
        tso_ipv6: u32,
        tx_csum: u32,
        rx_csum: u32,
        event_mode: u32,
        log_doorbell_stride: u32,
        log_doorbell_bar_size: u32,
        queue_counters_valid: u32,
        vnet_modify_ext: u32,
        virtio_net_q_addr_modify: u32,
        virtio_q_index_modify: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u32 = unsafe { ::std::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let desc_tunnel_offload_type: u32 =
                unsafe { ::std::mem::transmute(desc_tunnel_offload_type) };
            desc_tunnel_offload_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let eth_frame_offload_type: u32 =
                unsafe { ::std::mem::transmute(eth_frame_offload_type) };
            eth_frame_offload_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let virtio_version_1_0: u32 = unsafe { ::std::mem::transmute(virtio_version_1_0) };
            virtio_version_1_0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tso_ipv4: u32 = unsafe { ::std::mem::transmute(tso_ipv4) };
            tso_ipv4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tso_ipv6: u32 = unsafe { ::std::mem::transmute(tso_ipv6) };
            tso_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_csum: u32 = unsafe { ::std::mem::transmute(tx_csum) };
            tx_csum as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_csum: u32 = unsafe { ::std::mem::transmute(rx_csum) };
            rx_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let event_mode: u32 = unsafe { ::std::mem::transmute(event_mode) };
            event_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let log_doorbell_stride: u32 = unsafe { ::std::mem::transmute(log_doorbell_stride) };
            log_doorbell_stride as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let log_doorbell_bar_size: u32 =
                unsafe { ::std::mem::transmute(log_doorbell_bar_size) };
            log_doorbell_bar_size as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let queue_counters_valid: u32 = unsafe { ::std::mem::transmute(queue_counters_valid) };
            queue_counters_valid as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let vnet_modify_ext: u32 = unsafe { ::std::mem::transmute(vnet_modify_ext) };
            vnet_modify_ext as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let virtio_net_q_addr_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_net_q_addr_modify) };
            virtio_net_q_addr_modify as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let virtio_q_index_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_q_index_modify) };
            virtio_q_index_modify as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flow_attr {
    pub tunnel_header_0_1: u32,
    pub tunnel_header_2_3: u32,
}
#[doc = " Accumulate port PARSE_GRAPH_NODE capabilities from\n PARSE_GRAPH_NODE Capabilities and HCA Capabilities 2 tables"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flex_attr {
    pub node_in: u32,
    pub node_out: u32,
    pub header_length_mode: u16,
    pub sample_offset_mode: u16,
    pub max_num_arc_in: u8,
    pub max_num_arc_out: u8,
    pub max_num_sample: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_base_header_length: u16,
    pub max_sample_base_offset: u8,
    pub max_next_header_offset: u16,
    pub header_length_mask_width: u8,
}
impl mlx5_hca_flex_attr {
    #[inline]
    pub fn max_num_prog_sample(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_max_num_prog_sample(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_num_prog_sample_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_max_num_prog_sample_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_anchor(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parse_graph_anchor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_anchor_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_anchor_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_tunnel_inner2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_tunnel_inner2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_tunnel_inner2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_tunnel_inner2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zero_size_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zero_size_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zero_size_supported_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_zero_size_supported_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_id_in_out(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_id_in_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_id_in_out_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_id_in_out_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_num_prog_sample: u8,
        parse_graph_anchor: u8,
        query_match_sample_info: u8,
        sample_tunnel_inner2: u8,
        zero_size_supported: u8,
        sample_id_in_out: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let max_num_prog_sample: u8 = unsafe { ::std::mem::transmute(max_num_prog_sample) };
            max_num_prog_sample as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let parse_graph_anchor: u8 = unsafe { ::std::mem::transmute(parse_graph_anchor) };
            parse_graph_anchor as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let query_match_sample_info: u8 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sample_tunnel_inner2: u8 = unsafe { ::std::mem::transmute(sample_tunnel_inner2) };
            sample_tunnel_inner2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let zero_size_supported: u8 = unsafe { ::std::mem::transmute(zero_size_supported) };
            zero_size_supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sample_id_in_out: u8 = unsafe { ::std::mem::transmute(sample_id_in_out) };
            sample_id_in_out as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_crypto_mmo_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl mlx5_hca_crypto_mmo_attr {
    #[inline]
    pub fn crypto_mmo_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_mmo_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_mmo_qp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_mmo_qp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_96(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_96(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_96_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_96_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_crypto_mmo_max_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_log_crypto_mmo_max_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_crypto_mmo_max_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_crypto_mmo_max_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        crypto_mmo_qp: u32,
        gcm_256_encrypt: u32,
        gcm_128_encrypt: u32,
        gcm_256_decrypt: u32,
        gcm_128_decrypt: u32,
        gcm_auth_tag_128: u32,
        gcm_auth_tag_96: u32,
        log_crypto_mmo_max_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let crypto_mmo_qp: u32 = unsafe { ::std::mem::transmute(crypto_mmo_qp) };
            crypto_mmo_qp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gcm_256_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_encrypt) };
            gcm_256_encrypt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gcm_128_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_encrypt) };
            gcm_128_encrypt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gcm_256_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_decrypt) };
            gcm_256_decrypt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let gcm_128_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_decrypt) };
            gcm_128_decrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gcm_auth_tag_128: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_128) };
            gcm_auth_tag_128 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gcm_auth_tag_96: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_96) };
            gcm_auth_tag_96 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 6u8, {
            let log_crypto_mmo_max_size: u32 =
                unsafe { ::std::mem::transmute(log_crypto_mmo_max_size) };
            log_crypto_mmo_max_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_counter_bulk_alloc_bitmap: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_lso_cap: u32,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub lro_timer_supported_periods: [u32; 4usize],
    pub lro_min_mss_size: u16,
    pub flex_parser_protocols: u32,
    pub _bitfield_align_4: [u16; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 10usize]>,
    pub dev_freq_khz: u32,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub regexp_num_of_engines: u32,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub geneve_tlv_opt: u32,
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub qos: mlx5_hca_qos_attr,
    pub vdpa: mlx5_hca_vdpa_attr,
    pub flow: mlx5_hca_flow_attr,
    pub flex: mlx5_hca_flex_attr,
    pub crypto_mmo: mlx5_hca_crypto_mmo_attr,
    pub log_max_wq_sz: u8,
    pub log_max_qp_sz: u8,
    pub log_max_cq_sz: u8,
    pub log_max_qp: u8,
    pub log_max_cq: u8,
    pub log_max_pd: u32,
    pub log_max_mrw_sz: u32,
    pub log_max_srq: u32,
    pub log_max_srq_sz: u32,
    pub rss_ind_tbl_cap: u32,
    pub _bitfield_align_8: [u8; 0],
    pub _bitfield_8: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub esw_mgr_vport_id: u16,
    pub max_wqe_sz_sq: u16,
    pub _bitfield_align_9: [u16; 0],
    pub _bitfield_9: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1,
    pub _bitfield_align_10: [u8; 0],
    pub _bitfield_10: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_header_modify_pattern_length: u8,
    pub system_image_guid: u64,
    pub _bitfield_align_11: [u8; 0],
    pub _bitfield_11: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_hca_attr__bindgen_ty_1 {
    pub max_flow_counter: u32,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1 {
    pub max_flow_counter_15_0: u16,
    pub max_flow_counter_31_16: u16,
}
impl mlx5_hca_attr {
    #[inline]
    pub fn eswitch_manager(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eswitch_manager(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eswitch_manager_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eswitch_manager_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counters_dump(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counters_dump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counters_dump_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counters_dump_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_rq_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_rq_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_rq_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_rq_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rqt_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rqt_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rqt_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rqt_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_flex_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parse_graph_flex_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_flex_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_flex_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        eswitch_manager: u32,
        flow_counters_dump: u32,
        mem_rq_rmp: u32,
        log_max_rmp: u32,
        log_max_rqt_size: u32,
        parse_graph_flex_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eswitch_manager: u32 = unsafe { ::std::mem::transmute(eswitch_manager) };
            eswitch_manager as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_counters_dump: u32 = unsafe { ::std::mem::transmute(flow_counters_dump) };
            flow_counters_dump as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mem_rq_rmp: u32 = unsafe { ::std::mem::transmute(mem_rq_rmp) };
            mem_rq_rmp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let log_max_rmp: u32 = unsafe { ::std::mem::transmute(log_max_rmp) };
            log_max_rmp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log_max_rqt_size: u32 = unsafe { ::std::mem::transmute(log_max_rqt_size) };
            log_max_rqt_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let parse_graph_flex_node: u32 =
                unsafe { ::std::mem::transmute(parse_graph_flex_node) };
            parse_graph_flex_node as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eth_net_offloads(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_net_offloads(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_net_offloads_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_net_offloads_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_virt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_virt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_virt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_virt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_vlan_insert(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_vlan_insert(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_vlan_insert_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_vlan_insert_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csum_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_csum_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vport_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vport_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vport_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vport_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_geneve_rx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_geneve_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_geneve_rx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_geneve_rx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_max_opt_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_max_opt_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_max_opt_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_max_opt_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gtp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gtp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gtp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gtp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan_gpe_nsh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan_gpe_nsh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_gpe_nsh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_gpe_nsh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        eth_net_offloads: u32,
        eth_virt: u32,
        wqe_vlan_insert: u32,
        csum_cap: u32,
        vlan_cap: u32,
        wqe_inline_mode: u32,
        vport_inline_mode: u32,
        tunnel_stateless_geneve_rx: u32,
        geneve_max_opt_len: u32,
        tunnel_stateless_gtp: u32,
        tunnel_stateless_vxlan_gpe_nsh: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eth_net_offloads: u32 = unsafe { ::std::mem::transmute(eth_net_offloads) };
            eth_net_offloads as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let eth_virt: u32 = unsafe { ::std::mem::transmute(eth_virt) };
            eth_virt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wqe_vlan_insert: u32 = unsafe { ::std::mem::transmute(wqe_vlan_insert) };
            wqe_vlan_insert as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let csum_cap: u32 = unsafe { ::std::mem::transmute(csum_cap) };
            csum_cap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vlan_cap: u32 = unsafe { ::std::mem::transmute(vlan_cap) };
            vlan_cap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let wqe_inline_mode: u32 = unsafe { ::std::mem::transmute(wqe_inline_mode) };
            wqe_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let vport_inline_mode: u32 = unsafe { ::std::mem::transmute(vport_inline_mode) };
            vport_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tunnel_stateless_geneve_rx: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_geneve_rx) };
            tunnel_stateless_geneve_rx as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let geneve_max_opt_len: u32 = unsafe { ::std::mem::transmute(geneve_max_opt_len) };
            geneve_max_opt_len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tunnel_stateless_gtp: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gtp) };
            tunnel_stateless_gtp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tunnel_stateless_vxlan_gpe_nsh: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan_gpe_nsh) };
            tunnel_stateless_vxlan_gpe_nsh as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_lso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_lso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_lso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_lso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_max_msg_sz_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lro_max_msg_sz_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_max_msg_sz_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_max_msg_sz_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        scatter_fcs: u32,
        lro_cap: u32,
        tunnel_lro_gre: u32,
        tunnel_lro_vxlan: u32,
        tunnel_stateless_gre: u32,
        tunnel_stateless_vxlan: u32,
        swp: u32,
        swp_csum: u32,
        swp_lso: u32,
        lro_max_msg_sz_mode: u32,
        rq_delay_drop: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs: u32 = unsafe { ::std::mem::transmute(scatter_fcs) };
            scatter_fcs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lro_cap: u32 = unsafe { ::std::mem::transmute(lro_cap) };
            lro_cap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tunnel_lro_gre: u32 = unsafe { ::std::mem::transmute(tunnel_lro_gre) };
            tunnel_lro_gre as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tunnel_lro_vxlan: u32 = unsafe { ::std::mem::transmute(tunnel_lro_vxlan) };
            tunnel_lro_vxlan as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tunnel_stateless_gre: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gre) };
            tunnel_stateless_gre as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tunnel_stateless_vxlan: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan) };
            tunnel_stateless_vxlan as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let swp_csum: u32 = unsafe { ::std::mem::transmute(swp_csum) };
            swp_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let swp_lso: u32 = unsafe { ::std::mem::transmute(swp_lso) };
            swp_lso as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let lro_max_msg_sz_mode: u32 = unsafe { ::std::mem::transmute(lro_max_msg_sz_mode) };
            lro_max_msg_sz_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rq_delay_drop: u32 = unsafe { ::std::mem::transmute(rq_delay_drop) };
            rq_delay_drop as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn max_geneve_tlv_options(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_options(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_options_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_options_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_geneve_tlv_option_data_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_option_data_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_option_data_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_option_data_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_sample(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_sample_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_sample_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_sample_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(15usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_sample_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(15usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_sample_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                15usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_sample_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                15usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_queues(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_queues(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_queues_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                20usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_queues_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                20usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_wq_data_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_wq_data_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_wq_data_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                25usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_wq_data_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                25usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_num_packets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_num_packets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_num_packets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_num_packets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wqe_bb_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(37usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wqe_bb_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(37usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wqe_bb_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                37usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wqe_bb_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                37usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wq_in_host_mem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wq_in_host_mem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wq_in_host_mem_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wq_in_host_mem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_data_buffer_locked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_data_buffer_locked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_data_buffer_locked_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                42usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_data_buffer_locked_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vhca_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(43usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_vhca_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(43usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vhca_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                43usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vhca_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                43usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_write_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                59usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_write_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_read_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                60usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_read_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_register_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_access_register_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_register_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                61usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_access_register_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_index_ignore(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_index_ignore(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_index_ignore_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                62usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_index_ignore_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_channel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_channel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_channel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_channel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_wire_sq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_wire_sq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_wire_sq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                64usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_wire_sq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                64usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_static_sq_wq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(65usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_static_sq_wq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(65usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_static_sq_wq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                65usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_static_sq_wq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                65usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_lag_ports(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(70usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_num_lag_ports(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(70usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_lag_ports_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                70usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_lag_ports_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                70usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        max_geneve_tlv_options: u32,
        max_geneve_tlv_option_data_len: u32,
        geneve_tlv_sample: u32,
        geneve_tlv_option_offset: u32,
        geneve_tlv_option_sample_id: u32,
        hairpin: u32,
        log_max_hairpin_queues: u32,
        log_max_hairpin_wq_data_sz: u32,
        log_max_hairpin_num_packets: u32,
        hairpin_sq_wqe_bb_size: u32,
        hairpin_sq_wq_in_host_mem: u32,
        hairpin_data_buffer_locked: u32,
        vhca_id: u32,
        relaxed_ordering_write: u32,
        relaxed_ordering_read: u32,
        access_register_user: u32,
        wqe_index_ignore: u32,
        cross_channel: u32,
        non_wire_sq: u32,
        log_max_static_sq_wq: u32,
        num_lag_ports: u32,
    ) -> __BindgenBitfieldUnit<[u8; 10usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let max_geneve_tlv_options: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_options) };
            max_geneve_tlv_options as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let max_geneve_tlv_option_data_len: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_option_data_len) };
            max_geneve_tlv_option_data_len as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let geneve_tlv_sample: u32 = unsafe { ::std::mem::transmute(geneve_tlv_sample) };
            geneve_tlv_sample as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let geneve_tlv_option_offset: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_offset) };
            geneve_tlv_option_offset as u64
        });
        __bindgen_bitfield_unit.set(15usize, 4u8, {
            let geneve_tlv_option_sample_id: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_sample_id) };
            geneve_tlv_option_sample_id as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let hairpin: u32 = unsafe { ::std::mem::transmute(hairpin) };
            hairpin as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let log_max_hairpin_queues: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_queues) };
            log_max_hairpin_queues as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let log_max_hairpin_wq_data_sz: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_wq_data_sz) };
            log_max_hairpin_wq_data_sz as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let log_max_hairpin_num_packets: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_num_packets) };
            log_max_hairpin_num_packets as u64
        });
        __bindgen_bitfield_unit.set(37usize, 4u8, {
            let hairpin_sq_wqe_bb_size: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wqe_bb_size) };
            hairpin_sq_wqe_bb_size as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let hairpin_sq_wq_in_host_mem: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wq_in_host_mem) };
            hairpin_sq_wq_in_host_mem as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let hairpin_data_buffer_locked: u32 =
                unsafe { ::std::mem::transmute(hairpin_data_buffer_locked) };
            hairpin_data_buffer_locked as u64
        });
        __bindgen_bitfield_unit.set(43usize, 16u8, {
            let vhca_id: u32 = unsafe { ::std::mem::transmute(vhca_id) };
            vhca_id as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let relaxed_ordering_write: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_write) };
            relaxed_ordering_write as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let relaxed_ordering_read: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_read) };
            relaxed_ordering_read as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let access_register_user: u32 = unsafe { ::std::mem::transmute(access_register_user) };
            access_register_user as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let wqe_index_ignore: u32 = unsafe { ::std::mem::transmute(wqe_index_ignore) };
            wqe_index_ignore as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let cross_channel: u32 = unsafe { ::std::mem::transmute(cross_channel) };
            cross_channel as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let non_wire_sq: u32 = unsafe { ::std::mem::transmute(non_wire_sq) };
            non_wire_sq as u64
        });
        __bindgen_bitfield_unit.set(65usize, 5u8, {
            let log_max_static_sq_wq: u32 = unsafe { ::std::mem::transmute(log_max_static_sq_wq) };
            log_max_static_sq_wq as u64
        });
        __bindgen_bitfield_unit.set(70usize, 4u8, {
            let num_lag_ports: u32 = unsafe { ::std::mem::transmute(num_lag_ports) };
            num_lag_ports as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn roce(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn roce_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_roce_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wait_on_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wait_on_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wait_on_time_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wait_on_time_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qp_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_qp_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qp_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qp_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_params(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_params(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_params_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_params_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                15usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                15usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_c_preserve(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg_c_preserve(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_c_preserve_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_preserve_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aes_xts(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aes_xts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aes_xts_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aes_xts_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn import_kek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_import_kek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn import_kek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_import_kek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn credential(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_credential(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn credential_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_credential_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_login(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_login(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_login_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_login_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        scatter_fcs_w_decap_disable: u32,
        flow_hit_aso: u32,
        roce: u32,
        wait_on_time: u32,
        rq_ts_format: u32,
        sq_ts_format: u32,
        steering_format_version: u32,
        qp_ts_format: u32,
        regexp_params: u32,
        regexp_version: u32,
        reg_c_preserve: u32,
        ct_offload: u32,
        crypto: u32,
        aes_xts: u32,
        dek: u32,
        import_kek: u32,
        credential: u32,
        crypto_login: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso: u32 = unsafe { ::std::mem::transmute(flow_hit_aso) };
            flow_hit_aso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let roce: u32 = unsafe { ::std::mem::transmute(roce) };
            roce as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_on_time: u32 = unsafe { ::std::mem::transmute(wait_on_time) };
            wait_on_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rq_ts_format: u32 = unsafe { ::std::mem::transmute(rq_ts_format) };
            rq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let sq_ts_format: u32 = unsafe { ::std::mem::transmute(sq_ts_format) };
            sq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let qp_ts_format: u32 = unsafe { ::std::mem::transmute(qp_ts_format) };
            qp_ts_format as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let regexp_params: u32 = unsafe { ::std::mem::transmute(regexp_params) };
            regexp_params as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let regexp_version: u32 = unsafe { ::std::mem::transmute(regexp_version) };
            regexp_version as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reg_c_preserve: u32 = unsafe { ::std::mem::transmute(reg_c_preserve) };
            reg_c_preserve as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ct_offload: u32 = unsafe { ::std::mem::transmute(ct_offload) };
            ct_offload as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let crypto: u32 = unsafe { ::std::mem::transmute(crypto) };
            crypto as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let aes_xts: u32 = unsafe { ::std::mem::transmute(aes_xts) };
            aes_xts as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let dek: u32 = unsafe { ::std::mem::transmute(dek) };
            dek as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let import_kek: u32 = unsafe { ::std::mem::transmute(import_kek) };
            import_kek as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let credential: u32 = unsafe { ::std::mem::transmute(credential) };
            credential as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let crypto_login: u32 = unsafe { ::std::mem::transmute(crypto_login) };
            crypto_login as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_ft_sampler_num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_ft_sampler_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_ft_sampler_num_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_ft_sampler_num_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inner_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inner_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outer_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outer_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        log_max_ft_sampler_num: u32,
        inner_ipv4_ihl: u32,
        outer_ipv4_ihl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_max_ft_sampler_num: u32 =
                unsafe { ::std::mem::transmute(log_max_ft_sampler_num) };
            log_max_ft_sampler_num as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inner_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(inner_ipv4_ihl) };
            inner_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outer_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(outer_ipv4_ihl) };
            outer_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_flow_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_flow_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_flow_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_flow_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_l3_l4_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_l3_l4_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_l3_l4_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_l3_l4_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkt_integrity_match(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkt_integrity_match(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_integrity_match_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_integrity_match_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        cqe_compression: u32,
        mini_cqe_resp_flow_tag: u32,
        mini_cqe_resp_l3_l4_tag: u32,
        enhanced_cqe_compression: u32,
        pkt_integrity_match: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cqe_compression: u32 = unsafe { ::std::mem::transmute(cqe_compression) };
            cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mini_cqe_resp_flow_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_flow_tag) };
            mini_cqe_resp_flow_tag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mini_cqe_resp_l3_l4_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_l3_l4_tag) };
            mini_cqe_resp_l3_l4_tag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enhanced_cqe_compression: u32 =
                unsafe { ::std::mem::transmute(enhanced_cqe_compression) };
            enhanced_cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pkt_integrity_match: u32 = unsafe { ::std::mem::transmute(pkt_integrity_match) };
            pkt_integrity_match as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mmo_dma_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_decompress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_decompress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_decompress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_decompress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_dma_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v1_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v1_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v1_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v2_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v2_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v2_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn compress_min_block_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_compress_min_block_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compress_min_block_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                9usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compress_min_block_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_dma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_dma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_dma_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                13usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_dma_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                13usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_compress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_compress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_compress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                18usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_compress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                18usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_decompress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_decompress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_decompress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                23usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_decompress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                23usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_data_only_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_data_only_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_data_only_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_data_only_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_no_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_no_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_no_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_no_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_modify_entity_size_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_modify_entity_size_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_modify_entity_size_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_modify_entity_size_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_indirect_mkey_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_indirect_mkey_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_indirect_mkey_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_indirect_mkey_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_min_stride_wqe_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(33usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_min_stride_wqe_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(33usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_min_stride_wqe_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                33usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_min_stride_wqe_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                33usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn esw_mgr_vport_id_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mgr_vport_id_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mgr_vport_id_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mgr_vport_id_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_wrapped_import_method(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_wrapped_import_method(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_wrapped_import_method_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_wrapped_import_method_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_8(
        mmo_dma_sq_en: u32,
        mmo_compress_sq_en: u32,
        mmo_decompress_sq_en: u32,
        mmo_dma_qp_en: u32,
        mmo_compress_qp_en: u32,
        decomp_deflate_v1_en: u32,
        decomp_deflate_v2_en: u32,
        mmo_regex_qp_en: u32,
        mmo_regex_sq_en: u32,
        compress_min_block_size: u32,
        log_max_mmo_dma: u32,
        log_max_mmo_compress: u32,
        log_max_mmo_decompress: u32,
        decomp_lz4_data_only_en: u32,
        decomp_lz4_no_checksum_en: u32,
        decomp_lz4_checksum_en: u32,
        umr_modify_entity_size_disabled: u32,
        umr_indirect_mkey_disabled: u32,
        log_min_stride_wqe_sz: u32,
        esw_mgr_vport_id_valid: u32,
        crypto_wrapped_import_method: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmo_dma_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_sq_en) };
            mmo_dma_sq_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mmo_compress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_sq_en) };
            mmo_compress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmo_decompress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_decompress_sq_en) };
            mmo_decompress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mmo_dma_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_qp_en) };
            mmo_dma_qp_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mmo_compress_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_qp_en) };
            mmo_compress_qp_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let decomp_deflate_v1_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v1_en) };
            decomp_deflate_v1_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let decomp_deflate_v2_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v2_en) };
            decomp_deflate_v2_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mmo_regex_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_qp_en) };
            mmo_regex_qp_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmo_regex_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_sq_en) };
            mmo_regex_sq_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let compress_min_block_size: u32 =
                unsafe { ::std::mem::transmute(compress_min_block_size) };
            compress_min_block_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let log_max_mmo_dma: u32 = unsafe { ::std::mem::transmute(log_max_mmo_dma) };
            log_max_mmo_dma as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let log_max_mmo_compress: u32 = unsafe { ::std::mem::transmute(log_max_mmo_compress) };
            log_max_mmo_compress as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let log_max_mmo_decompress: u32 =
                unsafe { ::std::mem::transmute(log_max_mmo_decompress) };
            log_max_mmo_decompress as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let decomp_lz4_data_only_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_data_only_en) };
            decomp_lz4_data_only_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let decomp_lz4_no_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_no_checksum_en) };
            decomp_lz4_no_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let decomp_lz4_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_checksum_en) };
            decomp_lz4_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let umr_modify_entity_size_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_modify_entity_size_disabled) };
            umr_modify_entity_size_disabled as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let umr_indirect_mkey_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_indirect_mkey_disabled) };
            umr_indirect_mkey_disabled as u64
        });
        __bindgen_bitfield_unit.set(33usize, 5u8, {
            let log_min_stride_wqe_sz: u32 =
                unsafe { ::std::mem::transmute(log_min_stride_wqe_sz) };
            log_min_stride_wqe_sz as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let esw_mgr_vport_id_valid: u32 =
                unsafe { ::std::mem::transmute(esw_mgr_vport_id_valid) };
            esw_mgr_vport_id_valid as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let crypto_wrapped_import_method: u32 =
                unsafe { ::std::mem::transmute(crypto_wrapped_import_method) };
            crypto_wrapped_import_method as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn striding_rq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_striding_rq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn striding_rq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_striding_rq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_stride_num_range(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_stride_num_range(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_stride_num_range_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ext_stride_num_range_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_compression_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_reg_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(5usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_set_reg_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(5usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                5usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_set_reg_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                5usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nic_flow_table(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nic_flow_table(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nic_flow_table_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nic_flow_table_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ip_ecn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ip_ecn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ip_ecn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ip_ecn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ipv6_traffic_class(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ipv6_traffic_class(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ipv6_traffic_class_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ipv6_traffic_class_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_9(
        striding_rq: u32,
        ext_stride_num_range: u32,
        cqe_compression_128: u32,
        multi_pkt_send_wqe: u32,
        enhanced_multi_pkt_send_wqe: u32,
        set_reg_c: u32,
        nic_flow_table: u32,
        modify_outer_ip_ecn: u32,
        modify_outer_ipv6_traffic_class: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let striding_rq: u32 = unsafe { ::std::mem::transmute(striding_rq) };
            striding_rq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ext_stride_num_range: u32 = unsafe { ::std::mem::transmute(ext_stride_num_range) };
            ext_stride_num_range as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cqe_compression_128: u32 = unsafe { ::std::mem::transmute(cqe_compression_128) };
            cqe_compression_128 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let multi_pkt_send_wqe: u32 = unsafe { ::std::mem::transmute(multi_pkt_send_wqe) };
            multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enhanced_multi_pkt_send_wqe: u32 =
                unsafe { ::std::mem::transmute(enhanced_multi_pkt_send_wqe) };
            enhanced_multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(5usize, 16u8, {
            let set_reg_c: u32 = unsafe { ::std::mem::transmute(set_reg_c) };
            set_reg_c as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let nic_flow_table: u32 = unsafe { ::std::mem::transmute(nic_flow_table) };
            nic_flow_table as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let modify_outer_ip_ecn: u32 = unsafe { ::std::mem::transmute(modify_outer_ip_ecn) };
            modify_outer_ip_ecn as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let modify_outer_ipv6_traffic_class: u32 =
                unsafe { ::std::mem::transmute(modify_outer_ipv6_traffic_class) };
            modify_outer_ipv6_traffic_class as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_counter_bulk_log_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_bulk_log_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alloc_flow_counter_pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alloc_flow_counter_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alloc_flow_counter_pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_alloc_flow_counter_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_access_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_access_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_access_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_access_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_access_aso_opc_mod(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(13usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_access_aso_opc_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_access_aso_opc_mod_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                13usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_access_aso_opc_mod_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                13usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_vhca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_vhca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_vhca_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_vhca_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_based_flow_table_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_based_flow_table_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_based_flow_table_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_based_flow_table_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fdb_unified_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_unified_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_unified_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_unified_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jump_fdb_rx_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jump_fdb_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jump_fdb_rx_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_jump_fdb_rx_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_10(
        flow_counter_bulk_log_max_alloc: u32,
        flow_counter_bulk_log_granularity: u32,
        alloc_flow_counter_pd: u32,
        flow_counter_access_aso: u32,
        query_match_sample_info: u32,
        flow_access_aso_opc_mod: u32,
        cross_vhca: u32,
        lag_rx_port_affinity: u32,
        wqe_based_flow_table_sup: u32,
        fdb_unified_en: u32,
        jump_fdb_rx_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let flow_counter_bulk_log_max_alloc: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_max_alloc) };
            flow_counter_bulk_log_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let flow_counter_bulk_log_granularity: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_granularity) };
            flow_counter_bulk_log_granularity as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let alloc_flow_counter_pd: u32 =
                unsafe { ::std::mem::transmute(alloc_flow_counter_pd) };
            alloc_flow_counter_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let flow_counter_access_aso: u32 =
                unsafe { ::std::mem::transmute(flow_counter_access_aso) };
            flow_counter_access_aso as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let query_match_sample_info: u32 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let flow_access_aso_opc_mod: u32 =
                unsafe { ::std::mem::transmute(flow_access_aso_opc_mod) };
            flow_access_aso_opc_mod as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let cross_vhca: u32 = unsafe { ::std::mem::transmute(cross_vhca) };
            cross_vhca as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let lag_rx_port_affinity: u32 = unsafe { ::std::mem::transmute(lag_rx_port_affinity) };
            lag_rx_port_affinity as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wqe_based_flow_table_sup: u32 =
                unsafe { ::std::mem::transmute(wqe_based_flow_table_sup) };
            wqe_based_flow_table_sup as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fdb_unified_en: u32 = unsafe { ::std::mem::transmute(fdb_unified_en) };
            fdb_unified_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let jump_fdb_rx_en: u32 = unsafe { ::std::mem::transmute(jump_fdb_rx_en) };
            jump_fdb_rx_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_conn_track_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_11.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_conn_track_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_11.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_conn_track_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_11),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_conn_track_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_11),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_11(log_max_conn_track_offload: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_max_conn_track_offload: u32 =
                unsafe { ::std::mem::transmute(log_max_conn_track_offload) };
            log_max_conn_track_offload as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_info_query_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_devx_match_sample_info_query_attr {
    #[inline]
    pub fn modify_field_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_modify_field_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_field_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_field_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_data_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_data_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modify_field_id: u32,
        sample_dw_data: u32,
        sample_dw_ok_bit: u32,
        sample_dw_ok_bit_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let modify_field_id: u32 = unsafe { ::std::mem::transmute(modify_field_id) };
            modify_field_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let sample_dw_data: u32 = unsafe { ::std::mem::transmute(sample_dw_data) };
            sample_dw_data as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let sample_dw_ok_bit: u32 = unsafe { ::std::mem::transmute(sample_dw_ok_bit) };
            sample_dw_ok_bit as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let sample_dw_ok_bit_offset: u32 =
                unsafe { ::std::mem::transmute(sample_dw_ok_bit_offset) };
            sample_dw_ok_bit_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub flow_match_sample_field_offset_mask: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_match_sample_field_id: u32,
}
impl mlx5_devx_match_sample_attr {
    #[inline]
    pub fn flow_match_sample_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_offset_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_offset_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_offset_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_offset_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flow_match_sample_en: u32,
        flow_match_sample_field_offset: u32,
        flow_match_sample_offset_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flow_match_sample_en: u32 = unsafe { ::std::mem::transmute(flow_match_sample_en) };
            flow_match_sample_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let flow_match_sample_field_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset) };
            flow_match_sample_field_offset as u64
        });
        __bindgen_bitfield_unit.set(17usize, 4u8, {
            let flow_match_sample_offset_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_offset_mode) };
            flow_match_sample_offset_mode as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_match_sample_field_offset_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_base_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_base_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_base_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_base_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_tunnel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_tunnel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_tunnel_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_tunnel_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        flow_match_sample_field_offset_shift: u32,
        flow_match_sample_field_base_offset: u32,
        flow_match_sample_tunnel_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flow_match_sample_field_offset_shift: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset_shift) };
            flow_match_sample_field_offset_shift as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let flow_match_sample_field_base_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_base_offset) };
            flow_match_sample_field_base_offset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let flow_match_sample_tunnel_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_tunnel_mode) };
            flow_match_sample_tunnel_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_arc_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub parse_graph_node_handle: u32,
}
impl mlx5_devx_graph_arc_attr {
    #[inline]
    pub fn compare_condition_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_compare_condition_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compare_condition_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compare_condition_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn start_inner_tunnel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start_inner_tunnel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn start_inner_tunnel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_start_inner_tunnel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arc_parse_graph_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_arc_parse_graph_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arc_parse_graph_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arc_parse_graph_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare_condition_value: u32,
        start_inner_tunnel: u32,
        arc_parse_graph_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let compare_condition_value: u32 =
                unsafe { ::std::mem::transmute(compare_condition_value) };
            compare_condition_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let start_inner_tunnel: u32 = unsafe { ::std::mem::transmute(start_inner_tunnel) };
            start_inner_tunnel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let arc_parse_graph_node: u32 = unsafe { ::std::mem::transmute(arc_parse_graph_node) };
            arc_parse_graph_node as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_node_attr {
    pub modify_field_select: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub header_length_field_mask: u32,
    pub sample: [mlx5_devx_match_sample_attr; 8usize],
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub in_: [mlx5_devx_graph_arc_attr; 8usize],
    pub out: [mlx5_devx_graph_arc_attr; 8usize],
}
impl mlx5_devx_graph_node_attr {
    #[inline]
    pub fn header_length_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_base_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_base_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_base_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_base_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        header_length_mode: u32,
        header_length_base_value: u32,
        header_length_field_shift: u32,
        header_length_field_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let header_length_mode: u32 = unsafe { ::std::mem::transmute(header_length_mode) };
            header_length_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let header_length_base_value: u32 =
                unsafe { ::std::mem::transmute(header_length_base_value) };
            header_length_base_value as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let header_length_field_shift: u32 =
                unsafe { ::std::mem::transmute(header_length_field_shift) };
            header_length_field_shift as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let header_length_field_offset: u32 =
                unsafe { ::std::mem::transmute(header_length_field_offset) };
            header_length_field_offset as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn next_header_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn next_header_field_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        next_header_field_offset: u32,
        next_header_field_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let next_header_field_offset: u32 =
                unsafe { ::std::mem::transmute(next_header_field_offset) };
            next_header_field_offset as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let next_header_field_size: u32 =
                unsafe { ::std::mem::transmute(next_header_field_size) };
            next_header_field_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_cq {
    pub cq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_cq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_cq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub cqes: *mut mlx5_cqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_sq {
    pub sq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_sq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_sq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub wqes: *mut mlx5_wqe,
    pub aso_wqes: *mut mlx5_aso_wqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_wq_res {
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_rmp {
    pub rmp: *mut mlx5_devx_obj,
    pub ref_cnt: u32,
    pub wq: mlx5_devx_wq_res,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_rq {
    pub rq: *mut mlx5_devx_obj,
    pub rmp: *mut mlx5_devx_rmp,
    pub wq: mlx5_devx_wq_res,
}
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_UNKNOWN: rte_pci_kernel_driver = 0;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_IGB_UIO: rte_pci_kernel_driver = 1;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_VFIO: rte_pci_kernel_driver = 2;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_UIO_GENERIC: rte_pci_kernel_driver = 3;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NIC_UIO: rte_pci_kernel_driver = 4;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NONE: rte_pci_kernel_driver = 5;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NET_UIO: rte_pci_kernel_driver = 6;
pub type rte_pci_kernel_driver = ::std::os::raw::c_uint;
#[doc = " A structure describing a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_device {
    #[doc = "< Next probed PCI device."]
    pub next: rte_pci_device__bindgen_ty_1,
    #[doc = "< Inherit core device"]
    pub device: rte_device,
    #[doc = "< PCI location."]
    pub addr: rte_pci_addr,
    #[doc = "< PCI ID."]
    pub id: rte_pci_id,
    pub mem_resource: [rte_mem_resource; 6usize],
    #[doc = "< Interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = "< PCI driver used in probing"]
    pub driver: *mut rte_pci_driver,
    #[doc = "< sriov enable if not zero"]
    pub max_vfs: u16,
    #[doc = "< Kernel driver passthrough"]
    pub kdrv: rte_pci_kernel_driver,
    #[doc = "< PCI location (ASCII)"]
    pub name: [::std::os::raw::c_char; 18usize],
    #[doc = "< PCI bus specific info"]
    pub bus_info: *mut ::std::os::raw::c_char,
    pub vfio_req_intr_handle: *mut rte_intr_handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_device,
    pub tqe_prev: *mut *mut rte_pci_device,
}
#[doc = " Initialisation function for the driver called during PCI probing."]
pub type rte_pci_probe_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rte_pci_driver,
        arg2: *mut rte_pci_device,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Uninitialisation function for the driver called during hotplugging."]
pub type rte_pci_remove_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_pci_device) -> ::std::os::raw::c_int>;
#[doc = " Driver-specific DMA mapping. After a successful call the device\n will be able to read/write from/to this segment.\n\n @param dev\n   Pointer to the PCI device.\n @param addr\n   Starting virtual address of memory to be mapped.\n @param iova\n   Starting IOVA address of memory to be mapped.\n @param len\n   Length of memory segment being mapped.\n @return\n   - 0 On success.\n   - Negative value and rte_errno is set otherwise."]
pub type pci_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_pci_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Driver-specific DMA un-mapping. After a successful call the device\n will not be able to read/write from/to this segment.\n\n @param dev\n   Pointer to the PCI device.\n @param addr\n   Starting virtual address of memory to be unmapped.\n @param iova\n   Starting IOVA address of memory to be unmapped.\n @param len\n   Length of memory segment being unmapped.\n @return\n   - 0 On success.\n   - Negative value and rte_errno is set otherwise."]
pub type pci_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_pci_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A structure describing a PCI driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_driver {
    #[doc = "< Next in list."]
    pub next: rte_pci_driver__bindgen_ty_1,
    #[doc = "< Inherit core driver."]
    pub driver: rte_driver,
    #[doc = "< Device probe function."]
    pub probe: rte_pci_probe_t,
    #[doc = "< Device remove function."]
    pub remove: rte_pci_remove_t,
    #[doc = "< device dma map function."]
    pub dma_map: pci_dma_map_t,
    #[doc = "< device dma unmap function."]
    pub dma_unmap: pci_dma_unmap_t,
    #[doc = "< ID table, NULL terminated."]
    pub id_table: *const rte_pci_id,
    #[doc = "< Flags RTE_PCI_DRV_*."]
    pub drv_flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_driver,
    pub tqe_prev: *mut *mut rte_pci_driver,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_nl_info {
    pub ifindex: u32,
    pub valid: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_info {
    pub port_num: u32,
    pub ibindex: u32,
    pub ibname: [::std::os::raw::c_char; 65usize],
    pub probe_opt: u8,
    pub port_info: *mut mlx5_port_nl_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_obj {
    pub obj: *mut ::std::os::raw::c_void,
    pub id: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar_data {
    pub db: *mut u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar {
    pub bf_db: mlx5_uar_data,
    pub cq_db: mlx5_uar_data,
    pub obj: *mut ::std::os::raw::c_void,
    pub dbnc: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_dev_config {
    pub hca_attr: mlx5_hca_attr,
    pub dbnc: ::std::os::raw::c_int,
    pub device_fd: ::std::os::raw::c_int,
    pub pd_handle: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_common_dev_config {
    #[inline]
    pub fn devx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_devx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn devx_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_devx_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sys_mem_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sys_mem_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sys_mem_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sys_mem_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn probe_opt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_probe_opt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn probe_opt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_probe_opt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_mempool_reg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_mempool_reg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_mempool_reg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_mempool_reg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_ext_memseg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_ext_memseg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_ext_memseg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_ext_memseg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        devx: ::std::os::raw::c_uint,
        sys_mem_en: ::std::os::raw::c_uint,
        probe_opt: ::std::os::raw::c_uint,
        mr_mempool_reg_en: ::std::os::raw::c_uint,
        mr_ext_memseg_en: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let devx: u32 = unsafe { ::std::mem::transmute(devx) };
            devx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sys_mem_en: u32 = unsafe { ::std::mem::transmute(sys_mem_en) };
            sys_mem_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let probe_opt: u32 = unsafe { ::std::mem::transmute(probe_opt) };
            probe_opt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mr_mempool_reg_en: u32 = unsafe { ::std::mem::transmute(mr_mempool_reg_en) };
            mr_mempool_reg_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mr_ext_memseg_en: u32 = unsafe { ::std::mem::transmute(mr_ext_memseg_en) };
            mr_ext_memseg_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device {
    pub dev: *mut rte_device,
    pub next: mlx5_common_device__bindgen_ty_1,
    pub classes_loaded: u32,
    pub ctx: *mut ::std::os::raw::c_void,
    pub pd: *mut ::std::os::raw::c_void,
    pub dev_info: mlx5_dev_info,
    pub pdn: u32,
    pub mr_scache: mlx5_mr_share_cache,
    pub config: mlx5_common_dev_config,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_common_device,
    pub tqe_prev: *mut *mut mlx5_common_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_wrapped_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub imkey: *mut ::std::os::raw::c_void,
}
#[doc = " Structure of the entry in the mlx5 list, user should define its own struct\n that contains this in order to store the data."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry {
    pub next: mlx5_list_entry__bindgen_ty_1,
    pub ref_cnt: u32,
    pub lcore_idx: u32,
    pub __bindgen_anon_1: mlx5_list_entry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry__bindgen_ty_1 {
    pub le_next: *mut mlx5_list_entry,
    pub le_prev: *mut *mut mlx5_list_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_list_entry__bindgen_ty_2 {
    pub gentry: *mut mlx5_list_entry,
    pub bucket_idx: u32,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache {
    pub h: mlx5_list_cache_mlx5_list_head,
    pub inv_cnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache_mlx5_list_head {
    pub lh_first: *mut mlx5_list_entry,
}
#[doc = " Type of callback function for entry removal.\n\n @param tool_ctx\n   The tool instance user context.\n @param entry\n   The entry in the list."]
pub type mlx5_list_remove_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined matching.\n\n @param tool_ctx\n   The tool instance context.\n @param entry\n   The entry in the list.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   0 if matching, non-zero number otherwise."]
pub type mlx5_list_match_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_list_clone_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
pub type mlx5_list_clone_free_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined mlx5 list entry creation.\n\n @param tool_ctx\n   The mlx5 tool instance context.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   Pointer of entry on success, NULL otherwise."]
pub type mlx5_list_create_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
#[doc = " Linked mlx5 list constant object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_const {
    #[doc = "< Name of the mlx5 list."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub ctx: *mut ::std::os::raw::c_void,
    pub lcores_share: bool,
    pub lcore_lock: rte_spinlock_t,
    #[doc = "< entry create callback."]
    pub cb_create: mlx5_list_create_cb,
    #[doc = "< entry match callback."]
    pub cb_match: mlx5_list_match_cb,
    #[doc = "< entry remove callback."]
    pub cb_remove: mlx5_list_remove_cb,
    #[doc = "< entry clone callback."]
    pub cb_clone: mlx5_list_clone_cb,
    pub cb_clone_free: mlx5_list_clone_free_cb,
}
#[doc = " Linked mlx5 list inconstant data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_inconst {
    pub lock: rte_rwlock_t,
    pub gen_cnt: u32,
    pub count: u32,
    pub cache: [*mut mlx5_list_cache; 130usize],
}
#[doc = " Linked mlx5 list structure.\n\n Entry in mlx5 list could be reused if entry already exists,\n reference count will increase and the existing entry returns.\n\n When destroy an entry from list, decrease reference count and only\n destroy when no further reference.\n\n Linked list is designed for limited number of entries,\n read mostly, less modification.\n\n For huge amount of entries, please consider hash list.\n"]
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_list {
    pub l_const: mlx5_list_const,
    pub l_inconst: mlx5_list_inconst,
}
#[doc = " Hash List"]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hlist_bucket {
    pub l: mlx5_list_inconst,
}
#[doc = " Hash list table structure\n\n The hash list bucket using the mlx5_list object for managing."]
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_hlist {
    pub mask: u32,
    pub flags: u8,
    pub direct_key: bool,
    pub l_const: mlx5_list_const,
    pub __bindgen_padding_0: [u64; 4usize],
    pub buckets: __IncompleteArrayField<mlx5_hlist_bucket>,
}
pub const mlx5_l3t_type_MLX5_L3T_TYPE_WORD: mlx5_l3t_type = 0;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_DWORD: mlx5_l3t_type = 1;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_QWORD: mlx5_l3t_type = 2;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_PTR: mlx5_l3t_type = 3;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_MAX: mlx5_l3t_type = 4;
pub type mlx5_l3t_type = ::std::os::raw::c_uint;
#[repr(C)]
pub struct mlx5_l3t_level_tbl {
    pub ref_cnt: u64,
    pub tbl: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_tbl {
    pub type_: mlx5_l3t_type,
    pub eip: *mut mlx5_indexed_pool,
    pub tbl: *mut mlx5_l3t_level_tbl,
    pub sl: rte_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool_config {
    pub size: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_idx: u32,
    pub per_core_cache: u32,
    pub type_: *const ::std::os::raw::c_char,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            flags: u32,
            size: usize,
            align: ::std::os::raw::c_uint,
            socket: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>,
}
impl mlx5_indexed_pool_config {
    #[inline]
    pub fn trunk_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_trunk_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trunk_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trunk_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_trunk(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_trunk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_trunk_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_trunk_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn need_lock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_lock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn need_lock_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_need_lock_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn release_mem_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_release_mem_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn release_mem_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_release_mem_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        trunk_size: u32,
        grow_trunk: u32,
        grow_shift: u32,
        need_lock: u32,
        release_mem_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let trunk_size: u32 = unsafe { ::std::mem::transmute(trunk_size) };
            trunk_size as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let grow_trunk: u32 = unsafe { ::std::mem::transmute(grow_trunk) };
            grow_trunk as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let grow_shift: u32 = unsafe { ::std::mem::transmute(grow_shift) };
            grow_shift as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let need_lock: u32 = unsafe { ::std::mem::transmute(need_lock) };
            need_lock as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let release_mem_en: u32 = unsafe { ::std::mem::transmute(release_mem_en) };
            release_mem_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_indexed_trunk {
    pub idx: u32,
    pub prev: u32,
    pub next: u32,
    pub free: u32,
    pub bmp: *mut rte_bitmap,
    pub __bindgen_padding_0: [u8; 40usize],
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
pub struct mlx5_indexed_cache {
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub ref_cnt: u32,
    pub len: u32,
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_ipool_per_lcore {
    pub lc: *mut mlx5_indexed_cache,
    #[doc = "< Current cache count."]
    pub len: u32,
    #[doc = "< Cache objects."]
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_indexed_pool {
    pub cfg: mlx5_indexed_pool_config,
    pub rsz_lock: rte_spinlock_t,
    pub lcore_lock: rte_spinlock_t,
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1,
    pub n_entry: u32,
    pub trunk_new: u32,
    pub trunk_avail: u32,
    pub trunk_empty: u32,
    pub trunk_free: u32,
    pub grow_tbl: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_indexed_pool__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1 {
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub free_list: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2 {
    pub gc: *mut mlx5_indexed_cache,
    pub cache: [*mut mlx5_ipool_per_lcore; 129usize],
    pub ibmp: *mut rte_bitmap,
    pub bmp_mem: *mut ::std::os::raw::c_void,
}
pub const rte_pmd_mlx5_flow_engine_mode_RTE_PMD_MLX5_FLOW_ENGINE_MODE_ACTIVE:
    rte_pmd_mlx5_flow_engine_mode = 0;
pub const rte_pmd_mlx5_flow_engine_mode_RTE_PMD_MLX5_FLOW_ENGINE_MODE_STANDBY:
    rte_pmd_mlx5_flow_engine_mode = 1;
pub type rte_pmd_mlx5_flow_engine_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dr_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_hw_port_info {
    pub regc_mask: u32,
    pub regc_value: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl flow_hw_port_info {
    #[inline]
    pub fn is_wire(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_wire(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_wire_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_wire_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_wire: u32, direction: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_wire: u32 = unsafe { ::std::mem::transmute(is_wire) };
            is_wire as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap {
    pub max_cq: ::std::os::raw::c_int,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub max_sge: ::std::os::raw::c_int,
    pub mps: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub ind_table_max_size: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tso_max_payload_sz: u32,
    pub mprq: mlx5_dev_cap__bindgen_ty_1,
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub esw_info: flow_hw_port_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_min_stride_size: u32,
    pub log_max_stride_size: u32,
    pub log_min_stride_num: u32,
    pub log_max_stride_num: u32,
    pub log_min_stride_wqe_size: u32,
}
impl mlx5_dev_cap__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl mlx5_dev_cap {
    #[inline]
    pub fn vf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn txpp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txpp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn txpp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_txpp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_padding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_padding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_padding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_padding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dest_tir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_tir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dest_tir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dest_tir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vf: u32,
        sf: u32,
        txpp_en: u32,
        mpls_en: u32,
        cqe_comp: u32,
        hw_csum: u32,
        hw_padding: u32,
        dest_tir: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        swp: u32,
        hw_vlan_strip: u32,
        scatter_fcs_w_decap_disable: u32,
        hw_fcs_strip: u32,
        rt_timestamp: u32,
        rq_delay_drop_en: u32,
        tunnel_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vf: u32 = unsafe { ::std::mem::transmute(vf) };
            vf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sf: u32 = unsafe { ::std::mem::transmute(sf) };
            sf as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let txpp_en: u32 = unsafe { ::std::mem::transmute(txpp_en) };
            txpp_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpls_en: u32 = unsafe { ::std::mem::transmute(mpls_en) };
            mpls_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cqe_comp: u32 = unsafe { ::std::mem::transmute(cqe_comp) };
            cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hw_csum: u32 = unsafe { ::std::mem::transmute(hw_csum) };
            hw_csum as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hw_padding: u32 = unsafe { ::std::mem::transmute(hw_padding) };
            hw_padding as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dest_tir: u32 = unsafe { ::std::mem::transmute(dest_tir) };
            dest_tir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_vlan_strip: u32 = unsafe { ::std::mem::transmute(hw_vlan_strip) };
            hw_vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rt_timestamp: u32 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rq_delay_drop_en: u32 = unsafe { ::std::mem::transmute(rq_delay_drop_en) };
            rq_delay_drop_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let tunnel_en: u32 = unsafe { ::std::mem::transmute(tunnel_en) };
            tunnel_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(tso: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tso: u32 = unsafe { ::std::mem::transmute(tso) };
            tso as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mlx5_enable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
pub type mlx5_disable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_stat_counter_ctrl {
    pub enable: mlx5_enable_counter_t,
    pub disable: mlx5_disable_counter_t,
    pub enabled: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_ctrl {
    pub dpdk_name: [::std::os::raw::c_char; 64usize],
    pub ctr_name: [::std::os::raw::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ctrl: mlx5_stat_counter_ctrl,
}
impl mlx5_counter_ctrl {
    #[inline]
    pub fn dev(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dev(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dev_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(dev: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dev: u32 = unsafe { ::std::mem::transmute(dev) };
            dev as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_xstats_ctrl {
    pub stats_n: u16,
    pub stats_n_2nd: u16,
    pub mlx5_stats_n: u16,
    pub dev_cnt_start: u16,
    pub dev_table_idx: [u16; 64usize],
    pub xstats_o_idx: [u16; 64usize],
    pub base: [u64; 64usize],
    pub xstats: [u64; 64usize],
    pub hw_stats: [u64; 64usize],
    pub info: [mlx5_counter_ctrl; 64usize],
    pub dev_table_idx_2nd: [u16; 64usize],
    pub xstats_o_idx_2nd: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_stats_ctrl {
    pub imissed_base: u64,
    pub imissed: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub mprq: mlx5_port_config__bindgen_ty_1,
    pub mps: ::std::os::raw::c_int,
    pub max_dump_files_num: ::std::os::raw::c_uint,
    pub log_hp_size: ::std::os::raw::c_uint,
    pub lro_timeout: ::std::os::raw::c_uint,
    pub txqs_inline: ::std::os::raw::c_int,
    pub txq_inline_min: ::std::os::raw::c_int,
    pub txq_inline_max: ::std::os::raw::c_int,
    pub txq_inline_mpw: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_stride_num: ::std::os::raw::c_uint,
    pub log_stride_size: ::std::os::raw::c_uint,
    pub max_memcpy_len: ::std::os::raw::c_uint,
    pub min_rxqs_num: ::std::os::raw::c_uint,
}
impl mlx5_port_config__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl mlx5_port_config {
    #[inline]
    pub fn hw_vlan_insert(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_vlan_insert(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_padding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_padding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_padding_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_padding_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enh_cqe_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enh_cqe_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enh_cqe_comp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enh_cqe_comp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_fmt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_fmt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_fmt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_fmt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_vec_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_vec_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_vec_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_vec_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn std_delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_std_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn std_delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_std_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hp_delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hp_delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hp_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_insert: ::std::os::raw::c_uint,
        hw_padding: ::std::os::raw::c_uint,
        cqe_comp: ::std::os::raw::c_uint,
        enh_cqe_comp: ::std::os::raw::c_uint,
        cqe_comp_fmt: ::std::os::raw::c_uint,
        rx_vec_en: ::std::os::raw::c_uint,
        std_delay_drop: ::std::os::raw::c_uint,
        hp_delay_drop: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_insert: u32 = unsafe { ::std::mem::transmute(hw_vlan_insert) };
            hw_vlan_insert as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_padding: u32 = unsafe { ::std::mem::transmute(hw_padding) };
            hw_padding as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cqe_comp: u32 = unsafe { ::std::mem::transmute(cqe_comp) };
            cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enh_cqe_comp: u32 = unsafe { ::std::mem::transmute(enh_cqe_comp) };
            enh_cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let cqe_comp_fmt: u32 = unsafe { ::std::mem::transmute(cqe_comp_fmt) };
            cqe_comp_fmt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_vec_en: u32 = unsafe { ::std::mem::transmute(rx_vec_en) };
            rx_vec_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let std_delay_drop: u32 = unsafe { ::std::mem::transmute(std_delay_drop) };
            std_delay_drop as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hp_delay_drop: u32 = unsafe { ::std::mem::transmute(hp_delay_drop) };
            hp_delay_drop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config {
    pub tx_pp: ::std::os::raw::c_int,
    pub tx_skew: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: mlx5_sh_config__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config__bindgen_ty_1 {
    pub service_core: u16,
    pub cycle_time: u32,
}
impl mlx5_sh_config {
    #[inline]
    pub fn reclaim_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reclaim_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reclaim_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reclaim_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_xmeta_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dv_xmeta_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_xmeta_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_xmeta_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_miss_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_miss_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_miss_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_miss_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_vxlan_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3_vxlan_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_vxlan_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_vxlan_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vf_nl_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf_nl_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_nl_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_nl_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lacp_by_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lacp_by_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lacp_by_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lacp_by_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decap_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decap_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decap_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decap_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_duplicate_pattern(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_duplicate_pattern(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_duplicate_pattern_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_duplicate_pattern_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reclaim_mode: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        dv_xmeta_en: u32,
        dv_miss_info: u32,
        l3_vxlan_en: u32,
        vf_nl_en: u32,
        lacp_by_user: u32,
        decap_en: u32,
        hw_fcs_strip: u32,
        allow_duplicate_pattern: u32,
        lro_allowed: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reclaim_mode: u32 = unsafe { ::std::mem::transmute(reclaim_mode) };
            reclaim_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let dv_xmeta_en: u32 = unsafe { ::std::mem::transmute(dv_xmeta_en) };
            dv_xmeta_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_miss_info: u32 = unsafe { ::std::mem::transmute(dv_miss_info) };
            dv_miss_info as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l3_vxlan_en: u32 = unsafe { ::std::mem::transmute(l3_vxlan_en) };
            l3_vxlan_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vf_nl_en: u32 = unsafe { ::std::mem::transmute(vf_nl_en) };
            vf_nl_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let lacp_by_user: u32 = unsafe { ::std::mem::transmute(lacp_by_user) };
            lacp_by_user as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let decap_en: u32 = unsafe { ::std::mem::transmute(decap_en) };
            decap_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let allow_duplicate_pattern: u32 =
                unsafe { ::std::mem::transmute(allow_duplicate_pattern) };
            allow_duplicate_pattern as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let lro_allowed: u32 = unsafe { ::std::mem::transmute(lro_allowed) };
            lro_allowed as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn fdb_def_rule(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_def_rule(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_def_rule_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_def_rule_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repr_matching(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repr_matching(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repr_matching_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repr_matching_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        fdb_def_rule: u32,
        repr_matching: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fdb_def_rule: u32 = unsafe { ::std::mem::transmute(fdb_def_rule) };
            fdb_def_rule as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let repr_matching: u32 = unsafe { ::std::mem::transmute(repr_matching) };
            repr_matching as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_drop {
    pub hrxq: *mut mlx5_hrxq,
    pub rxq: *mut mlx5_rxq_priv,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lb_ctx {
    pub qp: *mut ibv_qp,
    pub ibv_cq: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_external_q {
    pub hw_id: u32,
    pub refcnt: u32,
}
#[doc = " Container for flow action data constructed during flow rule creation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_action_params {
    #[doc = " Array of constructed modify header commands."]
    pub mhdr_cmd: [mlx5_modification_cmd; 65usize],
    #[doc = " Constructed encap/decap data buffer."]
    pub encap_data: [u8; 132usize],
    #[doc = " Constructed IPv6 routing data buffer."]
    pub ipv6_push_data: [u8; 128usize],
}
#[doc = " Container for dynamically generated flow items used during flow rule creation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_pattern_params {
    #[doc = " Array of dynamically generated flow items."]
    pub items: [rte_flow_item; 16usize],
    #[doc = " Temporary REPRESENTED_PORT item generated by PMD."]
    pub port_spec: rte_flow_item_ethdev,
    #[doc = " Temporary TAG item generated by PMD."]
    pub tag_spec: rte_flow_item_tag,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q_job {
    pub type_: u32,
    pub indirect_type: u32,
    pub action: *const ::std::os::raw::c_void,
    pub user_data: *mut ::std::os::raw::c_void,
    pub query: mlx5_hw_q_job__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q_job__bindgen_ty_1 {
    pub user: *mut ::std::os::raw::c_void,
    pub hw: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q {
    pub job_idx: u32,
    pub size: u32,
    pub ongoing_flow_ops: u32,
    pub job: *mut *mut mlx5_hw_q_job,
    pub indir_cq: *mut rte_ring,
    pub indir_iq: *mut rte_ring,
    pub flow_transfer_pending: *mut rte_ring,
    pub flow_transfer_completed: *mut rte_ring,
    pub ap: mlx5_flow_hw_action_params,
    pub pp: mlx5_flow_hw_pattern_params,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_param {
    #[doc = "< Age state (atomically accessed)."]
    pub state: u16,
    #[doc = "< Port id of the counter."]
    pub port_id: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub sec_since_last_hit: u32,
    #[doc = "< Flow counter age context."]
    pub context: *mut ::std::os::raw::c_void,
}
impl mlx5_age_param {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_counter_stats {
    pub hits: u64,
    pub bytes: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_shared {
    pub __bindgen_anon_1: mlx5_flow_counter_shared__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter_shared__bindgen_ty_1 {
    pub refcnt: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter {
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_flow_counter__bindgen_ty_2,
    pub __bindgen_anon_3: mlx5_flow_counter__bindgen_ty_3,
    #[doc = "< Pointer to the dv action."]
    pub action: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_1 {
    pub next: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter,
    pub tqe_prev: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2 {
    pub shared_info: mlx5_flow_counter_shared,
    pub dcs_when_active: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_2 {
    #[doc = "< Reset value of hits packets."]
    pub hits: u64,
    #[doc = "< Counter pool."]
    pub pool: *mut mlx5_flow_counter_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_3 {
    #[doc = "< Reset value of bytes."]
    pub bytes: u64,
    pub dcs_when_free: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counters {
    pub tqh_first: *mut mlx5_flow_counter,
    pub tqh_last: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool {
    pub next: mlx5_flow_counter_pool__bindgen_ty_1,
    pub counters: [mlx5_counters; 2usize],
    pub min_dcs: *mut mlx5_devx_obj,
    pub time_of_last_age_check: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sl: rte_spinlock_t,
    pub csl: rte_spinlock_t,
    pub raw: *mut mlx5_counter_stats_raw,
    pub raw_hw: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter_pool,
    pub tqe_prev: *mut *mut mlx5_flow_counter_pool,
}
impl mlx5_flow_counter_pool {
    #[inline]
    pub fn index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_aged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_aged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_gen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_gen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_gen_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_gen_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        index: u32,
        is_aged: u32,
        query_gen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let index: u32 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_aged: u32 = unsafe { ::std::mem::transmute(is_aged) };
            is_aged as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let query_gen: u32 = unsafe { ::std::mem::transmute(query_gen) };
            query_gen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng {
    pub next: mlx5_counter_stats_mem_mng__bindgen_ty_1,
    pub raws: *mut mlx5_counter_stats_raw,
    pub wm: mlx5_pmd_wrapped_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_mem_mng,
    pub le_prev: *mut *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw {
    pub next: mlx5_counter_stats_raw__bindgen_ty_1,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub data: *mut flow_counter_stats,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_raw,
    pub le_prev: *mut *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng {
    pub n_valid: u16,
    pub last_pool_idx: u16,
    pub min_id: ::std::os::raw::c_int,
    pub max_id: ::std::os::raw::c_int,
    pub pool_update_sl: rte_spinlock_t,
    pub csl: [rte_spinlock_t; 2usize],
    pub counters: [mlx5_counters; 2usize],
    pub pools: *mut *mut mlx5_flow_counter_pool,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub flow_counters: mlx5_counters,
    pub pending_queries: u8,
    pub pool_index: u16,
    pub query_thread_on: u8,
    pub counter_fallback: bool,
    pub mem_mngs: mlx5_flow_counter_mng_mem_mngs,
    pub free_stat_raws: mlx5_flow_counter_mng_stat_raws,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_mem_mngs {
    pub lh_first: *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_stat_raws {
    pub lh_first: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cq {
    pub log_desc_n: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub cq_obj: mlx5_devx_cq,
    pub errors: u64,
}
impl mlx5_aso_cq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_sq_elem__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1,
    pub mtr: *mut mlx5_aso_mtr,
    pub __bindgen_anon_2: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2,
    pub user_data: *mut ::std::os::raw::c_void,
    pub quota_obj: *mut mlx5_quota,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1 {
    pub pool: *mut mlx5_aso_age_pool,
    pub burst_size: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2 {
    pub ct: *mut mlx5_aso_ct_action,
    pub query_data: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq {
    pub log_desc_n: u16,
    pub sqsl: rte_spinlock_t,
    pub cq: mlx5_aso_cq,
    pub sq_obj: mlx5_devx_sq,
    pub mr: mlx5_pmd_mr,
    pub db: *mut mlx5_aso_wqe,
    pub pi: u16,
    pub db_pi: u16,
    pub head: u32,
    pub tail: u32,
    pub sqn: u32,
    pub elts: [mlx5_aso_sq_elem; 1024usize],
    pub next: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action {
    pub next: mlx5_aso_age_action__bindgen_ty_1,
    pub dr_action: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u16,
    pub age_params: mlx5_age_param,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_age_action,
    pub le_prev: *mut *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_pool {
    pub flow_hit_aso_obj: *mut mlx5_devx_obj,
    pub index: u16,
    pub time_of_last_age_check: u64,
    pub actions: [mlx5_aso_age_action; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_age_list {
    pub lh_first: *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_mng {
    pub pools: *mut *mut mlx5_aso_age_pool,
    pub n: u16,
    pub next: u16,
    pub resize_rwl: rte_rwlock_t,
    pub free_sl: rte_spinlock_t,
    pub free: aso_age_list,
    pub aso_sq: mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_option_resource {
    pub obj: *mut mlx5_devx_obj,
    pub option_class: rte_be16_t,
    pub option_type: u8,
    pub length: u8,
    pub refcnt: u32,
}
#[repr(C)]
pub struct mlx5_hws_q_age_info {
    pub nb_rings: u16,
    pub aged_lists: __IncompleteArrayField<*mut rte_ring>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_age_info {
    pub aged_list: *mut rte_ring,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info {
    pub flags: u8,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_age_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_1 {
    pub aged_counters: mlx5_counters,
    pub aged_aso: aso_age_list,
    pub aged_sl: rte_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_2 {
    pub ages_ipool: *mut mlx5_indexed_pool,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub hw_age: mlx5_hws_age_info,
    pub hw_q_age: *mut mlx5_hws_q_age_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_shared_port {
    pub ih_port_id: u32,
    pub devx_ih_port_id: u32,
    pub nl_ih_port_id: u32,
    pub age_info: mlx5_age_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule {
    pub rule: *mut ::std::os::raw::c_void,
    pub matcher: *mut mlx5_flow_dv_matcher,
    pub next_port: mlx5_sub_policy_color_rule__bindgen_ty_1,
    pub src_port: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_sub_policy_color_rule,
    pub tqe_prev: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rules {
    pub tqh_first: *mut mlx5_sub_policy_color_rule,
    pub tqh_last: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_sub_policy {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub main_policy: *mut ::std::os::raw::c_void,
    pub tbl_rsc: *mut mlx5_flow_tbl_resource,
    pub rix_hrxq: [u32; 2usize],
    pub jump_tbl: [*mut mlx5_flow_tbl_resource; 2usize],
    pub color_rules: [mlx5_sub_policy_color_rules; 3usize],
}
impl mlx5_flow_meter_sub_policy {
    #[inline]
    pub fn main_policy_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_policy_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn main_policy_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_main_policy_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_idx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(main_policy_id: u32, idx: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let main_policy_id: u32 = unsafe { ::std::mem::transmute(main_policy_id) };
            main_policy_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let idx: u32 = unsafe { ::std::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_meter_policy_action_container {
    pub rix_mark: u32,
    pub modify_hdr: *mut mlx5_flow_dv_modify_hdr_resource,
    pub fate_action: u8,
    pub __bindgen_anon_1: mlx5_meter_policy_action_container__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_meter_policy_action_container__bindgen_ty_1 {
    pub rss: *mut rte_flow_action,
    pub rix_port_id_action: u32,
    pub dr_jump_action: [*mut ::std::os::raw::c_void; 3usize],
    pub queue: u16,
    pub __bindgen_anon_1: mlx5_meter_policy_action_container__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_meter_policy_action_container__bindgen_ty_1__bindgen_ty_1 {
    pub next_mtr_id: u32,
    pub next_sub_policy: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_policy {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub group: u16,
    pub sl: rte_spinlock_t,
    pub ref_cnt: u32,
    pub hws_item_templ: *mut rte_flow_pattern_template,
    pub hws_act_templ: [*mut rte_flow_actions_template; 3usize],
    pub hws_flow_table: [*mut rte_flow_template_table; 3usize],
    pub hws_flow_rule: [[*mut rte_flow; 3usize]; 3usize],
    pub act_cnt: [mlx5_meter_policy_action_container; 2usize],
    pub dr_drop_action: [*mut ::std::os::raw::c_void; 3usize],
    pub sub_policy_num: u16,
    pub sub_policys: [*mut *mut mlx5_flow_meter_sub_policy; 3usize],
}
impl mlx5_flow_meter_policy {
    #[inline]
    pub fn is_rss(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_rss(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_rss_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_rss_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_queue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_queue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_queue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_queue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hierarchy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hierarchy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hierarchy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hierarchy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn match_port(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_match_port(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn match_port_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_match_port_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchy_match_port(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchy_match_port(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchy_match_port_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchy_match_port_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_r(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_r(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_r_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_r_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_y_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_y_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_g(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_g_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_g_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_rss: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
        is_queue: u32,
        is_hierarchy: u32,
        match_port: u32,
        hierarchy_match_port: u32,
        skip_r: u32,
        skip_y: u32,
        skip_g: u32,
        mark: u32,
        initialized: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_rss: u32 = unsafe { ::std::mem::transmute(is_rss) };
            is_rss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_queue: u32 = unsafe { ::std::mem::transmute(is_queue) };
            is_queue as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_hierarchy: u32 = unsafe { ::std::mem::transmute(is_hierarchy) };
            is_hierarchy as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let match_port: u32 = unsafe { ::std::mem::transmute(match_port) };
            match_port as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hierarchy_match_port: u32 = unsafe { ::std::mem::transmute(hierarchy_match_port) };
            hierarchy_match_port as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skip_r: u32 = unsafe { ::std::mem::transmute(skip_r) };
            skip_r as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let skip_y: u32 = unsafe { ::std::mem::transmute(skip_y) };
            skip_y as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let skip_g: u32 = unsafe { ::std::mem::transmute(skip_g) };
            skip_g as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mark: u32 = unsafe { ::std::mem::transmute(mark) };
            mark as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_def_policy {
    pub sub_policy: mlx5_flow_meter_sub_policy,
    pub dr_jump_action: [*mut ::std::os::raw::c_void; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_info {
    pub meter_id: u32,
    pub policy_id: u32,
    pub profile: *mut mlx5_flow_meter_profile,
    #[doc = "< Meter action spinlock."]
    pub sl: rte_spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub drop_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub drop_cnt: u32,
    pub ref_cnt: u32,
    pub flow_ipool: *mut mlx5_indexed_pool,
    pub meter_action_g: *mut ::std::os::raw::c_void,
    pub meter_action_y: *mut ::std::os::raw::c_void,
    pub meter_offset: u32,
    pub group: u16,
}
impl mlx5_flow_meter_info {
    #[inline]
    pub fn bytes_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkts_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkts_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkts_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkts_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_active_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn def_policy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_def_policy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn def_policy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_def_policy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color_aware(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_aware(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_aware_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_color_aware_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bytes_dropped: u32,
        pkts_dropped: u32,
        active_state: u32,
        shared: u32,
        is_enable: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
        def_policy: u32,
        initialized: u32,
        color_aware: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bytes_dropped: u32 = unsafe { ::std::mem::transmute(bytes_dropped) };
            bytes_dropped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pkts_dropped: u32 = unsafe { ::std::mem::transmute(pkts_dropped) };
            pkts_dropped as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let active_state: u32 = unsafe { ::std::mem::transmute(active_state) };
            active_state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_enable: u32 = unsafe { ::std::mem::transmute(is_enable) };
            is_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let def_policy: u32 = unsafe { ::std::mem::transmute(def_policy) };
            def_policy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let color_aware: u32 = unsafe { ::std::mem::transmute(color_aware) };
            color_aware as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_srtcm_rfc2697_prm {
    pub cbs_cir: rte_be32_t,
    pub ebs_eir: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile {
    pub next: mlx5_flow_meter_profile__bindgen_ty_1,
    #[doc = "< Profile id."]
    pub id: u32,
    #[doc = "< Profile detail."]
    pub profile: rte_mtr_meter_profile,
    pub __bindgen_anon_1: mlx5_flow_meter_profile__bindgen_ty_2,
    #[doc = "< Use count."]
    pub ref_cnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_meter_profile,
    pub tqe_prev: *mut *mut mlx5_flow_meter_profile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_meter_profile__bindgen_ty_2 {
    pub srtcm_prm: mlx5_flow_meter_srtcm_rfc2697_prm,
}
impl mlx5_flow_meter_profile {
    #[inline]
    pub fn g_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_g_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn g_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_g_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn y_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_y_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn y_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_y_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        g_support: u32,
        y_support: u32,
        initialized: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let g_support: u32 = unsafe { ::std::mem::transmute(g_support) };
            g_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_support: u32 = unsafe { ::std::mem::transmute(y_support) };
            y_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mlx5_aso_mtr_type_ASO_METER_INDIRECT: mlx5_aso_mtr_type = 0;
pub const mlx5_aso_mtr_type_ASO_METER_DIRECT: mlx5_aso_mtr_type = 1;
pub type mlx5_aso_mtr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr {
    pub __bindgen_anon_1: mlx5_aso_mtr__bindgen_ty_1,
    pub type_: mlx5_aso_mtr_type,
    pub fm: mlx5_flow_meter_info,
    #[doc = "< ASO flow meter state."]
    pub state: u8,
    pub offset: u32,
    pub init_color: rte_color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_mtr__bindgen_ty_1 {
    pub next: mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1,
    pub pool: *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_mtr,
    pub le_prev: *mut *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pool {
    pub mtrs: [mlx5_aso_mtr; 128usize],
    pub devx_obj: *mut mlx5_devx_obj,
    pub action: *mut mlx5dr_action,
    pub idx_pool: *mut mlx5_indexed_pool,
    pub index: u32,
    pub nb_sq: u32,
    pub sq: *mut mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_meter_list {
    pub lh_first: *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pools_mng {
    pub n_valid: u16,
    pub n: u16,
    pub mtrsl: rte_spinlock_t,
    pub resize_mtrwl: rte_rwlock_t,
    pub meters: aso_meter_list,
    pub sq: mlx5_aso_sq,
    pub pools: *mut *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mtr_bulk {
    pub size: u32,
    pub action: *mut mlx5dr_action,
    pub devx_obj: *mut mlx5_devx_obj,
    pub aso: *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_mtr_mng {
    pub pools_mng: mlx5_aso_mtr_pools_mng,
    pub def_policy: [*mut mlx5_flow_meter_def_policy; 3usize],
    pub def_policy_id: u32,
    pub def_policy_ref_cnt: u32,
    #[doc = " def_policy meter use count."]
    pub drop_tbl: [*mut mlx5_flow_tbl_resource; 3usize],
    pub drop_matcher: [[*mut mlx5_flow_dv_matcher; 32usize]; 3usize],
    pub def_matcher: [*mut mlx5_flow_dv_matcher; 3usize],
    pub def_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub max_mtr_bits: u8,
    pub max_mtr_flow_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tbl_resource {
    #[doc = "< Pointer to DR table object."]
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_wq {
    pub cq_obj: mlx5_devx_cq,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sq_obj: mlx5_devx_sq,
    pub sq_size: u16,
    pub sq_ci: u16,
}
impl mlx5_txpp_wq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arm_sn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arm_sn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arm_sn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arm_sn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32, arm_sn: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let arm_sn: u32 = unsafe { ::std::mem::transmute(arm_sn) };
            arm_sn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_ts {
    pub ci_ts: u64,
    pub ts: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_txpp {
    pub mutex: pthread_mutex_t,
    pub refcnt: u32,
    pub freq: u32,
    pub tick: u32,
    pub test: u32,
    pub skew: i32,
    pub intr_handle: *mut rte_intr_handle,
    pub echan: *mut ::std::os::raw::c_void,
    pub clock_queue: mlx5_txpp_wq,
    pub rearm_queue: mlx5_txpp_wq,
    pub pp: *mut ::std::os::raw::c_void,
    pub pp_id: u16,
    pub ts_n: u16,
    pub ts_p: u16,
    pub tsa: *mut mlx5_txpp_ts,
    pub ts: mlx5_txpp_ts,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub err_miss_int: u64,
    pub err_rearm_queue: u64,
    pub err_clock_queue: u64,
    pub err_ts_past: u64,
    pub err_ts_future: u64,
    pub err_ts_order: u64,
}
impl mlx5_dev_txpp {
    #[inline]
    pub fn sync_lost(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync_lost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sync_lost_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sync_lost_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sync_lost: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sync_lost: u32 = unsafe { ::std::mem::transmute(sync_lost) };
            sync_lost as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ecpri_parser_profile {
    pub num: u32,
    pub ids: [u32; 8usize],
    pub offset: [u8; 8usize],
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info {
    pub n_port: ::std::os::raw::c_int,
    pub ifindex: u32,
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ports: [mlx5_bond_info__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info__bindgen_ty_1 {
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ifindex: u32,
    pub pci_addr: rte_pci_addr,
}
pub const mlx5_aso_ct_state_ASO_CONNTRACK_FREE: mlx5_aso_ct_state = 0;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT: mlx5_aso_ct_state = 1;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT_ASYNC: mlx5_aso_ct_state = 2;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_READY: mlx5_aso_ct_state = 3;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_QUERY: mlx5_aso_ct_state = 4;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_MAX: mlx5_aso_ct_state = 5;
pub type mlx5_aso_ct_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1,
    pub dr_action_orig: *mut ::std::os::raw::c_void,
    pub dr_action_rply: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u32,
    pub peer: u16,
    pub state: mlx5_aso_ct_state,
    pub is_original: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_action__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1 {
    pub next: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_ct_action,
    pub le_prev: *mut *mut mlx5_aso_ct_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2 {
    pub pool: *mut mlx5_aso_ct_pool,
}
#[repr(C)]
pub struct mlx5_aso_ct_pool {
    pub index: u16,
    pub cts: *mut mlx5_indexed_pool,
    pub devx_obj: *mut mlx5_devx_obj,
    pub __bindgen_anon_1: mlx5_aso_ct_pool__bindgen_ty_1,
    pub sq: *mut mlx5_aso_sq,
    pub shared_sq: *mut mlx5_aso_sq,
    pub actions: __IncompleteArrayField<mlx5_aso_ct_action>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_pool__bindgen_ty_1 {
    pub dummy_action: *mut ::std::os::raw::c_void,
    pub dr_action: *mut mlx5dr_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_ct_list {
    pub lh_first: *mut mlx5_aso_ct_action,
}
#[repr(C)]
pub struct mlx5_aso_ct_pools_mng {
    pub pools: *mut *mut mlx5_aso_ct_pool,
    pub n: u16,
    pub next: u16,
    pub nb_sq: u32,
    pub ct_sl: rte_spinlock_t,
    pub resize_rwl: rte_rwlock_t,
    pub free_cts: aso_ct_list,
    pub aso_sqs: __IncompleteArrayField<mlx5_aso_sq>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lag {
    pub tx_remap_affinity: [u8; 16usize],
    pub affinity_mode: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_parser_devx {
    pub entry: mlx5_list_entry,
    pub num_samples: u32,
    pub anchor_id: u8,
    pub devx_obj: *mut ::std::os::raw::c_void,
    pub devx_conf: mlx5_devx_graph_node_attr,
    pub sample_ids: [u32; 8usize],
    pub sample_info: [mlx5_devx_match_sample_info_query_attr; 8usize],
}
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct mlx5_flex_pattern_field {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl mlx5_flex_pattern_field {
    #[inline]
    pub fn width(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn width_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_width_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shift_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_shift_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_id(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_reg_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_id_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reg_id_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        width: u16,
        shift: u16,
        reg_id: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let width: u16 = unsafe { ::std::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let shift: u16 = unsafe { ::std::mem::transmute(shift) };
            shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let reg_id: u16 = unsafe { ::std::mem::transmute(reg_id) };
            reg_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_item {
    pub devx_fp: *mut mlx5_flex_parser_devx,
    pub refcnt: u32,
    pub tunnel_mode: rte_flow_item_flex_tunnel_mode,
    pub mapnum: u32,
    pub map: [mlx5_flex_pattern_field; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_internal_flex_parser_profile {
    pub refcnt: u32,
    pub flex: mlx5_flex_item,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_send_to_kernel_action {
    pub action: *mut ::std::os::raw::c_void,
    pub tbl: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_aso_mng {
    pub sq_num: u16,
    pub sqs: [mlx5_aso_sq; 4usize],
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_svc_mng {
    pub refcnt: u32,
    pub service_core: u32,
    pub query_interval: u32,
    pub service_thread: rte_thread_t,
    pub svc_running: u8,
    pub __bindgen_padding_0: [u64; 4usize],
    pub aso_mng: mlx5_hws_aso_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_registers {
    pub aso_reg: modify_reg,
    pub hw_avl_tags: [modify_reg; 12usize],
    pub nat64_regs: [modify_reg; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_options {
    _unused: [u8; 0],
}
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_UNKNOWN: mlx5_ipv6_tc_support = 0;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_FALLBACK: mlx5_ipv6_tc_support = 1;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_OK: mlx5_ipv6_tc_support = 2;
pub type mlx5_ipv6_tc_support = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_nic_config {
    pub ipv6_tc_fallback: mlx5_ipv6_tc_support,
}
#[doc = " Physical device structure.\n This device is created once per NIC to manage recourses shared by all ports\n under same physical device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device {
    pub next: mlx5_physical_device__bindgen_ty_1,
    pub ctx: *mut ::std::os::raw::c_void,
    pub guid: u64,
    pub tlv_options: *mut mlx5_geneve_tlv_options,
    pub config: mlx5_common_nic_config,
    pub refcnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device__bindgen_ty_1 {
    pub le_next: *mut mlx5_physical_device,
    pub le_prev: *mut *mut mlx5_physical_device,
}
#[repr(C)]
pub struct mlx5_dev_ctx_shared {
    pub next: mlx5_dev_ctx_shared__bindgen_ty_1,
    pub refcnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hws_max_nb_counters: u32,
    pub max_port: u32,
    pub bond: mlx5_bond_info,
    pub cdev: *mut mlx5_common_device,
    pub phdev: *mut mlx5_physical_device,
    pub tdn: u32,
    pub ibdev_name: [::std::os::raw::c_char; 65usize],
    pub ibdev_path: [::std::os::raw::c_char; 257usize],
    pub dev_cap: mlx5_dev_cap,
    pub config: mlx5_sh_config,
    pub numa_node: ::std::os::raw::c_int,
    pub txpp: mlx5_dev_txpp,
    pub dv_meta_mask: u32,
    pub dv_mark_mask: u32,
    pub dv_regc0_mask: u32,
    pub fdb_domain: *mut ::std::os::raw::c_void,
    pub rx_domain: *mut ::std::os::raw::c_void,
    pub tx_domain: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_dev_ctx_shared__bindgen_ty_2,
    pub mreg_cp_tbl: *mut mlx5_hlist,
    pub tunnel_hub: *mut mlx5_flow_tunnel_hub,
    pub dr_drop_action: *mut ::std::os::raw::c_void,
    pub pop_vlan_action: *mut ::std::os::raw::c_void,
    pub send_to_kernel_action: [mlx5_send_to_kernel_action; 6usize],
    pub encaps_decaps: *mut mlx5_hlist,
    pub modify_cmds: *mut mlx5_hlist,
    pub tag_table: *mut mlx5_hlist,
    pub port_id_action_list: *mut mlx5_list,
    pub push_vlan_action_list: *mut mlx5_list,
    pub sample_action_list: *mut mlx5_list,
    pub dest_array_list: *mut mlx5_list,
    pub flex_parsers_dv: *mut mlx5_list,
    pub sws_cmng: mlx5_flow_counter_mng,
    pub default_miss_action: *mut ::std::os::raw::c_void,
    pub ipool: [*mut mlx5_indexed_pool; 17usize],
    pub mdh_ipools: [*mut mlx5_indexed_pool; 32usize],
    pub intr_handle: *mut rte_intr_handle,
    pub intr_handle_devx: *mut rte_intr_handle,
    pub intr_handle_nl: *mut rte_intr_handle,
    pub intr_handle_ib: *mut rte_intr_handle,
    pub devx_comp: *mut ::std::os::raw::c_void,
    pub tis: [*mut mlx5_devx_obj; 16usize],
    pub td: *mut mlx5_devx_obj,
    pub lag: mlx5_lag,
    pub tx_uar: mlx5_uar,
    pub rx_uar: mlx5_uar,
    pub pppriv: *mut mlx5_proc_priv,
    pub ecpri_parser: mlx5_ecpri_parser_profile,
    pub srh_flex_parser: mlx5_internal_flex_parser_profile,
    pub shared_rxqs: mlx5_dev_ctx_shared_shared_rxqs,
    pub aso_age_mng: *mut mlx5_aso_age_mng,
    pub geneve_tlv_option_resource: *mut mlx5_geneve_tlv_option_resource,
    pub geneve_tlv_opt_sl: rte_spinlock_t,
    pub mtrmng: *mut mlx5_flow_mtr_mng,
    pub ct_mng: *mut mlx5_aso_ct_pools_mng,
    pub self_lb: mlx5_lb_ctx,
    pub flow_max_priority: ::std::os::raw::c_uint,
    pub flow_mreg_c: [modify_reg; 8usize],
    pub devx_channel_lwm: *mut ::std::os::raw::c_void,
    pub intr_handle_lwm: *mut rte_intr_handle,
    pub lwm_config_lock: pthread_mutex_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: *mut mlx5_hws_cnt_svc_mng,
    pub cpool_lock: rte_spinlock_t,
    pub hws_cpool_list: mlx5_dev_ctx_shared_hws_cpool_list,
    pub registers: mlx5_dev_registers,
    pub port: __IncompleteArrayField<mlx5_dev_shared_port>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared__bindgen_ty_1 {
    pub le_next: *mut mlx5_dev_ctx_shared,
    pub le_prev: *mut *mut mlx5_dev_ctx_shared,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_dev_ctx_shared__bindgen_ty_2 {
    pub flow_tbls: *mut mlx5_hlist,
    pub groups: *mut mlx5_hlist,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_shared_rxqs {
    pub lh_first: *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_hws_cpool_list {
    pub lh_first: *mut mlx5_hws_cnt_pool,
}
impl mlx5_dev_ctx_shared {
    #[inline]
    pub fn esw_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn meter_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meter_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn meter_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_meter_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_0_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_0_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_0_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_0_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_2_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_2_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_2_3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_2_3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn misc5_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_misc5_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn misc5_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_misc5_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dr_root_drop_action_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dr_root_drop_action_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dr_root_drop_action_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dr_root_drop_action_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn drop_action_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drop_action_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn drop_action_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_drop_action_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_priority_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_priority_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_priority_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_priority_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn metadata_regc_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_regc_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn metadata_regc_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_metadata_regc_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared_mark_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared_mark_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_mark_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_mark_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hws_max_log_bulk_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hws_max_log_bulk_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_max_log_bulk_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_max_log_bulk_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rdma_monitor_supp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdma_monitor_supp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rdma_monitor_supp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rdma_monitor_supp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        esw_mode: u32,
        flow_hit_aso_en: u32,
        steering_format_version: u32,
        meter_aso_en: u32,
        ct_aso_en: u32,
        tunnel_header_0_1: u32,
        tunnel_header_2_3: u32,
        misc5_cap: u32,
        dr_root_drop_action_en: u32,
        drop_action_check_flag: u32,
        flow_priority_check_flag: u32,
        metadata_regc_check_flag: u32,
        shared_mark_enabled: u32,
        lag_rx_port_affinity_en: u32,
        hws_max_log_bulk_sz: u32,
        rdma_monitor_supp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let esw_mode: u32 = unsafe { ::std::mem::transmute(esw_mode) };
            esw_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso_en: u32 = unsafe { ::std::mem::transmute(flow_hit_aso_en) };
            flow_hit_aso_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let meter_aso_en: u32 = unsafe { ::std::mem::transmute(meter_aso_en) };
            meter_aso_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ct_aso_en: u32 = unsafe { ::std::mem::transmute(ct_aso_en) };
            ct_aso_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tunnel_header_0_1: u32 = unsafe { ::std::mem::transmute(tunnel_header_0_1) };
            tunnel_header_0_1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tunnel_header_2_3: u32 = unsafe { ::std::mem::transmute(tunnel_header_2_3) };
            tunnel_header_2_3 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let misc5_cap: u32 = unsafe { ::std::mem::transmute(misc5_cap) };
            misc5_cap as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dr_root_drop_action_en: u32 =
                unsafe { ::std::mem::transmute(dr_root_drop_action_en) };
            dr_root_drop_action_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let drop_action_check_flag: u32 =
                unsafe { ::std::mem::transmute(drop_action_check_flag) };
            drop_action_check_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let flow_priority_check_flag: u32 =
                unsafe { ::std::mem::transmute(flow_priority_check_flag) };
            flow_priority_check_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let metadata_regc_check_flag: u32 =
                unsafe { ::std::mem::transmute(metadata_regc_check_flag) };
            metadata_regc_check_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let shared_mark_enabled: u32 = unsafe { ::std::mem::transmute(shared_mark_enabled) };
            shared_mark_enabled as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let lag_rx_port_affinity_en: u32 =
                unsafe { ::std::mem::transmute(lag_rx_port_affinity_en) };
            lag_rx_port_affinity_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let hws_max_log_bulk_sz: u32 = unsafe { ::std::mem::transmute(hws_max_log_bulk_sz) };
            hws_max_log_bulk_sz as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rdma_monitor_supp: u32 = unsafe { ::std::mem::transmute(rdma_monitor_supp) };
            rdma_monitor_supp as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn host_shaper_rate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_host_shaper_rate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn host_shaper_rate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_host_shaper_rate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_triggered(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_triggered(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_triggered_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_triggered_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        host_shaper_rate: u32,
        lwm_triggered: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let host_shaper_rate: u32 = unsafe { ::std::mem::transmute(host_shaper_rate) };
            host_shaper_rate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let lwm_triggered: u32 = unsafe { ::std::mem::transmute(lwm_triggered) };
            lwm_triggered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct mlx5_proc_priv {
    pub hca_bar: *mut ::std::os::raw::c_void,
    pub uar_table_sz: usize,
    pub uar_table: __IncompleteArrayField<mlx5_uar_data>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_legacy_flow_meters {
    pub tqh_first: *mut mlx5_legacy_flow_meter,
    pub tqh_last: *mut *mut mlx5_legacy_flow_meter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mtr_config {
    #[doc = "< Number of configured meters"]
    pub nb_meters: u32,
    #[doc = "< Number of configured meter profiles"]
    pub nb_meter_profiles: u32,
    #[doc = "< Number of configured meter policies"]
    pub nb_meter_policies: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj {
    pub next: mlx5_rxq_obj__bindgen_ty_1,
    pub rxq_ctrl: *mut mlx5_rxq_ctrl,
    pub fd: ::std::os::raw::c_int,
    pub __bindgen_anon_1: mlx5_rxq_obj__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_obj,
    pub le_prev: *mut *mut mlx5_rxq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_rxq_obj__bindgen_ty_2 {
    pub __bindgen_anon_1: mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_1,
    pub rq: *mut mlx5_devx_obj,
    pub __bindgen_anon_2: mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_1 {
    pub wq: *mut ::std::os::raw::c_void,
    pub ibv_cq: *mut ::std::os::raw::c_void,
    pub ibv_channel: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_2 {
    pub devx_rmp: mlx5_devx_rmp,
    pub cq_obj: mlx5_devx_cq,
    pub devx_channel: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ind_table_obj {
    pub next: mlx5_ind_table_obj__bindgen_ty_1,
    pub refcnt: u32,
    pub __bindgen_anon_1: mlx5_ind_table_obj__bindgen_ty_2,
    #[doc = "< Number of queues in the list."]
    pub queues_n: u32,
    #[doc = "< Queue list."]
    pub queues: *mut u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ind_table_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_ind_table_obj,
    pub le_prev: *mut *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ind_table_obj__bindgen_ty_2 {
    #[doc = "< Indirection table."]
    pub ind_table: *mut ::std::os::raw::c_void,
    pub rqt: *mut mlx5_devx_obj,
}
#[repr(C)]
pub struct mlx5_hrxq {
    pub entry: mlx5_list_entry,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ind_table: *mut mlx5_ind_table_obj,
    pub __bindgen_anon_1: mlx5_hrxq__bindgen_ty_1,
    pub action: *mut ::std::os::raw::c_void,
    pub symmetric_hash_function: bool,
    pub hws_flags: u32,
    pub hash_fields: u64,
    pub rss_key_len: u32,
    pub idx: u32,
    pub rss_key: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_hrxq__bindgen_ty_1 {
    pub qp: *mut ::std::os::raw::c_void,
    pub tir: *mut mlx5_devx_obj,
}
impl mlx5_hrxq {
    #[inline]
    pub fn standalone(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_standalone(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn standalone_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_standalone_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(standalone: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let standalone: u32 = unsafe { ::std::mem::transmute(standalone) };
            standalone as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj {
    pub next: mlx5_txq_obj__bindgen_ty_1,
    pub txq_ctrl: *mut mlx5_txq_ctrl,
    pub __bindgen_anon_1: mlx5_txq_obj__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_txq_obj,
    pub le_prev: *mut *mut mlx5_txq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_txq_obj__bindgen_ty_2 {
    pub __bindgen_anon_1: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_2,
    pub __bindgen_anon_3: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_1 {
    pub cq: *mut ::std::os::raw::c_void,
    pub qp: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_2 {
    pub sq: *mut mlx5_devx_obj,
    pub tis: *mut mlx5_devx_obj,
    pub umem_buf_wq_buffer: *mut ::std::os::raw::c_void,
    pub umem_obj_wq_buffer: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_3 {
    pub dev: *mut rte_eth_dev,
    pub cq_obj: mlx5_devx_cq,
    pub sq_obj: mlx5_devx_sq,
}
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_RST2RDY: mlx5_txq_modify_type = 0;
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_RDY2RST: mlx5_txq_modify_type = 1;
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_ERR2RDY: mlx5_txq_modify_type = 2;
pub type mlx5_txq_modify_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_obj_ops {
    pub rxq_obj_modify_vlan_strip: ::std::option::Option<
        unsafe extern "C" fn(
            rxq: *mut mlx5_rxq_priv,
            on: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_modify_counter_set_id: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv, counter_set_id: u32) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_new: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv) -> ::std::os::raw::c_int,
    >,
    pub rxq_event_get: ::std::option::Option<
        unsafe extern "C" fn(rxq_obj: *mut mlx5_rxq_obj) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_modify: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv, type_: u8) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_release: ::std::option::Option<unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv)>,
    pub rxq_event_get_lwm: ::std::option::Option<
        unsafe extern "C" fn(
            priv_: *mut mlx5_priv,
            rxq_idx: *mut ::std::os::raw::c_int,
            port_id: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_new: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            log_n: ::std::os::raw::c_uint,
            ind_tbl: *mut mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_modify: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            log_n: ::std::os::raw::c_uint,
            queues: *const u16,
            queues_n: u32,
            ind_tbl: *mut mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_destroy:
        ::std::option::Option<unsafe extern "C" fn(ind_tbl: *mut mlx5_ind_table_obj)>,
    pub hrxq_new: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            hrxq: *mut mlx5_hrxq,
            tunnel: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub hrxq_modify: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            hrxq: *mut mlx5_hrxq,
            rss_key: *const u8,
            hash_fields: u64,
            symmetric_hash_function: bool,
            ind_tbl: *const mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub hrxq_destroy: ::std::option::Option<unsafe extern "C" fn(hrxq: *mut mlx5_hrxq)>,
    pub drop_action_create:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>,
    pub drop_action_destroy: ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>,
    pub txq_obj_new: ::std::option::Option<
        unsafe extern "C" fn(dev: *mut rte_eth_dev, idx: u16) -> ::std::os::raw::c_int,
    >,
    pub txq_obj_modify: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut mlx5_txq_obj,
            type_: mlx5_txq_modify_type,
            dev_port: u8,
        ) -> ::std::os::raw::c_int,
    >,
    pub txq_obj_release: ::std::option::Option<unsafe extern "C" fn(txq_obj: *mut mlx5_txq_obj)>,
    pub lb_dummy_queue_create:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>,
    pub lb_dummy_queue_release: ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>,
}
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_GENERAL: mlx5_ctrl_flow_type = 0;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_SQ_MISS_ROOT: mlx5_ctrl_flow_type = 1;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_SQ_MISS: mlx5_ctrl_flow_type = 2;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_JUMP: mlx5_ctrl_flow_type = 3;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_TX_META_COPY: mlx5_ctrl_flow_type = 4;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_TX_REPR_MATCH: mlx5_ctrl_flow_type = 5;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_LACP_RX: mlx5_ctrl_flow_type = 6;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS: mlx5_ctrl_flow_type = 7;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS_UNICAST_DMAC: mlx5_ctrl_flow_type =
    8;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS_UNICAST_DMAC_VLAN:
    mlx5_ctrl_flow_type = 9;
pub type mlx5_ctrl_flow_type = ::std::os::raw::c_uint;
#[doc = " Additional info about control flow rule."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_info {
    #[doc = " Determines the kind of control flow rule."]
    pub type_: mlx5_ctrl_flow_type,
    pub __bindgen_anon_1: mlx5_ctrl_flow_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ctrl_flow_info__bindgen_ty_1 {
    #[doc = " If control flow is a SQ miss flow (root or not),\n then fields contains matching SQ number."]
    pub esw_mgr_sq: u32,
    #[doc = " If control flow is a Tx representor matching,\n then fields contains matching SQ number."]
    pub tx_repr_sq: u32,
    pub uc: mlx5_ctrl_flow_info__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Contains data relevant for unicast control flow rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_info__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " If control flow is a unicast DMAC (or with VLAN) flow rule,\n then this field contains DMAC."]
    pub dmac: rte_ether_addr,
    #[doc = " If control flow is a unicast DMAC with VLAN flow rule,\n then this field contains VLAN ID."]
    pub vlan: u16,
}
#[doc = " Entry for tracking control flow rules in HWS."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_entry {
    pub next: mlx5_ctrl_flow_entry__bindgen_ty_1,
    #[doc = " Owner device is a port on behalf of which flow rule was created.\n\n It's different from the port which really created the flow rule\n if and only if flow rule is created on transfer proxy port\n on behalf of representor port."]
    pub owner_dev: *mut rte_eth_dev,
    #[doc = " Pointer to flow rule handle."]
    pub flow: *mut rte_flow,
    #[doc = " Additional information about the control flow rule."]
    pub info: mlx5_ctrl_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_entry__bindgen_ty_1 {
    pub le_next: *mut mlx5_ctrl_flow_entry,
    pub le_prev: *mut *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_attr {
    pub port_attr: rte_flow_port_attr,
    pub nb_queue: u16,
    pub queue_attr: *mut rte_flow_queue_attr,
    pub nt_mode: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dv_flow_info {
    pub next: mlx5_dv_flow_info__bindgen_ty_1,
    pub orig_prio: u32,
    pub flow_idx_high_prio: u32,
    pub flow_idx_low_prio: u32,
    pub items: *mut rte_flow_item,
    pub actions: *mut rte_flow_action,
    pub attr: rte_flow_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dv_flow_info__bindgen_ty_1 {
    pub le_next: *mut mlx5_dv_flow_info,
    pub le_prev: *mut *mut mlx5_dv_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pmd_mlx5_flow_engine_mode_info {
    pub mode: rte_pmd_mlx5_flow_engine_mode,
    pub mode_flag: u32,
    pub hot_upgrade: rte_pmd_mlx5_flow_engine_mode_info_hot_up_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pmd_mlx5_flow_engine_mode_info_hot_up_info {
    pub lh_first: *mut mlx5_dv_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_ctrl_rx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_quota {
    pub state: u8,
    pub mode: u8,
    #[doc = " Keep track of application update types.\n PMD does not allow 2 consecutive ADD updates."]
    pub last_update: rte_flow_update_quota_op,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_quota_ctx {
    pub dr_action: *mut mlx5dr_action,
    pub devx_obj: *mut mlx5_devx_obj,
    pub mr: mlx5_pmd_mr,
    pub read_buf: *mut *mut mlx5_aso_mtr_dseg,
    pub sq: *mut mlx5_aso_sq,
    pub quota_ipool: *mut mlx5_indexed_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv {
    pub dev_data: *mut rte_eth_dev_data,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub dev_port: u32,
    pub pci_dev: *mut rte_pci_device,
    pub mac: [rte_ether_addr; 256usize],
    pub mac_own: [u64; 4usize],
    pub vlan_filter: [u16; 128usize],
    pub vlan_filter_n: ::std::os::raw::c_uint,
    pub mtu: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub domain_id: u16,
    pub vport_id: u16,
    pub vport_meta_tag: u32,
    pub vport_meta_mask: u32,
    pub representor_id: u16,
    pub pf_bond: i32,
    pub mpesw_owner: i32,
    pub mpesw_port: i32,
    pub mpesw_uplink: bool,
    pub if_index: ::std::os::raw::c_uint,
    pub rxqs_n: ::std::os::raw::c_uint,
    pub txqs_n: ::std::os::raw::c_uint,
    pub ext_rxqs: *mut mlx5_external_q,
    pub ext_txqs: *mut mlx5_external_q,
    pub rxq_privs: *mut [*mut mlx5_rxq_priv; 0usize],
    pub txqs: *mut [*mut mlx5_txq_data; 0usize],
    pub mprq_mp: *mut rte_mempool,
    pub rss_conf: rte_eth_rss_conf,
    pub reta_idx: *mut [::std::os::raw::c_uint; 0usize],
    pub reta_idx_n: ::std::os::raw::c_uint,
    pub drop_queue: mlx5_drop,
    pub root_drop_action: *mut ::std::os::raw::c_void,
    pub hw_ctrl_lock: rte_spinlock_t,
    pub hw_ctrl_flows: mlx5_priv_hw_ctrl_flow,
    pub hw_ext_ctrl_flows: mlx5_priv_hw_ext_ctrl_flow,
    pub hw_ctrl_fdb: *mut mlx5_flow_hw_ctrl_fdb,
    pub hw_tx_repr_tagging_pt: *mut rte_flow_pattern_template,
    pub hw_tx_repr_tagging_at: *mut rte_flow_actions_template,
    pub hw_tx_repr_tagging_tbl: *mut rte_flow_template_table,
    pub flows: [*mut mlx5_indexed_pool; 3usize],
    pub ctrl_flows: u32,
    pub flow_list_lock: rte_spinlock_t,
    pub obj_ops: mlx5_obj_ops,
    pub rxqsctrl: mlx5_priv_rxq,
    pub rxqsobj: mlx5_priv_rxqobj,
    pub hrxqs: *mut mlx5_list,
    pub txqsctrl: mlx5_priv_txq,
    pub txqsobj: mlx5_priv_txqobj,
    pub ind_tbls: mlx5_priv_ind_tables,
    pub standalone_ind_tbls: mlx5_priv_stdl_ind_tables,
    pub indirect_list_head: mlx5_priv_indirect_list,
    pub ind_tbls_lock: rte_rwlock_t,
    #[doc = "< Reference counter. */\n/**< Verbs modify header action object."]
    pub refcnt: u32,
    #[doc = "< Flow table type, Rx or Tx."]
    pub ft_type: u8,
    pub max_lro_msg_size: u32,
    pub link_speed_capa: u32,
    pub xstats_ctrl: mlx5_xstats_ctrl,
    pub stats_ctrl: mlx5_stats_ctrl,
    pub config: mlx5_port_config,
    pub nl_socket_rdma: ::std::os::raw::c_int,
    pub nl_socket_route: ::std::os::raw::c_int,
    pub vmwa_context: *mut mlx5_nl_vlan_vmwa_context,
    pub mtr_config: mlx5_mtr_config,
    pub mtr_sfx_reg: u8,
    pub flow_meters: mlx5_legacy_flow_meters,
    pub mtr_profile_tbl: *mut mlx5_l3t_tbl,
    pub mtr_profile_arr: *mut mlx5_flow_meter_profile,
    pub policy_idx_tbl: *mut mlx5_l3t_tbl,
    pub mtr_policy_arr: *mut mlx5_flow_meter_policy,
    pub mtr_idx_tbl: *mut mlx5_l3t_tbl,
    pub mtr_bulk: mlx5_mtr_bulk,
    pub quota_ctx: mlx5_quota_ctx,
    pub skip_default_rss_reta: u8,
    pub fdb_def_rule: u8,
    pub mp_id: mlx5_mp_id,
    pub fdir_flows: mlx5_priv_fdir,
    pub shared_act_sl: rte_spinlock_t,
    pub rss_shared_actions: u32,
    pub num_of_hairpin_q_counter_enabled: u64,
    pub q_counters: *mut mlx5_devx_obj,
    pub counter_set_id: u32,
    pub q_counter_hairpin: *mut mlx5_devx_obj,
    pub lag_affinity_idx: u32,
    pub flex_item_sl: rte_spinlock_t,
    pub flex_item: [mlx5_flex_item; 8usize],
    pub flex_item_map: u32,
    pub nb_queue: u32,
    pub hws_cpool: *mut mlx5_hws_cnt_pool,
    pub hws_mark_refcnt: u32,
    pub mode_info: rte_pmd_mlx5_flow_engine_mode_info,
    pub hw_attr: *mut mlx5_flow_hw_attr,
    #[doc = "< Whether this port is in rules flushing stage."]
    pub hws_rule_flushing: bool,
    pub flow_hw_itt: mlx5_priv_flow_hw_itt,
    pub flow_hw_at: mlx5_priv_flow_hw_at,
    #[doc = "< HW steering DR context."]
    pub dr_ctx: *mut mlx5dr_context,
    pub tlv_options: *mut mlx5_geneve_tlv_options,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub hw_q: *mut mlx5_hw_q,
    pub flow_hw_tbl: mlx5_priv_flow_hw_tbl,
    pub flow_hw_grp: mlx5_priv_flow_hw_grp,
    pub hw_push_vlan: [*mut mlx5dr_action; 6usize],
    pub hw_pop_vlan: [*mut mlx5dr_action; 6usize],
    pub hw_vport: *mut *mut mlx5dr_action,
    pub hw_drop: [*mut mlx5dr_action; 2usize],
    pub hw_tag: [*mut mlx5dr_action; 2usize],
    pub hw_def_miss: *mut mlx5dr_action,
    pub hw_send_to_kernel: [*mut mlx5dr_action; 6usize],
    pub flow_hw_tbl_ongo: mlx5_priv_flow_hw_tbl_ongo,
    pub acts_ipool: *mut mlx5_indexed_pool,
    pub ct_mng: *mut mlx5_aso_ct_pools_mng,
    pub hws_ctpool: *mut mlx5_aso_ct_pool,
    pub hws_mpool: *mut mlx5_aso_mtr_pool,
    pub hw_ctrl_rx: *mut mlx5_flow_hw_ctrl_rx,
    pub action_template_drop: [*mut rte_flow_actions_template; 6usize],
    pub action_nat64: [[*mut mlx5dr_action; 2usize]; 6usize],
    pub ptype_rss_groups: *mut mlx5_indexed_pool,
    pub shared_host: *mut rte_eth_dev,
    pub shared_refcnt: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_hw_ctrl_flow {
    pub lh_first: *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_hw_ext_ctrl_flow {
    pub lh_first: *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_rxq {
    pub lh_first: *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_rxqobj {
    pub lh_first: *mut mlx5_rxq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_txq {
    pub lh_first: *mut mlx5_txq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_txqobj {
    pub lh_first: *mut mlx5_txq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_ind_tables {
    pub lh_first: *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_stdl_ind_tables {
    pub lh_first: *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_indirect_list {
    pub lh_first: *mut mlx5_indirect_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_fdir {
    pub lh_first: *mut mlx5_fdir_flow,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_itt {
    pub lh_first: *mut rte_flow_pattern_template,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_at {
    pub lh_first: *mut rte_flow_actions_template,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_tbl {
    pub lh_first: *mut rte_flow_template_table,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_grp {
    pub lh_first: *mut mlx5_flow_group,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_tbl_ongo {
    pub lh_first: *mut rte_flow_template_table,
}
impl mlx5_priv {
    #[inline]
    pub fn isolated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isolated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isolated_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_isolated_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn representor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_representor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn representor_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_representor_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn master(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_master(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn master_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_master_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn txpp_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txpp_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn txpp_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_txpp_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sampler_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sampler_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sampler_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sampler_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mtr_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mtr_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mtr_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mtr_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mtr_reg_share(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mtr_reg_share(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mtr_reg_share_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mtr_reg_share_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lb_used(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lb_used(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lb_used_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lb_used_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv_notified(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv_notified(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_notified_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_notified_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_lag_ports(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_num_lag_ports(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_lag_ports_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_lag_ports_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unified_fdb_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unified_fdb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unified_fdb_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unified_fdb_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jump_fdb_rx_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jump_fdb_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jump_fdb_rx_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_jump_fdb_rx_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isolated: ::std::os::raw::c_uint,
        representor: ::std::os::raw::c_uint,
        master: ::std::os::raw::c_uint,
        txpp_en: ::std::os::raw::c_uint,
        sampler_en: ::std::os::raw::c_uint,
        mtr_en: ::std::os::raw::c_uint,
        mtr_reg_share: ::std::os::raw::c_uint,
        lb_used: ::std::os::raw::c_uint,
        rmv_notified: ::std::os::raw::c_uint,
        mark_enabled: u32,
        num_lag_ports: u32,
        tunnel_enabled: u32,
        unified_fdb_en: u32,
        jump_fdb_rx_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isolated: u32 = unsafe { ::std::mem::transmute(isolated) };
            isolated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let representor: u32 = unsafe { ::std::mem::transmute(representor) };
            representor as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let master: u32 = unsafe { ::std::mem::transmute(master) };
            master as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let txpp_en: u32 = unsafe { ::std::mem::transmute(txpp_en) };
            txpp_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sampler_en: u32 = unsafe { ::std::mem::transmute(sampler_en) };
            sampler_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mtr_en: u32 = unsafe { ::std::mem::transmute(mtr_en) };
            mtr_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mtr_reg_share: u32 = unsafe { ::std::mem::transmute(mtr_reg_share) };
            mtr_reg_share as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lb_used: u32 = unsafe { ::std::mem::transmute(lb_used) };
            lb_used as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rmv_notified: u32 = unsafe { ::std::mem::transmute(rmv_notified) };
            rmv_notified as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mark_enabled: u32 = unsafe { ::std::mem::transmute(mark_enabled) };
            mark_enabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let num_lag_ports: u32 = unsafe { ::std::mem::transmute(num_lag_ports) };
            num_lag_ports as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tunnel_enabled: u32 = unsafe { ::std::mem::transmute(tunnel_enabled) };
            tunnel_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let unified_fdb_en: u32 = unsafe { ::std::mem::transmute(unified_fdb_en) };
            unified_fdb_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let jump_fdb_rx_en: u32 = unsafe { ::std::mem::transmute(jump_fdb_rx_en) };
            jump_fdb_rx_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn hws_strict_queue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hws_strict_queue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_strict_queue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_strict_queue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hws_age_req(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hws_age_req(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_age_req_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_age_req_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        hws_strict_queue: u32,
        hws_age_req: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hws_strict_queue: u32 = unsafe { ::std::mem::transmute(hws_strict_queue) };
            hws_strict_queue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hws_age_req: u32 = unsafe { ::std::mem::transmute(hws_age_req) };
            hws_age_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @internal Declaration of the hairpin peer queue information structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_hairpin_peer_info {
    pub qp_id: u32,
    pub vhca_id: u32,
    pub peer_q: u16,
    pub tx_explicit: u16,
    pub manual_bind: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_stat {
    pub id: ::std::os::raw::c_int,
    pub count: u64,
    pub ctrl: mlx5_stat_counter_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_stats {
    #[doc = "< Total of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total of packets dropped when RX ring full."]
    pub idropped: u64,
    #[doc = "< Total of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = "< Total of hairpin queue out of buffers."]
    pub oobs: mlx5_rxq_stat,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rxq_zip {
    pub cqe_cnt: u16,
    pub ai: u16,
    pub ca: u32,
    pub na: u32,
    pub cq_ci: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_eth_rxseg {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = "< Reserved field."]
    pub reserved: u32,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_data {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub port_id: u16,
    pub rq_db: *mut u32,
    pub cq_db: *mut u32,
    pub elts_ci: u32,
    pub rq_ci: u32,
    pub consumed_strd: u16,
    pub rq_pi: u32,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub rq_repl_thresh: u16,
    pub byte_mask: u32,
    pub __bindgen_anon_1: mlx5_rxq_data__bindgen_ty_1,
    pub mr_ctrl: mlx5_mr_ctrl,
    pub mprq_max_memcpy_len: u16,
    pub wqes: *mut ::std::os::raw::c_void,
    pub cqes: *mut [mlx5_cqe; 0usize],
    pub title_cqe: mlx5_cqe,
    pub elts: *mut [*mut rte_mbuf; 0usize],
    pub __bindgen_padding_0: [u64; 4usize],
    pub title_pkt: rte_mbuf,
    pub mprq_bufs: *mut [*mut mlx5_mprq_buf; 0usize],
    pub mp: *mut rte_mempool,
    pub mprq_mp: *mut rte_mempool,
    pub mprq_repl: *mut mlx5_mprq_buf,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub idx: u16,
    pub stats: mlx5_rxq_stats,
    pub stats_reset: mlx5_rxq_stats,
    pub mbuf_initializer: rte_xmm_t,
    pub __bindgen_padding_1: [u64; 6usize],
    pub fake_mbuf: rte_mbuf,
    pub uar_data: mlx5_uar_data,
    pub cqn: u32,
    pub cq_arm_sn: u8,
    pub mark_flag: u64,
    pub tunnel: u32,
    pub timestamp_offset: ::std::os::raw::c_int,
    pub timestamp_rx_flag: u64,
    pub flow_meta_mask: u64,
    pub flow_meta_offset: i32,
    pub flow_meta_port_mask: u32,
    pub rxseg_n: u32,
    pub rxseg: [mlx5_eth_rxseg; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_rxq_data__bindgen_ty_1 {
    pub zip: rxq_zip,
    pub decompressed: u16,
}
impl mlx5_rxq_data {
    #[inline]
    pub fn csum(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csum(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_csum_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_timestamp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_timestamp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_timestamp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_timestamp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_strip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_strip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_strip_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_strip_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crc_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crc_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crc_present_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crc_present_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sges_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sges_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sges_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sges_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn elts_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_elts_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn elts_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_elts_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rss_hash(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rss_hash(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rss_hash_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rss_hash_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_strd_num(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_strd_num(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_strd_num_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_strd_num_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_strd_sz(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log_strd_sz(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_strd_sz_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_strd_sz_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strd_shift_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strd_shift_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strd_shift_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strd_shift_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn err_state(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_err_state(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn err_state_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_err_state_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strd_scatter_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strd_scatter_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strd_scatter_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strd_scatter_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dynf_meta(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dynf_meta(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dynf_meta_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dynf_meta_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mcqe_format(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcqe_format(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mcqe_format_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mcqe_format_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_layout(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_layout(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_layout_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_layout_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        csum: ::std::os::raw::c_uint,
        hw_timestamp: ::std::os::raw::c_uint,
        rt_timestamp: ::std::os::raw::c_uint,
        vlan_strip: ::std::os::raw::c_uint,
        crc_present: ::std::os::raw::c_uint,
        sges_n: ::std::os::raw::c_uint,
        cqe_n: ::std::os::raw::c_uint,
        elts_n: ::std::os::raw::c_uint,
        rss_hash: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_uint,
        log_strd_num: ::std::os::raw::c_uint,
        log_strd_sz: ::std::os::raw::c_uint,
        strd_shift_en: ::std::os::raw::c_uint,
        err_state: ::std::os::raw::c_uint,
        strd_scatter_en: ::std::os::raw::c_uint,
        lro: ::std::os::raw::c_uint,
        dynf_meta: ::std::os::raw::c_uint,
        mcqe_format: ::std::os::raw::c_uint,
        shared: ::std::os::raw::c_uint,
        delay_drop: ::std::os::raw::c_uint,
        cqe_comp_layout: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csum: u32 = unsafe { ::std::mem::transmute(csum) };
            csum as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_timestamp: u32 = unsafe { ::std::mem::transmute(hw_timestamp) };
            hw_timestamp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rt_timestamp: u32 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let vlan_strip: u32 = unsafe { ::std::mem::transmute(vlan_strip) };
            vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let crc_present: u32 = unsafe { ::std::mem::transmute(crc_present) };
            crc_present as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let sges_n: u32 = unsafe { ::std::mem::transmute(sges_n) };
            sges_n as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let cqe_n: u32 = unsafe { ::std::mem::transmute(cqe_n) };
            cqe_n as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let elts_n: u32 = unsafe { ::std::mem::transmute(elts_n) };
            elts_n as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rss_hash: u32 = unsafe { ::std::mem::transmute(rss_hash) };
            rss_hash as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mark: u32 = unsafe { ::std::mem::transmute(mark) };
            mark as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let log_strd_num: u32 = unsafe { ::std::mem::transmute(log_strd_num) };
            log_strd_num as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let log_strd_sz: u32 = unsafe { ::std::mem::transmute(log_strd_sz) };
            log_strd_sz as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let strd_shift_en: u32 = unsafe { ::std::mem::transmute(strd_shift_en) };
            strd_shift_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let err_state: u32 = unsafe { ::std::mem::transmute(err_state) };
            err_state as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let strd_scatter_en: u32 = unsafe { ::std::mem::transmute(strd_scatter_en) };
            strd_scatter_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lro: u32 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let dynf_meta: u32 = unsafe { ::std::mem::transmute(dynf_meta) };
            dynf_meta as u64
        });
        __bindgen_bitfield_unit.set(33usize, 3u8, {
            let mcqe_format: u32 = unsafe { ::std::mem::transmute(mcqe_format) };
            mcqe_format as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let delay_drop: u32 = unsafe { ::std::mem::transmute(delay_drop) };
            delay_drop as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let cqe_comp_layout: u32 = unsafe { ::std::mem::transmute(cqe_comp_layout) };
            cqe_comp_layout as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(cq_ci: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl {
    pub rxq: mlx5_rxq_data,
    pub next: mlx5_rxq_ctrl__bindgen_ty_1,
    pub owners: mlx5_rxq_ctrl_priv,
    pub obj: *mut mlx5_rxq_obj,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub is_hairpin: bool,
    pub socket: ::std::os::raw::c_uint,
    pub share_entry: mlx5_rxq_ctrl__bindgen_ty_2,
    pub ctrl_ref: i32,
    pub share_group: u32,
    pub share_qid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub flow_tunnels_n: [u32; 10usize],
    pub wqn: u32,
    pub rxseg_n: u32,
    pub rxseg: [rte_eth_rxseg_split; 32usize],
    pub dump_file_n: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_ctrl,
    pub le_prev: *mut *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl_priv {
    pub lh_first: *mut mlx5_rxq_priv,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl__bindgen_ty_2 {
    pub le_next: *mut mlx5_rxq_ctrl,
    pub le_prev: *mut *mut mlx5_rxq_ctrl,
}
impl mlx5_rxq_ctrl {
    #[inline]
    pub fn started(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_started(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn started_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_started_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        started: ::std::os::raw::c_uint,
        irq: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let started: u32 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let irq: u32 = unsafe { ::std::mem::transmute(irq) };
            irq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_priv {
    pub idx: u16,
    pub refcnt: u32,
    pub ctrl: *mut mlx5_rxq_ctrl,
    pub owner_entry: mlx5_rxq_priv__bindgen_ty_1,
    pub priv_: *mut mlx5_priv,
    pub devx_rq: mlx5_devx_rq,
    pub hairpin_conf: rte_eth_hairpin_conf,
    pub hairpin_status: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub q_counter: *mut mlx5_devx_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_priv__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_priv,
    pub le_prev: *mut *mut mlx5_rxq_priv,
}
impl mlx5_rxq_priv {
    #[inline]
    pub fn lwm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lwm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_event_pending(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_event_pending(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_event_pending_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_event_pending_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_devx_subscribed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_devx_subscribed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_devx_subscribed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_devx_subscribed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lwm: u32,
        lwm_event_pending: u32,
        lwm_devx_subscribed: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let lwm: u32 = unsafe { ::std::mem::transmute(lwm) };
            lwm as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let lwm_event_pending: u32 = unsafe { ::std::mem::transmute(lwm_event_pending) };
            lwm_event_pending as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let lwm_devx_subscribed: u32 = unsafe { ::std::mem::transmute(lwm_devx_subscribed) };
            lwm_devx_subscribed as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static mlx5_rx_functions: [eth_rx_burst_t; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg {
    pub _address: u8,
}
#[doc = "< class handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
#[doc = " Fast path flow API functions exported by PMD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_fp_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dr_action {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dv_matcher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dv_modify_hdr_resource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tunnel_hub {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_legacy_flow_meter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_ctrl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_ctrl_fdb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indirect_list {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_nl_vlan_vmwa_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_fdir_flow {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_group {
    pub _address: u8,
}
