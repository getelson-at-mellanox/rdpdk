/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }}
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }}
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }}
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }}
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        unsafe { ::std::mem::transmute(self) }
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        unsafe { ::std::mem::transmute(self) }
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type off_t = __off64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 253usize],
}
#[doc = " Action function typedef used by other components.\n\n As we create  socket channel for primary/secondary communication, use\n this function typedef to register action for coming messages.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Thread id descriptor."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_t {
    #[doc = "< thread identifier"]
    pub opaque_id: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data\n together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[doc = "< multi-thread safe (default mode)"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
#[doc = "< single thread only"]
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
#[doc = "< multi-thread relaxed tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
#[doc = "< multi-thread head/tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
#[doc = " prod/cons sync types"]
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[doc = " structures to hold a pair of head/tail values and other metadata.\n Depending on sync_type format of that structure might be different,\n but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure.\n\n The producer and the consumer have a head and a tail index. The particularity\n of these index is that they are not between 0 and size(ring)-1. These indexes\n are between 0 and 2^32 -1, and we mask their value when we access the ring[]\n field. Thanks to this assumption, we can do subtractions between 2 index\n values in a modulo-32bit base: that's why the overflow of the indexes is not\n a problem."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
pub type rte_xmm_t = rte_xmm;
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n layout for the first cache line for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(8))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[doc = " Bitmap data structure"]
#[repr(C)]
pub struct rte_bitmap {
    #[doc = "< Bitmap array1"]
    pub array1: *mut u64,
    #[doc = "< Bitmap array2"]
    pub array2: *mut u64,
    #[doc = "< Number of 64-bit slabs in array1 that are actually used"]
    pub array1_size: u32,
    #[doc = "< Number of 64-bit slabs in array2"]
    pub array2_size: u32,
    #[doc = "< Bitmap scan: Index of current array1 slab"]
    pub index1: u32,
    #[doc = "< Bitmap scan: Offset of current bit within current array1 slab"]
    pub offset1: u32,
    #[doc = "< Bitmap scan: Index of current array2 slab"]
    pub index2: u32,
    #[doc = "< Bitmap scan: Go/stop condition for current array2 cache line"]
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_gid {
    pub raw: [u8; 16usize],
    pub global: ibv_gid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
pub const ibv_node_type_IBV_NODE_UNKNOWN: ibv_node_type = -1;
pub const ibv_node_type_IBV_NODE_CA: ibv_node_type = 1;
pub const ibv_node_type_IBV_NODE_SWITCH: ibv_node_type = 2;
pub const ibv_node_type_IBV_NODE_ROUTER: ibv_node_type = 3;
pub const ibv_node_type_IBV_NODE_RNIC: ibv_node_type = 4;
pub const ibv_node_type_IBV_NODE_USNIC: ibv_node_type = 5;
pub const ibv_node_type_IBV_NODE_USNIC_UDP: ibv_node_type = 6;
pub const ibv_node_type_IBV_NODE_UNSPECIFIED: ibv_node_type = 7;
pub type ibv_node_type = ::std::os::raw::c_int;
pub const ibv_transport_type_IBV_TRANSPORT_UNKNOWN: ibv_transport_type = -1;
pub const ibv_transport_type_IBV_TRANSPORT_IB: ibv_transport_type = 0;
pub const ibv_transport_type_IBV_TRANSPORT_IWARP: ibv_transport_type = 1;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC: ibv_transport_type = 2;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC_UDP: ibv_transport_type = 3;
pub const ibv_transport_type_IBV_TRANSPORT_UNSPECIFIED: ibv_transport_type = 4;
pub type ibv_transport_type = ::std::os::raw::c_int;
pub const ibv_atomic_cap_IBV_ATOMIC_NONE: ibv_atomic_cap = 0;
pub const ibv_atomic_cap_IBV_ATOMIC_HCA: ibv_atomic_cap = 1;
pub const ibv_atomic_cap_IBV_ATOMIC_GLOB: ibv_atomic_cap = 2;
pub type ibv_atomic_cap = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: ::std::option::Option<
        unsafe extern "C" fn(
            dm: *mut ibv_dm,
            dm_offset: u64,
            host_addr: *const ::std::os::raw::c_void,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub memcpy_from_dm: ::std::option::Option<
        unsafe extern "C" fn(
            host_addr: *mut ::std::os::raw::c_void,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub comp_mask: u32,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pci_atomic_caps {
    pub fetch_add: u16,
    pub swap: u16,
    pub compare_swap: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
    pub pci_atomic_caps: ibv_pci_atomic_caps,
    pub xrc_odp_caps: u32,
    pub phys_port_cnt_ex: u32,
}
pub const ibv_mtu_IBV_MTU_256: ibv_mtu = 1;
pub const ibv_mtu_IBV_MTU_512: ibv_mtu = 2;
pub const ibv_mtu_IBV_MTU_1024: ibv_mtu = 3;
pub const ibv_mtu_IBV_MTU_2048: ibv_mtu = 4;
pub const ibv_mtu_IBV_MTU_4096: ibv_mtu = 5;
pub type ibv_mtu = ::std::os::raw::c_uint;
pub const ibv_port_state_IBV_PORT_NOP: ibv_port_state = 0;
pub const ibv_port_state_IBV_PORT_DOWN: ibv_port_state = 1;
pub const ibv_port_state_IBV_PORT_INIT: ibv_port_state = 2;
pub const ibv_port_state_IBV_PORT_ARMED: ibv_port_state = 3;
pub const ibv_port_state_IBV_PORT_ACTIVE: ibv_port_state = 4;
pub const ibv_port_state_IBV_PORT_ACTIVE_DEFER: ibv_port_state = 5;
pub type ibv_port_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_port_attr {
    pub state: ibv_port_state,
    pub max_mtu: ibv_mtu,
    pub active_mtu: ibv_mtu,
    pub gid_tbl_len: ::std::os::raw::c_int,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub port_cap_flags2: u16,
    pub active_speed_ex: u32,
}
pub const ibv_event_type_IBV_EVENT_CQ_ERR: ibv_event_type = 0;
pub const ibv_event_type_IBV_EVENT_QP_FATAL: ibv_event_type = 1;
pub const ibv_event_type_IBV_EVENT_QP_REQ_ERR: ibv_event_type = 2;
pub const ibv_event_type_IBV_EVENT_QP_ACCESS_ERR: ibv_event_type = 3;
pub const ibv_event_type_IBV_EVENT_COMM_EST: ibv_event_type = 4;
pub const ibv_event_type_IBV_EVENT_SQ_DRAINED: ibv_event_type = 5;
pub const ibv_event_type_IBV_EVENT_PATH_MIG: ibv_event_type = 6;
pub const ibv_event_type_IBV_EVENT_PATH_MIG_ERR: ibv_event_type = 7;
pub const ibv_event_type_IBV_EVENT_DEVICE_FATAL: ibv_event_type = 8;
pub const ibv_event_type_IBV_EVENT_PORT_ACTIVE: ibv_event_type = 9;
pub const ibv_event_type_IBV_EVENT_PORT_ERR: ibv_event_type = 10;
pub const ibv_event_type_IBV_EVENT_LID_CHANGE: ibv_event_type = 11;
pub const ibv_event_type_IBV_EVENT_PKEY_CHANGE: ibv_event_type = 12;
pub const ibv_event_type_IBV_EVENT_SM_CHANGE: ibv_event_type = 13;
pub const ibv_event_type_IBV_EVENT_SRQ_ERR: ibv_event_type = 14;
pub const ibv_event_type_IBV_EVENT_SRQ_LIMIT_REACHED: ibv_event_type = 15;
pub const ibv_event_type_IBV_EVENT_QP_LAST_WQE_REACHED: ibv_event_type = 16;
pub const ibv_event_type_IBV_EVENT_CLIENT_REREGISTER: ibv_event_type = 17;
pub const ibv_event_type_IBV_EVENT_GID_CHANGE: ibv_event_type = 18;
pub const ibv_event_type_IBV_EVENT_WQ_FATAL: ibv_event_type = 19;
pub type ibv_event_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_async_event {
    pub element: ibv_async_event__bindgen_ty_1,
    pub event_type: ibv_event_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_async_event__bindgen_ty_1 {
    pub cq: *mut ibv_cq,
    pub qp: *mut ibv_qp,
    pub srq: *mut ibv_srq,
    pub wq: *mut ibv_wq,
    pub port_num: ::std::os::raw::c_int,
}
pub const ibv_wc_status_IBV_WC_SUCCESS: ibv_wc_status = 0;
pub const ibv_wc_status_IBV_WC_LOC_LEN_ERR: ibv_wc_status = 1;
pub const ibv_wc_status_IBV_WC_LOC_QP_OP_ERR: ibv_wc_status = 2;
pub const ibv_wc_status_IBV_WC_LOC_EEC_OP_ERR: ibv_wc_status = 3;
pub const ibv_wc_status_IBV_WC_LOC_PROT_ERR: ibv_wc_status = 4;
pub const ibv_wc_status_IBV_WC_WR_FLUSH_ERR: ibv_wc_status = 5;
pub const ibv_wc_status_IBV_WC_MW_BIND_ERR: ibv_wc_status = 6;
pub const ibv_wc_status_IBV_WC_BAD_RESP_ERR: ibv_wc_status = 7;
pub const ibv_wc_status_IBV_WC_LOC_ACCESS_ERR: ibv_wc_status = 8;
pub const ibv_wc_status_IBV_WC_REM_INV_REQ_ERR: ibv_wc_status = 9;
pub const ibv_wc_status_IBV_WC_REM_ACCESS_ERR: ibv_wc_status = 10;
pub const ibv_wc_status_IBV_WC_REM_OP_ERR: ibv_wc_status = 11;
pub const ibv_wc_status_IBV_WC_RETRY_EXC_ERR: ibv_wc_status = 12;
pub const ibv_wc_status_IBV_WC_RNR_RETRY_EXC_ERR: ibv_wc_status = 13;
pub const ibv_wc_status_IBV_WC_LOC_RDD_VIOL_ERR: ibv_wc_status = 14;
pub const ibv_wc_status_IBV_WC_REM_INV_RD_REQ_ERR: ibv_wc_status = 15;
pub const ibv_wc_status_IBV_WC_REM_ABORT_ERR: ibv_wc_status = 16;
pub const ibv_wc_status_IBV_WC_INV_EECN_ERR: ibv_wc_status = 17;
pub const ibv_wc_status_IBV_WC_INV_EEC_STATE_ERR: ibv_wc_status = 18;
pub const ibv_wc_status_IBV_WC_FATAL_ERR: ibv_wc_status = 19;
pub const ibv_wc_status_IBV_WC_RESP_TIMEOUT_ERR: ibv_wc_status = 20;
pub const ibv_wc_status_IBV_WC_GENERAL_ERR: ibv_wc_status = 21;
pub const ibv_wc_status_IBV_WC_TM_ERR: ibv_wc_status = 22;
pub const ibv_wc_status_IBV_WC_TM_RNDV_INCOMPLETE: ibv_wc_status = 23;
pub type ibv_wc_status = ::std::os::raw::c_uint;
pub const ibv_wc_opcode_IBV_WC_SEND: ibv_wc_opcode = 0;
pub const ibv_wc_opcode_IBV_WC_RDMA_WRITE: ibv_wc_opcode = 1;
pub const ibv_wc_opcode_IBV_WC_RDMA_READ: ibv_wc_opcode = 2;
pub const ibv_wc_opcode_IBV_WC_COMP_SWAP: ibv_wc_opcode = 3;
pub const ibv_wc_opcode_IBV_WC_FETCH_ADD: ibv_wc_opcode = 4;
pub const ibv_wc_opcode_IBV_WC_BIND_MW: ibv_wc_opcode = 5;
pub const ibv_wc_opcode_IBV_WC_LOCAL_INV: ibv_wc_opcode = 6;
pub const ibv_wc_opcode_IBV_WC_TSO: ibv_wc_opcode = 7;
pub const ibv_wc_opcode_IBV_WC_FLUSH: ibv_wc_opcode = 8;
pub const ibv_wc_opcode_IBV_WC_ATOMIC_WRITE: ibv_wc_opcode = 9;
pub const ibv_wc_opcode_IBV_WC_RECV: ibv_wc_opcode = 128;
pub const ibv_wc_opcode_IBV_WC_RECV_RDMA_WITH_IMM: ibv_wc_opcode = 129;
pub const ibv_wc_opcode_IBV_WC_TM_ADD: ibv_wc_opcode = 130;
pub const ibv_wc_opcode_IBV_WC_TM_DEL: ibv_wc_opcode = 131;
pub const ibv_wc_opcode_IBV_WC_TM_SYNC: ibv_wc_opcode = 132;
pub const ibv_wc_opcode_IBV_WC_TM_RECV: ibv_wc_opcode = 133;
pub const ibv_wc_opcode_IBV_WC_TM_NO_TAG: ibv_wc_opcode = 134;
pub const ibv_wc_opcode_IBV_WC_DRIVER1: ibv_wc_opcode = 135;
pub const ibv_wc_opcode_IBV_WC_DRIVER2: ibv_wc_opcode = 136;
pub const ibv_wc_opcode_IBV_WC_DRIVER3: ibv_wc_opcode = 137;
pub type ibv_wc_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status,
    pub opcode: ibv_wc_opcode,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
pub const ibv_mw_type_IBV_MW_TYPE_1: ibv_mw_type = 1;
pub const ibv_mw_type_IBV_MW_TYPE_2: ibv_mw_type = 2;
pub type ibv_mw_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_global_route {
    pub dgid: ibv_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah_attr {
    pub grh: ibv_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
pub const ibv_wq_type_IBV_WQT_RQ: ibv_wq_type = 0;
pub type ibv_wq_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut ::std::os::raw::c_void,
    pub wq_type: ibv_wq_type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
pub const ibv_wq_state_IBV_WQS_RESET: ibv_wq_state = 0;
pub const ibv_wq_state_IBV_WQS_RDY: ibv_wq_state = 1;
pub const ibv_wq_state_IBV_WQS_ERR: ibv_wq_state = 2;
pub const ibv_wq_state_IBV_WQS_UNKNOWN: ibv_wq_state = 3;
pub type ibv_wq_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state,
    pub curr_wq_state: ibv_wq_state,
    pub flags: u32,
    pub flags_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: ::std::os::raw::c_int,
    pub ind_tbl_num: ::std::os::raw::c_int,
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
pub const ibv_qp_type_IBV_QPT_RC: ibv_qp_type = 2;
pub const ibv_qp_type_IBV_QPT_UC: ibv_qp_type = 3;
pub const ibv_qp_type_IBV_QPT_UD: ibv_qp_type = 4;
pub const ibv_qp_type_IBV_QPT_RAW_PACKET: ibv_qp_type = 8;
pub const ibv_qp_type_IBV_QPT_XRC_SEND: ibv_qp_type = 9;
pub const ibv_qp_type_IBV_QPT_XRC_RECV: ibv_qp_type = 10;
pub const ibv_qp_type_IBV_QPT_DRIVER: ibv_qp_type = 255;
pub type ibv_qp_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: ::std::os::raw::c_int,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
    pub send_ops_flags: u64,
}
pub const ibv_qp_state_IBV_QPS_RESET: ibv_qp_state = 0;
pub const ibv_qp_state_IBV_QPS_INIT: ibv_qp_state = 1;
pub const ibv_qp_state_IBV_QPS_RTR: ibv_qp_state = 2;
pub const ibv_qp_state_IBV_QPS_RTS: ibv_qp_state = 3;
pub const ibv_qp_state_IBV_QPS_SQD: ibv_qp_state = 4;
pub const ibv_qp_state_IBV_QPS_SQE: ibv_qp_state = 5;
pub const ibv_qp_state_IBV_QPS_ERR: ibv_qp_state = 6;
pub const ibv_qp_state_IBV_QPS_UNKNOWN: ibv_qp_state = 7;
pub type ibv_qp_state = ::std::os::raw::c_uint;
pub const ibv_mig_state_IBV_MIG_MIGRATED: ibv_mig_state = 0;
pub const ibv_mig_state_IBV_MIG_REARM: ibv_mig_state = 1;
pub const ibv_mig_state_IBV_MIG_ARMED: ibv_mig_state = 2;
pub type ibv_mig_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state,
    pub cur_qp_state: ibv_qp_state,
    pub path_mtu: ibv_mtu,
    pub path_mig_state: ibv_mig_state,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: ::std::os::raw::c_uint,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE: ibv_wr_opcode = 0;
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE_WITH_IMM: ibv_wr_opcode = 1;
pub const ibv_wr_opcode_IBV_WR_SEND: ibv_wr_opcode = 2;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_IMM: ibv_wr_opcode = 3;
pub const ibv_wr_opcode_IBV_WR_RDMA_READ: ibv_wr_opcode = 4;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_CMP_AND_SWP: ibv_wr_opcode = 5;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_FETCH_AND_ADD: ibv_wr_opcode = 6;
pub const ibv_wr_opcode_IBV_WR_LOCAL_INV: ibv_wr_opcode = 7;
pub const ibv_wr_opcode_IBV_WR_BIND_MW: ibv_wr_opcode = 8;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_INV: ibv_wr_opcode = 9;
pub const ibv_wr_opcode_IBV_WR_TSO: ibv_wr_opcode = 10;
pub const ibv_wr_opcode_IBV_WR_DRIVER1: ibv_wr_opcode = 11;
pub const ibv_wr_opcode_IBV_WR_FLUSH: ibv_wr_opcode = 14;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_WRITE: ibv_wr_opcode = 15;
pub type ibv_wr_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state,
    pub wq_type: ibv_wq_type,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_wq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state,
    pub qp_type: ibv_qp_type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub priv_: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status,
    pub wr_id: u64,
    pub start_poll: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_cq_ex,
            attr: *mut ibv_poll_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_poll: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_int,
    >,
    pub end_poll: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex)>,
    pub read_opcode:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ibv_wc_opcode>,
    pub read_vendor_err:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_byte_len: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_imm_data:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> __be32>,
    pub read_qp_num: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_src_qp: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_wc_flags: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_uint,
    >,
    pub read_slid: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_sl: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_dlid_path_bits:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_completion_ts:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
    pub read_cvlan: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u16>,
    pub read_flow_tag: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_tm_info: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex, tm_info: *mut ibv_wc_tm_info),
    >,
    pub read_completion_wallclock_ns:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
pub const ibv_flow_attr_type_IBV_FLOW_ATTR_NORMAL: ibv_flow_attr_type = 0;
pub const ibv_flow_attr_type_IBV_FLOW_ATTR_ALL_DEFAULT: ibv_flow_attr_type = 1;
pub const ibv_flow_attr_type_IBV_FLOW_ATTR_MC_DEFAULT: ibv_flow_attr_type = 2;
pub const ibv_flow_attr_type_IBV_FLOW_ATTR_SNIFFER: ibv_flow_attr_type = 3;
pub type ibv_flow_attr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub type_: ibv_flow_attr_type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
    pub parent_domain: *mut ibv_pd,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counters_init_attr {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counters {
    pub context: *mut ibv_context,
}
pub const ibv_counter_description_IBV_COUNTER_PACKETS: ibv_counter_description = 0;
pub const ibv_counter_description_IBV_COUNTER_BYTES: ibv_counter_description = 1;
pub type ibv_counter_description = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_attach_attr {
    pub counter_desc: ibv_counter_description,
    pub index: u32,
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: timespec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tmh {
    pub opcode: u8,
    pub reserved: [u8; 3usize],
    pub app_ctx: __be32,
    pub tag: __be64,
}
pub const mlx5_ib_uapi_flow_action_flags_MLX5_IB_UAPI_FLOW_ACTION_FLAGS_REQUIRE_METADATA:
    mlx5_ib_uapi_flow_action_flags = 1;
pub type mlx5_ib_uapi_flow_action_flags = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_RX:
    mlx5_ib_uapi_flow_table_type = 0;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_TX:
    mlx5_ib_uapi_flow_table_type = 1;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_FDB:
    mlx5_ib_uapi_flow_table_type = 2;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_RX:
    mlx5_ib_uapi_flow_table_type = 3;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_TX:
    mlx5_ib_uapi_flow_table_type = 4;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_TRANSPORT_RX:
    mlx5_ib_uapi_flow_table_type = 5;
pub const mlx5_ib_uapi_flow_table_type_MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_TRANSPORT_TX:
    mlx5_ib_uapi_flow_table_type = 6;
pub type mlx5_ib_uapi_flow_table_type = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_flow_action_packet_reformat_type_MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TUNNEL_TO_L2 : mlx5_ib_uapi_flow_action_packet_reformat_type = 0 ;
pub const mlx5_ib_uapi_flow_action_packet_reformat_type_MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L2_TUNNEL : mlx5_ib_uapi_flow_action_packet_reformat_type = 1 ;
pub const mlx5_ib_uapi_flow_action_packet_reformat_type_MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L3_TUNNEL_TO_L2 : mlx5_ib_uapi_flow_action_packet_reformat_type = 2 ;
pub const mlx5_ib_uapi_flow_action_packet_reformat_type_MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L3_TUNNEL : mlx5_ib_uapi_flow_action_packet_reformat_type = 3 ;
pub type mlx5_ib_uapi_flow_action_packet_reformat_type = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_reg_dmabuf_flags_MLX5_IB_UAPI_REG_DMABUF_ACCESS_DATA_DIRECT:
    mlx5_ib_uapi_reg_dmabuf_flags = 1;
pub type mlx5_ib_uapi_reg_dmabuf_flags = ::std::os::raw::c_uint;
#[repr(C)]
pub struct mlx5_ib_uapi_devx_async_cmd_hdr {
    pub wr_id: __u64,
    pub out_data: __IncompleteArrayField<__u8>,
}
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_VPORT_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 1;
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_VPORT_VHCA_ID_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 2;
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_ESW_OWNER_VHCA_ID_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 4;
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_VPORT_ICM_RX_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 8;
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_VPORT_ICM_TX_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 16;
pub const mlx5_ib_uapi_devx_query_port_comp_mask_MLX5_IB_UAPI_QUERY_PORT_MATCH_REG_C_0_OLD:
    mlx5_ib_uapi_devx_query_port_comp_mask = 32;
pub type mlx5_ib_uapi_devx_query_port_comp_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ib_uapi_devx_reg_32 {
    pub value: __u32,
    pub mask: __u32,
}
pub const mlx5_ib_uapi_dm_type_MLX5_IB_UAPI_DM_TYPE_MEMIC: mlx5_ib_uapi_dm_type = 0;
pub const mlx5_ib_uapi_dm_type_MLX5_IB_UAPI_DM_TYPE_STEERING_SW_ICM: mlx5_ib_uapi_dm_type = 1;
pub const mlx5_ib_uapi_dm_type_MLX5_IB_UAPI_DM_TYPE_HEADER_MODIFY_SW_ICM: mlx5_ib_uapi_dm_type = 2;
pub const mlx5_ib_uapi_dm_type_MLX5_IB_UAPI_DM_TYPE_HEADER_MODIFY_PATTERN_SW_ICM:
    mlx5_ib_uapi_dm_type = 3;
pub const mlx5_ib_uapi_dm_type_MLX5_IB_UAPI_DM_TYPE_ENCAP_SW_ICM: mlx5_ib_uapi_dm_type = 4;
pub type mlx5_ib_uapi_dm_type = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_devx_create_event_channel_flags_MLX5_IB_UAPI_DEVX_CR_EV_CH_FLAGS_OMIT_DATA : mlx5_ib_uapi_devx_create_event_channel_flags = 1 ;
pub type mlx5_ib_uapi_devx_create_event_channel_flags = ::std::os::raw::c_uint;
#[repr(C)]
pub struct mlx5_ib_uapi_devx_async_event_hdr {
    pub cookie: __u64,
    pub out_data: __IncompleteArrayField<__u8>,
}
pub const mlx5_ib_uapi_pp_alloc_flags_MLX5_IB_UAPI_PP_ALLOC_FLAGS_DEDICATED_INDEX:
    mlx5_ib_uapi_pp_alloc_flags = 1;
pub type mlx5_ib_uapi_pp_alloc_flags = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_uar_alloc_type_MLX5_IB_UAPI_UAR_ALLOC_TYPE_BF: mlx5_ib_uapi_uar_alloc_type =
    0;
pub const mlx5_ib_uapi_uar_alloc_type_MLX5_IB_UAPI_UAR_ALLOC_TYPE_NC: mlx5_ib_uapi_uar_alloc_type =
    1;
pub type mlx5_ib_uapi_uar_alloc_type = ::std::os::raw::c_uint;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_VPORT:
    mlx5_ib_uapi_query_port_flags = 1;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_VPORT_VHCA_ID:
    mlx5_ib_uapi_query_port_flags = 2;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_VPORT_STEERING_ICM_RX:
    mlx5_ib_uapi_query_port_flags = 4;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_VPORT_STEERING_ICM_TX:
    mlx5_ib_uapi_query_port_flags = 8;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_VPORT_REG_C0:
    mlx5_ib_uapi_query_port_flags = 16;
pub const mlx5_ib_uapi_query_port_flags_MLX5_IB_UAPI_QUERY_PORT_ESW_OWNER_VHCA_ID:
    mlx5_ib_uapi_query_port_flags = 32;
pub type mlx5_ib_uapi_query_port_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ib_uapi_reg {
    pub value: __u32,
    pub mask: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ib_uapi_query_port {
    pub flags: __u64,
    pub vport: __u16,
    pub vport_vhca_id: __u16,
    pub esw_owner_vhca_id: __u16,
    pub rsvd0: __u16,
    pub vport_steering_icm_rx: __u64,
    pub vport_steering_icm_tx: __u64,
    pub reg_c0: mlx5_ib_uapi_reg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_cqe_comp_caps {
    pub max_num: u32,
    pub supported_format: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_sw_parsing_caps {
    pub sw_parsing_offloads: u32,
    pub supported_qpts: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_striding_rq_caps {
    pub min_single_stride_log_num_of_bytes: u32,
    pub max_single_stride_log_num_of_bytes: u32,
    pub min_single_wqe_log_num_of_strides: u32,
    pub max_single_wqe_log_num_of_strides: u32,
    pub supported_qpts: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dci_streams_caps {
    pub max_log_num_concurent: u8,
    pub max_log_num_errored: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_sig_caps {
    pub block_size: u64,
    pub block_prot: u32,
    pub t10dif_bg: u16,
    pub crc_type: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_crypto_caps {
    pub failed_selftests: u16,
    pub crypto_engines: u8,
    pub wrapped_import_method: u8,
    pub log_max_num_deks: u8,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_ooo_recv_wrs_caps {
    pub max_rc: u32,
    pub max_xrc: u32,
    pub max_dct: u32,
    pub max_ud: u32,
    pub max_uc: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_context {
    pub version: u8,
    pub flags: u64,
    pub comp_mask: u64,
    pub cqe_comp_caps: mlx5dv_cqe_comp_caps,
    pub sw_parsing_caps: mlx5dv_sw_parsing_caps,
    pub striding_rq_caps: mlx5dv_striding_rq_caps,
    pub tunnel_offloads_caps: u32,
    pub max_dynamic_bfregs: u32,
    pub max_clock_info_update_nsec: u64,
    pub flow_action_flags: u32,
    pub dc_odp_caps: u32,
    pub hca_core_clock: *mut ::std::os::raw::c_void,
    pub num_lag_ports: u8,
    pub sig_caps: mlx5dv_sig_caps,
    pub dci_streams_caps: mlx5dv_dci_streams_caps,
    pub max_wr_memcpy_length: usize,
    pub crypto_caps: mlx5dv_crypto_caps,
    pub max_dc_rd_atom: u64,
    pub max_dc_init_rd_atom: u64,
    pub reg_c0: mlx5_ib_uapi_reg,
    pub ooo_recv_wrs_caps: mlx5dv_ooo_recv_wrs_caps,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_cq_init_attr {
    pub comp_mask: u64,
    pub cqe_comp_res_format: u8,
    pub flags: u32,
    pub cqe_size: u16,
}
pub const mlx5dv_dc_type_MLX5DV_DCTYPE_DCT: mlx5dv_dc_type = 1;
pub const mlx5dv_dc_type_MLX5DV_DCTYPE_DCI: mlx5dv_dc_type = 2;
pub type mlx5dv_dc_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dci_streams {
    pub log_num_concurent: u8,
    pub log_num_errored: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dc_init_attr {
    pub dc_type: mlx5dv_dc_type,
    pub __bindgen_anon_1: mlx5dv_dc_init_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5dv_dc_init_attr__bindgen_ty_1 {
    pub dct_access_key: u64,
    pub dci_streams: mlx5dv_dci_streams,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_qp_init_attr {
    pub comp_mask: u64,
    pub create_flags: u32,
    pub dc_init_attr: mlx5dv_dc_init_attr,
    pub send_ops_flags: u64,
}
#[repr(C)]
pub struct mlx5dv_flow_match_parameters {
    pub match_sz: usize,
    pub match_buf: __IncompleteArrayField<u64>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_flow_matcher_attr {
    pub type_: ibv_flow_attr_type,
    pub flags: u32,
    pub priority: u16,
    pub match_criteria_enable: u8,
    pub match_mask: *mut mlx5dv_flow_match_parameters,
    pub comp_mask: u64,
    pub ft_type: mlx5_ib_uapi_flow_table_type,
    pub ib_port: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_steering_anchor_attr {
    pub ft_type: mlx5_ib_uapi_flow_table_type,
    pub priority: u16,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_steering_anchor {
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_qp {
    pub dbrec: *mut __be32,
    pub sq: mlx5dv_qp__bindgen_ty_1,
    pub rq: mlx5dv_qp__bindgen_ty_2,
    pub bf: mlx5dv_qp__bindgen_ty_3,
    pub comp_mask: u64,
    pub uar_mmap_offset: off_t,
    pub tirn: u32,
    pub tisn: u32,
    pub rqn: u32,
    pub sqn: u32,
    pub tir_icm_addr: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_qp__bindgen_ty_1 {
    pub buf: *mut ::std::os::raw::c_void,
    pub wqe_cnt: u32,
    pub stride: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_qp__bindgen_ty_2 {
    pub buf: *mut ::std::os::raw::c_void,
    pub wqe_cnt: u32,
    pub stride: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_qp__bindgen_ty_3 {
    pub reg: *mut ::std::os::raw::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_cq {
    pub buf: *mut ::std::os::raw::c_void,
    pub dbrec: *mut __be32,
    pub cqe_cnt: u32,
    pub cqe_size: u32,
    pub cq_uar: *mut ::std::os::raw::c_void,
    pub cqn: u32,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_srq {
    pub buf: *mut ::std::os::raw::c_void,
    pub dbrec: *mut __be32,
    pub stride: u32,
    pub head: u32,
    pub tail: u32,
    pub comp_mask: u64,
    pub srqn: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_rwq {
    pub buf: *mut ::std::os::raw::c_void,
    pub dbrec: *mut __be32,
    pub wqe_cnt: u32,
    pub stride: u32,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dm {
    pub buf: *mut ::std::os::raw::c_void,
    pub length: u64,
    pub comp_mask: u64,
    pub remote_va: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_ah {
    pub av: *mut mlx5_wqe_av,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_pd {
    pub pdn: u32,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx {
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj {
    pub qp: mlx5dv_obj__bindgen_ty_1,
    pub cq: mlx5dv_obj__bindgen_ty_2,
    pub srq: mlx5dv_obj__bindgen_ty_3,
    pub rwq: mlx5dv_obj__bindgen_ty_4,
    pub dm: mlx5dv_obj__bindgen_ty_5,
    pub ah: mlx5dv_obj__bindgen_ty_6,
    pub pd: mlx5dv_obj__bindgen_ty_7,
    pub devx: mlx5dv_obj__bindgen_ty_8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_1 {
    pub in_: *mut ibv_qp,
    pub out: *mut mlx5dv_qp,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_2 {
    pub in_: *mut ibv_cq,
    pub out: *mut mlx5dv_cq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_3 {
    pub in_: *mut ibv_srq,
    pub out: *mut mlx5dv_srq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_4 {
    pub in_: *mut ibv_wq,
    pub out: *mut mlx5dv_rwq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_5 {
    pub in_: *mut ibv_dm,
    pub out: *mut mlx5dv_dm,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_6 {
    pub in_: *mut ibv_ah,
    pub out: *mut mlx5dv_ah,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_7 {
    pub in_: *mut ibv_pd,
    pub out: *mut mlx5dv_pd,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_obj__bindgen_ty_8 {
    pub in_: *mut mlx5dv_devx_obj,
    pub out: *mut mlx5dv_devx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_striding_rq_init_attr {
    pub single_stride_log_num_of_bytes: u32,
    pub single_wqe_log_num_of_strides: u32,
    pub two_byte_shift_en: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_wq_init_attr {
    pub comp_mask: u64,
    pub striding_rq_attrs: mlx5dv_striding_rq_init_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_err_cqe {
    pub rsvd0: [u8; 32usize],
    pub srqn: u32,
    pub rsvd1: [u8; 18usize],
    pub vendor_err_synd: u8,
    pub syndrome: u8,
    pub s_wqe_opcode_qpn: u32,
    pub wqe_counter: u16,
    pub signature: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_tm_cqe {
    pub success: __be32,
    pub hw_phase_cnt: __be16,
    pub rsvd0: [u8; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe64 {
    pub __bindgen_anon_1: mlx5_cqe64__bindgen_ty_1,
    pub srqn_uidx: __be32,
    pub imm_inval_pkey: __be32,
    pub app: u8,
    pub app_op: u8,
    pub app_info: __be16,
    pub byte_cnt: __be32,
    pub timestamp: __be64,
    pub sop_drop_qpn: __be32,
    pub wqe_counter: __be16,
    pub signature: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_cqe64__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_cqe64__bindgen_ty_1__bindgen_ty_1,
    pub tm_cqe: mlx5_tm_cqe,
    pub tmh: ibv_tmh,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe64__bindgen_ty_1__bindgen_ty_1 {
    pub rsvd0: [u8; 2usize],
    pub wqe_id: __be16,
    pub rsvd4: [u8; 13usize],
    pub ml_path: u8,
    pub rsvd20: [u8; 4usize],
    pub slid: __be16,
    pub flags_rqpn: __be32,
    pub hds_ip_ext: u8,
    pub l4_hdr_type_etc: u8,
    pub vlan_info: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_srq_next_seg {
    pub rsvd0: [u8; 2usize],
    pub next_wqe_index: __be16,
    pub signature: u8,
    pub rsvd1: [u8; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_data_seg {
    pub byte_count: __be32,
    pub lkey: __be32,
    pub addr: __be64,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_ctrl_seg {
    pub opmod_idx_opcode: __be32,
    pub qpn_ds: __be32,
    pub signature: u8,
    pub dci_stream_channel_id: __be16,
    pub fm_ce_se: u8,
    pub imm: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mprq_wqe {
    pub nseg: mlx5_wqe_srq_next_seg,
    pub dseg: mlx5_wqe_data_seg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_av {
    pub key: mlx5_wqe_av__bindgen_ty_1,
    pub dqp_dct: __be32,
    pub stat_rate_sl: u8,
    pub fl_mlid: u8,
    pub rlid: __be16,
    pub reserved0: [u8; 4usize],
    pub rmac: [u8; 6usize],
    pub tclass: u8,
    pub hop_limit: u8,
    pub grh_gid_fl: __be32,
    pub rgid: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_av__bindgen_ty_1 {
    pub qkey: mlx5_wqe_av__bindgen_ty_1__bindgen_ty_1,
    pub dc_key: __be64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_av__bindgen_ty_1__bindgen_ty_1 {
    pub qkey: __be32,
    pub reserved: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_datagram_seg {
    pub av: mlx5_wqe_av,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_raddr_seg {
    pub raddr: __be64,
    pub rkey: __be32,
    pub reserved: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_atomic_seg {
    pub swap_add: __be64,
    pub compare: __be64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_inl_data_seg {
    pub byte_count: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eth_seg {
    pub rsvd0: __be32,
    pub cs_flags: u8,
    pub rsvd1: u8,
    pub mss: __be16,
    pub rsvd2: __be32,
    pub inline_hdr_sz: __be16,
    pub inline_hdr_start: [u8; 2usize],
    pub inline_hdr: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_tm_seg {
    pub opcode: u8,
    pub flags: u8,
    pub index: __be16,
    pub rsvd0: [u8; 2usize],
    pub sw_cnt: __be16,
    pub rsvd1: [u8; 8usize],
    pub append_tag: __be64,
    pub append_mask: __be64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_umr_ctrl_seg {
    pub flags: u8,
    pub rsvd0: [u8; 3usize],
    pub klm_octowords: __be16,
    pub __bindgen_anon_1: mlx5_wqe_umr_ctrl_seg__bindgen_ty_1,
    pub mkey_mask: __be64,
    pub rsvd1: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_umr_ctrl_seg__bindgen_ty_1 {
    pub translation_offset: __be16,
    pub bsf_octowords: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_umr_klm_seg {
    pub byte_count: __be32,
    pub mkey: __be32,
    pub address: __be64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_umr_inline_seg {
    pub klm: mlx5_wqe_umr_klm_seg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_umr_repeat_ent_seg {
    pub stride: __be16,
    pub byte_count: __be16,
    pub memkey: __be32,
    pub va: __be64,
}
#[repr(C)]
pub struct mlx5_wqe_umr_repeat_block_seg {
    pub byte_count: __be32,
    pub op: __be32,
    pub repeat_count: __be32,
    pub reserved: __be16,
    pub num_ent: __be16,
    pub entries: __IncompleteArrayField<mlx5_wqe_umr_repeat_ent_seg>,
}
#[repr(C)]
pub struct mlx5_wqe_mkey_context_seg {
    pub free: u8,
    pub reserved1: u8,
    pub access_flags: u8,
    pub sf: u8,
    pub qpn_mkey: __be32,
    pub reserved2: __be32,
    pub flags_pd: __be32,
    pub start_addr: __be64,
    pub len: __be64,
    pub bsf_octword_size: __be32,
    pub reserved3: [__be32; 4usize],
    pub translations_octword_size: __be32,
    pub reserved4: [u8; 3usize],
    pub log_page_size: u8,
    pub reserved: __be32,
    pub inseg: __IncompleteArrayField<mlx5_wqe_umr_inline_seg>,
}
pub const mlx5dv_set_ctx_attr_type_MLX5DV_CTX_ATTR_BUF_ALLOCATORS: mlx5dv_set_ctx_attr_type = 1;
pub type mlx5dv_set_ctx_attr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx_obj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx_umem {
    pub umem_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx_uar {
    pub reg_addr: *mut ::std::os::raw::c_void,
    pub base_addr: *mut ::std::os::raw::c_void,
    pub page_id: u32,
    pub mmap_off: off_t,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_var {
    pub page_id: u32,
    pub length: u32,
    pub mmap_off: off_t,
    pub comp_mask: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx_cmd_comp {
    pub fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_devx_event_channel {
    pub fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_action {
    _unused: [u8; 0],
}
pub const mlx5dv_dr_domain_type_MLX5DV_DR_DOMAIN_TYPE_NIC_RX: mlx5dv_dr_domain_type = 0;
pub const mlx5dv_dr_domain_type_MLX5DV_DR_DOMAIN_TYPE_NIC_TX: mlx5dv_dr_domain_type = 1;
pub const mlx5dv_dr_domain_type_MLX5DV_DR_DOMAIN_TYPE_FDB: mlx5dv_dr_domain_type = 2;
pub type mlx5dv_dr_domain_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_flow_meter_attr {
    pub next_table: *mut mlx5dv_dr_table,
    pub active: u8,
    pub reg_c_index: u8,
    pub flow_meter_parameter_sz: usize,
    pub flow_meter_parameter: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_flow_sampler_attr {
    pub sample_ratio: u32,
    pub default_next_table: *mut mlx5dv_dr_table,
    pub num_sample_actions: u32,
    pub sample_actions: *mut *mut mlx5dv_dr_action,
    pub action: __be64,
}
pub const mlx5dv_dr_action_dest_type_MLX5DV_DR_ACTION_DEST: mlx5dv_dr_action_dest_type = 0;
pub const mlx5dv_dr_action_dest_type_MLX5DV_DR_ACTION_DEST_REFORMAT: mlx5dv_dr_action_dest_type = 1;
pub type mlx5dv_dr_action_dest_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_action_dest_reformat {
    pub reformat: *mut mlx5dv_dr_action,
    pub dest: *mut mlx5dv_dr_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_dr_action_dest_attr {
    pub type_: mlx5dv_dr_action_dest_type,
    pub __bindgen_anon_1: mlx5dv_dr_action_dest_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5dv_dr_action_dest_attr__bindgen_ty_1 {
    pub dest: *mut mlx5dv_dr_action,
    pub dest_reformat: *mut mlx5dv_dr_action_dest_reformat,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dv_pp {
    pub index: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_set_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_set_description {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_set_init_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_query_counter_set_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_info {
    pub query_flags: u16,
    pub vport_id: u16,
    pub esw_owner_vhca_id: u16,
    pub vport_meta_tag: u32,
    pub vport_meta_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_glue {
    pub version: *const ::std::os::raw::c_char,
    pub fork_init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub alloc_pd:
        ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context) -> *mut ibv_pd>,
    pub dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> ::std::os::raw::c_int>,
    pub import_pd: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context, pd_handle: u32) -> *mut ibv_pd,
    >,
    pub unimport_pd:
        ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> ::std::os::raw::c_int>,
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_device,
    >,
    pub free_device_list: ::std::option::Option<unsafe extern "C" fn(list: *mut *mut ibv_device)>,
    pub open_device:
        ::std::option::Option<unsafe extern "C" fn(device: *mut ibv_device) -> *mut ibv_context>,
    pub import_device: ::std::option::Option<
        unsafe extern "C" fn(cmd_fd: ::std::os::raw::c_int) -> *mut ibv_context,
    >,
    pub close_device: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context) -> ::std::os::raw::c_int,
    >,
    pub query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_device_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            input: *const ibv_query_device_ex_input,
            attr: *mut ibv_device_attr_ex,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_device_name: ::std::option::Option<
        unsafe extern "C" fn(device: *mut ibv_device) -> *const ::std::os::raw::c_char,
    >,
    pub query_rt_values_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            values: *mut ibv_values_ex,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_comp_channel: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context) -> *mut ibv_comp_channel,
    >,
    pub destroy_comp_channel: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut ibv_comp_channel) -> ::std::os::raw::c_int,
    >,
    pub create_cq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            cqe: ::std::os::raw::c_int,
            cq_context: *mut ::std::os::raw::c_void,
            channel: *mut ibv_comp_channel,
            comp_vector: ::std::os::raw::c_int,
        ) -> *mut ibv_cq,
    >,
    pub destroy_cq:
        ::std::option::Option<unsafe extern "C" fn(cq: *mut ibv_cq) -> ::std::os::raw::c_int>,
    pub get_cq_event: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut ibv_comp_channel,
            cq: *mut *mut ibv_cq,
            cq_context: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub ack_cq_events: ::std::option::Option<
        unsafe extern "C" fn(cq: *mut ibv_cq, nevents: ::std::os::raw::c_uint),
    >,
    pub create_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_rwq_ind_table_init_attr,
        ) -> *mut ibv_rwq_ind_table,
    >,
    pub destroy_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(rwq_ind_table: *mut ibv_rwq_ind_table) -> ::std::os::raw::c_int,
    >,
    pub create_wq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            wq_init_attr: *mut ibv_wq_init_attr,
        ) -> *mut ibv_wq,
    >,
    pub destroy_wq:
        ::std::option::Option<unsafe extern "C" fn(wq: *mut ibv_wq) -> ::std::os::raw::c_int>,
    pub modify_wq: ::std::option::Option<
        unsafe extern "C" fn(wq: *mut ibv_wq, wq_attr: *mut ibv_wq_attr) -> ::std::os::raw::c_int,
    >,
    pub create_flow: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp, flow: *mut ibv_flow_attr) -> *mut ibv_flow,
    >,
    pub destroy_flow: ::std::option::Option<
        unsafe extern "C" fn(flow_id: *mut ibv_flow) -> ::std::os::raw::c_int,
    >,
    pub destroy_flow_action: ::std::option::Option<
        unsafe extern "C" fn(action: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub create_qp: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, qp_init_attr: *mut ibv_qp_init_attr) -> *mut ibv_qp,
    >,
    pub create_qp_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            qp_init_attr_ex: *mut ibv_qp_init_attr_ex,
        ) -> *mut ibv_qp,
    >,
    pub destroy_qp:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp) -> ::std::os::raw::c_int>,
    pub modify_qp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            attr: *mut ibv_qp_attr,
            attr_mask: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub reg_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            addr: *mut ::std::os::raw::c_void,
            length: usize,
            access: ::std::os::raw::c_int,
        ) -> *mut ibv_mr,
    >,
    pub reg_mr_iova: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            addr: *mut ::std::os::raw::c_void,
            length: usize,
            iova: u64,
            access: ::std::os::raw::c_int,
        ) -> *mut ibv_mr,
    >,
    pub alloc_null_mr: ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> *mut ibv_mr>,
    pub dereg_mr:
        ::std::option::Option<unsafe extern "C" fn(mr: *mut ibv_mr) -> ::std::os::raw::c_int>,
    pub create_counter_set: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_counter_set_init_attr,
        ) -> *mut ibv_counter_set,
    >,
    pub destroy_counter_set: ::std::option::Option<
        unsafe extern "C" fn(cs: *mut ibv_counter_set) -> ::std::os::raw::c_int,
    >,
    pub describe_counter_set: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            counter_set_id: u16,
            cs_desc: *mut ibv_counter_set_description,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_counter_set: ::std::option::Option<
        unsafe extern "C" fn(
            query_attr: *mut ibv_query_counter_set_attr,
            cs_data: *mut ibv_counter_set_data,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_counters: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_counters_init_attr,
        ) -> *mut ibv_counters,
    >,
    pub destroy_counters: ::std::option::Option<
        unsafe extern "C" fn(counters: *mut ibv_counters) -> ::std::os::raw::c_int,
    >,
    pub attach_counters: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            attr: *mut ibv_counter_attach_attr,
            flow: *mut ibv_flow,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_counters: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            counters_value: *mut u64,
            ncounters: u32,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub ack_async_event: ::std::option::Option<unsafe extern "C" fn(event: *mut ibv_async_event)>,
    pub get_async_event: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            event: *mut ibv_async_event,
        ) -> ::std::os::raw::c_int,
    >,
    pub port_state_str: ::std::option::Option<
        unsafe extern "C" fn(port_state: ibv_port_state) -> *const ::std::os::raw::c_char,
    >,
    pub cq_ex_to_cq: ::std::option::Option<unsafe extern "C" fn(cq: *mut ibv_cq_ex) -> *mut ibv_cq>,
    pub dr_create_flow_action_dest_flow_tbl: ::std::option::Option<
        unsafe extern "C" fn(tbl: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_create_flow_action_dest_port: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut ::std::os::raw::c_void,
            port: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_create_flow_action_drop:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub dr_create_flow_action_push_vlan: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut mlx5dv_dr_domain,
            vlan_tag: rte_be32_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_create_flow_action_pop_vlan:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub dr_create_flow_tbl: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut ::std::os::raw::c_void,
            level: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_destroy_flow_tbl: ::std::option::Option<
        unsafe extern "C" fn(tbl: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub dr_create_domain: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            domain: mlx5dv_dr_domain_type,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_destroy_domain: ::std::option::Option<
        unsafe extern "C" fn(domain: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub dr_sync_domain: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut ::std::os::raw::c_void,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub dv_create_cq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            cq_attr: *mut ibv_cq_init_attr_ex,
            mlx5_cq_attr: *mut mlx5dv_cq_init_attr,
        ) -> *mut ibv_cq_ex,
    >,
    pub dv_create_wq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            wq_attr: *mut ibv_wq_init_attr,
            mlx5_wq_attr: *mut mlx5dv_wq_init_attr,
        ) -> *mut ibv_wq,
    >,
    pub dv_query_device: ::std::option::Option<
        unsafe extern "C" fn(
            ctx_in: *mut ibv_context,
            attrs_out: *mut mlx5dv_context,
        ) -> ::std::os::raw::c_int,
    >,
    pub dv_set_context_attr: ::std::option::Option<
        unsafe extern "C" fn(
            ibv_ctx: *mut ibv_context,
            type_: mlx5dv_set_ctx_attr_type,
            attr: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub dv_init_obj: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut mlx5dv_obj, obj_type: u64) -> ::std::os::raw::c_int,
    >,
    pub dv_create_qp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            qp_init_attr_ex: *mut ibv_qp_init_attr_ex,
            dv_qp_init_attr: *mut mlx5dv_qp_init_attr,
        ) -> *mut ibv_qp,
    >,
    pub dv_create_flow_matcher: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            matcher_attr: *mut mlx5dv_flow_matcher_attr,
            tbl: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_matcher_root: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            matcher_attr: *mut mlx5dv_flow_matcher_attr,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow: ::std::option::Option<
        unsafe extern "C" fn(
            matcher: *mut ::std::os::raw::c_void,
            match_value: *mut ::std::os::raw::c_void,
            num_actions: usize,
            actions: *mut *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_root: ::std::option::Option<
        unsafe extern "C" fn(
            matcher: *mut ::std::os::raw::c_void,
            match_value: *mut ::std::os::raw::c_void,
            num_actions: usize,
            actions: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_counter: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            offset: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_dest_ibv_qp: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_dest_devx_tir: ::std::option::Option<
        unsafe extern "C" fn(tir: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_modify_header: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            ft_type: mlx5_ib_uapi_flow_table_type,
            domain: *mut ::std::os::raw::c_void,
            flags: u64,
            actions_sz: usize,
            actions: *mut u64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_modify_header_root: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            actions_sz: usize,
            actions: *mut u64,
            ft_type: mlx5_ib_uapi_flow_table_type,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_packet_reformat: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            reformat_type: mlx5_ib_uapi_flow_action_packet_reformat_type,
            ft_type: mlx5_ib_uapi_flow_table_type,
            domain: *mut mlx5dv_dr_domain,
            flags: u32,
            data_sz: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_packet_reformat_root: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            data_sz: usize,
            data: *mut ::std::os::raw::c_void,
            reformat_type: mlx5_ib_uapi_flow_action_packet_reformat_type,
            ft_type: mlx5_ib_uapi_flow_table_type,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_tag:
        ::std::option::Option<unsafe extern "C" fn(tag: u32) -> *mut ::std::os::raw::c_void>,
    pub dv_create_flow_action_meter: ::std::option::Option<
        unsafe extern "C" fn(attr: *mut mlx5dv_dr_flow_meter_attr) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_modify_flow_action_meter: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut ::std::os::raw::c_void,
            attr: *mut mlx5dv_dr_flow_meter_attr,
            modify_bits: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub dr_create_flow_action_default_miss:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub dv_destroy_flow: ::std::option::Option<
        unsafe extern "C" fn(flow: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub dv_destroy_flow_matcher: ::std::option::Option<
        unsafe extern "C" fn(matcher: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub dv_destroy_flow_matcher_root: ::std::option::Option<
        unsafe extern "C" fn(matcher: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub dv_open_device:
        ::std::option::Option<unsafe extern "C" fn(device: *mut ibv_device) -> *mut ibv_context>,
    pub dv_alloc_var: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context, flags: u32) -> *mut mlx5dv_var,
    >,
    pub dv_free_var: ::std::option::Option<unsafe extern "C" fn(var: *mut mlx5dv_var)>,
    pub devx_alloc_uar: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context, flags: u32) -> *mut mlx5dv_devx_uar,
    >,
    pub devx_free_uar: ::std::option::Option<unsafe extern "C" fn(devx_uar: *mut mlx5dv_devx_uar)>,
    pub devx_obj_create: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> *mut mlx5dv_devx_obj,
    >,
    pub devx_obj_destroy: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut mlx5dv_devx_obj) -> ::std::os::raw::c_int,
    >,
    pub devx_obj_query: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut mlx5dv_devx_obj,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_obj_modify: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut mlx5dv_devx_obj,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_general_cmd: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_create_cmd_comp: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context) -> *mut mlx5dv_devx_cmd_comp,
    >,
    pub devx_destroy_cmd_comp:
        ::std::option::Option<unsafe extern "C" fn(cmd_comp: *mut mlx5dv_devx_cmd_comp)>,
    pub devx_obj_query_async: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut mlx5dv_devx_obj,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            outlen: usize,
            wr_id: u64,
            cmd_comp: *mut mlx5dv_devx_cmd_comp,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_get_async_cmd_comp: ::std::option::Option<
        unsafe extern "C" fn(
            cmd_comp: *mut mlx5dv_devx_cmd_comp,
            resp: *mut mlx5_ib_uapi_devx_async_cmd_hdr,
            cmd_resp_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_umem_reg: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            addr: *mut ::std::os::raw::c_void,
            size: usize,
            access: u32,
        ) -> *mut mlx5dv_devx_umem,
    >,
    pub devx_umem_dereg: ::std::option::Option<
        unsafe extern "C" fn(dv_devx_umem: *mut mlx5dv_devx_umem) -> ::std::os::raw::c_int,
    >,
    pub devx_qp_query: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_wq_query: ::std::option::Option<
        unsafe extern "C" fn(
            wq: *mut ibv_wq,
            in_: *const ::std::os::raw::c_void,
            inlen: usize,
            out: *mut ::std::os::raw::c_void,
            outlen: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_port_query: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ibv_context,
            port_num: u32,
            info: *mut mlx5_port_info,
        ) -> ::std::os::raw::c_int,
    >,
    pub dr_dump_domain: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut FILE,
            domain: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub dr_dump_rule: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut FILE,
            rule: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_query_eqn: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            cpus: u32,
            eqn: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_create_event_channel: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            flags: ::std::os::raw::c_int,
        ) -> *mut mlx5dv_devx_event_channel,
    >,
    pub devx_destroy_event_channel:
        ::std::option::Option<unsafe extern "C" fn(event_channel: *mut mlx5dv_devx_event_channel)>,
    pub devx_subscribe_devx_event: ::std::option::Option<
        unsafe extern "C" fn(
            event_channel: *mut mlx5dv_devx_event_channel,
            obj: *mut mlx5dv_devx_obj,
            events_sz: u16,
            events_num: *mut u16,
            cookie: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_subscribe_devx_event_fd: ::std::option::Option<
        unsafe extern "C" fn(
            event_channel: *mut mlx5dv_devx_event_channel,
            fd: ::std::os::raw::c_int,
            obj: *mut mlx5dv_devx_obj,
            event_num: u16,
        ) -> ::std::os::raw::c_int,
    >,
    pub devx_get_event: ::std::option::Option<
        unsafe extern "C" fn(
            event_channel: *mut mlx5dv_devx_event_channel,
            event_data: *mut mlx5_ib_uapi_devx_async_event_hdr,
            event_resp_len: usize,
        ) -> isize,
    >,
    pub dr_reclaim_domain_memory: ::std::option::Option<
        unsafe extern "C" fn(domain: *mut ::std::os::raw::c_void, enable: u32),
    >,
    pub dr_allow_duplicate_rules: ::std::option::Option<
        unsafe extern "C" fn(domain: *mut ::std::os::raw::c_void, allow: u32),
    >,
    pub dv_alloc_pp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            pp_context_sz: usize,
            pp_context: *const ::std::os::raw::c_void,
            flags: u32,
        ) -> *mut mlx5dv_pp,
    >,
    pub dv_free_pp: ::std::option::Option<unsafe extern "C" fn(pp: *mut mlx5dv_pp)>,
    pub dr_create_flow_action_sampler: ::std::option::Option<
        unsafe extern "C" fn(attr: *mut mlx5dv_dr_flow_sampler_attr) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_create_flow_action_dest_array: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut ::std::os::raw::c_void,
            num_dest: usize,
            dests: *mut *mut mlx5dv_dr_action_dest_attr,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dv_create_flow_action_aso: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *mut mlx5dv_dr_domain,
            aso_obj: *mut ::std::os::raw::c_void,
            offset: u32,
            flags: u32,
            return_reg_c: u8,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub dr_create_flow_action_send_to_kernel: ::std::option::Option<
        unsafe extern "C" fn(
            tbl: *mut ::std::os::raw::c_void,
            priority: u16,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub create_steering_anchor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut mlx5dv_steering_anchor_attr,
        ) -> *mut mlx5dv_steering_anchor,
    >,
    pub destroy_steering_anchor: ::std::option::Option<
        unsafe extern "C" fn(sa: *mut mlx5dv_steering_anchor) -> ::std::os::raw::c_int,
    >,
}
pub const mlx5_mp_req_type_MLX5_MP_REQ_VERBS_CMD_FD: mlx5_mp_req_type = 1;
pub const mlx5_mp_req_type_MLX5_MP_REQ_CREATE_MR: mlx5_mp_req_type = 2;
pub const mlx5_mp_req_type_MLX5_MP_REQ_MEMPOOL_REGISTER: mlx5_mp_req_type = 3;
pub const mlx5_mp_req_type_MLX5_MP_REQ_MEMPOOL_UNREGISTER: mlx5_mp_req_type = 4;
pub const mlx5_mp_req_type_MLX5_MP_REQ_START_RXTX: mlx5_mp_req_type = 5;
pub const mlx5_mp_req_type_MLX5_MP_REQ_STOP_RXTX: mlx5_mp_req_type = 6;
pub const mlx5_mp_req_type_MLX5_MP_REQ_QUEUE_STATE_MODIFY: mlx5_mp_req_type = 7;
pub const mlx5_mp_req_type_MLX5_MP_REQ_QUEUE_RX_STOP: mlx5_mp_req_type = 8;
pub const mlx5_mp_req_type_MLX5_MP_REQ_QUEUE_RX_START: mlx5_mp_req_type = 9;
pub const mlx5_mp_req_type_MLX5_MP_REQ_QUEUE_TX_STOP: mlx5_mp_req_type = 10;
pub const mlx5_mp_req_type_MLX5_MP_REQ_QUEUE_TX_START: mlx5_mp_req_type = 11;
pub type mlx5_mp_req_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_arg_queue_state_modify {
    pub is_wq: u8,
    pub queue_id: u16,
    pub state: ibv_wq_state,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_arg_queue_id {
    pub queue_id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_arg_mr_manage {
    pub cdev: *mut mlx5_common_device,
    pub __bindgen_anon_1: mlx5_mp_arg_mr_manage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_mp_arg_mr_manage__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_mp_arg_mr_manage__bindgen_ty_1__bindgen_ty_1,
    pub addr: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_arg_mr_manage__bindgen_ty_1__bindgen_ty_1 {
    pub mempool: *mut rte_mempool,
    pub is_extmem: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_param {
    pub type_: mlx5_mp_req_type,
    pub port_id: ::std::os::raw::c_int,
    pub result: ::std::os::raw::c_int,
    pub args: mlx5_mp_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_mp_param__bindgen_ty_1 {
    pub mr_manage: mlx5_mp_arg_mr_manage,
    pub state_modify: mlx5_mp_arg_queue_state_modify,
    pub queue_id: mlx5_mp_arg_queue_id,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mp_id {
    pub name: [::std::os::raw::c_char; 64usize],
    pub port_id: u16,
}
unsafe extern "C" {
    pub fn mlx5_mp_init_primary(
        name: *const ::std::os::raw::c_char,
        primary_action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_uninit_primary(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn mlx5_mp_init_secondary(
        name: *const ::std::os::raw::c_char,
        secondary_action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_uninit_secondary(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn mlx5_mp_req_mr_create(
        cdev: *mut mlx5_common_device,
        addr: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_req_mempool_reg(
        cdev: *mut mlx5_common_device,
        mempool: *mut rte_mempool,
        reg: bool,
        is_extmem: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_req_queue_state_modify(
        mp_id: *mut mlx5_mp_id,
        sm: *mut mlx5_mp_arg_queue_state_modify,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_req_verbs_cmd_fd(mp_id: *mut mlx5_mp_id) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub mkey: *mut mlx5_devx_obj,
}
#[doc = " mr operations typedef"]
pub type mlx5_reg_mr_t = ::std::option::Option<
    unsafe extern "C" fn(
        pd: *mut ::std::os::raw::c_void,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        pmd_mr: *mut mlx5_pmd_mr,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_dereg_mr_t = ::std::option::Option<unsafe extern "C" fn(pmd_mr: *mut mlx5_pmd_mr)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr {
    #[doc = "< Pointer to the prev/next entry."]
    pub mr: mlx5_mr__bindgen_ty_1,
    pub pmd_mr: mlx5_pmd_mr,
    pub msl: *const rte_memseg_list,
    pub ms_base_idx: ::std::os::raw::c_int,
    pub ms_n: ::std::os::raw::c_int,
    pub ms_bmp_n: u32,
    pub ms_bmp: *mut rte_bitmap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr__bindgen_ty_1 {
    pub le_next: *mut mlx5_mr,
    pub le_prev: *mut *mut mlx5_mr,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mr_cache_entry {
    pub start: usize,
    pub end: usize,
    pub lkey: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_btree {
    pub len: u32,
    pub size: u32,
    pub table: *mut [mr_cache_entry; 0usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_ctrl {
    pub dev_gen_ptr: *mut u32,
    pub cur_gen: u32,
    pub mru: u16,
    pub head: u16,
    pub cache: [mr_cache_entry; 8usize],
    pub cache_bh: mlx5_mr_btree,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_list {
    pub lh_first: *mut mlx5_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg_list {
    pub lh_first: *mut mlx5_mempool_reg,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_share_cache {
    pub dev_gen: u32,
    pub rwlock: rte_rwlock_t,
    pub mprwlock: rte_rwlock_t,
    pub cache: mlx5_mr_btree,
    pub mr_list: mlx5_mr_list,
    pub mr_free_list: mlx5_mr_list,
    pub mempool_reg_list: mlx5_mempool_reg_list,
    pub reg_mr_cb: mlx5_reg_mr_t,
    pub dereg_mr_cb: mlx5_dereg_mr_t,
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_mprq_buf {
    pub mp: *mut rte_mempool,
    pub refcnt: u16,
    pub shinfos: __IncompleteArrayField<rte_mbuf_ext_shared_info>,
}
unsafe extern "C" {
    pub fn mlx5_mprq_buf_free_cb(
        addr: *mut ::std::os::raw::c_void,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn mlx5_mr_flush_local_cache(mr_ctrl: *mut mlx5_mr_ctrl);
}
unsafe extern "C" {
    #[doc = " Bottom-half of LKey search on. If supported, lookup for the address from\n the mempool. Otherwise, search in old mechanism caches.\n\n @param mr_ctrl\n   Pointer to per-queue MR control structure.\n @param mb\n   Pointer to mbuf.\n\n @return\n   Searched LKey on success, UINT32_MAX on no match."]
    pub fn mlx5_mr_mb2mr_bh(mr_ctrl: *mut mlx5_mr_ctrl, mbuf: *mut rte_mbuf) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_mr_ctrl_init(
        mr_ctrl: *mut mlx5_mr_ctrl,
        dev_gen_ptr: *mut u32,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_btree_free(bt: *mut mlx5_mr_btree);
}
unsafe extern "C" {
    pub fn mlx5_mr_btree_dump(bt: *mut mlx5_mr_btree);
}
unsafe extern "C" {
    pub fn mlx5_mr_mempool2mr_bh(
        mr_ctrl: *mut mlx5_mr_ctrl,
        mp: *mut rte_mempool,
        addr: usize,
    ) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_mr_expand_cache(
        share_cache: *mut mlx5_mr_share_cache,
        new_size: u32,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_release_cache(mr_cache: *mut mlx5_mr_share_cache);
}
unsafe extern "C" {
    pub fn mlx5_mr_create_cache(
        share_cache: *mut mlx5_mr_share_cache,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_dump_cache(share_cache: *mut mlx5_mr_share_cache);
}
unsafe extern "C" {
    pub fn mlx5_mr_rebuild_cache(share_cache: *mut mlx5_mr_share_cache);
}
unsafe extern "C" {
    pub fn mlx5_free_mr_by_addr(
        share_cache: *mut mlx5_mr_share_cache,
        ibdev_name: *const ::std::os::raw::c_char,
        addr: *const ::std::os::raw::c_void,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn mlx5_mr_insert_cache(
        share_cache: *mut mlx5_mr_share_cache,
        mr: *mut mlx5_mr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_lookup_list(
        share_cache: *mut mlx5_mr_share_cache,
        entry: *mut mr_cache_entry,
        addr: usize,
    ) -> *mut mlx5_mr;
}
unsafe extern "C" {
    pub fn mlx5_create_mr_ext(
        pd: *mut ::std::os::raw::c_void,
        addr: usize,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        reg_mr_cb: mlx5_reg_mr_t,
    ) -> *mut mlx5_mr;
}
unsafe extern "C" {
    pub fn mlx5_mr_free(mr: *mut mlx5_mr, dereg_mr_cb: mlx5_dereg_mr_t);
}
unsafe extern "C" {
    pub fn mlx5_mr_create(
        cdev: *mut mlx5_common_device,
        share_cache: *mut mlx5_mr_share_cache,
        entry: *mut mr_cache_entry,
        addr: usize,
    ) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_mr_addr2mr_bh(mr_ctrl: *mut mlx5_mr_ctrl, addr: usize) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_common_verbs_reg_mr(
        pd: *mut ::std::os::raw::c_void,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        pmd_mr: *mut mlx5_pmd_mr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_common_verbs_dereg_mr(pmd_mr: *mut mlx5_pmd_mr);
}
unsafe extern "C" {
    pub fn mlx5_os_set_reg_mr_cb(reg_mr_cb: *mut mlx5_reg_mr_t, dereg_mr_cb: *mut mlx5_dereg_mr_t);
}
unsafe extern "C" {
    pub fn mlx5_mr_mempool_register(
        cdev: *mut mlx5_common_device,
        mp: *mut rte_mempool,
        is_extmem: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_mempool_unregister(
        cdev: *mut mlx5_common_device,
        mp: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mr_mempool_populate_cache(
        mr_ctrl: *mut mlx5_mr_ctrl,
        mp: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure describing an ID for a PCI driver. Each driver provides a\n table of these IDs for each device that it supports."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_id {
    #[doc = "< Class ID or RTE_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or RTE_PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or RTE_PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or RTE_PCI_ANY_ID."]
    pub subsystem_vendor_id: u16,
    #[doc = "< Subsystem device ID or RTE_PCI_ANY_ID."]
    pub subsystem_device_id: u16,
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
#[doc = " Ethernet address:\n A universally administered address is uniquely assigned to a device by its\n manufacturer. The first three octets (in transmission order) contain the\n Organizationally Unique Identifier (OUI). The following three (MAC-48 and\n EUI-48) octets are assigned by that organization with the only constraint\n of uniqueness.\n A locally administered address is assigned to a device by a network\n administrator and does not contain OUIs.\n See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct rte_ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[doc = " Ethernet header: Contains the destination address, source address\n and frame type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ether_hdr {
    #[doc = "< Destination address."]
    pub dst_addr: rte_ether_addr,
    #[doc = "< Source address."]
    pub src_addr: rte_ether_addr,
    #[doc = "< Frame type."]
    pub ether_type: rte_be16_t,
}
#[doc = " Ethernet VLAN Header.\n Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type\n of the encapsulated frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_hdr {
    #[doc = "< Priority (3) + CFI (1) + Identifier Code (12)"]
    pub vlan_tci: rte_be16_t,
    #[doc = "< Ethernet type of encapsulated frame."]
    pub eth_proto: rte_be16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bus {
    _unused: [u8; 0],
}
pub const rte_dev_policy_RTE_DEV_ALLOWED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLOCKED: rte_dev_policy = 1;
#[doc = " Device policies."]
pub type rte_dev_policy = ::std::os::raw::c_uint;
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Device bus specific information"]
    pub bus_info: *const ::std::os::raw::c_char,
    #[doc = "< Driver assigned after probing"]
    pub driver: *const rte_driver,
    #[doc = "< Bus handle assigned on scan"]
    pub bus: *const rte_bus,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Arguments for latest probing"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[doc = " Congestion based on Random Early Detection.\n\n https://en.wikipedia.org/wiki/Random_early_detection\n http://www.aciri.org/floyd/papers/red/red.html\n @see struct rte_cman_red_params"]
pub const rte_cman_mode_RTE_CMAN_RED: rte_cman_mode = 1;
#[doc = " Congestion management modes"]
pub type rte_cman_mode = ::std::os::raw::c_uint;
#[doc = " RED based congestion management configuration parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_cman_red_params {
    #[doc = " Minimum threshold (min_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub min_th: u8,
    #[doc = " Maximum threshold (max_th) value\n\n Value expressed as percentage. Value must be in 0 to 100(inclusive)."]
    pub max_th: u8,
    #[doc = " Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv)"]
    pub maxp_inv: u16,
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    _unused: [u8; 0],
}
#[doc = " Function to be registered for the specific interrupt"]
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
pub const rte_devtype_RTE_DEVTYPE_ALLOWED: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLOCKED: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
#[doc = " Type of generic device"]
pub type rte_devtype = ::std::os::raw::c_uint;
#[doc = " Structure that stores a device given by the user with its arguments\n\n A user device is a physical or a virtual device given by the user to\n the DPDK application at startup through command line arguments.\n\n The structure stores the configuration of the device, its PCI\n identifier if it's a PCI device or the driver name if it's a virtual\n device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< raw string including bus, class and driver parts."]
    pub data: *mut ::std::os::raw::c_char,
}
#[doc = " Next in list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = "< legacy name."]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< driver-related part of device string."]
    pub drv_str: *const ::std::os::raw::c_char,
}
#[doc = " Callback definition for monitoring conditions. Callbacks with this signature\n will be used by `rte_power_monitor()` to check if the entering of power\n optimized state should be aborted.\n\n @param val\n   The value read from memory.\n @param opaque\n   Callback-specific data.\n\n @return\n   0 if entering of power optimized state should proceed\n   -1 if entering of power optimized state should be aborted"]
pub type rte_power_monitor_clb_t = ::std::option::Option<
    unsafe extern "C" fn(val: u64, opaque: *const u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_power_monitor_cond {
    #[doc = "< Address to monitor for changes"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (in bytes) that will be read from the\n   monitored memory location (`addr`). Can be 1, 2,\n   4, or 8. Supplying any other value will result in\n   an error."]
    pub size: u8,
    #[doc = "< Callback to be used to check if\n   entering power optimized state should\n   be aborted."]
    pub fn_: rte_power_monitor_clb_t,
    pub opaque: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_reg_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
    #[doc = " Name of target module, filter for target subset of registers.\n This field could affects register selection for data/length/names."]
    pub filter: *const ::std::os::raw::c_char,
    #[doc = "< Registers name saver"]
    pub names: *mut rte_eth_reg_name,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return EEPROM"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start EEPROM address for access"]
    pub offset: u32,
    #[doc = "< Length of EEPROM region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[doc = " Placeholder for accessing plugin module EEPROM"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module EEPROM"]
    pub type_: u32,
    #[doc = "< Length of plugin module EEPROM"]
    pub eeprom_len: u32,
}
#[doc = " A structure used to retrieve statistics for an Ethernet port.\n Not all statistics fields in struct rte_eth_stats are supported\n by any type of network interface card (NIC). If any statistics\n field is not supported, its value is 0.\n All byte-related statistics do not include Ethernet FCS regardless\n of whether these bytes have been delivered to the application\n (see RTE_ETH_RX_OFFLOAD_KEEP_CRC)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    #[doc = " Total of Rx packets dropped by the HW,\n because there are no available buffer (i.e. Rx queues are full)."]
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of Rx mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = " Total number of queue Rx packets."]
    pub q_ipackets: [u64; 16usize],
    #[doc = " Total number of queue Tx packets."]
    pub q_opackets: [u64; 16usize],
    #[doc = " Total number of successfully received queue bytes."]
    pub q_ibytes: [u64; 16usize],
    #[doc = " Total number of successfully transmitted queue bytes."]
    pub q_obytes: [u64; 16usize],
    #[doc = " Total number of queue packets received that are dropped."]
    pub q_errors: [u64; 16usize],
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link {
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_link__bindgen_ty_1 {
    #[doc = "< used for atomic64 read/write"]
    pub val64: u64,
    pub __bindgen_anon_1: rte_eth_link__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< RTE_ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_link__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_duplex_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_duplex_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_autoneg_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_autoneg_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_status_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to get and set lanes capabilities per link speed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_speed_lanes_capa {
    pub speed: u32,
    pub capa: u32,
}
#[doc = " A structure used to configure the ring threshold registers of an Rx/Tx\n queue for an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[doc = " None of DCB, RSS or VMDq mode"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For Rx side, only RSS is on"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For Rx side,only DCB is on."]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDq, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDq+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDq and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route\n  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = ::std::os::raw::c_uint;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For Tx side,only DCB is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For Tx side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit\n packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Rx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Requested MTU."]
    pub mtu: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = " Per-port Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_RTE_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.\n Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = ::std::os::raw::c_uint;
#[doc = " A structure used to describe a VLAN filter.\n If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[doc = " DEFAULT means driver decides which hash algorithm to pick."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT:
    rte_eth_hash_function = 4;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 5;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature\n of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = " In rte_eth_dev_rss_hash_conf_get(), the *rss_key_len* should be\n greater than or equal to the *hash_key_size* which get from\n rte_eth_dev_info_get() API. And the *rss_key* should contain at least\n *hash_key_size* bytes. If not meet these requirements, the query\n result is unreliable even if the operation returns success.\n\n In rte_eth_dev_rss_hash_update() or rte_eth_dev_configure(), if\n *rss_key* is not NULL, the *rss_key_len* indicates the length of the\n *rss_key* in bytes and it should be equal to *hash_key_size*.\n If *rss_key* is NULL, drivers are free to use a random or a default key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = " Indicates the type of packets or the specific part of packets to\n which RSS hashing is to be applied."]
    pub rss_hf: u64,
    #[doc = "< Hash algorithm."]
    pub algorithm: rte_eth_hash_function,
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the\n Receive Side Scaling (RSS) feature of an Ethernet port. To configure\n more than 64 entries supported by hardware, an array of this structure\n is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    #[doc = " Mask bits indicate which entries need to be updated/queried."]
    pub mask: u64,
    #[doc = " Group of 64 redirection table entries."]
    pub reta: [u16; 64usize],
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes\n in DCB configurations"]
pub type rte_eth_nb_tcs = ::std::os::raw::c_uint;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools\n in VMDq configurations."]
pub type rte_eth_nb_pools = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[doc = " A structure used to configure the VMDq+DCB feature\n of an Ethernet port.\n\n Using this feature, packets are routed to a pool of queues, based\n on the VLAN ID in the VLAN tag, and then to a specific queue within\n that pool, using the user priority VLAN tag field.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    #[doc = " Selects a queue in a pool"]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the VMDq feature of an Ethernet port when\n not combined with the DCB feature.\n\n Using this feature, packets are routed to a pool of queues. By default,\n the pool selection is based on the MAC address, the VLAN ID in the\n VLAN tag as specified in the pool_map array.\n Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool\n selection using only the MAC address. MAC address to pool mapping is done\n using the rte_eth_dev_mac_addr_add function, with the pool parameter\n corresponding to the pool ID.\n\n Queue selection within the selected pool will be done using RSS when\n it is enabled or revert to the first queue of the pool if not.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from RTE_ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[doc = " A structure used to configure the Tx features of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< Tx multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_tagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_tagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_untagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_untagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_pvid_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_pvid_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A structure used to configure an Rx packet segment to split.\n\n If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,\n the PMD will split the received packets into multiple segments\n according to the specification in the description array:\n\n - The first network buffer will be allocated from the memory pool,\n   specified in the first array element, the second buffer, from the\n   pool in the second element, and so on.\n\n - The proto_hdrs in the elements define the split position of\n   received packets.\n\n - The offsets from the segment description elements specify\n   the data offset from the buffer beginning except the first mbuf.\n   The first segment offset is added with RTE_PKTMBUF_HEADROOM.\n\n - The lengths in the elements define the maximal data amount\n   being received to each segment. The receiving starts with filling\n   up the first mbuf data buffer up to specified length. If the\n   there are data remaining (packet is longer than buffer in the first\n   mbuf) the following data will be pushed to the next segment\n   up to its own length, and so on.\n\n - If the length in the segment description element is zero\n   the actual buffer size will be deduced from the appropriate\n   memory pool properties.\n\n - If there is not enough elements to describe the buffer for entire\n   packet of maximal length the following parameters will be used\n   for the all remaining segments:\n     - pool from the last valid element\n     - the buffer size from this pool\n     - zero offset\n\n - Length based buffer split:\n     - mp, length, offset should be configured.\n     - The proto_hdr field must be 0.\n\n - Protocol header based buffer split:\n     - mp, offset, proto_hdr should be configured.\n     - The length field must be 0.\n     - The proto_hdr field in the last segment should be 0.\n\n - When protocol header split is enabled, NIC may receive packets\n   which do not match all the protocol headers within the Rx segments.\n   At this point, NIC will have two possible split behaviors according to\n   matching results, one is exact match, another is longest match.\n   The split result of NIC must belong to one of them.\n   The exact match means NIC only do split when the packets exactly match all\n   the protocol headers in the segments.\n   Otherwise, the whole packet will be put into the last valid mempool.\n   The longest match means NIC will do split until packets mismatch\n   the protocol header in the segments.\n   The rest will be put into the last valid pool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = " proto_hdr defines a bit mask of the protocol sequence as RTE_PTYPE_*.\n The last RTE_PTYPE* in the mask indicates the split position.\n\n If one protocol header is defined to split packets into two segments,\n for non-tunneling packets, the complete protocol sequence should be defined.\n For tunneling packets, for simplicity, only the tunnel and inner part of\n complete protocol sequence is required.\n If several protocol headers are defined to split packets into multi-segments,\n the repeated parts of adjacent segments should be omitted."]
    pub proto_hdr: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[doc = " A structure used to configure an Rx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< Rx ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of Rx descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Share group index in Rx domain and switch domain.\n Non-zero value to enable Rx queue share, zero value disable share.\n PMD is responsible for Rx queue consistency checks to avoid member\n port's configuration contradict to each other."]
    pub share_group: u16,
    #[doc = "< Shared Rx queue ID in group"]
    pub share_qid: u16,
    #[doc = " Per-queue Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_queue_offload_capa or rx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet.\n Array elements are properties for consecutive Rx segments.\n\n The supported capabilities of receiving segmentation is reported\n in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = " Array of mempools to allocate Rx buffers from.\n\n This provides support for multiple mbuf pools per Rx queue.\n The capability is reported in device info via positive\n max_rx_mempools.\n\n It could be useful for more efficient usage of memory when an\n application creates different mempools to steer the specific\n size of the packet.\n\n If many mempools are specified, packets received using Rx\n burst may belong to any provided mempool. From ethdev user point\n of view it is undefined how PMD/NIC chooses mempool for a packet.\n\n If Rx scatter is enabled, a packet may be delivered using a chain\n of mbufs obtained from single mempool or multiple mempools based\n on the NIC implementation."]
    pub rx_mempools: *mut *mut rte_mempool,
    pub rx_nmempool: u16,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " A structure used to configure a Tx ring of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< Tx ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing Tx buffers if there are\nless free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_queue_offload_capa or tx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the Tx or Rx hairpin queue capabilities."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_queue_cap {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_eth_hairpin_queue_cap {
    #[inline]
    pub fn locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        locked_device_memory: u32,
        rte_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let locked_device_memory: u32 = unsafe { ::std::mem::transmute(locked_device_memory) };
            locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rte_memory: u32 = unsafe { ::std::mem::transmute(rte_memory) };
            rte_memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
    #[doc = "< Rx hairpin queue capabilities."]
    pub rx_cap: rte_eth_hairpin_queue_cap,
    #[doc = "< Tx hairpin queue capabilities."]
    pub tx_cap: rte_eth_hairpin_queue_cap,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure hairpin binding."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_hairpin_conf {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
impl rte_eth_hairpin_conf {
    #[inline]
    pub fn peer_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_peer_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn peer_count_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_peer_count_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_explicit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_explicit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_explicit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_explicit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn manual_bind(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manual_bind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn manual_bind_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_manual_bind_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_locked_device_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_locked_device_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_locked_device_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_locked_device_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_rte_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_rte_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_rte_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_rte_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn force_memory(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_memory(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_memory_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_force_memory_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        peer_count: u32,
        tx_explicit: u32,
        manual_bind: u32,
        use_locked_device_memory: u32,
        use_rte_memory: u32,
        force_memory: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let peer_count: u32 = unsafe { ::std::mem::transmute(peer_count) };
            peer_count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_explicit: u32 = unsafe { ::std::mem::transmute(tx_explicit) };
            tx_explicit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let manual_bind: u32 = unsafe { ::std::mem::transmute(manual_bind) };
            manual_bind as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let use_locked_device_memory: u32 =
                unsafe { ::std::mem::transmute(use_locked_device_memory) };
            use_locked_device_memory as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let use_rte_memory: u32 = unsafe { ::std::mem::transmute(use_rte_memory) };
            use_rte_memory as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let force_memory: u32 = unsafe { ::std::mem::transmute(force_memory) };
            force_memory as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet.\n\n - For TSO packet this is the total number of data descriptors allowed\n   by device.\n\n @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU.\n\n - For non-TSO packet, this is the maximum allowed number of segments\n   in a single transmit packet.\n\n - For TSO packet each segment within the TSO may span up to this\n   value.\n\n @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_ETH_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< Rx pause frame, enable flowctrl on Tx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< Tx pause frame, enable flowctrl on Rx side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_ETH_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure Ethernet flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[doc = " A structure used to configure Ethernet priority flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to retrieve information of queue based PFC."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_info {
    #[doc = " Maximum supported traffic class as per PFC (802.1Qbb) specification."]
    pub tc_max: u8,
    #[doc = " PFC queue mode capabilities."]
    pub mode_capa: rte_eth_fc_mode,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure Ethernet priority flow control parameters for\n ethdev queues.\n\n rte_eth_pfc_queue_conf::rx_pause structure shall be used to configure given\n tx_qid with corresponding tc. When ethdev device receives PFC frame with\n rte_eth_pfc_queue_conf::rx_pause::tc, traffic will be paused on\n rte_eth_pfc_queue_conf::rx_pause::tx_qid for that tc.\n\n rte_eth_pfc_queue_conf::tx_pause structure shall be used to configure given\n rx_qid. When rx_qid is congested, PFC frames are generated with\n rte_eth_pfc_queue_conf::rx_pause::tc and\n rte_eth_pfc_queue_conf::rx_pause::pause_time to the peer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf {
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    pub rx_pause: rte_eth_pfc_queue_conf__bindgen_ty_1,
    pub tx_pause: rte_eth_pfc_queue_conf__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_1 {
    #[doc = "< Tx queue ID"]
    pub tx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_pfc_queue_conf__bindgen_ty_2 {
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Rx queue ID"]
    pub rx_qid: u16,
    #[doc = " Traffic class as per PFC (802.1Qbb) spec. The value must be\n in the range [0, rte_eth_pfc_queue_info::tx_max - 1]"]
    pub tc: u8,
}
#[doc = "< Green"]
pub const rte_color_RTE_COLOR_GREEN: rte_color = 0;
#[doc = "< Yellow"]
pub const rte_color_RTE_COLOR_YELLOW: rte_color = 1;
#[doc = "< Red"]
pub const rte_color_RTE_COLOR_RED: rte_color = 2;
#[doc = "< Number of colors"]
pub const rte_color_RTE_COLORS: rte_color = 3;
#[doc = " Color"]
pub type rte_color = ::std::os::raw::c_uint;
#[doc = " Flow rule attributes.\n\n Priorities are set on a per rule based within groups.\n\n Lower values denote higher priority, the highest priority for a flow rule\n is 0, so that a flow that matches for than one rule, the rule with the\n lowest priority value will always be matched.\n\n Although optional, applications are encouraged to group similar rules as\n much as possible to fully take advantage of hardware capabilities\n (e.g. optimized matching) and work around limitations (e.g. a single\n pattern type possibly allowed in a given group). Applications should be\n aware that groups are not linked by default, and that they must be\n explicitly linked by the application using the JUMP action.\n\n Priority levels are arbitrary and up to the application, they\n do not need to be contiguous nor start from 0, however the maximum number\n varies between devices and may be affected by existing flow rules.\n\n If a packet is matched by several rules of a given group for a given\n priority level, the outcome is undefined. It can take any path, may be\n duplicated or even cause unrecoverable errors.\n\n Note that support for more than a single group and priority level is not\n guaranteed.\n\n At vNIC / ethdev level, flow rules can apply to inbound and / or outbound\n traffic (ingress / egress), with respect to the vNIC / ethdev in question.\n At embedded switch level, flow rules apply to all traffic seen by it\n unless fitting meta items are used to set concrete traffic source(s).\n\n Several pattern items and actions are valid and can be used in both\n directions. Those valid for only one direction are described as such.\n\n At least one direction must be specified.\n\n Specifying both directions at once for a given rule is not recommended\n but may be valid in a few cases."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_attr {
    #[doc = " A group is a superset of multiple rules.\n The default group is 0 and is processed for all packets.\n Rules in other groups are processed only if the group is chained\n by a jump action from a previously matched rule.\n It means the group hierarchy is made by the flow rules,\n and the group 0 is the hierarchy root.\n Note there is no automatic dead loop protection.\n @see rte_flow_action_jump"]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " [META]\n\n End marker for item lists. Prevents further processing of items,\n thereby ending the pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_END: rte_flow_item_type = 0;
#[doc = " [META]\n\n Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VOID: rte_flow_item_type = 1;
#[doc = " [META]\n\n Inverted matching, i.e. process packets that do not match the\n pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INVERT: rte_flow_item_type = 2;
#[doc = " Matches any protocol in place of the current layer, a single ANY\n may also stand for several protocol layers.\n\n See struct rte_flow_item_any."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ANY: rte_flow_item_type = 3;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT\n\n [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n given DPDK port ID.\n\n See struct rte_flow_item_port_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_ID: rte_flow_item_type = 4;
#[doc = " Matches a byte string of a given length at a given offset.\n\n See struct rte_flow_item_raw."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RAW: rte_flow_item_type = 5;
#[doc = " Matches an Ethernet header.\n\n See struct rte_flow_item_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ETH: rte_flow_item_type = 6;
#[doc = " Matches an 802.1Q/ad VLAN tag.\n\n See struct rte_flow_item_vlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VLAN: rte_flow_item_type = 7;
#[doc = " Matches an IPv4 header.\n\n See struct rte_flow_item_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV4: rte_flow_item_type = 8;
#[doc = " Matches an IPv6 header.\n\n See struct rte_flow_item_ipv6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6: rte_flow_item_type = 9;
#[doc = " Matches an ICMP header.\n\n See struct rte_flow_item_icmp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP: rte_flow_item_type = 10;
#[doc = " Matches a UDP header.\n\n See struct rte_flow_item_udp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_UDP: rte_flow_item_type = 11;
#[doc = " Matches a TCP header.\n\n See struct rte_flow_item_tcp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TCP: rte_flow_item_type = 12;
#[doc = " Matches a SCTP header.\n\n See struct rte_flow_item_sctp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_SCTP: rte_flow_item_type = 13;
#[doc = " Matches a VXLAN header.\n\n See struct rte_flow_item_vxlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN: rte_flow_item_type = 14;
#[doc = " Matches a E_TAG header.\n\n See struct rte_flow_item_e_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_E_TAG: rte_flow_item_type = 15;
#[doc = " Matches a NVGRE header.\n\n See struct rte_flow_item_nvgre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NVGRE: rte_flow_item_type = 16;
#[doc = " Matches a MPLS header.\n\n See struct rte_flow_item_mpls."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MPLS: rte_flow_item_type = 17;
#[doc = " Matches a GRE header.\n\n See struct rte_flow_item_gre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE: rte_flow_item_type = 18;
#[doc = " [META]\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy matching option.\n Usually a fuzzy matching is fast but the cost is accuracy.\n\n See struct rte_flow_item_fuzzy."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FUZZY: rte_flow_item_type = 19;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP: rte_flow_item_type = 20;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-C packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPC: rte_flow_item_type = 21;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-U packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPU: rte_flow_item_type = 22;
#[doc = " Matches a ESP header.\n\n See struct rte_flow_item_esp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ESP: rte_flow_item_type = 23;
#[doc = " Matches a GENEVE header.\n\n See struct rte_flow_item_geneve."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE: rte_flow_item_type = 24;
#[doc = " @deprecated\n @see RTE_FLOW_ITEM_TYPE_VXLAN\n\n Matches a VXLAN-GPE header.\n\n See struct rte_flow_item_vxlan_gpe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN_GPE: rte_flow_item_type = 25;
#[doc = " Matches an ARP header for Ethernet/IPv4.\n\n See struct rte_flow_item_arp_eth_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: rte_flow_item_type = 26;
#[doc = " Matches the presence of any IPv6 extension header.\n\n See struct rte_flow_item_ipv6_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_EXT: rte_flow_item_type = 27;
#[doc = " Matches any ICMPv6 header.\n\n See struct rte_flow_item_icmp6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6: rte_flow_item_type = 28;
#[doc = " Matches an ICMPv6 neighbor discovery solicitation.\n\n See struct rte_flow_item_icmp6_nd_ns."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: rte_flow_item_type = 29;
#[doc = " Matches an ICMPv6 neighbor discovery advertisement.\n\n See struct rte_flow_item_icmp6_nd_na."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: rte_flow_item_type = 30;
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option.\n\n See struct rte_flow_item_icmp6_nd_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: rte_flow_item_type = 31;
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: rte_flow_item_type = 32;
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: rte_flow_item_type = 33;
#[doc = " Matches specified mark field.\n\n See struct rte_flow_item_mark."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MARK: rte_flow_item_type = 34;
#[doc = " [META]\n\n Matches a metadata value.\n\n See struct rte_flow_item_meta."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_META: rte_flow_item_type = 35;
#[doc = " Matches a GRE optional key field.\n\n The value should a big-endian 32bit integer.\n\n When this item present the K bit is implicitly matched as \"1\"\n in the default mask.\n\n @p spec/mask type:\n @code rte_be32_t * @endcode"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_KEY: rte_flow_item_type = 36;
#[doc = " Matches a GTP extension header: PDU session container.\n\n Configure flow for GTP packets with extension header type 0x85.\n\n See struct rte_flow_item_gtp_psc."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP_PSC: rte_flow_item_type = 37;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE session packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOES: rte_flow_item_type = 38;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE discovery packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOED: rte_flow_item_type = 39;
#[doc = " Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n See struct rte_flow_item_pppoe_proto_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: rte_flow_item_type = 40;
#[doc = " Matches Network service header (NSH).\n See struct rte_flow_item_nsh.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NSH: rte_flow_item_type = 41;
#[doc = " Matches Internet Group Management Protocol (IGMP).\n See struct rte_flow_item_igmp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IGMP: rte_flow_item_type = 42;
#[doc = " Matches IP Authentication Header (AH).\n See struct rte_flow_item_ah.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AH: rte_flow_item_type = 43;
#[doc = " Matches a HIGIG header.\n see struct rte_flow_item_higig2_hdr."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_HIGIG2: rte_flow_item_type = 44;
#[doc = " [META]\n\n Matches a tag value.\n\n See struct rte_flow_item_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TAG: rte_flow_item_type = 45;
#[doc = " Matches a L2TPv3 over IP header.\n\n Configure flow for L2TPv3 over IP packets.\n\n See struct rte_flow_item_l2tpv3oip."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV3OIP: rte_flow_item_type = 46;
#[doc = " Matches PFCP Header.\n See struct rte_flow_item_pfcp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PFCP: rte_flow_item_type = 47;
#[doc = " Matches eCPRI Header.\n\n Configure flow for eCPRI over ETH or UDP packets.\n\n See struct rte_flow_item_ecpri."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ECPRI: rte_flow_item_type = 48;
#[doc = " Matches the presence of IPv6 fragment extension header.\n\n See struct rte_flow_item_ipv6_frag_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT: rte_flow_item_type = 49;
#[doc = " Matches Geneve Variable Length Option\n\n See struct rte_flow_item_geneve_opt"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE_OPT: rte_flow_item_type = 50;
#[doc = " [META]\n\n Matches on packet integrity.\n For some devices application needs to enable integration checks in HW\n before using this item.\n\n @see struct rte_flow_item_integrity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INTEGRITY: rte_flow_item_type = 51;
#[doc = " [META]\n\n Matches conntrack state.\n\n @see struct rte_flow_item_conntrack."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_CONNTRACK: rte_flow_item_type = 52;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR: rte_flow_item_type = 53;
#[doc = " [META]\n\n Matches traffic entering the embedded switch from\n the entity represented by the given ethdev.\n\n @see struct rte_flow_item_ethdev"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT: rte_flow_item_type = 54;
#[doc = " Matches a configured set of fields at runtime calculated offsets\n over the generic network header with variable length and\n flexible pattern\n\n @see struct rte_flow_item_flex."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FLEX: rte_flow_item_type = 55;
#[doc = " Matches L2TPv2 Header.\n\n See struct rte_flow_item_l2tpv2."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV2: rte_flow_item_type = 56;
#[doc = " Matches PPP Header.\n\n See struct rte_flow_item_ppp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPP: rte_flow_item_type = 57;
#[doc = " Matches GRE optional fields.\n\n See struct rte_flow_item_gre_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_OPTION: rte_flow_item_type = 58;
#[doc = " Matches MACsec Ethernet Header.\n\n See struct rte_flow_item_macsec."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MACSEC: rte_flow_item_type = 59;
#[doc = " Matches Meter Color Marker.\n\n See struct rte_flow_item_meter_color."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_METER_COLOR: rte_flow_item_type = 60;
#[doc = " Matches the presence of IPv6 routing extension header.\n\n @see struct rte_flow_item_ipv6_routing_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_ROUTING_EXT: rte_flow_item_type = 61;
#[doc = " Matches an ICMPv6 echo request.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REQUEST: rte_flow_item_type = 62;
#[doc = " Matches an ICMPv6 echo reply.\n\n @see struct rte_flow_item_icmp6_echo."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REPLY: rte_flow_item_type = 63;
#[doc = " Match Quota state\n\n @see struct rte_flow_item_quota"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_QUOTA: rte_flow_item_type = 64;
#[doc = " Matches on the aggregated port of the received packet.\n Used in case multiple ports are aggregated to the a DPDK port.\n First port is number 1.\n\n @see struct rte_flow_item_aggr_affinity."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AGGR_AFFINITY: rte_flow_item_type = 65;
#[doc = " Match Tx queue number.\n This is valid only for egress rules.\n\n @see struct rte_flow_item_tx_queue"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TX_QUEUE: rte_flow_item_type = 66;
#[doc = " Matches an InfiniBand base transport header in RoCE packet.\n\n @see struct rte_flow_item_ib_bth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IB_BTH: rte_flow_item_type = 67;
#[doc = " Matches the packet type as defined in rte_mbuf_ptype.\n\n See struct rte_flow_item_ptype.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PTYPE: rte_flow_item_type = 68;
#[doc = " [META]\n\n Matches a random value.\n\n This value is not based on the packet data/headers.\n The application shouldn't assume that this value is kept\n during the lifetime of the packet.\n\n @see struct rte_flow_item_random."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RANDOM: rte_flow_item_type = 69;
#[doc = " Match packet with various comparison types.\n\n See struct rte_flow_item_compare."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_COMPARE: rte_flow_item_type = 70;
#[doc = " Matching pattern item types.\n\n Pattern items fall in two categories:\n\n - Matching protocol headers and packet data, usually associated with a\n   specification structure. These must be stacked in the same order as the\n   protocol layers to match inside packets, starting from the lowest.\n\n - Matching meta-data or affecting pattern processing, often without a\n   specification structure. Since they do not match packet contents, their\n   position in the list is usually not relevant.\n\n See the description of individual types for more information. Those\n marked with [META] fall into the second category."]
pub type rte_flow_item_type = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ITEM_TYPE_ETH\n\n Matches an Ethernet header.\n\n Inside @p hdr field, the sub-field @p ether_type stands either for EtherType\n or TPID, depending on whether the item is followed by a VLAN item or not. If\n two VLAN items follow, the sub-field refers to the outer one, which, in turn,\n contains the inner TPID in the similar header field. The innermost VLAN item\n contains a layer-3 EtherType. All of that follows the order seen on the wire.\n\n If the field in question contains a TPID value, only tagged packets with the\n specified TPID will match the pattern. Alternatively, it's possible to match\n any type of tagged packets by means of the field @p has_vlan rather than use\n the EtherType/TPID field. Also, it's possible to leave the two fields unused.\n If this is the case, both tagged and untagged packets will match the pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_eth {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_eth__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_ether_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Destination MAC."]
    pub dst: rte_ether_addr,
    #[doc = "< Source MAC."]
    pub src: rte_ether_addr,
    #[doc = "< EtherType or TPID."]
    pub type_: rte_be16_t,
}
impl rte_flow_item_eth {
    #[inline]
    pub fn has_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_vlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_vlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vlan: u32 = unsafe { ::std::mem::transmute(has_vlan) };
            has_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ITEM_TYPE_VLAN\n\n Matches an 802.1Q/ad VLAN tag.\n\n The corresponding standard outer EtherType (TPID) values are\n RTE_ETHER_TYPE_VLAN or RTE_ETHER_TYPE_QINQ. It can be overridden by\n the preceding pattern item.\n If a @p VLAN item is present in the pattern, then only tagged packets will\n match the pattern.\n The field @p has_more_vlan can be used to match any type of tagged packets,\n instead of using the @p eth_proto field of @p hdr.\n If the @p eth_proto of @p hdr and @p has_more_vlan fields are not specified,\n then any tagged packets will match the pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vlan {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_vlan_hdr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Tag control information."]
    pub tci: rte_be16_t,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
impl rte_flow_item_vlan {
    #[inline]
    pub fn has_more_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_more_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_more_vlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_more_vlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_more_vlan: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_more_vlan: u32 = unsafe { ::std::mem::transmute(has_more_vlan) };
            has_more_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_TAG\n\n Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
#[doc = " Provides an ethdev port ID for use with the following items:\n RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR,\n RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ethdev {
    #[doc = "< ethdev port ID"]
    pub port_id: u16,
}
#[doc = " Matching pattern item definition.\n\n A pattern is formed by stacking items starting from the lowest protocol\n layer to match. This stacking restriction does not apply to meta items\n which can be placed anywhere in the stack without affecting the meaning\n of the resulting pattern.\n\n Patterns are terminated by END items.\n\n The spec field should be a valid pointer to a structure of the related\n item type. It may remain unspecified (NULL) in many cases to request\n broad (nonspecific) matching. In such cases, last and mask must also be\n set to NULL.\n\n Optionally, last can point to a structure of the same type to define an\n inclusive range. This is mostly supported by integer and address fields,\n may cause errors otherwise. Fields that do not support ranges must be set\n to 0 or to the same value as the corresponding fields in spec.\n\n Only the fields defined to nonzero values in the default masks (see\n rte_flow_item_{name}_mask constants) are considered relevant by\n default. This can be overridden by providing a mask structure of the\n same type with applicable bits set to one. It can also be used to\n partially filter out specific fields (e.g. as an alternate mean to match\n ranges of IP addresses).\n\n Mask is a simple bit-mask applied before interpreting the contents of\n spec and last, which may yield unexpected results if not used\n carefully. For example, if for an IPv4 address field, spec provides\n 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the\n effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_FLEX\n\n Matches a specified set of fields within the network protocol\n header. Each field is presented as set of bits with specified width, and\n bit offset from the header beginning.\n\n The pattern is concatenation of bit fields configured at item creation\n by rte_flow_flex_item_create(). At configuration the fields are presented\n by sample_data array.\n\n This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex {
    #[doc = "< Opaque item handle."]
    pub handle: *mut rte_flow_item_flex_handle,
    #[doc = "< Pattern length in bytes."]
    pub length: u32,
    #[doc = "< Combined bitfields pattern to match."]
    pub pattern: *const u8,
}
#[doc = " The protocol header can be present in the packet only once.\n No multiple flex item flow inclusions (for inner/outer) are allowed.\n No any relations with tunnel protocols are imposed. The drivers\n can optimize hardware resource usage to handle match on single flex\n item of specific type."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_SINGLE: rte_flow_item_flex_tunnel_mode =
    0;
#[doc = " Flex item presents outer header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_OUTER: rte_flow_item_flex_tunnel_mode = 1;
#[doc = " Flex item presents inner header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_INNER: rte_flow_item_flex_tunnel_mode = 2;
#[doc = " Flex item presents either inner or outer header. The driver\n handles as many multiple inners as hardware supports."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_MULTI: rte_flow_item_flex_tunnel_mode = 3;
#[doc = " Flex item presents tunnel protocol header."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_TUNNEL: rte_flow_item_flex_tunnel_mode =
    4;
#[doc = " Flex item field tunnel mode"]
pub type rte_flow_item_flex_tunnel_mode = ::std::os::raw::c_uint;
#[doc = " End marker for action lists. Prevents further processing of\n actions, thereby ending the list.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_END: rte_flow_action_type = 0;
#[doc = " Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VOID: rte_flow_action_type = 1;
#[doc = " Leaves traffic up for additional processing by subsequent flow\n rules; makes a flow rule non-terminating.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PASSTHRU: rte_flow_action_type = 2;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n See struct rte_flow_action_jump."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP: rte_flow_action_type = 3;
#[doc = " Attaches an integer value to packets and sets RTE_MBUF_F_RX_FDIR and\n RTE_MBUF_F_RX_FDIR_ID mbuf flags.\n\n See struct rte_flow_action_mark.\n\n One should negotiate mark delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_MARK"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MARK: rte_flow_action_type = 4;
#[doc = " Flags packets. Similar to MARK without a specific value; only\n sets the RTE_MBUF_F_RX_FDIR mbuf flag.\n\n No associated configuration structure.\n\n One should negotiate flag delivery from the NIC to the PMD.\n @see rte_eth_rx_metadata_negotiate()\n @see RTE_ETH_RX_METADATA_USER_FLAG"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_FLAG: rte_flow_action_type = 5;
#[doc = " Assigns packets to a given queue index.\n\n See struct rte_flow_action_queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUEUE: rte_flow_action_type = 6;
#[doc = " Drops packets.\n\n PASSTHRU overrides this action if both are specified.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DROP: rte_flow_action_type = 7;
#[doc = " Enables counters for this flow rule.\n\n These counters can be retrieved and reset through rte_flow_query() or\n rte_flow_action_handle_query() if the action provided via handle,\n see struct rte_flow_query_count.\n\n See struct rte_flow_action_count."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_COUNT: rte_flow_action_type = 8;
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets\n to spread them among several queues according to the provided\n parameters.\n\n See struct rte_flow_action_rss."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RSS: rte_flow_action_type = 9;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to the physical function (PF) of the\n current device.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PF: rte_flow_action_type = 10;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given virtual function of the\n current device.\n\n See struct rte_flow_action_vf."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VF: rte_flow_action_type = 11;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR\n @see RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT\n\n Directs matching traffic to a given DPDK port ID.\n\n See struct rte_flow_action_port_id."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_ID: rte_flow_action_type = 12;
#[doc = " Traffic metering and policing (MTR).\n\n See struct rte_flow_action_meter.\n See file rte_mtr.h for MTR object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER: rte_flow_action_type = 13;
#[doc = " Redirects packets to security engine of current device for security\n processing as specified by security session.\n\n See struct rte_flow_action_security."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SECURITY: rte_flow_action_type = 14;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by\n the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: rte_flow_action_type = 15;
#[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined\n by the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: rte_flow_action_type = 16;
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_vlan."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: rte_flow_action_type = 17;
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN ID\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_vid."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: rte_flow_action_type = 18;
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_pcp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: rte_flow_action_type = 19;
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined\n by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_pop_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: rte_flow_action_type = 20;
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: rte_flow_action_type = 21;
#[doc = " Encapsulate flow in VXLAN tunnel as defined in\n rte_flow_action_vxlan_encap action structure.\n\n See struct rte_flow_action_vxlan_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: rte_flow_action_type = 22;
#[doc = " Decapsulate outer most VXLAN tunnel from matched flow.\n\n If flow pattern does not define a valid VXLAN tunnel (as specified by\n RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: rte_flow_action_type = 23;
#[doc = " Encapsulate flow in NVGRE tunnel defined in the\n rte_flow_action_nvgre_encap action structure.\n\n See struct rte_flow_action_nvgre_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: rte_flow_action_type = 24;
#[doc = " Decapsulate outer most NVGRE tunnel from matched flow.\n\n If flow pattern does not define a valid NVGRE tunnel (as specified by\n RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: rte_flow_action_type = 25;
#[doc = " Add outer header whose template is provided in its data buffer\n\n See struct rte_flow_action_raw_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_ENCAP: rte_flow_action_type = 26;
#[doc = " Remove outer header whose template is provided in its data buffer.\n\n See struct rte_flow_action_raw_decap"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_DECAP: rte_flow_action_type = 27;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 source address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: rte_flow_action_type = 28;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 destination address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: rte_flow_action_type = 29;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 source address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: rte_flow_action_type = 30;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 destination address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: rte_flow_action_type = 31;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify source port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_SRC: rte_flow_action_type = 32;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify destination port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_DST: rte_flow_action_type = 33;
#[doc = " Swap the source and destination MAC addresses in the outermost\n Ethernet header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MAC_SWAP: rte_flow_action_type = 34;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease TTL value directly\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TTL: rte_flow_action_type = 35;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set TTL value\n\n See struct rte_flow_action_set_ttl"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TTL: rte_flow_action_type = 36;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set source MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: rte_flow_action_type = 37;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set destination MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_DST: rte_flow_action_type = 38;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase sequence number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: rte_flow_action_type = 39;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease sequence number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: rte_flow_action_type = 40;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Increase acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: rte_flow_action_type = 41;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Decrease acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: rte_flow_action_type = 42;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set Tag.\n\n Tag is for internal flow usage only and\n is not delivered to the application.\n\n See struct rte_flow_action_set_tag."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TAG: rte_flow_action_type = 43;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Set metadata on ingress or egress path.\n\n See struct rte_flow_action_set_meta."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_META: rte_flow_action_type = 44;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv4 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP: rte_flow_action_type = 45;
#[doc = " @warning This is a legacy action.\n @see RTE_FLOW_ACTION_TYPE_MODIFY_FIELD\n\n Modify IPv6 DSCP in the outermost IP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_dscp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP: rte_flow_action_type = 46;
#[doc = " Report as aged flow if timeout passed without any matching on the\n flow.\n\n See struct rte_flow_action_age.\n See function rte_flow_get_q_aged_flows\n See function rte_flow_get_aged_flows\n see enum RTE_ETH_EVENT_FLOW_AGED\n See struct rte_flow_query_age\n See struct rte_flow_update_age"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_AGE: rte_flow_action_type = 47;
#[doc = " The matching packets will be duplicated with specified ratio and\n applied with own set of actions with a fate action.\n\n See struct rte_flow_action_sample."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SAMPLE: rte_flow_action_type = 48;
#[doc = " @deprecated\n @see RTE_FLOW_ACTION_TYPE_INDIRECT\n\n Describe action shared across multiple flow rules.\n\n Allow multiple rules reference the same action by handle (see\n struct rte_flow_shared_action)."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SHARED: rte_flow_action_type = 49;
#[doc = " Modify a packet header field, tag, mark or metadata.\n\n Allow the modification of an arbitrary header field via\n set, add and sub operations or copying its content into\n tag, meta or mark for future processing.\n\n See struct rte_flow_action_modify_field."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MODIFY_FIELD: rte_flow_action_type = 50;
#[doc = " An action handle is referenced in a rule through an indirect action.\n\n The same action handle may be used in multiple rules for the same\n or different ethdev ports."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT: rte_flow_action_type = 51;
#[doc = " [META]\n\n Enable tracking a TCP connection state.\n\n @see struct rte_flow_action_conntrack."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_CONNTRACK: rte_flow_action_type = 52;
#[doc = " Color the packet to reflect the meter color result.\n Set the meter color in the mbuf to the selected color.\n\n See struct rte_flow_action_meter_color."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_COLOR: rte_flow_action_type = 53;
#[doc = " At embedded switch level, sends matching traffic to the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR: rte_flow_action_type = 54;
#[doc = " At embedded switch level, send matching traffic to\n the entity represented by the given ethdev.\n\n @see struct rte_flow_action_ethdev"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT: rte_flow_action_type = 55;
#[doc = " Traffic metering and marking (MTR).\n\n @see struct rte_flow_action_meter_mark\n See file rte_mtr.h for MTR profile object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_MARK: rte_flow_action_type = 56;
#[doc = " Send packets to the kernel, without going to userspace at all.\n The packets will be received by the kernel driver sharing\n the same device as the DPDK port on which this action is configured.\n This action mostly suits bifurcated driver model.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SEND_TO_KERNEL: rte_flow_action_type = 57;
#[doc = " Apply the quota verdict (PASS or BLOCK) to a flow.\n\n @see struct rte_flow_action_quota\n @see struct rte_flow_query_quota\n @see struct rte_flow_update_quota"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUOTA: rte_flow_action_type = 58;
#[doc = " Skip congestion management configuration.\n\n Using rte_eth_cman_config_set(), the application\n can configure ethdev Rx queue's congestion mechanism.\n This flow action allows to skip the congestion configuration\n applied to the given ethdev Rx queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SKIP_CMAN: rte_flow_action_type = 59;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH\n\n Push IPv6 extension into IPv6 packet.\n\n @see struct rte_flow_action_ipv6_ext_push."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH: rte_flow_action_type = 60;
#[doc = " RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE\n\n Remove IPv6 extension from IPv6 packet whose type\n is provided in its configuration buffer.\n\n @see struct rte_flow_action_ipv6_ext_remove."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE: rte_flow_action_type = 61;
#[doc = " Action handle to reference flow actions list.\n\n @see struct rte_flow_action_indirect_list"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT_LIST: rte_flow_action_type = 62;
#[doc = " Program action. These actions are defined by the program currently\n loaded on the device. For example, these actions are applicable to\n devices that can be programmed through the P4 language.\n\n @see struct rte_flow_action_prog."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PROG: rte_flow_action_type = 63;
#[doc = " NAT64 translation of IPv4/IPv6 headers.\n\n @see struct rte_flow_action_nat64"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NAT64: rte_flow_action_type = 64;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX,\n\n Redirects packets to a particular index in a flow table.\n\n @see struct rte_flow_action_jump_to_table_index."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP_TO_TABLE_INDEX: rte_flow_action_type = 65;
#[doc = " Action types.\n\n Each possible action is represented by a type.\n An action can have an associated configuration object.\n Several actions combined in a list can be assigned\n to a flow rule and are performed in order.\n\n They fall in three categories:\n\n - Actions that modify the fate of matching traffic, for instance by\n   dropping or assigning it a specific destination.\n\n - Actions that modify matching traffic contents or its properties. This\n   includes adding/removing encapsulation, encryption, compression and\n   marks.\n\n - Actions related to the flow rule itself, such as updating counters or\n   making it non-terminating.\n\n Flow rules being terminating by default, not specifying any action of the\n fate kind results in undefined behavior. This applies to both ingress and\n egress.\n\n PASSTHRU, when supported, makes a flow rule non-terminating."]
pub type rte_flow_action_type = ::std::os::raw::c_uint;
#[doc = "< Count packets."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_PACKET: rte_flow_quota_mode = 1;
#[doc = "< Count packet bytes starting from L2."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_L2: rte_flow_quota_mode = 2;
#[doc = "< Count packet bytes starting from L3."]
pub const rte_flow_quota_mode_RTE_FLOW_QUOTA_MODE_L3: rte_flow_quota_mode = 3;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n QUOTA operational mode.\n\n @see struct rte_flow_action_quota"]
pub type rte_flow_quota_mode = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Create QUOTA action.\n\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_quota {
    #[doc = "< Quota operational mode."]
    pub mode: rte_flow_quota_mode,
    #[doc = "< Quota value."]
    pub quota: i64,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Query indirect QUOTA action.\n\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_query_quota {
    #[doc = "< Quota value."]
    pub quota: i64,
}
#[doc = "< Set new quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_SET: rte_flow_update_quota_op = 0;
#[doc = "< Increase quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_ADD: rte_flow_update_quota_op = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Indirect QUOTA update operations.\n\n @see struct rte_flow_update_quota"]
pub type rte_flow_update_quota_op = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT (query)\n\n Query structure to retrieve and reset flow rule counters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_query_count {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Number of hits for this rule [out]."]
    pub hits: u64,
    #[doc = "< Number of bytes through this rule [out]."]
    pub bytes: u64,
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hits_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hits_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_INDIRECT\n\n Opaque type returned after successfully creating an indirect action object.\n The definition of the object handle is different per driver or\n per direct action type.\n\n This handle can be used to manage and query the related direct action:\n - referenced in single flow rule or across multiple flow rules\n   over multiple ports\n - update action object configuration\n - query action object data\n - destroy action object"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_handle {
    _unused: [u8; 0],
}
#[doc = " SYN-ACK packet was seen."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_SYN_RECV: rte_flow_conntrack_state = 0;
#[doc = " 3-way handshake was done."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_ESTABLISHED: rte_flow_conntrack_state =
    1;
#[doc = " First FIN packet was received to close the connection."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_FIN_WAIT: rte_flow_conntrack_state = 2;
#[doc = " First FIN was ACKed."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_CLOSE_WAIT: rte_flow_conntrack_state =
    3;
#[doc = " Second FIN was received, waiting for the last ACK."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_LAST_ACK: rte_flow_conntrack_state = 4;
#[doc = " Second FIN was ACKed, connection was closed."]
pub const rte_flow_conntrack_state_RTE_FLOW_CONNTRACK_STATE_TIME_WAIT: rte_flow_conntrack_state = 5;
#[doc = " The state of a TCP connection."]
pub type rte_flow_conntrack_state = ::std::os::raw::c_uint;
#[doc = "< No Flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_NONE:
    rte_flow_conntrack_tcp_last_index = 0;
#[doc = "< With SYN flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_SYN:
    rte_flow_conntrack_tcp_last_index = 1;
#[doc = "< With SYNACK flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_SYNACK:
    rte_flow_conntrack_tcp_last_index = 2;
#[doc = "< With FIN flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_FIN:
    rte_flow_conntrack_tcp_last_index = 4;
#[doc = "< With ACK flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_ACK:
    rte_flow_conntrack_tcp_last_index = 8;
#[doc = "< With RST flag."]
pub const rte_flow_conntrack_tcp_last_index_RTE_FLOW_CONNTRACK_FLAG_RST:
    rte_flow_conntrack_tcp_last_index = 16;
#[doc = " The last passed TCP packet flags of a connection."]
pub type rte_flow_conntrack_tcp_last_index = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n Configuration parameters for each direction of a TCP connection.\n All fields should be in host byte order.\n If needed, driver should convert all fields to network byte order\n if HW needs them in that way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tcp_dir_param {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Maximal value of sequence + payload length in sent\n packets (next ACK from the opposite direction)."]
    pub sent_end: u32,
    #[doc = " Maximal value of (ACK + window size) in received packet + length\n over sent packet (maximal sequence could be sent)."]
    pub reply_end: u32,
    #[doc = " Maximal value of actual window size in sent packets."]
    pub max_win: u32,
    #[doc = " Maximal value of ACK in sent packets."]
    pub max_ack: u32,
}
impl rte_flow_tcp_dir_param {
    #[inline]
    pub fn scale(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn close_initiated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_initiated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn close_initiated_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_close_initiated_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_ack_seen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_ack_seen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_ack_seen_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_ack_seen_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn data_unacked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_unacked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_unacked_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_data_unacked_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scale: u32,
        close_initiated: u32,
        last_ack_seen: u32,
        data_unacked: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let scale: u32 = unsafe { ::std::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let close_initiated: u32 = unsafe { ::std::mem::transmute(close_initiated) };
            close_initiated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_ack_seen: u32 = unsafe { ::std::mem::transmute(last_ack_seen) };
            last_ack_seen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let data_unacked: u32 = unsafe { ::std::mem::transmute(data_unacked) };
            data_unacked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_CONNTRACK\n\n Configuration and initial state for the connection tracking module.\n This structure could be used for both setting and query.\n All fields should be in host byte order."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action_conntrack {
    #[doc = " The peer port number, can be the same port."]
    pub peer_port: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The current state of this connection."]
    pub state: rte_flow_conntrack_state,
    #[doc = " Scaling factor for maximal allowed ACK window."]
    pub max_ack_window: u8,
    #[doc = " Maximal allowed number of retransmission times."]
    pub retransmission_limit: u8,
    #[doc = " TCP parameters of the original direction."]
    pub original_dir: rte_flow_tcp_dir_param,
    #[doc = " TCP parameters of the reply direction."]
    pub reply_dir: rte_flow_tcp_dir_param,
    #[doc = " The window value of the last packet passed this conntrack."]
    pub last_window: u16,
    pub last_index: rte_flow_conntrack_tcp_last_index,
    #[doc = " The sequence of the last packet passed this conntrack."]
    pub last_seq: u32,
    #[doc = " The acknowledgment of the last packet passed this conntrack."]
    pub last_ack: u32,
    #[doc = " The total value ACK + payload length of the last packet\n passed this conntrack."]
    pub last_end: u32,
}
impl rte_flow_action_conntrack {
    #[inline]
    pub fn is_original_dir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_original_dir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_original_dir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_original_dir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn live_connection(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_live_connection(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn live_connection_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_live_connection_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn selective_ack(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selective_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selective_ack_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_selective_ack_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn challenge_ack_passed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_challenge_ack_passed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn challenge_ack_passed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_challenge_ack_passed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn liberal_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_liberal_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn liberal_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_liberal_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_original_dir: u32,
        enable: u32,
        live_connection: u32,
        selective_ack: u32,
        challenge_ack_passed: u32,
        last_direction: u32,
        liberal_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_original_dir: u32 = unsafe { ::std::mem::transmute(is_original_dir) };
            is_original_dir as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable: u32 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let live_connection: u32 = unsafe { ::std::mem::transmute(live_connection) };
            live_connection as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let selective_ack: u32 = unsafe { ::std::mem::transmute(selective_ack) };
            selective_ack as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let challenge_ack_passed: u32 = unsafe { ::std::mem::transmute(challenge_ack_passed) };
            challenge_ack_passed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let last_direction: u32 = unsafe { ::std::mem::transmute(last_direction) };
            last_direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let liberal_mode: u32 = unsafe { ::std::mem::transmute(liberal_mode) };
            liberal_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Definition of a single action.\n\n A list of actions is terminated by a END action.\n\n For simple actions without a configuration object, conf remains NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[doc = " Opaque type returned after successfully creating a flow.\n\n This handle can be used to manage and query the related flow (e.g. to\n destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = "< No error."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_NONE: rte_flow_error_type = 0;
#[doc = "< Cause unspecified."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_UNSPECIFIED: rte_flow_error_type = 1;
#[doc = "< Flow rule (handle)."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_HANDLE: rte_flow_error_type = 2;
#[doc = "< Group field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_GROUP: rte_flow_error_type = 3;
#[doc = "< Priority field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: rte_flow_error_type = 4;
#[doc = "< Ingress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: rte_flow_error_type = 5;
#[doc = "< Egress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: rte_flow_error_type = 6;
#[doc = "< Transfer field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: rte_flow_error_type = 7;
#[doc = "< Attributes structure."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR: rte_flow_error_type = 8;
#[doc = "< Pattern length."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_NUM: rte_flow_error_type = 9;
#[doc = "< Item specification."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_SPEC: rte_flow_error_type = 10;
#[doc = "< Item specification range."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_LAST: rte_flow_error_type = 11;
#[doc = "< Item specification mask."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_MASK: rte_flow_error_type = 12;
#[doc = "< Specific pattern item."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM: rte_flow_error_type = 13;
#[doc = "< Number of actions."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_NUM: rte_flow_error_type = 14;
#[doc = "< Action configuration."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_CONF: rte_flow_error_type = 15;
#[doc = "< Specific action."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION: rte_flow_error_type = 16;
#[doc = "< Current device state."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_STATE: rte_flow_error_type = 17;
#[doc = " Verbose error types.\n\n Most of them provide the type of the object referenced by struct\n rte_flow_error.cause."]
pub type rte_flow_error_type = ::std::os::raw::c_uint;
#[doc = " Verbose error structure definition.\n\n This object is normally allocated by applications and set by PMDs, the\n message points to a constant string which does not need to be freed by\n the application, however its pointer can be considered valid only as long\n as its associated DPDK port remains configured. Closing the underlying\n device or unloading the PMD invalidates it.\n\n Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_error {
    #[doc = "< Cause field and error types."]
    pub type_: rte_flow_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine resources settings.\n The zero value means on demand resource allocations only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_port_attr {
    #[doc = " Number of counters to configure.\n @see RTE_FLOW_ACTION_TYPE_COUNT"]
    pub nb_counters: u32,
    #[doc = " Number of aging objects to configure.\n @see RTE_FLOW_ACTION_TYPE_AGE"]
    pub nb_aging_objects: u32,
    #[doc = " Number of traffic meters to configure.\n @see RTE_FLOW_ACTION_TYPE_METER"]
    pub nb_meters: u32,
    #[doc = " Number of connection trackings to configure.\n @see RTE_FLOW_ACTION_TYPE_CONNTRACK"]
    pub nb_conn_tracks: u32,
    #[doc = " Port to base shared objects on."]
    pub host_port_id: u16,
    #[doc = " Maximum number of quota actions.\n @see RTE_FLOW_ACTION_TYPE_QUOTA"]
    pub nb_quotas: u32,
    #[doc = " Port flags (RTE_FLOW_PORT_FLAG_*)."]
    pub flags: u32,
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Flow engine asynchronous queues settings.\n The value means default value picked by PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_queue_attr {
    #[doc = " Number of flow rule operations a queue can hold."]
    pub size: u32,
}
#[doc = " Opaque type returned after successful creation of pattern template.\n This handle can be used to manage the created pattern template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_pattern_template {
    _unused: [u8; 0],
}
#[doc = " Opaque type returned after successful creation of actions template.\n This handle can be used to manage the created actions template."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_actions_template {
    _unused: [u8; 0],
}
#[doc = " Opaque type returned after successful creation of a template table.\n This handle can be used to manage the created template table."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_template_table {
    _unused: [u8; 0],
}
#[doc = " The operation was completed successfully."]
pub const rte_flow_op_status_RTE_FLOW_OP_SUCCESS: rte_flow_op_status = 0;
#[doc = " The operation was not completed successfully."]
pub const rte_flow_op_status_RTE_FLOW_OP_ERROR: rte_flow_op_status = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Asynchronous operation status."]
pub type rte_flow_op_status = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Asynchronous operation result."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_op_result {
    #[doc = " Returns the status of the operation that this completion signals."]
    pub status: rte_flow_op_status,
    #[doc = " The user data that will be returned on the completion events."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[doc = " UDP tunneling configuration.\n\n Used to configure the classifier of a device,\n associating an UDP port with a type of tunnel.\n\n Some NICs may need such configuration to properly parse a tunnel\n with any standard or custom UDP port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. @see rte_eth_tunnel_type"]
    pub prot_type: u8,
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port.\n Depending upon the Rx multi-queue mode, extra advanced\n configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be\nused. RTE_ETH_LINK_SPEED_FIXED disables link\nautonegotiation, and a unique speed shall be\nset. Otherwise, the bitmap defines the set of\nspeeds to be advertised. If the special value\nRTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds\nsupported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port Rx configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port Tx configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value\nis 0, meaning the loopback mode is disabled.\nRead the datasheet of given Ethernet controller\nfor details. The possible values of this field\nare defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port Rx filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port Tx DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC\nis needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    #[doc = " Port VMDq+DCB configuration."]
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    #[doc = " Port DCB Rx configuration."]
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    #[doc = " Port VMDq Rx configuration."]
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    #[doc = " Port VMDq+DCB Tx configuration."]
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    #[doc = " Port DCB Tx configuration."]
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    #[doc = " Port VMDq Tx configuration."]
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[doc = " Preferred Rx/Tx port parameters.\n There are separate instances of this structure for transmission\n and reception respectively."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain ID"]
    pub domain_id: u16,
    #[doc = " Mapping to the devices physical switch port as enumerated from the\n perspective of the embedded interconnect/switch. For SR-IOV enabled\n device this may correspond to the VF_ID of each virtual function,\n but each driver should explicitly define the mapping of switch\n port identifier to that physical interconnect/switch"]
    pub port_id: u16,
    #[doc = " Shared Rx queue sub-domain boundary. Only ports in same Rx domain\n and switch domain can share Rx queue. Valid only if device advertised\n RTE_ETH_DEV_CAPA_RXQ_SHARE capability."]
    pub rx_domain: u16,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pools_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pools_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_align_log2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_align_log2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< not a representor."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_NONE: rte_eth_representor_type = 0;
#[doc = "< representor of Virtual Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_VF: rte_eth_representor_type = 1;
#[doc = "< representor of Sub Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_SF: rte_eth_representor_type = 2;
#[doc = "< representor of Physical Function."]
pub const rte_eth_representor_type_RTE_ETH_REPRESENTOR_PF: rte_eth_representor_type = 3;
#[doc = " Ethernet device representor port type."]
pub type rte_eth_representor_type = ::std::os::raw::c_uint;
#[doc = " No error handling modes are supported."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_NONE: rte_eth_err_handle_mode = 0;
#[doc = " Passive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_INTR_RESET event,\n and the application invokes @see rte_eth_dev_reset to recover the port."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: rte_eth_err_handle_mode = 1;
#[doc = " Proactive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_ERR_RECOVERING event,\n do recovery internally, and finally reports the recovery result event\n (@see RTE_ETH_EVENT_RECOVERY_*)."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: rte_eth_err_handle_mode = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this enumeration may change without prior notice.\n\n Ethernet device error handling mode."]
pub type rte_eth_err_handle_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to retrieve the contextual information of\n an Ethernet device, such as the controlling driver of the\n device, etc..."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Generic device information"]
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none.\nUse if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = " Minimum Rx buffer size per descriptor supported by HW."]
    pub min_rx_bufsize: u32,
    #[doc = " Maximum Rx buffer size per descriptor supported by HW.\n The value is not enforced, information only to application to\n optimize mbuf size.\n Its value is UINT32_MAX when not specified by the driver."]
    pub max_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of Rx pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of Rx queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of Tx queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    #[doc = " Maximum number of hash MAC addresses for MTA and UTA."]
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    #[doc = " All Rx offload capabilities including all per-queue ones"]
    pub rx_offload_capa: u64,
    #[doc = " All Tx offload capabilities including all per-queue ones"]
    pub tx_offload_capa: u64,
    #[doc = " Device per-queue Rx offload capabilities."]
    pub rx_queue_offload_capa: u64,
    #[doc = " Device per-queue Tx offload capabilities."]
    pub tx_queue_offload_capa: u64,
    #[doc = " Device redirection table size, the total number of entries."]
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    #[doc = " RSS hash algorithms capabilities */\n/** Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default Rx configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default Tx configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDq pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDq pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDq pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< Rx descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Tx descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (RTE_ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of Rx queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues."]
    pub nb_tx_queues: u16,
    #[doc = " Maximum number of Rx mempools supported per Rx queue.\n\n Value greater than 0 means that the driver supports Rx queue\n mempools specification via rx_conf->rx_mempools."]
    pub max_rx_mempools: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a\n embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = " Supported error handling mode."]
    pub err_handle_mode: rte_eth_err_handle_mode,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[doc = " Ethernet device Rx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets Rx supported."]
    pub scattered_rx: u8,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    #[doc = "< hardware receive buffer size."]
    pub rx_buf_size: u16,
    #[doc = " Available Rx descriptors threshold defined as percentage\n of Rx queue size. If number of available descriptors is lower,\n the event RTE_ETH_EVENT_RX_AVAIL_THESH is generated.\n Value 0 means that the threshold monitoring is disabled."]
    pub avail_thresh: u8,
}
#[doc = " Ethernet device Tx queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
    #[doc = "< one of RTE_ETH_QUEUE_STATE_*."]
    pub queue_state: u8,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx queue information structure for recycling mbufs.\n Used to retrieve Rx queue information when Tx queue reusing mbufs and moving\n them into Rx mbuf ring."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_recycle_rxq_info {
    #[doc = "< mbuf ring of Rx queue."]
    pub mbuf_ring: *mut *mut rte_mbuf,
    #[doc = "< mempool of Rx queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< head of Rx queue refilling mbufs."]
    pub refill_head: *mut u16,
    #[doc = "< tail of Rx queue receiving pkts."]
    pub receive_tail: *mut u16,
    #[doc = "< configured number of mbuf ring size."]
    pub mbuf_ring_size: u16,
    #[doc = " Requirement on mbuf refilling batch size of Rx mbuf ring.\n For some PMD drivers, the number of Rx mbuf ring refilling mbufs\n should be aligned with mbuf ring size, in order to simplify\n ring wrapping around.\n Value 0 means that PMD drivers have no requirement for this."]
    pub refill_requirement: u16,
}
#[doc = " Ethernet device Rx/Tx queue packet burst mode information structure.\n Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[doc = " An Ethernet device extended statistic structure\n\n This structure is used by rte_eth_xstats_get() to provide\n statistics that are not provided in the generic *rte_eth_stats*\n structure.\n It maps a name ID, corresponding to an index in the array returned\n by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[doc = " A name element for extended statistics.\n\n An array of this structure is returned by rte_eth_xstats_get_names().\n It lists the names of extended statistics for a PMD. The *rte_eth_xstat*\n structure references these names by their array index.\n\n The xstats should follow a common naming scheme.\n Some names are standardized in rte_stats_strings.\n Examples:\n     - rx_missed_errors\n     - tx_q3_bytes\n     - tx_size_128_to_255_packets"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " A structure used to get the information of queue and\n TC mapping on both Tx and Rx paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " Rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u16,
    pub nb_queue: u16,
}
#[doc = " A structure used to get the information of DCB.\n It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< Tx BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " Rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fec_capa {
    #[doc = "< Link speed (see RTE_ETH_SPEED_NUM_*)"]
    pub speed: u32,
    #[doc = "< FEC capabilities bitmask"]
    pub capa: u32,
}
#[doc = " Function type used for Rx packet processing packet callbacks.\n\n The callback function is called on Rx with a burst of packets that have\n been received on the given port and queue.\n\n @param port_id\n   The Ethernet port on which Rx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to receive the packets.\n @param pkts\n   The burst of packets that have just been received.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param max_pkts\n   The max number of packets that can be stored in the \"pkts\" array.\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for Tx packet processing packet callbacks.\n\n The callback function is called on Tx with a burst of packets immediately\n before the packets are put onto the hardware queue for transmission.\n\n @param port_id\n   The Ethernet port on which Tx is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to transmit the packets.\n @param pkts\n   The burst of packets that are about to be transmitted.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Device is unused before being probed."]
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
#[doc = " Device is attached when allocated in probing."]
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
#[doc = " Device is in removed state when plug-out is detected."]
pub const rte_eth_dev_state_RTE_ETH_DEV_REMOVED: rte_eth_dev_state = 2;
#[doc = " Possible states of an ethdev port."]
pub type rte_eth_dev_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< Rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor ID range entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_representor_range {
    #[doc = "< Representor type"]
    pub type_: rte_eth_representor_type,
    #[doc = "< Controller index"]
    pub controller: ::std::os::raw::c_int,
    #[doc = "< Physical function index"]
    pub pf: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_eth_representor_range__bindgen_ty_1,
    #[doc = "< Representor ID start index"]
    pub id_base: u32,
    #[doc = "< Representor ID end index"]
    pub id_end: u32,
    #[doc = "< Representor name"]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_representor_range__bindgen_ty_1 {
    #[doc = "< VF start index"]
    pub vf: ::std::os::raw::c_int,
    #[doc = "< SF start index"]
    pub sf: ::std::os::raw::c_int,
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device representor information"]
#[repr(C)]
pub struct rte_eth_representor_info {
    #[doc = "< Controller ID of caller device."]
    pub controller: u16,
    #[doc = "< Physical function ID of caller device."]
    pub pf: u16,
    #[doc = "< Size of the ranges array."]
    pub nb_ranges_alloc: u32,
    #[doc = "< Number of initialized ranges."]
    pub nb_ranges: u32,
    #[doc = "< Representor ID range."]
    pub ranges: __IncompleteArrayField<rte_eth_representor_range>,
}
#[doc = " A structure used to get/set IP reassembly configuration. It is also used\n to get the maximum capability values that a PMD can support.\n\n If rte_eth_ip_reassembly_capability_get() returns 0, IP reassembly can be\n enabled using rte_eth_ip_reassembly_conf_set() and params values lower than\n capability params can be set in the PMD."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_ip_reassembly_params {
    #[doc = " Maximum time in ms which PMD can wait for other fragments."]
    pub timeout_ms: u32,
    #[doc = " Maximum number of fragments that can be reassembled."]
    pub max_frags: u16,
    #[doc = " Flags to enable reassembly of packet types -\n RTE_ETH_DEV_REASSEMBLY_F_xxx."]
    pub flags: u16,
}
#[doc = " Congestion management based on Rx queue depth"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE: rte_eth_cman_obj = 1;
#[doc = " Congestion management based on mempool depth associated with Rx queue\n @see rte_eth_rx_queue_setup()"]
pub const rte_eth_cman_obj_RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL: rte_eth_cman_obj = 2;
#[doc = " Enumerate list of ethdev congestion management objects"]
pub type rte_eth_cman_obj = ::std::os::raw::c_uint;
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to retrieve information of ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_info {
    #[doc = " Set of supported congestion management modes\n @see enum rte_cman_mode"]
    pub modes_supported: u64,
    #[doc = " Set of supported congestion management objects\n @see enum rte_eth_cman_obj"]
    pub objs_supported: u64,
    #[doc = " Reserved for future fields. Always returned as 0 when\n rte_eth_cman_info_get() is invoked"]
    pub rsvd: [u8; 8usize],
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change, or be removed, without prior notice\n\n A structure used to configure the ethdev congestion management."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_cman_config {
    #[doc = " Congestion management object"]
    pub obj: rte_eth_cman_obj,
    #[doc = " Congestion management mode"]
    pub mode: rte_cman_mode,
    pub obj_param: rte_eth_cman_config__bindgen_ty_1,
    pub mode_param: rte_eth_cman_config__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_1 {
    #[doc = " Rx queue to configure congestion management.\n\n Valid when object is RTE_ETH_CMAN_OBJ_RX_QUEUE or\n RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL."]
    pub rx_queue: u16,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_obj_params: [u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_cman_config__bindgen_ty_2 {
    #[doc = " RED configuration parameters.\n\n Valid when mode is RTE_CMAN_RED."]
    pub red: rte_cman_red_params,
    #[doc = " Reserved for future fields.\n It must be set to 0 when rte_eth_cman_config_set() is invoked\n and will be returned as 0 when rte_eth_cman_config_get() is\n invoked."]
    pub rsvd_mode_params: [u8; 4usize],
}
#[doc = " @file\n\n RTE Ethernet Device internal header.\n\n This header contains internal data types. But they are still part of the\n public API because they are used by inline functions in the published API.\n\n Applications should not use these directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[doc = " @internal Retrieve input packets from a receive queue of an Ethernet device."]
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Send output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Prepare output packets on a transmit queue of an Ethernet device."]
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
#[doc = " @internal Get number of used descriptors on a receive queue."]
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void) -> u32>;
#[doc = " @internal Check the status of a Rx descriptor"]
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get number of used descriptors on a transmit queue."]
pub type eth_tx_queue_count_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Check the status of a Tx descriptor"]
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Copy used mbufs from Tx mbuf ring into Rx mbuf ring"]
pub type eth_recycle_tx_mbufs_reuse_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ) -> u16,
>;
#[doc = " @internal Refill Rx descriptors with the recycling mbufs"]
pub type eth_recycle_rx_descriptors_refill_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, nb: u16)>;
#[doc = " @internal\n Structure used to hold information about the callbacks to be called for a\n queue on Rx and Tx."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
}
#[doc = " @internal\n The generic data structure associated with each Ethernet device.\n\n Pointers to burst-oriented packet receive and transmit functions are\n located at the beginning of the structure, along with the pointer to\n where all the data elements for the particular device are stored in shared\n memory. This split allows the function pointer and driver data to be per-\n process, while the actual configuration data for the device is shared."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    #[doc = "< Pointer to PMD receive function"]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = "< Pointer to PMD transmit function"]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = " Pointer to PMD transmit prepare function"]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = " Get the number of used Rx descriptors"]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = " Check the status of a Rx descriptor"]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = " Get the number of used Tx descriptors"]
    pub tx_queue_count: eth_tx_queue_count_t,
    #[doc = " Check the status of a Tx descriptor"]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = " Pointer to PMD transmit mbufs reuse function"]
    pub recycle_tx_mbufs_reuse: eth_recycle_tx_mbufs_reuse_t,
    #[doc = " Pointer to PMD receive descriptors refill function"]
    pub recycle_rx_descriptors_refill: eth_recycle_rx_descriptors_refill_t,
    #[doc = " Device data that is shared between primary and secondary processes"]
    pub data: *mut rte_eth_dev_data,
    #[doc = "< Pointer to per-process device data"]
    pub process_private: *mut ::std::os::raw::c_void,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *const eth_dev_ops,
    #[doc = " Fast path flow API functions exported by PMD"]
    pub flow_fp_ops: *mut rte_flow_fp_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = " User application callbacks for NIC interrupts"]
    pub link_intr_cbs: rte_eth_dev_cb_list,
    #[doc = " User-supplied functions called from rx_burst to post-process\n received packets before passing them to the user"]
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = " User-supplied functions called from tx_burst to pre-process\n received packets before passing them to the driver for transmission"]
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = "< Flag indicating the port state"]
    pub state: rte_eth_dev_state,
    #[doc = "< Context for security ops"]
    pub security_ctx: *mut ::std::os::raw::c_void,
}
#[doc = " @internal\n The data part, with no function pointers, associated with each Ethernet\n device. This structure is safe to place in shared memory to be common\n among different processes in a multi-process configuration."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Array of pointers to Rx queues"]
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Array of pointers to Tx queues"]
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Number of Rx queues"]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues"]
    pub nb_tx_queues: u16,
    #[doc = "< SRIOV data"]
    pub sriov: rte_eth_dev_sriov,
    #[doc = " PMD-specific private data. @see rte_eth_dev_release_port()"]
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Link-level information & status"]
    pub dev_link: rte_eth_link,
    #[doc = "< Configuration applied to device"]
    pub dev_conf: rte_eth_conf,
    #[doc = "< Maximum Transmission Unit"]
    pub mtu: u16,
    #[doc = " Common Rx buffer size handled by all queues"]
    pub min_rx_buf_size: u32,
    #[doc = "< Rx ring mbuf allocation failures"]
    pub rx_mbuf_alloc_failed: u64,
    #[doc = " Device Ethernet link addresses.\n All entries are unique.\n The first entry (index zero) is the default address."]
    pub mac_addrs: *mut rte_ether_addr,
    #[doc = " Bitmap associating MAC addresses to pools"]
    pub mac_pool_sel: [u64; 128usize],
    #[doc = " Device Ethernet MAC addresses of hash filtering.\n @see rte_eth_dev_release_port()"]
    pub hash_mac_addrs: *mut rte_ether_addr,
    #[doc = "< Device [external] port identifier"]
    pub port_id: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub rx_queue_state: [u8; 1024usize],
    #[doc = " Queues state: HAIRPIN(2) / STARTED(1) / STOPPED(0)"]
    pub tx_queue_state: [u8; 1024usize],
    #[doc = "< Capabilities"]
    pub dev_flags: u32,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = " VLAN filter configuration"]
    pub vlan_filter_conf: rte_vlan_filter_conf,
    #[doc = "< The port owner"]
    pub owner: rte_eth_dev_owner,
    #[doc = " Switch-specific identifier.\n Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub representor_id: u16,
    #[doc = " Port ID of the backing device.\n This device will be used to query representor info and calculate\n representor IDs. Valid if RTE_ETH_DEV_REPRESENTOR in dev_flags."]
    pub backer_port_id: u16,
    #[doc = "< rte_flow ops mutex"]
    pub flow_ops_mutex: pthread_mutex_t,
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn promiscuous_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_promiscuous_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scattered_rx_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_scattered_rx_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn all_multicast_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_all_multicast_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_started_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dev_started_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lro_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dev_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_configured_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dev_configured_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_configured(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_configured(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_configured_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flow_configured_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
        dev_configured: u8,
        flow_configured: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dev_configured: u8 = unsafe { ::std::mem::transmute(dev_configured) };
            dev_configured as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let flow_configured: u8 = unsafe { ::std::mem::transmute(flow_configured) };
            flow_configured as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @internal Ethernet device configuration."]
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to start a configured Ethernet device."]
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to stop a configured Ethernet device."]
pub type eth_dev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link up a configured Ethernet device."]
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to link down a configured Ethernet device."]
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to close a configured Ethernet device."]
pub type eth_dev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to reset a configured Ethernet device."]
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to detect an Ethernet device removal."]
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Function used to enable the Rx promiscuous mode of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, promiscuous mode is enabled.\n @retval -ENOTSUP\n   Promiscuous mode is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to enable promiscuous mode failed because of timeout.\n @retval -EAGAIN\n   Failed to enable promiscuous mode."]
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Function used to disable the Rx promiscuous mode of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, promiscuous mode is disabled.\n @retval -ENOTSUP\n   Promiscuous mode disabling is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to disable promiscuous mode failed because of timeout.\n @retval -EAGAIN\n   Failed to disable promiscuous mode."]
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Enable the receipt of all multicast packets by an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, all-multicast mode is enabled.\n @retval -ENOTSUP\n   All-multicast mode is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to enable all-multicast mode failed because of timeout.\n @retval -EAGAIN\n   Failed to enable all-multicast mode."]
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Disable the receipt of all multicast packets by an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, all-multicast mode is disabled.\n @retval -ENOTSUP\n   All-multicast mode disabling is not supported.\n @retval -ENODEV\n   Device is gone.\n @retval -E_RTE_SECONDARY\n   Function was called from a secondary process instance and not supported.\n @retval -ETIMEDOUT\n   Attempt to disable all-multicast mode failed because of timeout.\n @retval -EAGAIN\n   Failed to disable all-multicast mode."]
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Get link speed, duplex mode and state (up/down) of an Ethernet device."]
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get number of current active lanes\n\n @param dev\n   ethdev handle of port.\n @param speed_lanes\n   Number of active lanes that the link has trained up. This information\n   is displayed for Autonegotiated or Fixed speed trained link.\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, get speed_lanes data success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed."]
pub type eth_speed_lanes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, speed_lanes: *mut u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set speed lanes supported by the NIC. This configuration is applicable only when\n fix speed is already configured and or will be configured. This api requires the\n port be stopped, since driver has to re-configure PHY with fixed speed and lanes.\n If no lanes are configured prior or after \"port config X speed Y duplex Z\", the\n driver will choose the default lane for that speed to bring up the link.\n\n @param dev\n   ethdev handle of port.\n @param speed_lanes\n   Non-negative number of lanes\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, set lanes success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   Unsupported number of lanes for fixed speed requested.\n @retval -EIO\n   Device is removed."]
pub type eth_speed_lanes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, speed_lanes: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get supported link speed lanes capability. The driver returns number of lanes\n supported per speed in the form of lanes capability bitmap per speed.\n\n @param speed_lanes_capa\n   A pointer to num of rte_eth_speed_lanes_capa struct array which carries the\n   bit map of lanes supported per speed. The number of supported speeds is the\n   size of this speed_lanes_capa table. In link up condition, only active supported\n   speeds lanes bitmap information will be displayed. In link down condition, all\n   the supported speeds and its supported lanes bitmap would be fetched and displayed.\n\n   This api is overloaded to fetch the size of the speed_lanes_capa array if\n   testpmd calls the driver with speed_lanes_capa = NULL and num = 0\n\n @param num\n   Number of elements in a speed_speed_lanes_capa array. This num is equal to the\n   number of supported speeds by the controller. This value will vary in link up\n   and link down condition. num is updated by the driver if speed_lanes_capa is NULL.\n\n @return\n   Negative errno value on error, positive value on success.\n\n @retval positive value\n   A non-negative value lower or equal to num: success. The return value\n   is the number of entries filled in the speed lanes array.\n   A non-negative value higher than num: error, the given speed lanes capa array\n   is too small. The return value corresponds to the num that should\n   be given to succeed. The entries in the speed lanes capa array are not valid\n   and shall not be used by the caller.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   *num* or *speed_lanes_capa* invalid."]
pub type eth_speed_lanes_get_capability_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        speed_lanes_capa: *mut rte_eth_speed_lanes_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get global I/O statistics of an Ethernet device."]
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        igb_stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Reset global I/O statistics of an Ethernet device to 0.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, statistics has been reset.\n @retval -ENOTSUP\n   Resetting statistics is not supported.\n @retval -EINVAL\n   Resetting statistics is not valid.\n @retval -ENOMEM\n   Not enough memory to get the stats."]
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get extended stats of an Ethernet device."]
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n @param ids\n   IDs array to retrieve specific statistics. Must not be NULL.\n @param values\n   A pointer to a table to be filled with device statistics values.\n   Must not be NULL.\n @param n\n   Element count in @p ids and @p values.\n\n @return\n   - A number of filled in stats.\n   - A negative value on error."]
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Reset extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, statistics has been reset.\n @retval -ENOTSUP\n   Resetting statistics is not supported.\n @retval -EINVAL\n   Resetting statistics is not valid.\n @retval -ENOMEM\n   Not enough memory to get the stats."]
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Get names of extended stats of an Ethernet device."]
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get names of extended stats of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n @param ids\n   IDs array to retrieve specific statistics. Must not be NULL.\n @param xstats_names\n   An rte_eth_xstat_name array of at least @p size elements to be filled.\n   Must not be NULL.\n @param size\n   Element count in @p ids and @p xstats_names.\n\n @return\n   - A number of filled in stats.\n   - A negative value on error."]
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Enable an xstat of an Ethernet device."]
pub type eth_xstats_enable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Disable an xstat of an Ethernet device."]
pub type eth_xstats_disable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query the state of an xstat the can be enabled and disabled in runtime."]
pub type eth_xstats_query_state_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set a queue statistics mapping for a Tx/Rx queue of an Ethernet device."]
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get specific information of an Ethernet device."]
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Function used to get supported ptypes of an Ethernet device.\n\n @param dev\n   ethdev handle of port.\n\n @param no_of_elements\n   number of ptypes elements. Must be initialized to 0.\n\n @retval\n   Success, array of ptypes elements and valid no_of_elements > 0.\n   Failures, NULL."]
pub type eth_dev_supported_ptypes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, no_of_elements: *mut usize) -> *const u32,
>;
#[doc = " @internal\n Inform Ethernet device about reduced range of packet types to handle.\n\n @param dev\n   The Ethernet device identifier.\n @param ptype_mask\n   The ptype family that application is interested in should be bitwise OR of\n   RTE_PTYPE_*_MASK or 0.\n @return\n   - (0) if Success."]
pub type eth_dev_ptypes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ptype_mask: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Start Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Stop Rx and Tx of a queue of an Ethernet device."]
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set up a receive queue of an Ethernet device."]
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup a transmit queue of an Ethernet device."]
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Enable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Disable interrupt of a receive queue of an Ethernet device."]
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Release memory resources allocated by given Rx/Tx queue."]
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16)>;
#[doc = " @internal Get firmware information of an Ethernet device."]
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Force mbufs to be from Tx ring."]
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type eth_recycle_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        recycle_rxq_info: *mut rte_eth_recycle_rxq_info,
    ),
>;
pub type eth_burst_mode_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set MTU."]
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Filtering of a VLAN Tag Identifier by an Ethernet device."]
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set the outer/inner VLAN-TPID by an Ethernet device."]
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set VLAN offload function by an Ethernet device."]
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set port based Tx VLAN insertion by an Ethernet device."]
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal VLAN stripping enable/disable by an queue of Ethernet device."]
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
#[doc = " @internal Get current flow control parameter on an Ethernet device."]
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup flow control parameter on an Ethernet device."]
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Setup priority flow control parameter on an Ethernet device."]
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get info for queue based PFC on an Ethernet device."]
pub type priority_flow_ctrl_queue_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_info: *mut rte_eth_pfc_queue_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Configure queue based PFC parameter on an Ethernet device."]
pub type priority_flow_ctrl_queue_config_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_queue_conf: *mut rte_eth_pfc_queue_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS redirection table on an Ethernet device."]
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query RSS redirection table on an Ethernet device."]
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update RSS hash configuration of an Ethernet device."]
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get current RSS hash configuration of an Ethernet device."]
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Turn on SW controllable LED on an Ethernet device."]
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Turn off SW controllable LED on an Ethernet device."]
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Remove MAC address from receive address register."]
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a MAC address into Receive Address Register."]
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set a Unicast Hash bitmap."]
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set all Unicast Hash bitmap."]
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set queue Tx rate."]
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Add tunneling UDP port."]
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Delete tunneling UDP port."]
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal set the list of multicast addresses on an Ethernet device."]
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to enable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to disable IEEE1588/802.1AS timestamping."]
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Function used to read an Rx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to read a Tx IEEE1588/802.1AS timestamp."]
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to adjust the device clock."]
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to adjust the clock frequency."]
pub type eth_timesync_adjust_freq = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get time from the device clock."]
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Function used to get the current value of the device clock."]
pub type eth_read_clock = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve registers."]
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve EEPROM size."]
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal Retrieve EEPROM data."]
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Program EEPROM data."]
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve type and size of plugin module EEPROM."]
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve plugin module EEPROM data."]
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_ops {
    _unused: [u8; 0],
}
#[doc = " @internal\n Get flow operations.\n\n If the flow API is not supported for the specified device,\n the driver can return NULL."]
pub type eth_flow_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut *const rte_flow_ops,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Management (TM) operations on an Ethernet device."]
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get Traffic Metering and Policing (MTR) operations."]
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get DCB information on an Ethernet device."]
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Test if a port supports specific mempool ops."]
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get the hairpin capabilities.\n\n @param dev\n   ethdev handle of port.\n @param cap\n   returns the hairpin capabilities from the device.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported."]
pub type eth_hairpin_cap_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Setup Rx hairpin queue.\n\n @param dev\n   ethdev handle of port.\n @param rx_queue_id\n   the selected Rx queue index.\n @param nb_rx_desc\n   the requested number of descriptors for this queue. 0 - use PMD default.\n @param conf\n   the Rx hairpin configuration structure.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -ENOMEM\n   Unable to allocate resources."]
pub type eth_rx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Setup Tx hairpin queue.\n\n @param dev\n   ethdev handle of port.\n @param tx_queue_id\n   the selected Tx queue index.\n @param nb_tx_desc\n   the requested number of descriptors for this queue. 0 - use PMD default.\n @param conf\n   the Tx hairpin configuration structure.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, hairpin is supported.\n @retval -ENOTSUP\n   Hairpin is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -ENOMEM\n   Unable to allocate resources."]
pub type eth_tx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get Forward Error Correction(FEC) capability.\n\n @param dev\n   ethdev handle of port.\n @param speed_fec_capa\n   speed_fec_capa is out only with per-speed capabilities.\n @param num\n   a number of elements in an speed_fec_capa array.\n\n @return\n   Negative errno value on error, positive value on success.\n\n @retval positive value\n   A non-negative value lower or equal to num: success. The return value\n   is the number of entries filled in the fec capa array.\n   A non-negative value higher than num: error, the given fec capa array\n   is too small. The return value corresponds to the num that should\n   be given to succeed. The entries in the fec capa array are not valid\n   and shall not be used by the caller.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed.\n @retval -EINVAL\n   *num* or *speed_fec_capa* invalid."]
pub type eth_fec_get_capability_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get Forward Error Correction(FEC) mode.\n\n @param dev\n   ethdev handle of port.\n @param fec_capa\n   a bitmask of enabled FEC modes. If AUTO bit is set, other\n   bits specify FEC modes which may be negotiated. If AUTO\n   bit is clear, specify FEC modes to be used (only one valid\n   mode per speed may be set).\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, get FEC success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EIO\n   Device is removed."]
pub type eth_fec_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: *mut u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set Forward Error Correction(FEC) mode.\n\n @param dev\n   ethdev handle of port.\n @param fec_capa\n   bitmask of allowed FEC modes. It must be only one\n   if AUTO is disabled. If AUTO is enabled, other\n   bits specify FEC modes which may be negotiated.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, set FEC success.\n @retval -ENOTSUP\n   Operation is not supported.\n @retval -EINVAL\n   Unsupported FEC mode requested.\n @retval -EIO\n   Device is removed."]
pub type eth_fec_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fec_capa: u32) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get all hairpin Tx/Rx peer ports of the current device, if any.\n\n @param dev\n   ethdev handle of port.\n @param peer_ports\n   array to save the ports list.\n @param len\n   array length.\n @param direction\n   value to decide the current to peer direction\n   positive - used as Tx to get all peer Rx ports.\n   zero - used as Rx to get all peer Tx ports.\n\n @return\n   Negative errno value on error, 0 or positive on success.\n\n @retval 0\n   Success, no peer ports.\n @retval >0\n   Actual number of the peer ports.\n @retval -ENOTSUP\n   Get peer ports API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid."]
pub type hairpin_get_peer_ports_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_ports: *mut u16,
        len: usize,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Bind all hairpin Tx queues of one port to the Rx queues of the peer port.\n\n @param dev\n   ethdev handle of port.\n @param rx_port\n   the peer Rx port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, bind successfully.\n @retval -ENOTSUP\n   Bind API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -EBUSY\n   Device is not started."]
pub type eth_hairpin_bind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Unbind all hairpin Tx queues of one port from the Rx queues of the peer port.\n\n @param dev\n   ethdev handle of port.\n @param rx_port\n   the peer Rx port.\n\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success, unbind successfully.\n @retval -ENOTSUP\n   Bind API is not supported.\n @retval -EINVAL\n   One of the parameters is invalid.\n @retval -EBUSY\n   Device is already stopped."]
pub type eth_hairpin_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Update and fetch peer queue information."]
pub type eth_hairpin_queue_peer_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        peer_queue: u16,
        current_info: *mut rte_hairpin_peer_info,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Bind peer queue to the current queue with fetched information."]
pub type eth_hairpin_queue_peer_bind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Unbind peer queue from the current queue."]
pub type eth_hairpin_queue_peer_unbind_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        direction: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get address of memory location whose contents will change whenever there is\n new data to be received on an Rx queue.\n\n @param rxq\n   Ethdev queue pointer.\n @param pmc\n   The pointer to power-optimized monitoring condition structure.\n @return\n   Negative errno value on error, 0 on success.\n\n @retval 0\n   Success\n @retval -EINVAL\n   Invalid parameters"]
pub type eth_get_monitor_addr_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get representor info to be able to calculate the unique representor ID.\n\n Caller should pass NULL as pointer of info to get number of entries,\n allocate info buffer according to returned entry number, then call\n again with buffer to get real info.\n\n To calculate the representor ID, caller should iterate each entry,\n match controller index, pf index, vf or sf start index and range,\n then calculate representor ID from offset to vf/sf start index.\n @see rte_eth_representor_id_get.\n\n @param dev\n   Ethdev handle of port.\n @param [out] info\n   Pointer to memory to save device representor info.\n @return\n   Negative errno value on error, number of info entries otherwise."]
pub type eth_representor_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[inout] features\n   Feature selection buffer\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_rx_metadata_negotiate_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, features: *mut u64) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get IP reassembly offload capability of a PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[out] conf\n   IP reassembly capability supported by the PMD\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_capability_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        capa: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get IP reassembly offload configuration parameters set in PMD.\n\n @param dev\n   Port (ethdev) handle\n\n @param[out] conf\n   Configuration parameters for IP reassembly.\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *mut rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Set configuration parameters for enabling IP reassembly offload in hardware.\n\n @param dev\n   Port (ethdev) handle\n\n @param[in] conf\n   Configuration parameters for IP reassembly.\n\n @return\n   Negative errno value on error, zero otherwise"]
pub type eth_ip_reassembly_conf_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        conf: *const rte_eth_ip_reassembly_params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get supported header protocols of a PMD to split.\n\n @param dev\n   Ethdev handle of port.\n\n @return\n   An array pointer to store supported protocol headers."]
pub type eth_buffer_split_supported_hdr_ptypes_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, no_of_elements: *mut usize) -> *const u32,
>;
#[doc = " @internal\n Dump private info from device to a file.\n\n @param dev\n   Port (ethdev) handle.\n @param file\n   A pointer to a file for output.\n\n @return\n   Negative value on error, 0 on success.\n\n @retval 0\n   Success\n @retval -EINVAL\n   Invalid file"]
pub type eth_dev_priv_dump_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, file: *mut FILE) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Set Rx queue available descriptors threshold.\n @see rte_eth_rx_avail_thresh_set()\n\n Driver should round down number of descriptors on conversion from\n percentage."]
pub type eth_rx_queue_avail_thresh_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        avail_thresh: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Query Rx queue available descriptors threshold event.\n @see rte_eth_rx_avail_thresh_query()"]
pub type eth_rx_queue_avail_thresh_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: *mut u16,
        avail_thresh: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Get congestion management information."]
pub type eth_cman_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_cman_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Init congestion management structure with default values."]
pub type eth_cman_config_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Configure congestion management on a port."]
pub type eth_cman_config_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *const rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal Retrieve congestion management configuration of a port."]
pub type eth_cman_config_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        config: *mut rte_eth_cman_config,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Dump Rx descriptor info to a file.\n\n It is used for debugging, not a dataplane API.\n\n @param dev\n   Port (ethdev) handle.\n @param queue_id\n   A Rx queue identifier on this port.\n @param offset\n   The offset of the descriptor starting from tail. (0 is the next\n   packet to be received by the driver).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   Negative errno value on error, zero on success."]
pub type eth_rx_descriptor_dump_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_eth_dev,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Dump Tx descriptor info to a file.\n\n This API is used for debugging, not a dataplane API.\n\n @param dev\n   Port (ethdev) handle.\n @param queue_id\n   A Tx queue identifier on this port.\n @param offset\n   The offset of the descriptor starting from tail. (0 is the place where\n   the next packet will be send).\n @param num\n   The number of the descriptors to dump.\n @param file\n   A pointer to a file for output.\n @return\n   Negative errno value on error, zero on success."]
pub type eth_tx_descriptor_dump_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_eth_dev,
        queue_id: u16,
        offset: u16,
        num: u16,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal\n Get the number of aggregated ports.\n\n @param dev\n   Port (ethdev) handle.\n\n @return\n   Negative errno value on error, 0 or positive on success.\n\n @retval >=0\n   The number of aggregated port if success."]
pub type eth_count_aggr_ports_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
#[doc = " @internal\n Map a Tx queue with an aggregated port of the DPDK port.\n\n @param dev\n   Port (ethdev) handle.\n @param tx_queue_id\n   The index of the transmit queue used in rte_eth_tx_burst().\n @param affinity\n   The number of the aggregated port.\n\n @return\n   Negative on error, 0 on success."]
pub type eth_map_aggr_tx_affinity_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        affinity: u8,
    ) -> ::std::os::raw::c_int,
>;
pub const rte_eth_dev_operation_RTE_ETH_START: rte_eth_dev_operation = 0;
#[doc = " @internal\n Defines types of operations which can be executed by the application."]
pub type rte_eth_dev_operation = ::std::os::raw::c_uint;
#[doc = " @internal\n Fetch from the driver what kind of configuration must be restored by ethdev layer,\n after certain operations are performed by the application (such as rte_eth_dev_start()).\n\n @param dev\n   Port (ethdev) handle.\n @param op\n   Type of operation executed by the application.\n\n @return\n   ORed restore flags indicating which configuration should be restored by ethdev.\n   0 if no restore is required by the driver."]
pub type eth_get_restore_flags_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, op: rte_eth_dev_operation) -> u64,
>;
#[doc = " @internal A structure containing the functions exported by an Ethernet driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eth_dev_ops {
    #[doc = "< Configure device"]
    pub dev_configure: eth_dev_configure_t,
    #[doc = "< Start device"]
    pub dev_start: eth_dev_start_t,
    #[doc = "< Stop device"]
    pub dev_stop: eth_dev_stop_t,
    #[doc = "< Device link up"]
    pub dev_set_link_up: eth_dev_set_link_up_t,
    #[doc = "< Device link down"]
    pub dev_set_link_down: eth_dev_set_link_down_t,
    #[doc = "< Close device"]
    pub dev_close: eth_dev_close_t,
    #[doc = "< Reset device"]
    pub dev_reset: eth_dev_reset_t,
    #[doc = "< Get device link state"]
    pub link_update: eth_link_update_t,
    #[doc = "< Get link speed active lanes"]
    pub speed_lanes_get: eth_speed_lanes_get_t,
    #[doc = "< Set link speeds supported lanes"]
    pub speed_lanes_set: eth_speed_lanes_set_t,
    #[doc = " Get link speed lanes capability"]
    pub speed_lanes_get_capa: eth_speed_lanes_get_capability_t,
    #[doc = " Check if the device was physically removed"]
    pub is_removed: eth_is_removed_t,
    #[doc = "< Promiscuous ON"]
    pub promiscuous_enable: eth_promiscuous_enable_t,
    #[doc = "< Promiscuous OFF"]
    pub promiscuous_disable: eth_promiscuous_disable_t,
    #[doc = "< Rx multicast ON"]
    pub allmulticast_enable: eth_allmulticast_enable_t,
    #[doc = "< Rx multicast OFF"]
    pub allmulticast_disable: eth_allmulticast_disable_t,
    #[doc = "< Remove MAC address"]
    pub mac_addr_remove: eth_mac_addr_remove_t,
    #[doc = "< Add a MAC address"]
    pub mac_addr_add: eth_mac_addr_add_t,
    #[doc = "< Set a MAC address"]
    pub mac_addr_set: eth_mac_addr_set_t,
    #[doc = " Set list of multicast addresses"]
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    #[doc = "< Set MTU"]
    pub mtu_set: mtu_set_t,
    #[doc = " Get generic device statistics"]
    pub stats_get: eth_stats_get_t,
    #[doc = " Reset generic device statistics"]
    pub stats_reset: eth_stats_reset_t,
    #[doc = " Get extended device statistics"]
    pub xstats_get: eth_xstats_get_t,
    #[doc = " Reset extended device statistics"]
    pub xstats_reset: eth_xstats_reset_t,
    #[doc = " Get names of extended statistics"]
    pub xstats_get_names: eth_xstats_get_names_t,
    #[doc = " Configure per queue stat counter mapping"]
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    #[doc = "< Get device info"]
    pub dev_infos_get: eth_dev_infos_get_t,
    #[doc = " Retrieve Rx queue information"]
    pub rxq_info_get: eth_rxq_info_get_t,
    #[doc = " Retrieve Tx queue information"]
    pub txq_info_get: eth_txq_info_get_t,
    #[doc = " Retrieve mbufs recycle Rx queue information"]
    pub recycle_rxq_info_get: eth_recycle_rxq_info_get_t,
    #[doc = "< Get Rx burst mode"]
    pub rx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get Tx burst mode"]
    pub tx_burst_mode_get: eth_burst_mode_get_t,
    #[doc = "< Get firmware version"]
    pub fw_version_get: eth_fw_version_get_t,
    #[doc = " Get packet types supported and identified by device"]
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    #[doc = " Inform Ethernet device about reduced range of packet types to\n handle"]
    pub dev_ptypes_set: eth_dev_ptypes_set_t,
    #[doc = " Filter VLAN Setup"]
    pub vlan_filter_set: vlan_filter_set_t,
    #[doc = " Outer/Inner VLAN TPID Setup"]
    pub vlan_tpid_set: vlan_tpid_set_t,
    #[doc = " VLAN Stripping on queue"]
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    #[doc = " Set VLAN Offload"]
    pub vlan_offload_set: vlan_offload_set_t,
    #[doc = " Set port based Tx VLAN insertion"]
    pub vlan_pvid_set: vlan_pvid_set_t,
    #[doc = "< Start Rx for a queue"]
    pub rx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Rx for a queue"]
    pub rx_queue_stop: eth_queue_stop_t,
    #[doc = "< Start Tx for a queue"]
    pub tx_queue_start: eth_queue_start_t,
    #[doc = "< Stop Tx for a queue"]
    pub tx_queue_stop: eth_queue_stop_t,
    #[doc = "< Set up device Rx queue"]
    pub rx_queue_setup: eth_rx_queue_setup_t,
    #[doc = "< Release Rx queue"]
    pub rx_queue_release: eth_queue_release_t,
    #[doc = " Enable Rx queue interrupt"]
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    #[doc = " Disable Rx queue interrupt"]
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    #[doc = "< Set up device Tx queue"]
    pub tx_queue_setup: eth_tx_queue_setup_t,
    #[doc = "< Release Tx queue"]
    pub tx_queue_release: eth_queue_release_t,
    #[doc = "< Free Tx ring mbufs"]
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    #[doc = "< Turn on LED"]
    pub dev_led_on: eth_dev_led_on_t,
    #[doc = "< Turn off LED"]
    pub dev_led_off: eth_dev_led_off_t,
    #[doc = "< Get flow control"]
    pub flow_ctrl_get: flow_ctrl_get_t,
    #[doc = "< Setup flow control"]
    pub flow_ctrl_set: flow_ctrl_set_t,
    #[doc = " Setup priority flow control"]
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    #[doc = " Priority flow control queue info get"]
    pub priority_flow_ctrl_queue_info_get: priority_flow_ctrl_queue_info_get_t,
    #[doc = " Priority flow control queue configure"]
    pub priority_flow_ctrl_queue_config: priority_flow_ctrl_queue_config_t,
    #[doc = " Set Unicast Table Array"]
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    #[doc = " Set Unicast hash bitmap"]
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    #[doc = " Add UDP tunnel port"]
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    #[doc = " Delete UDP tunnel port"]
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    #[doc = " Set queue rate limit"]
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    #[doc = " Configure RSS hash protocols and hashing key"]
    pub rss_hash_update: rss_hash_update_t,
    #[doc = " Get current RSS hash configuration"]
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    #[doc = " Update redirection table"]
    pub reta_update: reta_update_t,
    #[doc = " Query redirection table"]
    pub reta_query: reta_query_t,
    #[doc = "< Get registers"]
    pub get_reg: eth_get_reg_t,
    #[doc = "< Get EEPROM length"]
    pub get_eeprom_length: eth_get_eeprom_length_t,
    #[doc = "< Get EEPROM data"]
    pub get_eeprom: eth_get_eeprom_t,
    #[doc = "< Set EEPROM"]
    pub set_eeprom: eth_set_eeprom_t,
    #[doc = " Get plugin module EEPROM attribute"]
    pub get_module_info: eth_get_module_info_t,
    #[doc = " Get plugin module EEPROM data"]
    pub get_module_eeprom: eth_get_module_eeprom_t,
    #[doc = "< Get flow operations"]
    pub flow_ops_get: eth_flow_ops_get_t,
    #[doc = "< Get DCB information"]
    pub get_dcb_info: eth_get_dcb_info,
    #[doc = " Turn IEEE1588/802.1AS timestamping on"]
    pub timesync_enable: eth_timesync_enable_t,
    #[doc = " Turn IEEE1588/802.1AS timestamping off"]
    pub timesync_disable: eth_timesync_disable_t,
    #[doc = " Read the IEEE1588/802.1AS Rx timestamp"]
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    #[doc = " Read the IEEE1588/802.1AS Tx timestamp"]
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    #[doc = " Adjust the device clock"]
    pub timesync_adjust_time: eth_timesync_adjust_time,
    #[doc = " Adjust the clock frequency"]
    pub timesync_adjust_freq: eth_timesync_adjust_freq,
    #[doc = " Get the device clock time"]
    pub timesync_read_time: eth_timesync_read_time,
    #[doc = " Set the device clock time"]
    pub timesync_write_time: eth_timesync_write_time,
    pub read_clock: eth_read_clock,
    #[doc = " Get extended device statistic values by ID"]
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    #[doc = " Get name of extended device statistics by ID"]
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub xstats_enable: eth_xstats_enable_counter_t,
    pub xstats_disable: eth_xstats_disable_counter_t,
    pub xstats_query_state: eth_xstats_query_state_t,
    #[doc = " Get Traffic Management (TM) operations"]
    pub tm_ops_get: eth_tm_ops_get_t,
    #[doc = " Get Traffic Metering and Policing (MTR) operations"]
    pub mtr_ops_get: eth_mtr_ops_get_t,
    #[doc = " Test if a port supports specific mempool ops"]
    pub pool_ops_supported: eth_pool_ops_supported_t,
    #[doc = " Returns the hairpin capabilities"]
    pub hairpin_cap_get: eth_hairpin_cap_get_t,
    #[doc = " Set up device Rx hairpin queue"]
    pub rx_hairpin_queue_setup: eth_rx_hairpin_queue_setup_t,
    #[doc = " Set up device Tx hairpin queue"]
    pub tx_hairpin_queue_setup: eth_tx_hairpin_queue_setup_t,
    #[doc = " Get Forward Error Correction(FEC) capability"]
    pub fec_get_capability: eth_fec_get_capability_t,
    #[doc = " Get Forward Error Correction(FEC) mode"]
    pub fec_get: eth_fec_get_t,
    #[doc = " Set Forward Error Correction(FEC) mode"]
    pub fec_set: eth_fec_set_t,
    #[doc = " Get hairpin peer ports list"]
    pub hairpin_get_peer_ports: hairpin_get_peer_ports_t,
    #[doc = " Bind all hairpin Tx queues of device to the peer port Rx queues"]
    pub hairpin_bind: eth_hairpin_bind_t,
    #[doc = " Unbind all hairpin Tx queues from the peer port Rx queues"]
    pub hairpin_unbind: eth_hairpin_unbind_t,
    #[doc = " Pass the current queue info and get the peer queue info"]
    pub hairpin_queue_peer_update: eth_hairpin_queue_peer_update_t,
    #[doc = " Set up the connection between the pair of hairpin queues"]
    pub hairpin_queue_peer_bind: eth_hairpin_queue_peer_bind_t,
    #[doc = " Disconnect the hairpin queues of a pair from each other"]
    pub hairpin_queue_peer_unbind: eth_hairpin_queue_peer_unbind_t,
    #[doc = " Get power monitoring condition for Rx queue"]
    pub get_monitor_addr: eth_get_monitor_addr_t,
    #[doc = " Get representor info"]
    pub representor_info_get: eth_representor_info_get_t,
    #[doc = " Negotiate the NIC's ability to deliver specific\n kinds of metadata to the PMD"]
    pub rx_metadata_negotiate: eth_rx_metadata_negotiate_t,
    #[doc = " Get IP reassembly capability"]
    pub ip_reassembly_capability_get: eth_ip_reassembly_capability_get_t,
    #[doc = " Get IP reassembly configuration"]
    pub ip_reassembly_conf_get: eth_ip_reassembly_conf_get_t,
    #[doc = " Set IP reassembly configuration"]
    pub ip_reassembly_conf_set: eth_ip_reassembly_conf_set_t,
    #[doc = " Get supported header ptypes to split"]
    pub buffer_split_supported_hdr_ptypes_get: eth_buffer_split_supported_hdr_ptypes_get_t,
    #[doc = " Dump private info from device"]
    pub eth_dev_priv_dump: eth_dev_priv_dump_t,
    #[doc = " Set Rx queue available descriptors threshold"]
    pub rx_queue_avail_thresh_set: eth_rx_queue_avail_thresh_set_t,
    #[doc = " Query Rx queue available descriptors threshold event"]
    pub rx_queue_avail_thresh_query: eth_rx_queue_avail_thresh_query_t,
    #[doc = " Dump Rx descriptor info"]
    pub eth_rx_descriptor_dump: eth_rx_descriptor_dump_t,
    #[doc = " Dump Tx descriptor info"]
    pub eth_tx_descriptor_dump: eth_tx_descriptor_dump_t,
    #[doc = " Get congestion management information"]
    pub cman_info_get: eth_cman_info_get_t,
    #[doc = " Initialize congestion management structure with default values"]
    pub cman_config_init: eth_cman_config_init_t,
    #[doc = " Configure congestion management"]
    pub cman_config_set: eth_cman_config_set_t,
    #[doc = " Retrieve congestion management configuration"]
    pub cman_config_get: eth_cman_config_get_t,
    #[doc = " Get the number of aggregated ports"]
    pub count_aggr_ports: eth_count_aggr_ports_t,
    #[doc = " Map a Tx queue with an aggregated port of the DPDK port"]
    pub map_aggr_tx_affinity: eth_map_aggr_tx_affinity_t,
    #[doc = " Get configuration which ethdev should restore"]
    pub get_restore_flags: eth_get_restore_flags_t,
}
#[doc = " No traffic metering performed, the output color is the same as the\n input color for every input packet. The meter of the MTR object is\n working in pass-through mode, having same effect as meter disable.\n @see rte_mtr_meter_disable()"]
pub const rte_mtr_algorithm_RTE_MTR_NONE: rte_mtr_algorithm = 0;
#[doc = " Single Rate Three Color Marker (srTCM) - IETF RFC 2697."]
pub const rte_mtr_algorithm_RTE_MTR_SRTCM_RFC2697: rte_mtr_algorithm = 1;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 2698."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC2698: rte_mtr_algorithm = 2;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 4115."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC4115: rte_mtr_algorithm = 3;
#[doc = " Traffic metering algorithms"]
pub type rte_mtr_algorithm = ::std::os::raw::c_uint;
#[doc = " Meter profile"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile {
    #[doc = " Traffic metering algorithm."]
    pub alg: rte_mtr_algorithm,
    pub __bindgen_anon_1: rte_mtr_meter_profile__bindgen_ty_1,
    #[doc = " When zero, the byte mode is enabled for the current profile, so the\n *rate* and *size* fields are specified in bytes per second\n and bytes, respectively.\n When non-zero, the packet mode is enabled for the current profile,\n so the *rate* and *size* fields are specified in packets per second\n and packets, respectively."]
    pub packet_mode: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mtr_meter_profile__bindgen_ty_1 {
    pub srtcm_rfc2697: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1,
    pub trtcm_rfc2698: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2,
    pub trtcm_rfc4115: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Items only valid when *alg* is set to srTCM - RFC 2697."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 2698."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Peak Information Rate (PIR)\n (bytes per second or packets per second)."]
    pub pir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Peak Burst Size (PBS) (bytes or packets)."]
    pub pbs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 4115."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Excess Information Rate (EIR)\n (bytes per second or packets per second)."]
    pub eir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = "< No error."]
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_NONE: rte_mtr_error_type = 0;
#[doc = "< Cause unspecified."]
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_UNSPECIFIED: rte_mtr_error_type = 1;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_METER_PROFILE_ID: rte_mtr_error_type = 2;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_METER_PROFILE: rte_mtr_error_type = 3;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_METER_PROFILE_PACKET_MODE: rte_mtr_error_type = 4;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_MTR_ID: rte_mtr_error_type = 5;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_MTR_PARAMS: rte_mtr_error_type = 6;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_POLICER_ACTION_GREEN: rte_mtr_error_type = 7;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_POLICER_ACTION_YELLOW: rte_mtr_error_type = 8;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_POLICER_ACTION_RED: rte_mtr_error_type = 9;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_STATS_MASK: rte_mtr_error_type = 10;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_STATS: rte_mtr_error_type = 11;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_SHARED: rte_mtr_error_type = 12;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_METER_POLICY_ID: rte_mtr_error_type = 13;
pub const rte_mtr_error_type_RTE_MTR_ERROR_TYPE_METER_POLICY: rte_mtr_error_type = 14;
#[doc = " Verbose error types.\n\n Most of them provide the type of the object referenced by struct\n rte_mtr_error::cause."]
pub type rte_mtr_error_type = ::std::os::raw::c_uint;
#[doc = " Verbose error structure definition.\n\n This object is normally allocated by applications and set by PMDs, the\n message points to a constant string which does not need to be freed by\n the application, however its pointer can be considered valid only as long\n as its associated DPDK port remains configured. Closing the underlying\n device or unloading the PMD invalidates it.\n\n Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_error {
    #[doc = "< Cause field and error type."]
    pub type_: rte_mtr_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
pub const mlx5_completion_mode_MLX5_COMP_ONLY_ERR: mlx5_completion_mode = 0;
pub const mlx5_completion_mode_MLX5_COMP_ONLY_FIRST_ERR: mlx5_completion_mode = 1;
pub const mlx5_completion_mode_MLX5_COMP_ALWAYS: mlx5_completion_mode = 2;
pub const mlx5_completion_mode_MLX5_COMP_CQE_AND_EQE: mlx5_completion_mode = 3;
pub type mlx5_completion_mode = ::std::os::raw::c_uint;
pub const mlx5_mpw_mode_MLX5_MPW_DISABLED: mlx5_mpw_mode = 0;
pub const mlx5_mpw_mode_MLX5_MPW: mlx5_mpw_mode = 1;
pub const mlx5_mpw_mode_MLX5_MPW_ENHANCED: mlx5_mpw_mode = 2;
pub type mlx5_mpw_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_cseg {
    pub opcode: u32,
    pub sq_ds: u32,
    pub flags: u32,
    pub misc: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg {
    pub bcount: u32,
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_dseg__bindgen_ty_1 {
    pub inline_data: [u8; 12usize],
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1 {
    pub lkey: u32,
    pub pbuf: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1 {
    pub swp_offs: u32,
    pub cs_flags: u8,
    pub swp_flags: u8,
    pub mss: u16,
    pub metadata: u32,
    pub inline_hdr_sz: u16,
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inline_data: u16,
    pub vlan_tag: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2 {
    pub offsets: u32,
    pub flags: u32,
    pub flow_metadata: u32,
    pub inline_hdr: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_qseg {
    pub reserved0: u32,
    pub reserved1: u32,
    pub max_index: u32,
    pub qpn_cqn: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_wseg {
    pub operation: u32,
    pub lkey: u32,
    pub va_high: u32,
    pub va_low: u32,
    pub value: u64,
    pub mask: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe {
    pub __bindgen_anon_1: mlx5_wqe__bindgen_ty_1,
    pub eseg: mlx5_wqe_eseg,
    pub __bindgen_anon_2: mlx5_wqe__bindgen_ty_2,
}
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_1 {
    pub cseg: mlx5_wqe_cseg,
    pub ctrl: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_2 {
    pub dseg: [mlx5_wqe_dseg; 2usize],
    pub data: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_mprq {
    pub next_seg: mlx5_wqe_srq_next_seg,
    pub dseg: mlx5_wqe_data_seg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_error_cqe {
    pub rsvd0: [u8; 2usize],
    pub eth_wqe_id: u16,
    pub rsvd1: [u8; 16usize],
    pub ib_stride_index: u16,
    pub rsvd2: [u8; 10usize],
    pub srqn: u32,
    pub rsvd3: [u8; 8usize],
    pub byte_cnt: u32,
    pub rsvd4: [u8; 4usize],
    pub hw_err_synd: u8,
    pub hw_synd_type: u8,
    pub vendor_err_synd: u8,
    pub syndrome: u8,
    pub s_wqe_opcode_qpn: u32,
    pub wqe_counter: u16,
    pub signature: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe {
    pub pkt_info: u8,
    pub rsvd0: u8,
    pub wqe_id: u16,
    pub lro_tcppsh_abort_dupack: u8,
    pub lro_min_ttl: u8,
    pub lro_tcp_win: u16,
    pub lro_ack_seq_num: u32,
    pub rx_hash_res: u32,
    pub rx_hash_type: u8,
    pub rsvd1: [u8; 3usize],
    pub csum: u16,
    pub rsvd2: [u8; 6usize],
    pub hdr_type_etc: u16,
    pub vlan_info: u16,
    pub lro_num_seg: u8,
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1,
    pub flow_table_metadata: u32,
    pub rsvd4: [u8; 4usize],
    pub byte_cnt: u32,
    pub timestamp: u64,
    pub sop_drop_qpn: u32,
    pub wqe_counter: u16,
    pub validity_iteration_count: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_cqe__bindgen_ty_1 {
    pub user_index_bytes: [u8; 3usize],
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe__bindgen_ty_1__bindgen_ty_1 {
    pub user_index_hi: u8,
    pub user_index_low: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe_ts {
    pub timestamp: u64,
    pub sop_drop_qpn: u32,
    pub wqe_counter: u16,
    pub validity_iteration_count: u8,
    pub op_own: u8,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_rseg {
    pub raddr: u64,
    pub rkey: u32,
    pub reserved: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_umr_cseg {
    pub if_cf_toe_cq_res: u32,
    pub ko_to_bs: u32,
    pub mkey_mask: u64,
    pub rsvd1: [u32; 8usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_mkey_cseg {
    pub fr_res_af_sf: u32,
    pub qpn_mkey: u32,
    pub reserved2: u32,
    pub flags_pd: u32,
    pub start_addr: u64,
    pub len: u64,
    pub bsf_octword_size: u32,
    pub reserved3: [u32; 4usize],
    pub translations_octword_size: u32,
    pub res4_lps: u32,
    pub reserved: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_umr_bsf_seg {
    pub bs_bpt_eo_es: u32,
    pub raw_data_size: u32,
    pub bsp_res: u32,
    pub reserved0: u32,
    pub xts_initial_tweak: [u8; 16usize],
    pub res_dp: u32,
    pub reserved1: u32,
    pub keytag: u64,
    pub reserved2: [u32; 4usize],
}
#[repr(C, packed)]
pub struct mlx5_umr_wqe {
    pub ctr: mlx5_wqe_cseg,
    pub ucseg: mlx5_wqe_umr_cseg,
    pub mkc: mlx5_wqe_mkey_cseg,
    pub __bindgen_anon_1: mlx5_umr_wqe__bindgen_ty_1,
}
#[repr(C)]
pub struct mlx5_umr_wqe__bindgen_ty_1 {
    pub kseg: __BindgenUnionField<[mlx5_wqe_dseg; 0usize]>,
    pub bsf: __BindgenUnionField<[mlx5_wqe_umr_bsf_seg; 0usize]>,
    pub bindgen_union_field: [u8; 0usize],
}
#[repr(C, packed)]
pub struct mlx5_rdma_write_wqe {
    pub ctr: mlx5_wqe_cseg,
    pub rseg: mlx5_wqe_rseg,
    pub dseg: __IncompleteArrayField<mlx5_wqe_dseg>,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_send_en_seg {
    pub reserve: [u32; 2usize],
    pub sqnpc: u32,
    pub qpn: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_send_en_wqe {
    pub ctr: mlx5_wqe_cseg,
    pub sseg: mlx5_wqe_send_en_seg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_metadata_seg {
    pub mmo_control_31_0: u32,
    pub lkey: u32,
    pub addr: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_wqe {
    pub opcode: u32,
    pub sq_ds: u32,
    pub flags: u32,
    pub gga_ctrl1: u32,
    pub gga_ctrl2: u32,
    pub opaque_lkey: u32,
    pub opaque_vaddr: u64,
    pub gather: mlx5_wqe_dseg,
    pub scatter: mlx5_wqe_dseg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_gga_compress_opaque {
    pub __bindgen_anon_1: mlx5_gga_compress_opaque__bindgen_ty_1,
    pub data: [u32; 64usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_compress_opaque__bindgen_ty_1 {
    pub syndrome: u32,
    pub reserved0: u32,
    pub scattered_length: u32,
    pub __bindgen_anon_1: mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1 {
    pub v1: mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub v2: mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub reserved1: [u32; 5usize],
    pub crc32: u32,
    pub adler32: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_compress_opaque__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub crc32: u32,
    pub adler32: u32,
    pub crc32c: u32,
    pub xxh32: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_gga_crypto_opaque {
    pub __bindgen_anon_1: mlx5_gga_crypto_opaque__bindgen_ty_1,
    pub data: [u8; 64usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_crypto_opaque__bindgen_ty_1 {
    pub syndrome: u32,
    pub reserved0: [u32; 2usize],
    pub cp: mlx5_gga_crypto_opaque__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_gga_crypto_opaque__bindgen_ty_1__bindgen_ty_1 {
    pub iv: [u32; 3usize],
    pub tag_size: u32,
    pub aad_size: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_regexp_mmo_control_bits {
    pub reserved_at_31: [u8; 2usize],
    pub le: [u8; 1usize],
    pub reserved_at_28: [u8; 1usize],
    pub subset_id_0: [u8; 12usize],
    pub reserved_at_16: [u8; 4usize],
    pub subset_id_1: [u8; 12usize],
    pub ctrl: [u8; 4usize],
    pub subset_id_2: [u8; 12usize],
    pub reserved_at_16_1: [u8; 4usize],
    pub subset_id_3: [u8; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_regexp_metadata_bits {
    pub rof_version: [u8; 16usize],
    pub latency_count: [u8; 16usize],
    pub instruction_count: [u8; 16usize],
    pub primary_thread_count: [u8; 16usize],
    pub match_count: [u8; 8usize],
    pub detected_match_count: [u8; 8usize],
    pub status: [u8; 16usize],
    pub job_id: [u8; 32usize],
    pub reserved: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_regexp_match_tuple_bits {
    pub length: [u8; 16usize],
    pub start_ptr: [u8; 16usize],
    pub rule_id: [u8; 32usize],
}
pub const mlx5_modification_field_MLX5_MODI_OUT_NONE: mlx5_modification_field = -1;
pub const mlx5_modification_field_MLX5_MODI_OUT_SMAC_47_16: mlx5_modification_field = 1;
pub const mlx5_modification_field_MLX5_MODI_OUT_SMAC_15_0: mlx5_modification_field = 2;
pub const mlx5_modification_field_MLX5_MODI_OUT_ETHERTYPE: mlx5_modification_field = 3;
pub const mlx5_modification_field_MLX5_MODI_OUT_DMAC_47_16: mlx5_modification_field = 4;
pub const mlx5_modification_field_MLX5_MODI_OUT_DMAC_15_0: mlx5_modification_field = 5;
pub const mlx5_modification_field_MLX5_MODI_OUT_IP_DSCP: mlx5_modification_field = 6;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_FLAGS: mlx5_modification_field = 7;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_SPORT: mlx5_modification_field = 8;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_DPORT: mlx5_modification_field = 9;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV4_TTL: mlx5_modification_field = 10;
pub const mlx5_modification_field_MLX5_MODI_OUT_UDP_SPORT: mlx5_modification_field = 11;
pub const mlx5_modification_field_MLX5_MODI_OUT_UDP_DPORT: mlx5_modification_field = 12;
pub const mlx5_modification_field_MLX5_MODI_OUT_SIPV6_127_96: mlx5_modification_field = 13;
pub const mlx5_modification_field_MLX5_MODI_OUT_SIPV6_95_64: mlx5_modification_field = 14;
pub const mlx5_modification_field_MLX5_MODI_OUT_SIPV6_63_32: mlx5_modification_field = 15;
pub const mlx5_modification_field_MLX5_MODI_OUT_SIPV6_31_0: mlx5_modification_field = 16;
pub const mlx5_modification_field_MLX5_MODI_OUT_DIPV6_127_96: mlx5_modification_field = 17;
pub const mlx5_modification_field_MLX5_MODI_OUT_DIPV6_95_64: mlx5_modification_field = 18;
pub const mlx5_modification_field_MLX5_MODI_OUT_DIPV6_63_32: mlx5_modification_field = 19;
pub const mlx5_modification_field_MLX5_MODI_OUT_DIPV6_31_0: mlx5_modification_field = 20;
pub const mlx5_modification_field_MLX5_MODI_OUT_SIPV4: mlx5_modification_field = 21;
pub const mlx5_modification_field_MLX5_MODI_OUT_DIPV4: mlx5_modification_field = 22;
pub const mlx5_modification_field_MLX5_MODI_OUT_FIRST_VID: mlx5_modification_field = 23;
pub const mlx5_modification_field_MLX5_MODI_IN_SMAC_47_16: mlx5_modification_field = 49;
pub const mlx5_modification_field_MLX5_MODI_IN_SMAC_15_0: mlx5_modification_field = 50;
pub const mlx5_modification_field_MLX5_MODI_IN_ETHERTYPE: mlx5_modification_field = 51;
pub const mlx5_modification_field_MLX5_MODI_IN_DMAC_47_16: mlx5_modification_field = 52;
pub const mlx5_modification_field_MLX5_MODI_IN_DMAC_15_0: mlx5_modification_field = 53;
pub const mlx5_modification_field_MLX5_MODI_IN_IP_DSCP: mlx5_modification_field = 54;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_FLAGS: mlx5_modification_field = 55;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_SPORT: mlx5_modification_field = 56;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_DPORT: mlx5_modification_field = 57;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV4_TTL: mlx5_modification_field = 58;
pub const mlx5_modification_field_MLX5_MODI_IN_UDP_SPORT: mlx5_modification_field = 59;
pub const mlx5_modification_field_MLX5_MODI_IN_UDP_DPORT: mlx5_modification_field = 60;
pub const mlx5_modification_field_MLX5_MODI_IN_SIPV6_127_96: mlx5_modification_field = 61;
pub const mlx5_modification_field_MLX5_MODI_IN_SIPV6_95_64: mlx5_modification_field = 62;
pub const mlx5_modification_field_MLX5_MODI_IN_SIPV6_63_32: mlx5_modification_field = 63;
pub const mlx5_modification_field_MLX5_MODI_IN_SIPV6_31_0: mlx5_modification_field = 64;
pub const mlx5_modification_field_MLX5_MODI_IN_DIPV6_127_96: mlx5_modification_field = 65;
pub const mlx5_modification_field_MLX5_MODI_IN_DIPV6_95_64: mlx5_modification_field = 66;
pub const mlx5_modification_field_MLX5_MODI_IN_DIPV6_63_32: mlx5_modification_field = 67;
pub const mlx5_modification_field_MLX5_MODI_IN_DIPV6_31_0: mlx5_modification_field = 68;
pub const mlx5_modification_field_MLX5_MODI_IN_SIPV4: mlx5_modification_field = 69;
pub const mlx5_modification_field_MLX5_MODI_IN_DIPV4: mlx5_modification_field = 70;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV6_HOPLIMIT: mlx5_modification_field = 71;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV6_HOPLIMIT: mlx5_modification_field = 72;
pub const mlx5_modification_field_MLX5_MODI_META_DATA_REG_A: mlx5_modification_field = 73;
pub const mlx5_modification_field_MLX5_MODI_OUT_IP_PROTOCOL: mlx5_modification_field = 74;
pub const mlx5_modification_field_MLX5_MODI_META_DATA_REG_B: mlx5_modification_field = 80;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_0: mlx5_modification_field = 81;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_1: mlx5_modification_field = 82;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_2: mlx5_modification_field = 83;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_3: mlx5_modification_field = 84;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_4: mlx5_modification_field = 85;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_5: mlx5_modification_field = 86;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_6: mlx5_modification_field = 87;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_7: mlx5_modification_field = 88;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_SEQ_NUM: mlx5_modification_field = 89;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_SEQ_NUM: mlx5_modification_field = 90;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_ACK_NUM: mlx5_modification_field = 91;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_ACK_NUM: mlx5_modification_field = 92;
pub const mlx5_modification_field_MLX5_MODI_OUT_ESP_SPI: mlx5_modification_field = 94;
pub const mlx5_modification_field_MLX5_MODI_IN_ESP_SPI: mlx5_modification_field = 95;
pub const mlx5_modification_field_MLX5_MODI_GTP_TEID: mlx5_modification_field = 110;
pub const mlx5_modification_field_MLX5_MODI_OUT_IP_ECN: mlx5_modification_field = 115;
pub const mlx5_modification_field_MLX5_MODI_IN_IP_ECN: mlx5_modification_field = 116;
pub const mlx5_modification_field_MLX5_MODI_TUNNEL_HDR_DW_1: mlx5_modification_field = 117;
pub const mlx5_modification_field_MLX5_MODI_GTPU_FIRST_EXT_DW_0: mlx5_modification_field = 118;
pub const mlx5_modification_field_MLX5_MODI_HASH_RESULT: mlx5_modification_field = 129;
pub const mlx5_modification_field_MLX5_MODI_OUT_ESP_SEQ_NUM: mlx5_modification_field = 130;
pub const mlx5_modification_field_MLX5_MODI_IN_ESP_SEQ_NUM: mlx5_modification_field = 131;
pub const mlx5_modification_field_MLX5_MODI_IN_MPLS_LABEL_0: mlx5_modification_field = 138;
pub const mlx5_modification_field_MLX5_MODI_IN_MPLS_LABEL_1: mlx5_modification_field = 139;
pub const mlx5_modification_field_MLX5_MODI_IN_MPLS_LABEL_2: mlx5_modification_field = 140;
pub const mlx5_modification_field_MLX5_MODI_IN_MPLS_LABEL_3: mlx5_modification_field = 141;
pub const mlx5_modification_field_MLX5_MODI_IN_MPLS_LABEL_4: mlx5_modification_field = 142;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_8: mlx5_modification_field = 143;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_9: mlx5_modification_field = 144;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_10: mlx5_modification_field = 145;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_11: mlx5_modification_field = 146;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_12: mlx5_modification_field = 147;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_13: mlx5_modification_field = 148;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_14: mlx5_modification_field = 149;
pub const mlx5_modification_field_MLX5_MODI_META_REG_C_15: mlx5_modification_field = 150;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV6_TRAFFIC_CLASS: mlx5_modification_field = 284;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV4_TOTAL_LEN: mlx5_modification_field = 285;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV6_PAYLOAD_LEN: mlx5_modification_field = 286;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV4_IHL: mlx5_modification_field = 287;
pub const mlx5_modification_field_MLX5_MODI_OUT_TCP_DATA_OFFSET: mlx5_modification_field = 288;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV6_TRAFFIC_CLASS: mlx5_modification_field = 289;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV4_TOTAL_LEN: mlx5_modification_field = 290;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV6_PAYLOAD_LEN: mlx5_modification_field = 291;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV4_IHL: mlx5_modification_field = 292;
pub const mlx5_modification_field_MLX5_MODI_IN_TCP_DATA_OFFSET: mlx5_modification_field = 293;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPSEC_NEXT_HDR: mlx5_modification_field = 294;
pub const mlx5_modification_field_MLX5_MODI_OUT_IPV6_FLOW_LABEL: mlx5_modification_field = 295;
pub const mlx5_modification_field_MLX5_MODI_IN_IPV6_FLOW_LABEL: mlx5_modification_field = 296;
pub const mlx5_modification_field_MLX5_MODI_INVALID: mlx5_modification_field = 2147483647;
pub type mlx5_modification_field = ::std::os::raw::c_int;
pub const modify_reg_REG_NON: modify_reg = 0;
pub const modify_reg_REG_A: modify_reg = 1;
pub const modify_reg_REG_B: modify_reg = 2;
pub const modify_reg_REG_C_0: modify_reg = 3;
pub const modify_reg_REG_C_1: modify_reg = 4;
pub const modify_reg_REG_C_2: modify_reg = 5;
pub const modify_reg_REG_C_3: modify_reg = 6;
pub const modify_reg_REG_C_4: modify_reg = 7;
pub const modify_reg_REG_C_5: modify_reg = 8;
pub const modify_reg_REG_C_6: modify_reg = 9;
pub const modify_reg_REG_C_7: modify_reg = 10;
pub const modify_reg_REG_C_8: modify_reg = 11;
pub const modify_reg_REG_C_9: modify_reg = 12;
pub const modify_reg_REG_C_10: modify_reg = 13;
pub const modify_reg_REG_C_11: modify_reg = 14;
pub type modify_reg = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd {
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_modification_cmd__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mlx5_modification_cmd__bindgen_ty_1 {
    pub data0: u32,
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_modification_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn field(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_field(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn field_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_field_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn action_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_action_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn action_type_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_action_type_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        length: ::std::os::raw::c_uint,
        rsvd0: ::std::os::raw::c_uint,
        offset: ::std::os::raw::c_uint,
        rsvd1: ::std::os::raw::c_uint,
        field: ::std::os::raw::c_uint,
        action_type: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsvd0: u32 = unsafe { ::std::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let offset: u32 = unsafe { ::std::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let rsvd1: u32 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let field: u32 = unsafe { ::std::mem::transmute(field) };
            field as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let action_type: u32 = unsafe { ::std::mem::transmute(action_type) };
            action_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mlx5_modification_cmd__bindgen_ty_2 {
    pub data1: u32,
    pub data: [u8; 4usize],
    pub __bindgen_anon_1: mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_modification_cmd__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rsvd2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd2_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd2_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_offset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dst_offset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_offset_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_offset_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd3_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd3_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_field(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_dst_field(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_field_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_field_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd4(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd4(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd4_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd4_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsvd2: ::std::os::raw::c_uint,
        dst_offset: ::std::os::raw::c_uint,
        rsvd3: ::std::os::raw::c_uint,
        dst_field: ::std::os::raw::c_uint,
        rsvd4: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rsvd2: u32 = unsafe { ::std::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let dst_offset: u32 = unsafe { ::std::mem::transmute(dst_offset) };
            dst_offset as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let rsvd3: u32 = unsafe { ::std::mem::transmute(rsvd3) };
            rsvd3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let dst_field: u32 = unsafe { ::std::mem::transmute(dst_field) };
            dst_field as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rsvd4: u32 = unsafe { ::std::mem::transmute(rsvd4) };
            rsvd4 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type u8_ = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_misc_bits {
    pub gre_c_present: [u8_; 1usize],
    pub reserved_at_1: [u8_; 1usize],
    pub gre_k_present: [u8_; 1usize],
    pub gre_s_present: [u8_; 1usize],
    pub source_vhci_port: [u8_; 4usize],
    pub source_sqn: [u8_; 24usize],
    pub reserved_at_20: [u8_; 16usize],
    pub source_port: [u8_; 16usize],
    pub outer_second_prio: [u8_; 3usize],
    pub outer_second_cfi: [u8_; 1usize],
    pub outer_second_vid: [u8_; 12usize],
    pub inner_second_prio: [u8_; 3usize],
    pub inner_second_cfi: [u8_; 1usize],
    pub inner_second_vid: [u8_; 12usize],
    pub outer_second_cvlan_tag: [u8_; 1usize],
    pub inner_second_cvlan_tag: [u8_; 1usize],
    pub outer_second_svlan_tag: [u8_; 1usize],
    pub inner_second_svlan_tag: [u8_; 1usize],
    pub reserved_at_64: [u8_; 12usize],
    pub gre_protocol: [u8_; 16usize],
    pub gre_key_h: [u8_; 24usize],
    pub gre_key_l: [u8_; 8usize],
    pub vxlan_vni: [u8_; 24usize],
    pub bth_opcode: [u8_; 8usize],
    pub geneve_vni: [u8_; 24usize],
    pub lag_rx_port_affinity: [u8_; 4usize],
    pub reserved_at_e8: [u8_; 2usize],
    pub geneve_tlv_option_0_exist: [u8_; 1usize],
    pub geneve_oam: [u8_; 1usize],
    pub reserved_at_e0: [u8_; 12usize],
    pub outer_ipv6_flow_label: [u8_; 20usize],
    pub reserved_at_100: [u8_; 12usize],
    pub inner_ipv6_flow_label: [u8_; 20usize],
    pub reserved_at_120: [u8_; 10usize],
    pub geneve_opt_len: [u8_; 6usize],
    pub geneve_protocol_type: [u8_; 16usize],
    pub reserved_at_140: [u8_; 8usize],
    pub bth_dst_qp: [u8_; 24usize],
    pub inner_esp_spi: [u8_; 32usize],
    pub outer_esp_spi: [u8_; 32usize],
    pub reserved_at_1a0: [u8_; 96usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ipv4_layout_bits {
    pub reserved_at_0: [u8_; 96usize],
    pub ipv4: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ipv6_layout_bits {
    pub ipv6: [[u8_; 8usize]; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_ipv6_layout_ipv4_layout_auto_bits {
    pub ipv6_layout: mlx5_ifc_ipv6_layout_bits,
    pub ipv4_layout: mlx5_ifc_ipv4_layout_bits,
    pub reserved_at_0: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_lyr_2_4_bits {
    pub smac_47_16: [u8_; 32usize],
    pub smac_15_0: [u8_; 16usize],
    pub ethertype: [u8_; 16usize],
    pub dmac_47_16: [u8_; 32usize],
    pub dmac_15_0: [u8_; 16usize],
    pub first_prio: [u8_; 3usize],
    pub first_cfi: [u8_; 1usize],
    pub first_vid: [u8_; 12usize],
    pub ip_protocol: [u8_; 8usize],
    pub ip_dscp: [u8_; 6usize],
    pub ip_ecn: [u8_; 2usize],
    pub cvlan_tag: [u8_; 1usize],
    pub svlan_tag: [u8_; 1usize],
    pub frag: [u8_; 1usize],
    pub ip_version: [u8_; 4usize],
    pub tcp_flags: [u8_; 9usize],
    pub tcp_sport: [u8_; 16usize],
    pub tcp_dport: [u8_; 16usize],
    pub reserved_at_c0: [u8_; 16usize],
    pub ipv4_ihl: [u8_; 4usize],
    pub l3_ok: [u8_; 1usize],
    pub l4_ok: [u8_; 1usize],
    pub ipv4_checksum_ok: [u8_; 1usize],
    pub l4_checksum_ok: [u8_; 1usize],
    pub ip_ttl_hoplimit: [u8_; 8usize],
    pub udp_sport: [u8_; 16usize],
    pub udp_dport: [u8_; 16usize],
    pub src_ipv4_src_ipv6: mlx5_ifc_ipv6_layout_ipv4_layout_auto_bits,
    pub dst_ipv4_dst_ipv6: mlx5_ifc_ipv6_layout_ipv4_layout_auto_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_mpls_bits {
    pub mpls_label: [u8_; 20usize],
    pub mpls_exp: [u8_; 3usize],
    pub mpls_s_bos: [u8_; 1usize],
    pub mpls_ttl: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_misc2_bits {
    pub outer_first_mpls: mlx5_ifc_fte_match_mpls_bits,
    pub inner_first_mpls: mlx5_ifc_fte_match_mpls_bits,
    pub outer_first_mpls_over_gre: mlx5_ifc_fte_match_mpls_bits,
    pub outer_first_mpls_over_udp: mlx5_ifc_fte_match_mpls_bits,
    pub metadata_reg_c_7: [u8_; 32usize],
    pub metadata_reg_c_6: [u8_; 32usize],
    pub metadata_reg_c_5: [u8_; 32usize],
    pub metadata_reg_c_4: [u8_; 32usize],
    pub metadata_reg_c_3: [u8_; 32usize],
    pub metadata_reg_c_2: [u8_; 32usize],
    pub metadata_reg_c_1: [u8_; 32usize],
    pub metadata_reg_c_0: [u8_; 32usize],
    pub metadata_reg_a: [u8_; 32usize],
    pub metadata_reg_b: [u8_; 32usize],
    pub reserved_at_1c0: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_misc3_bits {
    pub inner_tcp_seq_num: [u8_; 32usize],
    pub outer_tcp_seq_num: [u8_; 32usize],
    pub inner_tcp_ack_num: [u8_; 32usize],
    pub outer_tcp_ack_num: [u8_; 32usize],
    pub reserved_at_auto1: [u8_; 8usize],
    pub outer_vxlan_gpe_vni: [u8_; 24usize],
    pub outer_vxlan_gpe_next_protocol: [u8_; 8usize],
    pub outer_vxlan_gpe_flags: [u8_; 8usize],
    pub reserved_at_a8: [u8_; 16usize],
    pub icmp_header_data: [u8_; 32usize],
    pub icmpv6_header_data: [u8_; 32usize],
    pub icmp_type: [u8_; 8usize],
    pub icmp_code: [u8_; 8usize],
    pub icmpv6_type: [u8_; 8usize],
    pub icmpv6_code: [u8_; 8usize],
    pub geneve_tlv_option_0_data: [u8_; 32usize],
    pub gtpu_teid: [u8_; 32usize],
    pub gtpu_msg_type: [u8_; 8usize],
    pub gtpu_msg_flags: [u8_; 8usize],
    pub reserved_at_170: [u8_; 16usize],
    pub gtpu_dw_2: [u8_; 32usize],
    pub gtpu_first_ext_dw_0: [u8_; 32usize],
    pub gtpu_dw_0: [u8_; 32usize],
    pub reserved_at_240: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_misc4_bits {
    pub prog_sample_field_value_0: [u8_; 32usize],
    pub prog_sample_field_id_0: [u8_; 32usize],
    pub prog_sample_field_value_1: [u8_; 32usize],
    pub prog_sample_field_id_1: [u8_; 32usize],
    pub prog_sample_field_value_2: [u8_; 32usize],
    pub prog_sample_field_id_2: [u8_; 32usize],
    pub prog_sample_field_value_3: [u8_; 32usize],
    pub prog_sample_field_id_3: [u8_; 32usize],
    pub prog_sample_field_value_4: [u8_; 32usize],
    pub prog_sample_field_id_4: [u8_; 32usize],
    pub prog_sample_field_value_5: [u8_; 32usize],
    pub prog_sample_field_id_5: [u8_; 32usize],
    pub prog_sample_field_value_6: [u8_; 32usize],
    pub prog_sample_field_id_6: [u8_; 32usize],
    pub prog_sample_field_value_7: [u8_; 32usize],
    pub prog_sample_field_id_7: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_set_misc5_bits {
    pub macsec_tag_0: [u8_; 32usize],
    pub macsec_tag_1: [u8_; 32usize],
    pub macsec_tag_2: [u8_; 32usize],
    pub macsec_tag_3: [u8_; 32usize],
    pub tunnel_header_0: [u8_; 32usize],
    pub tunnel_header_1: [u8_; 32usize],
    pub tunnel_header_2: [u8_; 32usize],
    pub tunnel_header_3: [u8_; 32usize],
    pub reserved: [u8_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_fte_match_param_bits {
    pub outer_headers: mlx5_ifc_fte_match_set_lyr_2_4_bits,
    pub misc_parameters: mlx5_ifc_fte_match_set_misc_bits,
    pub inner_headers: mlx5_ifc_fte_match_set_lyr_2_4_bits,
    pub misc_parameters_2: mlx5_ifc_fte_match_set_misc2_bits,
    pub misc_parameters_3: mlx5_ifc_fte_match_set_misc3_bits,
    pub misc_parameters_4: mlx5_ifc_fte_match_set_misc4_bits,
    pub misc_parameters_5: mlx5_ifc_fte_match_set_misc5_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dest_format_struct_bits {
    pub destination_type: [u8_; 8usize],
    pub destination_id: [u8_; 24usize],
    pub reserved_0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_flow_counter_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub flow_counter_id: [u8_; 32usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_flow_counter_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_at_60: [u8_; 19usize],
    pub flow_counter_bulk_log_size: [u8_; 5usize],
    pub flow_counter_bulk: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dealloc_flow_counter_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dealloc_flow_counter_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub flow_counter_id: [u8_; 32usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_traffic_counter_bits {
    pub packets: [u8_; 64usize],
    pub octets: [u8_; 64usize],
}
#[repr(C)]
pub struct mlx5_ifc_query_flow_counter_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub flow_statistics: __IncompleteArrayField<mlx5_ifc_traffic_counter_bits>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_flow_counter_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 32usize],
    pub mkey: [u8_; 32usize],
    pub address: [u8_; 64usize],
    pub clear: [u8_; 1usize],
    pub dump_to_memory: [u8_; 1usize],
    pub num_of_counters: [u8_; 30usize],
    pub flow_counter_id: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_match_sample_info_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub reserved_at_80: [u8_; 4usize],
    pub modify_field_id: [u8_; 12usize],
    pub ok_bit_format_select_dw: [u8_; 8usize],
    pub field_format_select_dw: [u8_; 8usize],
    pub reserved_at_a0: [u8_; 3usize],
    pub ok_bit_offset: [u8_; 5usize],
    pub reserved_at_a8: [u8_; 24usize],
    pub reserved_at_c0: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_match_sample_info_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 96usize],
    pub sample_field_id: [u8_; 32usize],
    pub reserved_at_c0: [u8_; 320usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_klm_bits {
    pub byte_count: [u8_; 32usize],
    pub mkey: [u8_; 32usize],
    pub address: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_mkc_bits {
    pub reserved_at_0: [u8_; 1usize],
    pub free: [u8_; 1usize],
    pub reserved_at_2: [u8_; 1usize],
    pub access_mode_4_2: [u8_; 3usize],
    pub reserved_at_6: [u8_; 7usize],
    pub relaxed_ordering_write: [u8_; 1usize],
    pub reserved_at_e: [u8_; 1usize],
    pub small_fence_on_rdma_read_response: [u8_; 1usize],
    pub umr_en: [u8_; 1usize],
    pub a: [u8_; 1usize],
    pub rw: [u8_; 1usize],
    pub rr: [u8_; 1usize],
    pub lw: [u8_; 1usize],
    pub lr: [u8_; 1usize],
    pub access_mode_1_0: [u8_; 2usize],
    pub reserved_at_18: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub mkey_7_0: [u8_; 8usize],
    pub reserved_at_40: [u8_; 32usize],
    pub length64: [u8_; 1usize],
    pub bsf_en: [u8_; 1usize],
    pub sync_umr: [u8_; 1usize],
    pub reserved_at_63: [u8_; 2usize],
    pub expected_sigerr_count: [u8_; 1usize],
    pub reserved_at_66: [u8_; 1usize],
    pub en_rinval: [u8_; 1usize],
    pub pd: [u8_; 24usize],
    pub start_addr: [u8_; 64usize],
    pub len: [u8_; 64usize],
    pub bsf_octword_size: [u8_; 32usize],
    pub reserved_at_120: [u8_; 128usize],
    pub translations_octword_size: [u8_; 32usize],
    pub reserved_at_1c0: [u8_; 25usize],
    pub relaxed_ordering_read: [u8_; 1usize],
    pub reserved_at_1da: [u8_; 1usize],
    pub log_page_size: [u8_; 5usize],
    pub reserved_at_1e0: [u8_; 3usize],
    pub crypto_en: [u8_; 2usize],
    pub reserved_at_1e5: [u8_; 27usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_mkey_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub mkey_index: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
pub struct mlx5_ifc_create_mkey_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 32usize],
    pub pg_access: [u8_; 1usize],
    pub reserved_at_61: [u8_; 31usize],
    pub memory_key_mkey_entry: mlx5_ifc_mkc_bits,
    pub reserved_at_280: [u8_; 128usize],
    pub translations_octword_actual_size: [u8_; 32usize],
    pub mkey_umem_id: [u8_; 32usize],
    pub mkey_umem_offset: [u8_; 64usize],
    pub reserved_at_380: [u8_; 1280usize],
    pub klm_pas_mtt: __IncompleteArrayField<[u8_; 32usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_cmd_hca_cap_bits {
    pub access_other_hca_roce: [u8_; 1usize],
    pub alloc_flow_counter_pd: [u8_; 1usize],
    pub flow_counter_access_aso: [u8_; 1usize],
    pub query_match_sample_info: [u8_; 1usize],
    pub reserved_at_4: [u8_; 4usize],
    pub flow_access_aso_opc_mod: [u8_; 8usize],
    pub reserved_at_10: [u8_; 15usize],
    pub vhca_resource_manager: [u8_; 1usize],
    pub hca_cap_2: [u8_; 1usize],
    pub reserved_at_21: [u8_; 15usize],
    pub vhca_id: [u8_; 16usize],
    pub reserved_at_40: [u8_; 32usize],
    pub reserved_at_60: [u8_; 3usize],
    pub log_regexp_scatter_gather_size: [u8_; 5usize],
    pub reserved_at_68: [u8_; 3usize],
    pub log_dma_mmo_size: [u8_; 5usize],
    pub reserved_at_70: [u8_; 3usize],
    pub log_compress_mmo_size: [u8_; 5usize],
    pub decompress_lz4_data_only_v2: [u8_; 1usize],
    pub decompress_lz4_no_checksum_v2: [u8_; 1usize],
    pub decompress_lz4_checksum_v2: [u8_; 1usize],
    pub log_decompress_mmo_size: [u8_; 5usize],
    pub log_max_srq_sz: [u8_; 8usize],
    pub log_max_qp_sz: [u8_; 8usize],
    pub reserved_at_90: [u8_; 9usize],
    pub wqe_index_ignore_cap: [u8_; 1usize],
    pub dynamic_qp_allocation: [u8_; 1usize],
    pub log_max_qp: [u8_; 5usize],
    pub reserved_at_a0: [u8_; 4usize],
    pub regexp_num_of_engines: [u8_; 4usize],
    pub reserved_at_a8: [u8_; 1usize],
    pub reg_c_preserve: [u8_; 1usize],
    pub reserved_at_aa: [u8_; 1usize],
    pub log_max_srq: [u8_; 5usize],
    pub reserved_at_b0: [u8_; 11usize],
    pub scatter_fcs_w_decap_disable: [u8_; 1usize],
    pub reserved_at_bc: [u8_; 4usize],
    pub reserved_at_c0: [u8_; 8usize],
    pub log_max_cq_sz: [u8_; 8usize],
    pub reserved_at_d0: [u8_; 2usize],
    pub access_register_user: [u8_; 1usize],
    pub reserved_at_d3: [u8_; 8usize],
    pub log_max_cq: [u8_; 5usize],
    pub log_max_eq_sz: [u8_; 8usize],
    pub relaxed_ordering_write: [u8_; 1usize],
    pub relaxed_ordering_read: [u8_; 1usize],
    pub log_max_mkey: [u8_; 6usize],
    pub reserved_at_f0: [u8_; 8usize],
    pub dump_fill_mkey: [u8_; 1usize],
    pub reserved_at_f9: [u8_; 3usize],
    pub log_max_eq: [u8_; 4usize],
    pub max_indirection: [u8_; 8usize],
    pub fixed_buffer_size: [u8_; 1usize],
    pub log_max_mrw_sz: [u8_; 7usize],
    pub force_teardown: [u8_; 1usize],
    pub reserved_at_111: [u8_; 1usize],
    pub log_max_bsf_list_size: [u8_; 6usize],
    pub umr_extended_translation_offset: [u8_; 1usize],
    pub null_mkey: [u8_; 1usize],
    pub log_maxklm_list_size: [u8_; 6usize],
    pub non_wire_sq: [u8_; 1usize],
    pub reserved_at_121: [u8_; 9usize],
    pub log_max_ra_req_dc: [u8_; 6usize],
    pub reserved_at_130: [u8_; 3usize],
    pub log_max_static_sq_wq: [u8_; 5usize],
    pub reserved_at_138: [u8_; 2usize],
    pub log_max_ra_res_dc: [u8_; 6usize],
    pub reserved_at_140: [u8_; 10usize],
    pub log_max_ra_req_qp: [u8_; 6usize],
    pub rtr2rts_qp_counters_set_id: [u8_; 1usize],
    pub rts2rts_udp_sport: [u8_; 1usize],
    pub rts2rts_lag_tx_port_affinity: [u8_; 1usize],
    pub dma_mmo_sq: [u8_; 1usize],
    pub compress_min_block_size: [u8_; 4usize],
    pub compress_mmo_sq: [u8_; 1usize],
    pub decompress_mmo_sq: [u8_; 1usize],
    pub log_max_ra_res_qp: [u8_; 6usize],
    pub end_pad: [u8_; 1usize],
    pub cc_query_allowed: [u8_; 1usize],
    pub cc_modify_allowed: [u8_; 1usize],
    pub start_pad: [u8_; 1usize],
    pub cache_line_128byte: [u8_; 1usize],
    pub reserved_at_165: [u8_; 10usize],
    pub qcam_reg: [u8_; 1usize],
    pub gid_table_size: [u8_; 16usize],
    pub out_of_seq_cnt: [u8_; 1usize],
    pub vport_counters: [u8_; 1usize],
    pub retransmission_q_counters: [u8_; 1usize],
    pub debug: [u8_; 1usize],
    pub modify_rq_counter_set_id: [u8_; 1usize],
    pub rq_delay_drop: [u8_; 1usize],
    pub max_qp_cnt: [u8_; 10usize],
    pub pkey_table_size: [u8_; 16usize],
    pub vport_group_manager: [u8_; 1usize],
    pub vhca_group_manager: [u8_; 1usize],
    pub ib_virt: [u8_; 1usize],
    pub eth_virt: [u8_; 1usize],
    pub vnic_env_queue_counters: [u8_; 1usize],
    pub ets: [u8_; 1usize],
    pub nic_flow_table: [u8_; 1usize],
    pub eswitch_manager: [u8_; 1usize],
    pub device_memory: [u8_; 1usize],
    pub mcam_reg: [u8_; 1usize],
    pub pcam_reg: [u8_; 1usize],
    pub local_ca_ack_delay: [u8_; 5usize],
    pub port_module_event: [u8_; 1usize],
    pub enhanced_error_q_counters: [u8_; 1usize],
    pub ports_check: [u8_; 1usize],
    pub reserved_at_1b3: [u8_; 1usize],
    pub disable_link_up: [u8_; 1usize],
    pub beacon_led: [u8_; 1usize],
    pub port_type: [u8_; 2usize],
    pub num_ports: [u8_; 8usize],
    pub reserved_at_1c0: [u8_; 1usize],
    pub pps: [u8_; 1usize],
    pub pps_modify: [u8_; 1usize],
    pub log_max_msg: [u8_; 5usize],
    pub reserved_at_1c8: [u8_; 4usize],
    pub max_tc: [u8_; 4usize],
    pub temp_warn_event: [u8_; 1usize],
    pub dcbx: [u8_; 1usize],
    pub general_notification_event: [u8_; 1usize],
    pub reserved_at_1d3: [u8_; 2usize],
    pub fpga: [u8_; 1usize],
    pub rol_s: [u8_; 1usize],
    pub rol_g: [u8_; 1usize],
    pub reserved_at_1d8: [u8_; 1usize],
    pub wol_s: [u8_; 1usize],
    pub wol_g: [u8_; 1usize],
    pub wol_a: [u8_; 1usize],
    pub wol_b: [u8_; 1usize],
    pub wol_m: [u8_; 1usize],
    pub wol_u: [u8_; 1usize],
    pub wol_p: [u8_; 1usize],
    pub stat_rate_support: [u8_; 16usize],
    pub reserved_at_1ef: [u8_; 11usize],
    pub wqe_based_flow_table_update_cap: [u8_; 1usize],
    pub cqe_version: [u8_; 4usize],
    pub compact_address_vector: [u8_; 1usize],
    pub striding_rq: [u8_; 1usize],
    pub reserved_at_202: [u8_; 1usize],
    pub ipoib_enhanced_offloads: [u8_; 1usize],
    pub ipoib_basic_offloads: [u8_; 1usize],
    pub reserved_at_205: [u8_; 1usize],
    pub repeated_block_disabled: [u8_; 1usize],
    pub umr_modify_entity_size_disabled: [u8_; 1usize],
    pub umr_modify_atomic_disabled: [u8_; 1usize],
    pub umr_indirect_mkey_disabled: [u8_; 1usize],
    pub umr_fence: [u8_; 2usize],
    pub reserved_at_20c: [u8_; 3usize],
    pub drain_sigerr: [u8_; 1usize],
    pub cmdif_checksum: [u8_; 2usize],
    pub sigerr_cqe: [u8_; 1usize],
    pub reserved_at_213: [u8_; 1usize],
    pub wq_signature: [u8_; 1usize],
    pub sctr_data_cqe: [u8_; 1usize],
    pub reserved_at_216: [u8_; 1usize],
    pub sho: [u8_; 1usize],
    pub tph: [u8_; 1usize],
    pub rf: [u8_; 1usize],
    pub dct: [u8_; 1usize],
    pub qos: [u8_; 1usize],
    pub eth_net_offloads: [u8_; 1usize],
    pub roce: [u8_; 1usize],
    pub atomic: [u8_; 1usize],
    pub reserved_at_21f: [u8_; 1usize],
    pub cq_oi: [u8_; 1usize],
    pub cq_resize: [u8_; 1usize],
    pub cq_moderation: [u8_; 1usize],
    pub reserved_at_223: [u8_; 3usize],
    pub cq_eq_remap: [u8_; 1usize],
    pub pg: [u8_; 1usize],
    pub block_lb_mc: [u8_; 1usize],
    pub reserved_at_229: [u8_; 1usize],
    pub scqe_break_moderation: [u8_; 1usize],
    pub cq_period_start_from_cqe: [u8_; 1usize],
    pub cd: [u8_; 1usize],
    pub reserved_at_22d: [u8_; 1usize],
    pub apm: [u8_; 1usize],
    pub vector_calc: [u8_; 1usize],
    pub umr_ptr_rlky: [u8_; 1usize],
    pub imaicl: [u8_; 1usize],
    pub reserved_at_232: [u8_; 4usize],
    pub qkv: [u8_; 1usize],
    pub pkv: [u8_; 1usize],
    pub set_deth_sqpn: [u8_; 1usize],
    pub reserved_at_239: [u8_; 3usize],
    pub xrc: [u8_; 1usize],
    pub ud: [u8_; 1usize],
    pub uc: [u8_; 1usize],
    pub rc: [u8_; 1usize],
    pub uar_4k: [u8_; 1usize],
    pub reserved_at_241: [u8_; 8usize],
    pub regexp_params: [u8_; 1usize],
    pub uar_sz: [u8_; 6usize],
    pub port_selection_cap: [u8_; 1usize],
    pub reserved_at_251: [u8_; 7usize],
    pub log_pg_sz: [u8_; 8usize],
    pub bf: [u8_; 1usize],
    pub driver_version: [u8_; 1usize],
    pub pad_tx_eth_packet: [u8_; 1usize],
    pub reserved_at_263: [u8_; 8usize],
    pub log_bf_reg_size: [u8_; 5usize],
    pub reserved_at_270: [u8_; 11usize],
    pub lag_master: [u8_; 1usize],
    pub num_lag_ports: [u8_; 4usize],
    pub reserved_at_280: [u8_; 16usize],
    pub max_wqe_sz_sq: [u8_; 16usize],
    pub reserved_at_2a0: [u8_; 12usize],
    pub regexp_mmo_sq: [u8_; 1usize],
    pub regexp_version: [u8_; 3usize],
    pub max_wqe_sz_rq: [u8_; 16usize],
    pub max_flow_counter_31_16: [u8_; 16usize],
    pub max_wqe_sz_sq_dc: [u8_; 16usize],
    pub reserved_at_2e0: [u8_; 7usize],
    pub max_qp_mcg: [u8_; 25usize],
    pub reserved_at_300: [u8_; 16usize],
    pub flow_counter_bulk_alloc: [u8_; 8usize],
    pub log_max_mcg: [u8_; 8usize],
    pub reserved_at_320: [u8_; 3usize],
    pub log_max_transport_domain: [u8_; 5usize],
    pub reserved_at_328: [u8_; 3usize],
    pub log_max_pd: [u8_; 5usize],
    pub reserved_at_330: [u8_; 11usize],
    pub log_max_xrcd: [u8_; 5usize],
    pub nic_receive_steering_discard: [u8_; 1usize],
    pub receive_discard_vport_down: [u8_; 1usize],
    pub transmit_discard_vport_down: [u8_; 1usize],
    pub reserved_at_343: [u8_; 5usize],
    pub log_max_flow_counter_bulk: [u8_; 8usize],
    pub max_flow_counter_15_0: [u8_; 16usize],
    pub modify_tis: [u8_; 1usize],
    pub flow_counters_dump: [u8_; 1usize],
    pub reserved_at_360: [u8_; 1usize],
    pub log_max_rq: [u8_; 5usize],
    pub reserved_at_368: [u8_; 3usize],
    pub log_max_sq: [u8_; 5usize],
    pub reserved_at_370: [u8_; 3usize],
    pub log_max_tir: [u8_; 5usize],
    pub reserved_at_378: [u8_; 3usize],
    pub log_max_tis: [u8_; 5usize],
    pub basic_cyclic_rcv_wqe: [u8_; 1usize],
    pub reserved_at_381: [u8_; 1usize],
    pub mem_rq_rmp: [u8_; 1usize],
    pub log_max_rmp: [u8_; 5usize],
    pub reserved_at_388: [u8_; 3usize],
    pub log_max_rqt: [u8_; 5usize],
    pub reserved_at_390: [u8_; 3usize],
    pub log_max_rqt_size: [u8_; 5usize],
    pub reserved_at_398: [u8_; 3usize],
    pub log_max_tis_per_sq: [u8_; 5usize],
    pub ext_stride_num_range: [u8_; 1usize],
    pub reserved_at_3a1: [u8_; 2usize],
    pub log_max_stride_sz_rq: [u8_; 5usize],
    pub reserved_at_3a8: [u8_; 3usize],
    pub log_min_stride_sz_rq: [u8_; 5usize],
    pub reserved_at_3b0: [u8_; 3usize],
    pub log_max_stride_sz_sq: [u8_; 5usize],
    pub reserved_at_3b8: [u8_; 3usize],
    pub log_min_stride_sz_sq: [u8_; 5usize],
    pub hairpin: [u8_; 1usize],
    pub reserved_at_3c1: [u8_; 2usize],
    pub log_max_hairpin_queues: [u8_; 5usize],
    pub reserved_at_3c8: [u8_; 3usize],
    pub log_max_hairpin_wq_data_sz: [u8_; 5usize],
    pub reserved_at_3d0: [u8_; 3usize],
    pub log_max_hairpin_num_packets: [u8_; 5usize],
    pub reserved_at_3d8: [u8_; 3usize],
    pub log_max_wq_sz: [u8_; 5usize],
    pub nic_vport_change_event: [u8_; 1usize],
    pub disable_local_lb_uc: [u8_; 1usize],
    pub disable_local_lb_mc: [u8_; 1usize],
    pub log_min_hairpin_wq_data_sz: [u8_; 5usize],
    pub reserved_at_3e8: [u8_; 3usize],
    pub log_max_vlan_list: [u8_; 5usize],
    pub reserved_at_3f0: [u8_; 1usize],
    pub aes_xts_single_block_le_tweak: [u8_; 1usize],
    pub aes_xts_multi_block_be_tweak: [u8_; 1usize],
    pub log_max_current_mc_list: [u8_; 5usize],
    pub reserved_at_3f8: [u8_; 3usize],
    pub log_max_current_uc_list: [u8_; 5usize],
    pub general_obj_types: [u8_; 64usize],
    pub sq_ts_format: [u8_; 2usize],
    pub rq_ts_format: [u8_; 2usize],
    pub steering_format_version: [u8_; 4usize],
    pub reserved_at_448: [u8_; 24usize],
    pub reserved_at_460: [u8_; 8usize],
    pub aes_xts: [u8_; 1usize],
    pub crypto: [u8_; 1usize],
    pub ipsec_offload: [u8_; 1usize],
    pub reserved_at_46b: [u8_; 5usize],
    pub max_num_eqs: [u8_; 16usize],
    pub reserved_at_480: [u8_; 3usize],
    pub log_max_l2_table: [u8_; 5usize],
    pub reserved_at_488: [u8_; 8usize],
    pub log_uar_page_sz: [u8_; 16usize],
    pub reserved_at_4a0: [u8_; 32usize],
    pub device_frequency_mhz: [u8_; 32usize],
    pub device_frequency_khz: [u8_; 32usize],
    pub reserved_at_500: [u8_; 32usize],
    pub num_of_uars_per_page: [u8_; 32usize],
    pub flex_parser_protocols: [u8_; 32usize],
    pub max_geneve_tlv_options: [u8_; 8usize],
    pub geneve_tlv_sample: [u8_; 1usize],
    pub geneve_tlv_option_offset: [u8_; 1usize],
    pub reserved_at_56a: [u8_; 1usize],
    pub max_geneve_tlv_option_data_len: [u8_; 5usize],
    pub flex_parser_header_modify: [u8_; 1usize],
    pub reserved_at_571: [u8_; 2usize],
    pub log_max_guaranteed_connections: [u8_; 5usize],
    pub driver_version_before_init_hca: [u8_; 1usize],
    pub adv_virtualization: [u8_; 1usize],
    pub reserved_at_57a: [u8_; 1usize],
    pub log_max_dct_connections: [u8_; 5usize],
    pub log_max_atomic_size_qp: [u8_; 8usize],
    pub reserved_at_587: [u8_; 3usize],
    pub log_max_dci_stream_channels: [u8_; 5usize],
    pub reserved_at_58f: [u8_; 3usize],
    pub log_max_dci_errored_streams: [u8_; 5usize],
    pub log_max_atomic_dize_dc: [u8_; 8usize],
    pub max_multi_user_ggroup_size: [u8_; 16usize],
    pub enhanced_cqe_compression: [u8_; 1usize],
    pub reserved_at_5b0: [u8_; 1usize],
    pub crossing_vhca_mkey: [u8_; 1usize],
    pub log_max_dek: [u8_; 5usize],
    pub reserved_at_5b7: [u8_; 1usize],
    pub mini_cqe_resp_l3_l4_tag: [u8_; 1usize],
    pub mini_cqe_resp_flow_tag: [u8_; 1usize],
    pub reserved_at_5ba: [u8_; 1usize],
    pub mini_cqe_resp_stride_index: [u8_; 1usize],
    pub cqe_128_always: [u8_; 1usize],
    pub cqe_compression_128: [u8_; 1usize],
    pub cqe_compression: [u8_; 1usize],
    pub cqe_compression_timeout: [u8_; 16usize],
    pub cqe_compression_max_num: [u8_; 16usize],
    pub reserved_at_5e0: [u8_; 8usize],
    pub flex_parser_id_gtpu_dw_0: [u8_; 4usize],
    pub reserved_at_5ec: [u8_; 4usize],
    pub tag_matching: [u8_; 1usize],
    pub rndv_offload_rc: [u8_; 1usize],
    pub rndv_offload_dc: [u8_; 1usize],
    pub log_tag_matching_list_sz: [u8_; 5usize],
    pub reserved_at_5f8: [u8_; 3usize],
    pub log_max_xrq: [u8_; 5usize],
    pub affiliate_nic_vport_criteria: [u8_; 8usize],
    pub native_port_num: [u8_; 8usize],
    pub num_vhca_ports: [u8_; 8usize],
    pub flex_parser_id_gtpu_teid: [u8_; 4usize],
    pub reserved_at_61c: [u8_; 2usize],
    pub sw_owner_id: [u8_; 1usize],
    pub reserved_at_61f: [u8_; 108usize],
    pub wait_on_data: [u8_; 1usize],
    pub wait_on_time: [u8_; 1usize],
    pub reserved_at_68d: [u8_; 55usize],
    pub flex_parser_id_geneve_opt_0: [u8_; 4usize],
    pub flex_parser_id_icmp_dw1: [u8_; 4usize],
    pub flex_parser_id_icmp_dw0: [u8_; 4usize],
    pub flex_parser_id_icmpv6_dw1: [u8_; 4usize],
    pub flex_parser_id_icmpv6_dw0: [u8_; 4usize],
    pub flex_parser_id_outer_first_mpls_over_gre: [u8_; 4usize],
    pub flex_parser_id_outer_first_mpls_over_udp_label: [u8_; 4usize],
    pub reserved_at_6e0: [u8_; 32usize],
    pub flex_parser_id_gtpu_dw_2: [u8_; 4usize],
    pub flex_parser_id_gtpu_first_ext_dw_0: [u8_; 4usize],
    pub reserved_at_708: [u8_; 64usize],
    pub dma_mmo_qp: [u8_; 1usize],
    pub regexp_mmo_qp: [u8_; 1usize],
    pub compress_mmo_qp: [u8_; 1usize],
    pub decompress_deflate_v1: [u8_; 1usize],
    pub reserved_at_74c: [u8_; 4usize],
    pub decompress_deflate_v2: [u8_; 1usize],
    pub reserved_at_751: [u8_; 15usize],
    pub reserved_at_760: [u8_; 3usize],
    pub log_max_num_header_modify_argument: [u8_; 5usize],
    pub log_header_modify_argument_granularity_offset: [u8_; 4usize],
    pub log_header_modify_argument_granularity: [u8_; 4usize],
    pub reserved_at_770: [u8_; 3usize],
    pub log_header_modify_argument_max_alloc: [u8_; 5usize],
    pub reserved_at_778: [u8_; 8usize],
    pub reserved_at_780: [u8_; 64usize],
    pub match_definer_format_supported: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_qos_cap_bits {
    pub packet_pacing: [u8_; 1usize],
    pub esw_scheduling: [u8_; 1usize],
    pub esw_bw_share: [u8_; 1usize],
    pub esw_rate_limit: [u8_; 1usize],
    pub reserved_at_4: [u8_; 1usize],
    pub packet_pacing_burst_bound: [u8_; 1usize],
    pub packet_pacing_typical_size: [u8_; 1usize],
    pub flow_meter_old: [u8_; 1usize],
    pub reserved_at_8: [u8_; 8usize],
    pub log_max_flow_meter: [u8_; 8usize],
    pub flow_meter_reg_id: [u8_; 8usize],
    pub wqe_rate_pp: [u8_; 1usize],
    pub reserved_at_25: [u8_; 7usize],
    pub flow_meter: [u8_; 1usize],
    pub reserved_at_2e: [u8_; 23usize],
    pub packet_pacing_max_rate: [u8_; 32usize],
    pub packet_pacing_min_rate: [u8_; 32usize],
    pub reserved_at_80: [u8_; 16usize],
    pub packet_pacing_rate_table_size: [u8_; 16usize],
    pub esw_element_type: [u8_; 16usize],
    pub esw_tsar_type: [u8_; 16usize],
    pub reserved_at_c0: [u8_; 16usize],
    pub max_qos_para_vport: [u8_; 16usize],
    pub max_tsar_bw_share: [u8_; 32usize],
    pub nic_element_type: [u8_; 16usize],
    pub nic_tsar_type: [u8_; 16usize],
    pub reserved_at_120: [u8_; 3usize],
    pub log_meter_aso_granularity: [u8_; 5usize],
    pub reserved_at_128: [u8_; 3usize],
    pub log_meter_aso_max_alloc: [u8_; 5usize],
    pub reserved_at_130: [u8_; 3usize],
    pub log_max_num_meter_aso: [u8_; 5usize],
    pub reserved_at_138: [u8_; 1712usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_per_protocol_networking_offload_caps_bits {
    pub csum_cap: [u8_; 1usize],
    pub vlan_cap: [u8_; 1usize],
    pub lro_cap: [u8_; 1usize],
    pub lro_psh_flag: [u8_; 1usize],
    pub lro_time_stamp: [u8_; 1usize],
    pub lro_max_msg_sz_mode: [u8_; 2usize],
    pub wqe_vlan_insert: [u8_; 1usize],
    pub self_lb_en_modifiable: [u8_; 1usize],
    pub self_lb_mc: [u8_; 1usize],
    pub self_lb_uc: [u8_; 1usize],
    pub max_lso_cap: [u8_; 5usize],
    pub multi_pkt_send_wqe: [u8_; 2usize],
    pub wqe_inline_mode: [u8_; 2usize],
    pub rss_ind_tbl_cap: [u8_; 4usize],
    pub reg_umr_sq: [u8_; 1usize],
    pub scatter_fcs: [u8_; 1usize],
    pub enhanced_multi_pkt_send_wqe: [u8_; 1usize],
    pub tunnel_lso_const_out_ip_id: [u8_; 1usize],
    pub tunnel_lro_gre: [u8_; 1usize],
    pub tunnel_lro_vxlan: [u8_; 1usize],
    pub tunnel_stateless_gre: [u8_; 1usize],
    pub tunnel_stateless_vxlan: [u8_; 1usize],
    pub swp: [u8_; 1usize],
    pub swp_csum: [u8_; 1usize],
    pub swp_lso: [u8_; 1usize],
    pub reserved_at_23: [u8_; 8usize],
    pub tunnel_stateless_gtp: [u8_; 1usize],
    pub reserved_at_25: [u8_; 2usize],
    pub tunnel_stateless_vxlan_gpe_nsh: [u8_; 1usize],
    pub reserved_at_28: [u8_; 1usize],
    pub max_vxlan_udp_ports: [u8_; 8usize],
    pub reserved_at_38: [u8_; 6usize],
    pub max_geneve_opt_len: [u8_; 1usize],
    pub tunnel_stateless_geneve_rx: [u8_; 1usize],
    pub reserved_at_40: [u8_; 16usize],
    pub lro_min_mss_size: [u8_; 16usize],
    pub reserved_at_60: [u8_; 288usize],
    pub lro_timer_supported_periods: [[u8_; 32usize]; 4usize],
    pub reserved_at_200: [u8_; 1536usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_virtio_emulation_cap_bits {
    pub desc_tunnel_offload_type: [u8_; 1usize],
    pub eth_frame_offload_type: [u8_; 1usize],
    pub virtio_version_1_0: [u8_; 1usize],
    pub tso_ipv4: [u8_; 1usize],
    pub tso_ipv6: [u8_; 1usize],
    pub tx_csum: [u8_; 1usize],
    pub rx_csum: [u8_; 1usize],
    pub reserved_at_7: [[u8_; 9usize]; 1usize],
    pub event_mode: [u8_; 8usize],
    pub virtio_queue_type: [u8_; 8usize],
    pub reserved_at_20: [u8_; 19usize],
    pub log_doorbell_stride: [u8_; 5usize],
    pub vnet_modify_ext: [u8_; 1usize],
    pub virtio_net_q_addr_modify: [u8_; 1usize],
    pub virtio_q_index_modify: [u8_; 1usize],
    pub log_doorbell_bar_size: [u8_; 5usize],
    pub doorbell_bar_offset: [u8_; 64usize],
    pub reserved_at_80: [u8_; 8usize],
    pub max_num_virtio_queues: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 96usize],
    pub umem_1_buffer_param_a: [u8_; 32usize],
    pub umem_1_buffer_param_b: [u8_; 32usize],
    pub umem_2_buffer_param_a: [u8_; 32usize],
    pub umem_2_buffer_param_b: [u8_; 32usize],
    pub umem_3_buffer_param_a: [u8_; 32usize],
    pub umem_3_buffer_param_b: [u8_; 32usize],
    pub reserved_at_1c0: [u8_; 1568usize],
}
#[doc = " PARSE_GRAPH_NODE Capabilities Field Descriptions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_parse_graph_node_cap_bits {
    pub node_in: [u8_; 32usize],
    pub node_out: [u8_; 32usize],
    pub header_length_mode: [u8_; 16usize],
    pub sample_offset_mode: [u8_; 16usize],
    pub max_num_arc_in: [u8_; 8usize],
    pub max_num_arc_out: [u8_; 8usize],
    pub max_num_sample: [u8_; 8usize],
    pub reserved_at_78: [u8_; 3usize],
    pub parse_graph_anchor: [u8_; 1usize],
    pub reserved_at_7c: [u8_; 1usize],
    pub sample_tunnel_inner2: [u8_; 1usize],
    pub zero_size_supported: [u8_; 1usize],
    pub sample_id_in_out: [u8_; 1usize],
    pub max_base_header_length: [u8_; 16usize],
    pub reserved_at_90: [u8_; 8usize],
    pub max_sample_base_offset: [u8_; 8usize],
    pub max_next_header_offset: [u8_; 16usize],
    pub reserved_at_b0: [u8_; 8usize],
    pub header_length_mask_width: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_prop_layout_bits {
    pub ft_support: [u8_; 1usize],
    pub flow_tag: [u8_; 1usize],
    pub flow_counter: [u8_; 1usize],
    pub flow_modify_en: [u8_; 1usize],
    pub modify_root: [u8_; 1usize],
    pub identified_miss_table: [u8_; 1usize],
    pub flow_table_modify: [u8_; 1usize],
    pub reformat: [u8_; 1usize],
    pub decap: [u8_; 1usize],
    pub reset_root_to_default: [u8_; 1usize],
    pub pop_vlan: [u8_; 1usize],
    pub push_vlan: [u8_; 1usize],
    pub fpga_vendor_acceleration: [u8_; 1usize],
    pub pop_vlan_2: [u8_; 1usize],
    pub push_vlan_2: [u8_; 1usize],
    pub reformat_and_vlan_action: [u8_; 1usize],
    pub modify_and_vlan_action: [u8_; 1usize],
    pub sw_owner: [u8_; 1usize],
    pub reformat_l3_tunnel_to_l2: [u8_; 1usize],
    pub reformat_l2_to_l3_tunnel: [u8_; 1usize],
    pub reformat_and_modify_action: [u8_; 1usize],
    pub reserved_at_15: [u8_; 9usize],
    pub sw_owner_v2: [u8_; 1usize],
    pub reserved_at_1f: [u8_; 1usize],
    pub reserved_at_20: [u8_; 2usize],
    pub log_max_ft_size: [u8_; 6usize],
    pub log_max_modify_header_context: [u8_; 8usize],
    pub max_modify_header_actions: [u8_; 8usize],
    pub max_ft_level: [u8_; 8usize],
    pub reserved_at_40: [u8_; 8usize],
    pub log_max_ft_sampler_num: [u8_; 8usize],
    pub metadata_reg_b_width: [u8_; 8usize],
    pub metadata_reg_a_width: [u8_; 8usize],
    pub reserved_at_60: [u8_; 10usize],
    pub reparse: [u8_; 1usize],
    pub reserved_at_6b: [u8_; 1usize],
    pub cross_vhca_object: [u8_; 1usize],
    pub reformat_l2_to_l3_audp_tunnel: [u8_; 1usize],
    pub reformat_l3_audp_tunnel_to_l2: [u8_; 1usize],
    pub ignore_flow_level_rtc_valid: [u8_; 1usize],
    pub reserved_at_70: [u8_; 8usize],
    pub log_max_ft_num: [u8_; 8usize],
    pub reserved_at_80: [u8_; 16usize],
    pub log_max_flow_counter: [u8_; 8usize],
    pub log_max_destination: [u8_; 8usize],
    pub reserved_at_a0: [u8_; 24usize],
    pub log_max_flow: [u8_; 8usize],
    pub reserved_at_c0: [u8_; 320usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_roce_caps_bits {
    pub reserved_0: [u8_; 30usize],
    pub qp_ts_format: [u8_; 2usize],
    pub reserved_at_20: [u8_; 160usize],
    pub r_roce_max_src_udp_port: [u8_; 16usize],
    pub r_roce_min_src_udp_port: [u8_; 16usize],
    pub reserved_at_e0: [u8_; 1824usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ft_fields_support_bits {
    pub outer_dmac: [u8_; 1usize],
    pub outer_smac: [u8_; 1usize],
    pub outer_ether_type: [u8_; 1usize],
    pub reserved_at_3: [u8_; 1usize],
    pub outer_first_prio: [u8_; 1usize],
    pub outer_first_cfi: [u8_; 1usize],
    pub outer_first_vid: [u8_; 1usize],
    pub reserved_at_7: [u8_; 1usize],
    pub outer_second_prio: [u8_; 1usize],
    pub outer_second_cfi: [u8_; 1usize],
    pub outer_second_vid: [u8_; 1usize],
    pub reserved_at_b: [u8_; 1usize],
    pub outer_sip: [u8_; 1usize],
    pub outer_dip: [u8_; 1usize],
    pub outer_frag: [u8_; 1usize],
    pub outer_ip_protocol: [u8_; 1usize],
    pub outer_ip_ecn: [u8_; 1usize],
    pub outer_ip_dscp: [u8_; 1usize],
    pub outer_udp_sport: [u8_; 1usize],
    pub outer_udp_dport: [u8_; 1usize],
    pub outer_tcp_sport: [u8_; 1usize],
    pub outer_tcp_dport: [u8_; 1usize],
    pub outer_tcp_flags: [u8_; 1usize],
    pub outer_gre_protocol: [u8_; 1usize],
    pub outer_gre_key: [u8_; 1usize],
    pub outer_vxlan_vni: [u8_; 1usize],
    pub reserved_at_1a: [u8_; 5usize],
    pub source_eswitch_port: [u8_; 1usize],
    pub inner_dmac: [u8_; 1usize],
    pub inner_smac: [u8_; 1usize],
    pub inner_ether_type: [u8_; 1usize],
    pub reserved_at_23: [u8_; 1usize],
    pub inner_first_prio: [u8_; 1usize],
    pub inner_first_cfi: [u8_; 1usize],
    pub inner_first_vid: [u8_; 1usize],
    pub reserved_at_27: [u8_; 1usize],
    pub inner_second_prio: [u8_; 1usize],
    pub inner_second_cfi: [u8_; 1usize],
    pub inner_second_vid: [u8_; 1usize],
    pub reserved_at_2b: [u8_; 1usize],
    pub inner_sip: [u8_; 1usize],
    pub inner_dip: [u8_; 1usize],
    pub inner_frag: [u8_; 1usize],
    pub inner_ip_protocol: [u8_; 1usize],
    pub inner_ip_ecn: [u8_; 1usize],
    pub inner_ip_dscp: [u8_; 1usize],
    pub inner_udp_sport: [u8_; 1usize],
    pub inner_udp_dport: [u8_; 1usize],
    pub inner_tcp_sport: [u8_; 1usize],
    pub inner_tcp_dport: [u8_; 1usize],
    pub inner_tcp_flags: [u8_; 1usize],
    pub reserved_at_37: [u8_; 9usize],
    pub reserved_at_40: [u8_; 32usize],
    pub reserved_at_60: [u8_; 24usize],
    pub __bindgen_anon_1: mlx5_ifc_ft_fields_support_bits__bindgen_ty_1,
    pub reserved_at_80: [u8_; 55usize],
    pub outer_ipv6_traffic_class: [u8_; 1usize],
    pub reserved_at_B8: [u8_; 72usize],
    pub reserved_at_100: [u8_; 128usize],
    pub reserved_at_180: [u8_; 128usize],
    pub reserved_at_200: [u8_; 128usize],
    pub reserved_at_280: [u8_; 128usize],
    pub reserved_at_300: [u8_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_ft_fields_support_bits__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_ifc_ft_fields_support_bits__bindgen_ty_1__bindgen_ty_1,
    pub metadata_reg_c_x: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ft_fields_support_bits__bindgen_ty_1__bindgen_ty_1 {
    pub metadata_reg_c_7: [u8_; 1usize],
    pub metadata_reg_c_6: [u8_; 1usize],
    pub metadata_reg_c_5: [u8_; 1usize],
    pub metadata_reg_c_4: [u8_; 1usize],
    pub metadata_reg_c_3: [u8_; 1usize],
    pub metadata_reg_c_2: [u8_; 1usize],
    pub metadata_reg_c_1: [u8_; 1usize],
    pub metadata_reg_c_0: [u8_; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ft_fields_support_2_bits {
    pub reserved_at_0: [u8_; 10usize],
    pub lag_rx_port_affinity: [u8_; 1usize],
    pub reserved_at_c: [u8_; 2usize],
    pub hash_result: [u8_; 1usize],
    pub reserved_at_e: [u8_; 1usize],
    pub tunnel_header_2_3: [u8_; 1usize],
    pub tunnel_header_0_1: [u8_; 1usize],
    pub macsec_syndrome: [u8_; 1usize],
    pub macsec_tag: [u8_; 1usize],
    pub outer_lrh_sl: [u8_; 1usize],
    pub inner_ipv4_ihl: [u8_; 1usize],
    pub outer_ipv4_ihl: [u8_; 1usize],
    pub psp_syndrome: [u8_; 1usize],
    pub inner_l3_ok: [u8_; 1usize],
    pub inner_l4_ok: [u8_; 1usize],
    pub outer_l3_ok: [u8_; 1usize],
    pub outer_l4_ok: [u8_; 1usize],
    pub psp_header: [u8_; 1usize],
    pub inner_ipv4_checksum_ok: [u8_; 1usize],
    pub inner_l4_checksum_ok: [u8_; 1usize],
    pub outer_ipv4_checksum_ok: [u8_; 1usize],
    pub outer_l4_checksum_ok: [u8_; 1usize],
    pub reserved_at_20: [u8_; 23usize],
    pub outer_ipv6_traffic_class: [u8_; 1usize],
    pub __bindgen_anon_1: mlx5_ifc_ft_fields_support_2_bits__bindgen_ty_1,
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_ft_fields_support_2_bits__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_ifc_ft_fields_support_2_bits__bindgen_ty_1__bindgen_ty_1,
    pub metadata_reg_c_8_15: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ft_fields_support_2_bits__bindgen_ty_1__bindgen_ty_1 {
    pub metadata_reg_c_15: [u8_; 1usize],
    pub metadata_reg_c_14: [u8_; 1usize],
    pub metadata_reg_c_13: [u8_; 1usize],
    pub metadata_reg_c_12: [u8_; 1usize],
    pub metadata_reg_c_11: [u8_; 1usize],
    pub metadata_reg_c_10: [u8_; 1usize],
    pub metadata_reg_c_9: [u8_; 1usize],
    pub metadata_reg_c_8: [u8_; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_nic_cap_bits {
    pub reserved_at_0: [u8_; 512usize],
    pub flow_table_properties_nic_receive: mlx5_ifc_flow_table_prop_layout_bits,
    pub flow_table_properties_nic_receive_rdma: mlx5_ifc_flow_table_prop_layout_bits,
    pub flow_table_properties_nic_receive_sniffer: mlx5_ifc_flow_table_prop_layout_bits,
    pub flow_table_properties_nic_transmit: mlx5_ifc_flow_table_prop_layout_bits,
    pub flow_table_properties_nic_transmit_rdma: mlx5_ifc_flow_table_prop_layout_bits,
    pub flow_table_properties_nic_transmit_sniffer: mlx5_ifc_flow_table_prop_layout_bits,
    pub reserved_at_e00: [u8_; 512usize],
    pub ft_header_modify_nic_receive: mlx5_ifc_ft_fields_support_bits,
    pub ft_field_support_2_nic_receive: mlx5_ifc_ft_fields_support_2_bits,
    pub reserved_at_1480: [u8_; 640usize],
    pub ft_field_support_2_nic_transmit: mlx5_ifc_ft_fields_support_2_bits,
    pub reserved_at_1780: [u8_; 1152usize],
    pub ft_header_modify_nic_transmit: mlx5_ifc_ft_fields_support_bits,
    pub reserved_at_2000: [u8_; 24576usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_esw_cap_bits {
    pub reserved_at_0: [u8_; 2048usize],
    pub ft_header_modify_esw_fdb: mlx5_ifc_ft_fields_support_bits,
    pub reserved_at_C00: [u8_; 2048usize],
    pub ft_field_support_2_esw_fdb: mlx5_ifc_ft_fields_support_2_bits,
    pub reserved_at_1480: [u8_; 27520usize],
}
pub const mlx5_ifc_cross_vhca_object_to_object_supported_types_MLX5_CROSS_VHCA_OBJ_TO_OBJ_TYPE_STC_TO_TIR : mlx5_ifc_cross_vhca_object_to_object_supported_types = 1024 ;
pub const mlx5_ifc_cross_vhca_object_to_object_supported_types_MLX5_CROSS_VHCA_OBJ_TO_OBJ_TYPE_STC_TO_FT : mlx5_ifc_cross_vhca_object_to_object_supported_types = 2048 ;
pub const mlx5_ifc_cross_vhca_object_to_object_supported_types_MLX5_CROSS_VHCA_OBJ_TO_OBJ_TYPE_FT_TO_FT : mlx5_ifc_cross_vhca_object_to_object_supported_types = 4096 ;
pub const mlx5_ifc_cross_vhca_object_to_object_supported_types_MLX5_CROSS_VHCA_OBJ_TO_OBJ_TYPE_FT_TO_RTC : mlx5_ifc_cross_vhca_object_to_object_supported_types = 8192 ;
pub type mlx5_ifc_cross_vhca_object_to_object_supported_types = ::std::os::raw::c_uint;
pub const mlx5_ifc_cross_vhca_allowed_objects_types_MLX5_CROSS_VHCA_ALLOWED_OBJS_TIR:
    mlx5_ifc_cross_vhca_allowed_objects_types = 256;
pub const mlx5_ifc_cross_vhca_allowed_objects_types_MLX5_CROSS_VHCA_ALLOWED_OBJS_FT:
    mlx5_ifc_cross_vhca_allowed_objects_types = 512;
pub const mlx5_ifc_cross_vhca_allowed_objects_types_MLX5_CROSS_VHCA_ALLOWED_OBJS_RTC:
    mlx5_ifc_cross_vhca_allowed_objects_types = 1024;
pub type mlx5_ifc_cross_vhca_allowed_objects_types = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_cmd_hca_cap_2_bits {
    pub reserved_at_0: [u8_; 128usize],
    pub reserved_at_80: [u8_; 3usize],
    pub max_num_prog_sample_field: [u8_; 5usize],
    pub reserved_at_88: [u8_; 3usize],
    pub log_max_num_reserved_qpn: [u8_; 5usize],
    pub reserved_at_90: [u8_; 3usize],
    pub log_reserved_qpn_granularity: [u8_; 5usize],
    pub reserved_at_98: [u8_; 3usize],
    pub log_reserved_qpn_max_alloc: [u8_; 5usize],
    pub max_reformat_insert_size: [u8_; 8usize],
    pub max_reformat_insert_offset: [u8_; 8usize],
    pub max_reformat_remove_size: [u8_; 8usize],
    pub max_reformat_remove_offset: [u8_; 8usize],
    pub reserved_at_c0: [u8_; 3usize],
    pub log_min_stride_wqe_sz: [u8_; 5usize],
    pub reserved_at_c8: [u8_; 3usize],
    pub log_conn_track_granularity: [u8_; 5usize],
    pub reserved_at_d0: [u8_; 3usize],
    pub log_conn_track_max_alloc: [u8_; 5usize],
    pub reserved_at_d8: [u8_; 3usize],
    pub log_max_conn_track_offload: [u8_; 5usize],
    pub cross_vhca_object_to_object_supported: [u8_; 32usize],
    pub allowed_object_for_other_vhca_access_high: [u8_; 32usize],
    pub allowed_object_for_other_vhca_access: [u8_; 32usize],
    pub reserved_at_140: [u8_; 32usize],
    pub reserved_at_160: [u8_; 3usize],
    pub hairpin_sq_wqe_bb_size: [u8_; 5usize],
    pub hairpin_sq_wq_in_host_mem: [u8_; 1usize],
    pub hairpin_data_buffer_locked: [u8_; 1usize],
    pub reserved_at_16a: [u8_; 22usize],
    pub reserved_at_180: [u8_; 32usize],
    pub reserved_at_1a0: [u8_; 10usize],
    pub format_select_dw_8_6_ext: [u8_; 1usize],
    pub reserved_at_1ac: [u8_; 21usize],
    pub general_obj_types_127_64: [u8_; 64usize],
    pub reserved_at_200: [u8_; 83usize],
    pub flow_counter_bulk_log_max_alloc: [u8_; 5usize],
    pub reserved_at_258: [u8_; 3usize],
    pub flow_counter_bulk_log_granularity: [u8_; 5usize],
    pub reserved_at_260: [u8_; 32usize],
    pub format_select_dw_gtpu_dw_0: [u8_; 8usize],
    pub format_select_dw_gtpu_dw_1: [u8_; 8usize],
    pub format_select_dw_gtpu_dw_2: [u8_; 8usize],
    pub format_select_dw_gtpu_first_ext_dw_0: [u8_; 8usize],
    pub generate_wqe_type: [u8_; 32usize],
    pub reserved_at_2c0: [u8_; 352usize],
    pub reserved_at_420: [u8_; 24usize],
    pub encap_entropy_hash_type: [u8_; 4usize],
    pub flow_table_hash_type: [u8_; 4usize],
    pub reserved_at_440: [u8_; 960usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_esw_cap_bits {
    pub reserved_at_0: [u8_; 29usize],
    pub merged_eswitch: [u8_; 1usize],
    pub reserved_at_1e: [u8_; 2usize],
    pub reserved_at_20: [u8_; 64usize],
    pub esw_manager_vport_number_valid: [u8_; 1usize],
    pub reserved_at_61: [u8_; 15usize],
    pub esw_manager_vport_number: [u8_; 16usize],
    pub reserved_at_80: [u8_; 1920usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_wqe_based_flow_table_cap_bits {
    pub reserved_at_0: [u8_; 3usize],
    pub log_max_num_ste: [u8_; 5usize],
    pub reserved_at_8: [u8_; 3usize],
    pub log_max_num_stc: [u8_; 5usize],
    pub reserved_at_10: [u8_; 3usize],
    pub log_max_num_rtc: [u8_; 5usize],
    pub reserved_at_18: [u8_; 3usize],
    pub log_max_num_header_modify_pattern: [u8_; 5usize],
    pub rtc_hash_split_table: [u8_; 1usize],
    pub rtc_linear_lookup_table: [u8_; 1usize],
    pub reserved_at_22: [u8_; 1usize],
    pub stc_alloc_log_granularity: [u8_; 5usize],
    pub reserved_at_28: [u8_; 3usize],
    pub stc_alloc_log_max: [u8_; 5usize],
    pub reserved_at_30: [u8_; 3usize],
    pub ste_alloc_log_granularity: [u8_; 5usize],
    pub reserved_at_38: [u8_; 3usize],
    pub ste_alloc_log_max: [u8_; 5usize],
    pub reserved_at_40: [u8_; 11usize],
    pub rtc_reparse_mode: [u8_; 5usize],
    pub reserved_at_50: [u8_; 3usize],
    pub rtc_index_mode: [u8_; 5usize],
    pub reserved_at_58: [u8_; 3usize],
    pub rtc_log_depth_max: [u8_; 5usize],
    pub reserved_at_60: [u8_; 8usize],
    pub max_header_modify_pattern_length: [u8_; 8usize],
    pub ste_format: [u8_; 16usize],
    pub stc_action_type_63_0: [u8_; 64usize],
    pub stc_action_type_127_64: [u8_; 64usize],
    pub header_insert_type: [u8_; 16usize],
    pub header_remove_type: [u8_; 16usize],
    pub trivial_match_definer: [u8_; 32usize],
    pub reserved_at_140: [u8_; 27usize],
    pub rtc_max_num_hash_definer_gen_wqe: [u8_; 5usize],
    pub reserved_at_160: [u8_; 24usize],
    pub access_index_mode: [u8_; 8usize],
    pub reserved_at_180: [u8_; 16usize],
    pub ste_format_gen_wqe: [u8_; 16usize],
    pub linear_match_definer_reg_c3: [u8_; 32usize],
    pub fdb_jump_to_tir_stc: [u8_; 1usize],
    pub reserved_at_1c1: [u8_; 1usize],
    pub fdb_unified_en: [u8_; 1usize],
    pub reserved_at_1c3: [u8_; 29usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_hca_cap_union_bits {
    pub cmd_hca_cap: mlx5_ifc_cmd_hca_cap_bits,
    pub cmd_hca_cap_2: mlx5_ifc_cmd_hca_cap_2_bits,
    pub per_protocol_networking_offload_caps: mlx5_ifc_per_protocol_networking_offload_caps_bits,
    pub qos_cap: mlx5_ifc_qos_cap_bits,
    pub vdpa_caps: mlx5_ifc_virtio_emulation_cap_bits,
    pub flow_table_nic_cap: mlx5_ifc_flow_table_nic_cap_bits,
    pub flow_table_esw_cap: mlx5_ifc_flow_table_esw_cap_bits,
    pub esw_cap: mlx5_ifc_esw_cap_bits,
    pub roce_caps: mlx5_ifc_roce_caps_bits,
    pub wqe_based_flow_table_cap: mlx5_ifc_wqe_based_flow_table_cap_bits,
    pub reserved_at_0: [u8_; 32768usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_action_in_bits {
    pub action_type: [u8_; 4usize],
    pub field: [u8_; 12usize],
    pub reserved_at_10: [u8_; 3usize],
    pub offset: [u8_; 5usize],
    pub reserved_at_18: [u8_; 3usize],
    pub length: [u8_; 5usize],
    pub data: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_copy_action_in_bits {
    pub action_type: [u8_; 4usize],
    pub src_field: [u8_; 12usize],
    pub reserved_at_10: [u8_; 3usize],
    pub src_offset: [u8_; 5usize],
    pub reserved_at_18: [u8_; 3usize],
    pub length: [u8_; 5usize],
    pub reserved_at_20: [u8_; 4usize],
    pub dst_field: [u8_; 12usize],
    pub reserved_at_30: [u8_; 3usize],
    pub dst_offset: [u8_; 5usize],
    pub reserved_at_38: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_hca_cap_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub capability: mlx5_ifc_hca_cap_union_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_hca_cap_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_mac_address_layout_bits {
    pub reserved_at_0: [u8_; 16usize],
    pub mac_addr_47_32: [u8_; 16usize],
    pub mac_addr_31_0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_nic_vport_context_bits {
    pub reserved_at_0: [u8_; 5usize],
    pub min_wqe_inline_mode: [u8_; 3usize],
    pub reserved_at_8: [u8_; 21usize],
    pub disable_mc_local_lb: [u8_; 1usize],
    pub disable_uc_local_lb: [u8_; 1usize],
    pub roce_en: [u8_; 1usize],
    pub arm_change_event: [u8_; 1usize],
    pub reserved_at_21: [u8_; 26usize],
    pub event_on_mtu: [u8_; 1usize],
    pub event_on_promisc_change: [u8_; 1usize],
    pub event_on_vlan_change: [u8_; 1usize],
    pub event_on_mc_address_change: [u8_; 1usize],
    pub event_on_uc_address_change: [u8_; 1usize],
    pub reserved_at_40: [u8_; 12usize],
    pub affiliation_criteria: [u8_; 4usize],
    pub affiliated_vhca_id: [u8_; 16usize],
    pub reserved_at_60: [u8_; 208usize],
    pub mtu: [u8_; 16usize],
    pub system_image_guid: [u8_; 64usize],
    pub port_guid: [u8_; 64usize],
    pub node_guid: [u8_; 64usize],
    pub reserved_at_200: [u8_; 320usize],
    pub qkey_violation_counter: [u8_; 16usize],
    pub reserved_at_350: [u8_; 1072usize],
    pub promisc_uc: [u8_; 1usize],
    pub promisc_mc: [u8_; 1usize],
    pub promisc_all: [u8_; 1usize],
    pub reserved_at_783: [u8_; 2usize],
    pub allowed_list_type: [u8_; 3usize],
    pub reserved_at_788: [u8_; 12usize],
    pub allowed_list_size: [u8_; 12usize],
    pub permanent_address: mlx5_ifc_mac_address_layout_bits,
    pub reserved_at_7e0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_nic_vport_context_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub nic_vport_context: mlx5_ifc_nic_vport_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_nic_vport_context_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub other_vport: [u8_; 1usize],
    pub reserved_at_41: [u8_; 15usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 5usize],
    pub allowed_list_type: [u8_; 3usize],
    pub reserved_at_68: [u8_; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_tisc_bits {
    pub strict_lag_tx_port_affinity: [u8_; 1usize],
    pub reserved_at_1: [u8_; 3usize],
    pub lag_tx_port_affinity: [u8_; 4usize],
    pub reserved_at_8: [u8_; 4usize],
    pub prio: [u8_; 4usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 256usize],
    pub reserved_at_120: [u8_; 8usize],
    pub transport_domain: [u8_; 24usize],
    pub reserved_at_140: [u8_; 8usize],
    pub underlay_qpn: [u8_; 24usize],
    pub reserved_at_160: [u8_; 928usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_tis_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub tis_context: mlx5_ifc_tisc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_tis_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub tisn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
pub const mlx5_lag_mode_type_MLX5_LAG_MODE_TIS: mlx5_lag_mode_type = 0;
pub const mlx5_lag_mode_type_MLX5_LAG_MODE_HASH: mlx5_lag_mode_type = 1;
pub type mlx5_lag_mode_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_lag_context_bits {
    pub fdb_selection_mode: [u8_; 1usize],
    pub reserved_at_1: [u8_; 20usize],
    pub port_select_mode: [u8_; 3usize],
    pub reserved_at_18: [u8_; 5usize],
    pub lag_state: [u8_; 3usize],
    pub reserved_at_20: [u8_; 20usize],
    pub tx_remap_affinity_2: [u8_; 4usize],
    pub reserved_at_38: [u8_; 4usize],
    pub tx_remap_affinity_1: [u8_; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_lag_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_lag_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub context: mlx5_ifc_lag_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_transport_domain_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub transport_domain: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_transport_domain_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_wq_bits {
    pub wq_type: [u8_; 4usize],
    pub wq_signature: [u8_; 1usize],
    pub end_padding_mode: [u8_; 2usize],
    pub cd_slave: [u8_; 1usize],
    pub reserved_at_8: [u8_; 24usize],
    pub hds_skip_first_sge: [u8_; 1usize],
    pub log2_hds_buf_size: [u8_; 3usize],
    pub reserved_at_24: [u8_; 7usize],
    pub page_offset: [u8_; 5usize],
    pub lwm: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_at_60: [u8_; 8usize],
    pub uar_page: [u8_; 24usize],
    pub dbr_addr: [u8_; 64usize],
    pub hw_counter: [u8_; 32usize],
    pub sw_counter: [u8_; 32usize],
    pub reserved_at_100: [u8_; 12usize],
    pub log_wq_stride: [u8_; 4usize],
    pub reserved_at_110: [u8_; 3usize],
    pub log_wq_pg_sz: [u8_; 5usize],
    pub reserved_at_118: [u8_; 3usize],
    pub log_wq_sz: [u8_; 5usize],
    pub dbr_umem_valid: [u8_; 1usize],
    pub wq_umem_valid: [u8_; 1usize],
    pub reserved_at_122: [u8_; 1usize],
    pub log_hairpin_num_packets: [u8_; 5usize],
    pub reserved_at_128: [u8_; 3usize],
    pub log_hairpin_data_sz: [u8_; 5usize],
    pub reserved_at_130: [u8_; 4usize],
    pub single_wqe_log_num_of_strides: [u8_; 4usize],
    pub two_byte_shift_en: [u8_; 1usize],
    pub reserved_at_139: [u8_; 4usize],
    pub single_stride_log_num_of_bytes: [u8_; 3usize],
    pub dbr_umem_id: [u8_; 32usize],
    pub wq_umem_id: [u8_; 32usize],
    pub wq_umem_offset: [u8_; 64usize],
    pub reserved_at_1c0: [u8_; 1088usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rqc_bits {
    pub rlky: [u8_; 1usize],
    pub delay_drop_en: [u8_; 1usize],
    pub scatter_fcs: [u8_; 1usize],
    pub vsd: [u8_; 1usize],
    pub mem_rq_type: [u8_; 4usize],
    pub state: [u8_; 4usize],
    pub reserved_at_c: [u8_; 1usize],
    pub flush_in_error_en: [u8_; 1usize],
    pub hairpin: [u8_; 1usize],
    pub reserved_at_f: [u8_; 6usize],
    pub hairpin_data_buffer_type: [u8_; 3usize],
    pub reserved_at_a8: [u8_; 2usize],
    pub ts_format: [u8_; 2usize],
    pub reserved_at_1c: [u8_; 4usize],
    pub reserved_at_20: [u8_; 8usize],
    pub user_index: [u8_; 24usize],
    pub reserved_at_40: [u8_; 8usize],
    pub cqn: [u8_; 24usize],
    pub counter_set_id: [u8_; 8usize],
    pub reserved_at_68: [u8_; 24usize],
    pub reserved_at_80: [u8_; 8usize],
    pub rmpn: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub hairpin_peer_sq: [u8_; 24usize],
    pub reserved_at_c0: [u8_; 16usize],
    pub hairpin_peer_vhca: [u8_; 16usize],
    pub reserved_at_e0: [u8_; 160usize],
    pub wq: mlx5_ifc_wq_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rq_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub ctx: mlx5_ifc_rqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_rq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_rq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 192usize],
    pub rq_context: mlx5_ifc_rqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_rq_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rmpc_bits {
    pub reserved_at_0: [u8_; 8usize],
    pub state: [u8_; 4usize],
    pub reserved_at_c: [u8_; 20usize],
    pub basic_cyclic_rcv_wqe: [u8_; 1usize],
    pub reserved_at_21: [u8_; 31usize],
    pub reserved_at_40: [u8_; 320usize],
    pub wq: mlx5_ifc_wq_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_rmp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 192usize],
    pub rmp_context: mlx5_ifc_rmpc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_rmp_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rmpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_rmp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rmp_bitmask_bits {
    pub reserved_at_0: [u8_; 32usize],
    pub reserved_at_20: [u8_; 31usize],
    pub lwm: [u8_; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_rmp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub rmp_state: [u8_; 4usize],
    pub reserved_at_44: [u8_; 4usize],
    pub rmpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub bitmask: mlx5_ifc_rmp_bitmask_bits,
    pub reserved_at_c0: [u8_; 64usize],
    pub ctx: mlx5_ifc_rmpc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rmp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rmpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rmp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub ctx: mlx5_ifc_rmpc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_tis_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub tisn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_tis_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub ctx: mlx5_ifc_tisc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_rq_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub rq_state: [u8_; 4usize],
    pub reserved_at_44: [u8_; 4usize],
    pub rqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub modify_bitmask: [u8_; 64usize],
    pub reserved_at_c0: [u8_; 64usize],
    pub ctx: mlx5_ifc_rqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rx_hash_field_select_bits {
    pub l3_prot_type: [u8_; 1usize],
    pub l4_prot_type: [u8_; 1usize],
    pub selected_fields: [u8_; 30usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_tirc_bits {
    pub reserved_at_0: [u8_; 32usize],
    pub disp_type: [u8_; 4usize],
    pub reserved_at_24: [u8_; 28usize],
    pub reserved_at_40: [u8_; 64usize],
    pub reserved_at_80: [u8_; 4usize],
    pub lro_timeout_period_usecs: [u8_; 16usize],
    pub lro_enable_mask: [u8_; 4usize],
    pub lro_max_msg_sz: [u8_; 8usize],
    pub reserved_at_a0: [u8_; 64usize],
    pub reserved_at_e0: [u8_; 8usize],
    pub inline_rqn: [u8_; 24usize],
    pub rx_hash_symmetric: [u8_; 1usize],
    pub reserved_at_101: [u8_; 1usize],
    pub tunneled_offload_en: [u8_; 1usize],
    pub reserved_at_103: [u8_; 5usize],
    pub indirect_table: [u8_; 24usize],
    pub rx_hash_fn: [u8_; 4usize],
    pub reserved_at_124: [u8_; 2usize],
    pub self_lb_block: [u8_; 2usize],
    pub transport_domain: [u8_; 24usize],
    pub rx_hash_toeplitz_key: [[u8_; 32usize]; 10usize],
    pub rx_hash_field_selector_outer: mlx5_ifc_rx_hash_field_select_bits,
    pub rx_hash_field_selector_inner: mlx5_ifc_rx_hash_field_select_bits,
    pub reserved_at_2c0: [u8_; 1216usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_tir_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub tirn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_tir_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub ctx: mlx5_ifc_tirc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_tir_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_tir_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub tirn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub modify_bitmask: [u8_; 64usize],
    pub reserved_at_c0: [u8_; 64usize],
    pub ctx: mlx5_ifc_tirc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rq_num_bits {
    pub reserved_at_0: [u8_; 8usize],
    pub rq_num: [u8_; 24usize],
}
#[repr(C)]
pub struct mlx5_ifc_rqtc_bits {
    pub reserved_at_0: [u8_; 165usize],
    pub list_q_type: [u8_; 3usize],
    pub reserved_at_a8: [u8_; 8usize],
    pub rqt_max_size: [u8_; 16usize],
    pub reserved_at_c0: [u8_; 16usize],
    pub rqt_actual_size: [u8_; 16usize],
    pub reserved_at_e0: [u8_; 1696usize],
    pub rq_num: __IncompleteArrayField<mlx5_ifc_rq_num_bits>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rqt_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rqtn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
pub struct mlx5_ifc_create_rqt_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub rqt_context: mlx5_ifc_rqtc_bits,
}
#[repr(C)]
pub struct mlx5_ifc_modify_rqt_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub rqtn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub modify_bitmask: [u8_; 64usize],
    pub reserved_at_c0: [u8_; 64usize],
    pub rqt_context: mlx5_ifc_rqtc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_rqt_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_sqc_bits {
    pub rlky: [u8_; 1usize],
    pub cd_master: [u8_; 1usize],
    pub fre: [u8_; 1usize],
    pub flush_in_error_en: [u8_; 1usize],
    pub allow_multi_pkt_send_wqe: [u8_; 1usize],
    pub min_wqe_inline_mode: [u8_; 3usize],
    pub state: [u8_; 4usize],
    pub reg_umr: [u8_; 1usize],
    pub allow_swp: [u8_; 1usize],
    pub hairpin: [u8_; 1usize],
    pub non_wire: [u8_; 1usize],
    pub static_sq_wq: [u8_; 1usize],
    pub reserved_at_11: [u8_; 4usize],
    pub hairpin_wq_buffer_type: [u8_; 3usize],
    pub reserved_at_18: [u8_; 2usize],
    pub ts_format: [u8_; 2usize],
    pub reserved_at_1c: [u8_; 4usize],
    pub reserved_at_20: [u8_; 8usize],
    pub user_index: [u8_; 24usize],
    pub reserved_at_40: [u8_; 8usize],
    pub cqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 8usize],
    pub hairpin_peer_rq: [u8_; 24usize],
    pub reserved_at_80: [u8_; 16usize],
    pub hairpin_peer_vhca: [u8_; 16usize],
    pub reserved_at_a0: [u8_; 80usize],
    pub packet_pacing_rate_limit_index: [u8_; 16usize],
    pub tis_lst_sz: [u8_; 16usize],
    pub reserved_at_110: [u8_; 16usize],
    pub reserved_at_120: [u8_; 64usize],
    pub reserved_at_160: [u8_; 8usize],
    pub tis_num_0: [u8_; 24usize],
    pub wq: mlx5_ifc_wq_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_sq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 192usize],
    pub sq_context: mlx5_ifc_sqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_sq_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub sqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_sq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_sq_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub sq_state: [u8_; 4usize],
    pub reserved_at_44: [u8_; 4usize],
    pub sqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub modify_bitmask: [u8_; 64usize],
    pub reserved_at_c0: [u8_; 64usize],
    pub ctx: mlx5_ifc_sqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_sq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub sqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_sq_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 192usize],
    pub ctx: mlx5_ifc_sqc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_meter_parameters_bits {
    pub valid: [u8_; 1usize],
    pub bucket_overflow: [u8_; 1usize],
    pub start_color: [u8_; 2usize],
    pub both_buckets_on_green: [u8_; 1usize],
    pub meter_mode: [u8_; 2usize],
    pub reserved_at_1: [u8_; 25usize],
    pub reserved_at_2: [u8_; 32usize],
    pub reserved_at_3: [u8_; 3usize],
    pub cbs_exponent: [u8_; 5usize],
    pub cbs_mantissa: [u8_; 8usize],
    pub reserved_at_4: [u8_; 3usize],
    pub cir_exponent: [u8_; 5usize],
    pub cir_mantissa: [u8_; 8usize],
    pub reserved_at_5: [u8_; 32usize],
    pub reserved_at_6: [u8_; 3usize],
    pub ebs_exponent: [u8_; 5usize],
    pub ebs_mantissa: [u8_; 8usize],
    pub reserved_at_7: [u8_; 3usize],
    pub eir_exponent: [u8_; 5usize],
    pub eir_mantissa: [u8_; 8usize],
    pub reserved_at_8: [u8_; 96usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_cqc_bits {
    pub status: [u8_; 4usize],
    pub as_notify: [u8_; 1usize],
    pub initiator_src_dct: [u8_; 1usize],
    pub dbr_umem_valid: [u8_; 1usize],
    pub ext_element: [u8_; 1usize],
    pub cqe_sz: [u8_; 3usize],
    pub cc: [u8_; 1usize],
    pub reserved_at_c: [u8_; 1usize],
    pub scqe_break_moderation_en: [u8_; 1usize],
    pub oi: [u8_; 1usize],
    pub cq_period_mode: [u8_; 2usize],
    pub cqe_comp_en: [u8_; 1usize],
    pub mini_cqe_res_format: [u8_; 2usize],
    pub st: [u8_; 4usize],
    pub always_armed_cq: [u8_; 1usize],
    pub ext_element_type: [u8_; 3usize],
    pub reserved_at_1c: [u8_; 2usize],
    pub cqe_comp_layout: [u8_; 2usize],
    pub dbr_umem_id: [u8_; 32usize],
    pub reserved_at_40: [u8_; 20usize],
    pub page_offset: [u8_; 6usize],
    pub reserved_at_5a: [u8_; 2usize],
    pub mini_cqe_res_format_ext: [u8_; 2usize],
    pub cq_timestamp_format: [u8_; 2usize],
    pub reserved_at_60: [u8_; 3usize],
    pub log_cq_size: [u8_; 5usize],
    pub uar_page: [u8_; 24usize],
    pub reserved_at_80: [u8_; 4usize],
    pub cq_period: [u8_; 12usize],
    pub cq_max_count: [u8_; 16usize],
    pub reserved_at_a0: [u8_; 24usize],
    pub c_eqn: [u8_; 8usize],
    pub reserved_at_c0: [u8_; 3usize],
    pub log_page_size: [u8_; 5usize],
    pub reserved_at_c8: [u8_; 24usize],
    pub reserved_at_e0: [u8_; 32usize],
    pub reserved_at_100: [u8_; 8usize],
    pub last_notified_index: [u8_; 24usize],
    pub reserved_at_120: [u8_; 8usize],
    pub last_solicit_index: [u8_; 24usize],
    pub reserved_at_140: [u8_; 8usize],
    pub consumer_counter: [u8_; 24usize],
    pub reserved_at_160: [u8_; 8usize],
    pub producer_counter: [u8_; 24usize],
    pub local_partition_id: [u8_; 12usize],
    pub process_id: [u8_; 20usize],
    pub reserved_at_1A0: [u8_; 32usize],
    pub dbr_addr: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_health_buffer_bits {
    pub reserved_0: [u8_; 256usize],
    pub assert_existptr: [u8_; 32usize],
    pub assert_callra: [u8_; 32usize],
    pub reserved_1: [u8_; 64usize],
    pub fw_version: [u8_; 32usize],
    pub hw_id: [u8_; 32usize],
    pub reserved_2: [u8_; 32usize],
    pub irisc_index: [u8_; 8usize],
    pub synd: [u8_; 8usize],
    pub ext_synd: [u8_; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_initial_seg_bits {
    pub fw_rev_minor: [u8_; 16usize],
    pub fw_rev_major: [u8_; 16usize],
    pub cmd_interface_rev: [u8_; 16usize],
    pub fw_rev_subminor: [u8_; 16usize],
    pub reserved_0: [u8_; 64usize],
    pub cmdq_phy_addr_63_32: [u8_; 32usize],
    pub cmdq_phy_addr_31_12: [u8_; 20usize],
    pub reserved_1: [u8_; 2usize],
    pub nic_interface: [u8_; 2usize],
    pub log_cmdq_size: [u8_; 4usize],
    pub log_cmdq_stride: [u8_; 4usize],
    pub command_doorbell_vector: [u8_; 32usize],
    pub reserved_2: [u8_; 3840usize],
    pub initializing: [u8_; 1usize],
    pub nic_interface_supported: [u8_; 7usize],
    pub reserved_4: [u8_; 24usize],
    pub health_buffer: mlx5_ifc_health_buffer_bits,
    pub no_dram_nic_offset: [u8_; 32usize],
    pub reserved_5: [u8_; 28128usize],
    pub internal_timer_h: [u8_; 32usize],
    pub internal_timer_l: [u8_; 32usize],
    pub reserved_6: [u8_; 32usize],
    pub reserved_7: [u8_; 31usize],
    pub clear_int: [u8_; 1usize],
    pub health_syndrome: [u8_; 8usize],
    pub health_counter: [u8_; 24usize],
    pub reserved_8: [u8_; 352usize],
    pub real_time: [u8_; 64usize],
    pub reserved_9: [u8_; 97824usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_cq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub cqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
pub struct mlx5_ifc_create_cq_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
    pub cq_context: mlx5_ifc_cqc_bits,
    pub cq_umem_offset: [u8_; 64usize],
    pub cq_umem_id: [u8_; 32usize],
    pub cq_umem_valid: [u8_; 1usize],
    pub reserved_at_2e1: [u8_; 31usize],
    pub reserved_at_300: [u8_; 1408usize],
    pub pas: __IncompleteArrayField<u8_>,
}
#[repr(C)]
pub struct mlx5_ifc_query_cq_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub cq_context: mlx5_ifc_cqc_bits,
    pub reserved_at_280: [u8_; 1536usize],
    pub pas: __IncompleteArrayField<[u8_; 64usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_cq_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub cqn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_general_obj_in_cmd_hdr_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 32usize],
    pub obj_type: [u8_; 16usize],
    pub obj_id: [u8_; 32usize],
    pub __bindgen_anon_1: mlx5_ifc_general_obj_in_cmd_hdr_bits__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_general_obj_in_cmd_hdr_bits__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_ifc_general_obj_in_cmd_hdr_bits__bindgen_ty_1__bindgen_ty_1,
    pub obj_offset: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_general_obj_in_cmd_hdr_bits__bindgen_ty_1__bindgen_ty_1 {
    pub alias_object: [u8_; 1usize],
    pub reserved_at_61: [u8_; 2usize],
    pub log_obj_range: [u8_; 5usize],
    pub reserved_at_68: [u8_; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_general_obj_out_cmd_hdr_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub obj_id: [u8_; 32usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_allow_other_vhca_access_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 80usize],
    pub object_type_to_be_accessed: [u8_; 16usize],
    pub object_id_to_be_accessed: [u8_; 32usize],
    pub reserved_at_c0: [u8_; 64usize],
    pub __bindgen_anon_1: mlx5_ifc_allow_other_vhca_access_in_bits__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_allow_other_vhca_access_in_bits__bindgen_ty_1 {
    pub access_key_raw: [u8_; 256usize],
    pub access_key: [[u8_; 32usize]; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_allow_other_vhca_access_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_virtio_q_counters_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 64usize],
    pub received_desc: [u8_; 64usize],
    pub completed_desc: [u8_; 64usize],
    pub error_cqes: [u8_; 32usize],
    pub bad_desc_errors: [u8_; 32usize],
    pub exceed_max_chain: [u8_; 32usize],
    pub invalid_buffer: [u8_; 32usize],
    pub reserved_at_180: [u8_; 80usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_geneve_tlv_option_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 8usize],
    pub sample_offset: [u8_; 8usize],
    pub sample_id_valid: [u8_; 1usize],
    pub sample_offset_valid: [u8_; 1usize],
    pub option_class_ignore: [u8_; 1usize],
    pub reserved_at_53: [u8_; 5usize],
    pub geneve_option_fte_index: [u8_; 8usize],
    pub option_class: [u8_; 16usize],
    pub option_type: [u8_; 8usize],
    pub reserved_at_78: [u8_; 3usize],
    pub option_data_length: [u8_; 5usize],
    pub geneve_sample_field_id: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 352usize],
}
pub const mlx5_ifc_rtc_update_mode_MLX5_IFC_RTC_STE_UPDATE_MODE_BY_HASH: mlx5_ifc_rtc_update_mode =
    0;
pub const mlx5_ifc_rtc_update_mode_MLX5_IFC_RTC_STE_UPDATE_MODE_BY_OFFSET:
    mlx5_ifc_rtc_update_mode = 1;
pub type mlx5_ifc_rtc_update_mode = ::std::os::raw::c_uint;
pub const mlx5_ifc_rtc_access_mode_MLX5_IFC_RTC_STE_ACCESS_MODE_BY_HASH: mlx5_ifc_rtc_access_mode =
    0;
pub const mlx5_ifc_rtc_access_mode_MLX5_IFC_RTC_STE_ACCESS_MODE_LINEAR: mlx5_ifc_rtc_access_mode =
    1;
pub type mlx5_ifc_rtc_access_mode = ::std::os::raw::c_uint;
pub const mlx5_ifc_rtc_ste_format_MLX5_IFC_RTC_STE_FORMAT_8DW: mlx5_ifc_rtc_ste_format = 4;
pub const mlx5_ifc_rtc_ste_format_MLX5_IFC_RTC_STE_FORMAT_11DW: mlx5_ifc_rtc_ste_format = 5;
pub const mlx5_ifc_rtc_ste_format_MLX5_IFC_RTC_STE_FORMAT_RANGE: mlx5_ifc_rtc_ste_format = 7;
pub const mlx5_ifc_rtc_ste_format_MLX5_IFC_RTC_STE_FORMAT_4DW_RANGE: mlx5_ifc_rtc_ste_format = 8;
pub type mlx5_ifc_rtc_ste_format = ::std::os::raw::c_uint;
pub const mlx5_ifc_rtc_reparse_mode_MLX5_IFC_RTC_REPARSE_NEVER: mlx5_ifc_rtc_reparse_mode = 0;
pub const mlx5_ifc_rtc_reparse_mode_MLX5_IFC_RTC_REPARSE_ALWAYS: mlx5_ifc_rtc_reparse_mode = 1;
pub const mlx5_ifc_rtc_reparse_mode_MLX5_IFC_RTC_REPARSE_BY_STC: mlx5_ifc_rtc_reparse_mode = 2;
pub type mlx5_ifc_rtc_reparse_mode = ::std::os::raw::c_uint;
pub const mlx5_ifc_stc_action_type_bit_index_MLX5_IFC_STC_ACTION_TYPE_BIT_64_INDEX:
    mlx5_ifc_stc_action_type_bit_index = 64;
pub const mlx5_ifc_stc_action_type_bit_index_MLX5_IFC_STC_ACTION_TYPE_JUMP_FLOW_TABLE_FDB_RX_BIT_INDEX : mlx5_ifc_stc_action_type_bit_index = 71 ;
pub type mlx5_ifc_stc_action_type_bit_index = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rtc_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 64usize],
    pub update_index_mode: [u8_; 2usize],
    pub reparse_mode: [u8_; 2usize],
    pub num_match_ste: [u8_; 4usize],
    pub pd: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 9usize],
    pub access_index_mode: [u8_; 3usize],
    pub num_hash_definer: [u8_; 4usize],
    pub update_method: [u8_; 1usize],
    pub reserved_at_b1: [u8_; 2usize],
    pub log_depth: [u8_; 5usize],
    pub log_hash_size: [u8_; 8usize],
    pub ste_format_0: [u8_; 8usize],
    pub table_type: [u8_; 8usize],
    pub ste_format_1: [u8_; 8usize],
    pub reserved_at_d8: [u8_; 8usize],
    pub match_definer_0: [u8_; 32usize],
    pub stc_id: [u8_; 32usize],
    pub ste_table_base_id: [u8_; 32usize],
    pub ste_table_offset: [u8_; 32usize],
    pub reserved_at_160: [u8_; 8usize],
    pub miss_flow_table_id: [u8_; 24usize],
    pub match_definer_1: [u8_; 32usize],
    pub reserved_at_1a0: [u8_; 608usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ste_match_4dw_range_ctrl_dw_bits {
    pub match_: [u8_; 1usize],
    pub reserved_at_1: [u8_; 2usize],
    pub base1: [u8_; 1usize],
    pub inverse1: [u8_; 1usize],
    pub reserved_at_5: [u8_; 1usize],
    pub operator1: [u8_; 2usize],
    pub reserved_at_8: [u8_; 3usize],
    pub base0: [u8_; 1usize],
    pub inverse0: [u8_; 1usize],
    pub reserved_at_a: [u8_; 1usize],
    pub operator0: [u8_; 2usize],
    pub compare_delta: [u8_; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alias_context_bits {
    pub vhca_id_to_be_accessed: [u8_; 16usize],
    pub reserved_at_10: [u8_; 13usize],
    pub status: [u8_; 3usize],
    pub object_id_to_be_accessed: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub __bindgen_anon_1: mlx5_ifc_alias_context_bits__bindgen_ty_1,
    pub metadata: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_alias_context_bits__bindgen_ty_1 {
    pub access_key_raw: [u8_; 256usize],
    pub access_key: [[u8_; 32usize]; 8usize],
}
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_NOP: mlx5_ifc_stc_action_type = 0;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_COPY: mlx5_ifc_stc_action_type = 5;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_SET: mlx5_ifc_stc_action_type = 6;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_ADD: mlx5_ifc_stc_action_type = 7;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_REMOVE_WORDS: mlx5_ifc_stc_action_type =
    8;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_HEADER_REMOVE:
    mlx5_ifc_stc_action_type = 9;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_HEADER_INSERT:
    mlx5_ifc_stc_action_type = 11;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_TAG: mlx5_ifc_stc_action_type = 12;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_ACC_MODIFY_LIST:
    mlx5_ifc_stc_action_type = 14;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_ASO: mlx5_ifc_stc_action_type = 18;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_COUNTER: mlx5_ifc_stc_action_type = 20;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_ADD_FIELD: mlx5_ifc_stc_action_type =
    27;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_STE_TABLE:
    mlx5_ifc_stc_action_type = 128;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_TIR: mlx5_ifc_stc_action_type =
    129;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_FT: mlx5_ifc_stc_action_type =
    130;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_DROP: mlx5_ifc_stc_action_type = 131;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_ALLOW: mlx5_ifc_stc_action_type = 132;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_VPORT:
    mlx5_ifc_stc_action_type = 133;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_UPLINK:
    mlx5_ifc_stc_action_type = 134;
pub const mlx5_ifc_stc_action_type_MLX5_IFC_STC_ACTION_TYPE_JUMP_TO_FLOW_TABLE_FDB_RX:
    mlx5_ifc_stc_action_type = 135;
pub type mlx5_ifc_stc_action_type = ::std::os::raw::c_uint;
pub const mlx5_ifc_stc_reparse_mode_MLX5_IFC_STC_REPARSE_IGNORE: mlx5_ifc_stc_reparse_mode = 0;
pub const mlx5_ifc_stc_reparse_mode_MLX5_IFC_STC_REPARSE_NEVER: mlx5_ifc_stc_reparse_mode = 1;
pub const mlx5_ifc_stc_reparse_mode_MLX5_IFC_STC_REPARSE_ALWAYS: mlx5_ifc_stc_reparse_mode = 2;
pub type mlx5_ifc_stc_reparse_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_ste_table_bits {
    pub ste_obj_id: [u8_; 32usize],
    pub match_definer_id: [u8_; 32usize],
    pub reserved_at_40: [u8_; 3usize],
    pub log_hash_size: [u8_; 5usize],
    pub reserved_at_48: [u8_; 56usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_tir_bits {
    pub reserved_at_0: [u8_; 8usize],
    pub tirn: [u8_; 24usize],
    pub reserved_at_20: [u8_; 96usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_table_bits {
    pub reserved_at_0: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub reserved_at_20: [u8_; 96usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_flow_counter_bits {
    pub flow_counter_id: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_execute_aso_bits {
    pub aso_object_id: [u8_; 32usize],
    pub return_reg_id: [u8_; 4usize],
    pub aso_type: [u8_; 4usize],
    pub reserved_at_28: [u8_; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_header_modify_list_bits {
    pub header_modify_pattern_id: [u8_; 32usize],
    pub header_modify_argument_id: [u8_; 32usize],
}
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_PACKET_START: mlx5_ifc_header_anchors = 0;
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_FIRST_VLAN_START: mlx5_ifc_header_anchors = 2;
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_IPV6_IPV4: mlx5_ifc_header_anchors = 7;
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_TCP_UDP: mlx5_ifc_header_anchors = 9;
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_INNER_MAC: mlx5_ifc_header_anchors = 19;
pub const mlx5_ifc_header_anchors_MLX5_HEADER_ANCHOR_INNER_IPV6_IPV4: mlx5_ifc_header_anchors = 25;
pub type mlx5_ifc_header_anchors = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_remove_bits {
    pub action_type: [u8_; 4usize],
    pub decap: [u8_; 1usize],
    pub reserved_at_5: [u8_; 5usize],
    pub remove_start_anchor: [u8_; 6usize],
    pub reserved_at_10: [u8_; 2usize],
    pub remove_end_anchor: [u8_; 6usize],
    pub reserved_at_18: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_remove_words_bits {
    pub action_type: [u8_; 4usize],
    pub reserved_at_4: [u8_; 6usize],
    pub remove_start_anchor: [u8_; 6usize],
    pub reserved_at_10: [u8_; 1usize],
    pub remove_offset: [u8_; 7usize],
    pub reserved_at_18: [u8_; 2usize],
    pub remove_size: [u8_; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_insert_bits {
    pub action_type: [u8_; 4usize],
    pub encap: [u8_; 1usize],
    pub inline_data: [u8_; 1usize],
    pub push_esp: [u8_; 1usize],
    pub reserved_at_7: [u8_; 3usize],
    pub insert_anchor: [u8_; 6usize],
    pub reserved_at_10: [u8_; 1usize],
    pub insert_offset: [u8_; 7usize],
    pub reserved_at_18: [u8_; 1usize],
    pub insert_size: [u8_; 7usize],
    pub insert_argument: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_ste_param_vport_bits {
    pub eswitch_owner_vhca_id: [u8_; 16usize],
    pub vport_number: [u8_; 16usize],
    pub eswitch_owner_vhca_id_valid: [u8_; 1usize],
    pub reserved_at_21: [u8_; 95usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_stc_param_bits {
    pub ste_table: mlx5_ifc_stc_ste_param_ste_table_bits,
    pub tir: mlx5_ifc_stc_ste_param_tir_bits,
    pub table: mlx5_ifc_stc_ste_param_table_bits,
    pub counter: mlx5_ifc_stc_ste_param_flow_counter_bits,
    pub modify_header: mlx5_ifc_stc_ste_param_header_modify_list_bits,
    pub aso: mlx5_ifc_stc_ste_param_execute_aso_bits,
    pub remove_header: mlx5_ifc_stc_ste_param_remove_bits,
    pub insert_header: mlx5_ifc_stc_ste_param_insert_bits,
    pub add: mlx5_ifc_set_action_in_bits,
    pub set: mlx5_ifc_set_action_in_bits,
    pub copy: mlx5_ifc_copy_action_in_bits,
    pub vport: mlx5_ifc_stc_ste_param_vport_bits,
    pub reserved_at_0: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_stc_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 70usize],
    pub reparse_mode: [u8_; 2usize],
    pub table_type: [u8_; 8usize],
    pub ste_action_offset: [u8_; 8usize],
    pub action_type: [u8_; 8usize],
    pub reserved_at_a0: [u8_; 96usize],
    pub stc_param: mlx5_ifc_stc_param_bits,
    pub reserved_at_180: [u8_; 640usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ste_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 72usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_90: [u8_; 880usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_definer_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 80usize],
    pub format_id: [u8_; 16usize],
    pub reserved_at_60: [u8_; 96usize],
    pub format_select_dw3: [u8_; 8usize],
    pub format_select_dw2: [u8_; 8usize],
    pub format_select_dw1: [u8_; 8usize],
    pub format_select_dw0: [u8_; 8usize],
    pub format_select_dw7: [u8_; 8usize],
    pub format_select_dw6: [u8_; 8usize],
    pub format_select_dw5: [u8_; 8usize],
    pub format_select_dw4: [u8_; 8usize],
    pub reserved_at_100: [u8_; 24usize],
    pub format_select_dw8: [u8_; 8usize],
    pub reserved_at_120: [u8_; 32usize],
    pub format_select_byte3: [u8_; 8usize],
    pub format_select_byte2: [u8_; 8usize],
    pub format_select_byte1: [u8_; 8usize],
    pub format_select_byte0: [u8_; 8usize],
    pub format_select_byte7: [u8_; 8usize],
    pub format_select_byte6: [u8_; 8usize],
    pub format_select_byte5: [u8_; 8usize],
    pub format_select_byte4: [u8_; 8usize],
    pub reserved_at_180: [u8_; 64usize],
    pub ctrl: [u8_; 160usize],
    pub match_mask: [u8_; 352usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_arg_bits {
    pub rsvd0: [u8_; 136usize],
    pub access_pd: [u8_; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_header_modify_pattern_in_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 64usize],
    pub pattern_length: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 96usize],
    pub pattern_data: [u8_; 4096usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_virtio_q_counters_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub virtio_q_counters: mlx5_ifc_virtio_q_counters_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_virtio_q_counters_out_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub virtio_q_counters: mlx5_ifc_virtio_q_counters_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_geneve_tlv_option_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub geneve_tlv_opt: mlx5_ifc_geneve_tlv_option_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_geneve_tlv_option_out_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub geneve_tlv_opt: mlx5_ifc_geneve_tlv_option_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_rtc_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub rtc: mlx5_ifc_rtc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_stc_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub stc: mlx5_ifc_stc_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_ste_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub ste: mlx5_ifc_ste_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_definer_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub definer: mlx5_ifc_definer_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_arg_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub arg: mlx5_ifc_arg_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_header_modify_pattern_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub pattern: mlx5_ifc_header_modify_pattern_in_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_alias_obj_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub alias_ctx: mlx5_ifc_alias_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_generate_wqe_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mode: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
    pub reserved_at_80: [u8_; 8usize],
    pub pdn: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 352usize],
    pub wqe_ctrl: [u8_; 128usize],
    pub wqe_gta_ctrl: [u8_; 384usize],
    pub wqe_gta_data_0: [u8_; 512usize],
    pub wqe_gta_data_1: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_generate_wqe_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 448usize],
    pub cqe_data: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dek_bits {
    pub modify_field_select: [u8_; 64usize],
    pub state: [u8_; 8usize],
    pub reserved_at_48: [u8_; 12usize],
    pub key_size: [u8_; 4usize],
    pub has_keytag: [u8_; 1usize],
    pub reserved_at_59: [u8_; 3usize],
    pub key_purpose: [u8_; 4usize],
    pub reserved_at_60: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_at_80: [u8_; 256usize],
    pub opaque: [u8_; 64usize],
    pub reserved_at_1c0: [u8_; 64usize],
    pub key: [u8_; 1024usize],
    pub reserved_at_600: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_dek_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub dek: mlx5_ifc_dek_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_import_kek_bits {
    pub modify_field_select: [u8_; 64usize],
    pub state: [u8_; 8usize],
    pub reserved_at_48: [u8_; 12usize],
    pub key_size: [u8_; 4usize],
    pub reserved_at_58: [u8_; 424usize],
    pub key: [u8_; 1024usize],
    pub reserved_at_600: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_import_kek_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub import_kek: mlx5_ifc_import_kek_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_credential_bits {
    pub modify_field_select: [u8_; 64usize],
    pub state: [u8_; 8usize],
    pub reserved_at_48: [u8_; 16usize],
    pub credential_role: [u8_; 8usize],
    pub reserved_at_60: [u8_; 416usize],
    pub credential: [u8_; 384usize],
    pub reserved_at_380: [u8_; 1152usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_credential_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub credential: mlx5_ifc_credential_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_crypto_login_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 72usize],
    pub credential_pointer: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub session_import_kek_ptr: [u8_; 24usize],
    pub reserved_at_c0: [u8_; 320usize],
    pub credential: [u8_; 384usize],
    pub reserved_at_380: [u8_; 1152usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_crypto_login_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub crypto_login: mlx5_ifc_crypto_login_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_virtio_q_bits {
    pub virtio_q_type: [u8_; 8usize],
    pub reserved_at_8: [u8_; 5usize],
    pub event_mode: [u8_; 3usize],
    pub queue_index: [u8_; 16usize],
    pub full_emulation: [u8_; 1usize],
    pub virtio_version_1_0: [u8_; 1usize],
    pub reserved_at_22: [u8_; 2usize],
    pub offload_type: [u8_; 4usize],
    pub event_qpn_or_msix: [u8_; 24usize],
    pub doorbell_stride_idx: [u8_; 16usize],
    pub queue_size: [u8_; 16usize],
    pub device_emulation_id: [u8_; 32usize],
    pub desc_addr: [u8_; 64usize],
    pub used_addr: [u8_; 64usize],
    pub available_addr: [u8_; 64usize],
    pub virtio_q_mkey: [u8_; 32usize],
    pub reserved_at_160: [u8_; 24usize],
    pub error_type: [u8_; 8usize],
    pub umem_1_id: [u8_; 32usize],
    pub umem_1_size: [u8_; 32usize],
    pub umem_1_offset: [u8_; 64usize],
    pub umem_2_id: [u8_; 32usize],
    pub umem_2_size: [u8_; 32usize],
    pub umem_2_offset: [u8_; 64usize],
    pub umem_3_id: [u8_; 32usize],
    pub umem_3_size: [u8_; 32usize],
    pub umem_3_offset: [u8_; 64usize],
    pub counter_set_id: [u8_; 32usize],
    pub reserved_at_320: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_at_340: [u8_; 2usize],
    pub queue_period_mode: [u8_; 2usize],
    pub queue_period_us: [u8_; 12usize],
    pub queue_max_count: [u8_; 16usize],
    pub reserved_at_360: [u8_; 160usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_virtio_net_q_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 64usize],
    pub tso_ipv4: [u8_; 1usize],
    pub tso_ipv6: [u8_; 1usize],
    pub tx_csum: [u8_; 1usize],
    pub rx_csum: [u8_; 1usize],
    pub reserved_at_84: [u8_; 6usize],
    pub dirty_bitmap_dump_enable: [u8_; 1usize],
    pub vhost_log_page: [u8_; 5usize],
    pub reserved_at_90: [u8_; 12usize],
    pub state: [u8_; 4usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub tisn_or_qpn: [u8_; 24usize],
    pub dirty_bitmap_mkey: [u8_; 32usize],
    pub dirty_bitmap_size: [u8_; 32usize],
    pub dirty_bitmap_addr: [u8_; 64usize],
    pub hw_available_index: [u8_; 16usize],
    pub hw_used_index: [u8_; 16usize],
    pub reserved_at_160: [u8_; 160usize],
    pub virtio_q_context: mlx5_ifc_virtio_q_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_virtq_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub virtq: mlx5_ifc_virtio_net_q_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_virtq_out_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub virtq: mlx5_ifc_virtio_net_q_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_hit_aso_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 72usize],
    pub access_pd: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 352usize],
    pub flag: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_hit_aso_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub flow_hit_aso: mlx5_ifc_flow_hit_aso_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_meter_aso_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 72usize],
    pub access_pd: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 352usize],
    pub parameters: [u8_; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_meter_aso_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub flow_meter_aso: mlx5_ifc_flow_meter_aso_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_tcp_window_params_bits {
    pub max_ack: [u8_; 32usize],
    pub max_win: [u8_; 32usize],
    pub reply_end: [u8_; 32usize],
    pub sent_end: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_conn_track_aso_bits {
    pub reply_dir: mlx5_ifc_tcp_window_params_bits,
    pub original_dir: mlx5_ifc_tcp_window_params_bits,
    pub last_end: [u8_; 32usize],
    pub last_ack: [u8_; 32usize],
    pub last_seq: [u8_; 32usize],
    pub last_win: [u8_; 16usize],
    pub reserved_at_170: [u8_; 10usize],
    pub last_dir: [u8_; 1usize],
    pub last_index: [u8_; 5usize],
    pub reserved_at_180: [u8_; 64usize],
    pub reply_direction_tcp_scale: [u8_; 4usize],
    pub reply_direction_tcp_close_initiated: [u8_; 1usize],
    pub reply_direction_tcp_liberal_enabled: [u8_; 1usize],
    pub reply_direction_tcp_data_unacked: [u8_; 1usize],
    pub reply_direction_tcp_max_ack: [u8_; 1usize],
    pub reserved_at_1c8: [u8_; 8usize],
    pub original_direction_tcp_scale: [u8_; 4usize],
    pub original_direction_tcp_close_initiated: [u8_; 1usize],
    pub original_direction_tcp_liberal_enabled: [u8_; 1usize],
    pub original_direction_tcp_data_unacked: [u8_; 1usize],
    pub original_direction_tcp_max_ack: [u8_; 1usize],
    pub reserved_at_1d8: [u8_; 8usize],
    pub valid: [u8_; 1usize],
    pub state: [u8_; 3usize],
    pub freeze_track: [u8_; 1usize],
    pub reserved_at_1e5: [u8_; 11usize],
    pub reserved_at_1f0: [u8_; 1usize],
    pub connection_assured: [u8_; 1usize],
    pub sack_permitted: [u8_; 1usize],
    pub challenged_acked: [u8_; 1usize],
    pub heartbeat: [u8_; 1usize],
    pub max_ack_window: [u8_; 3usize],
    pub reserved_at_1f8: [u8_; 1usize],
    pub retransmission_counter: [u8_; 3usize],
    pub retranmission_limit_exceeded: [u8_; 1usize],
    pub retranmission_limit: [u8_; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_conn_track_offload_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_40: [u8_; 64usize],
    pub reserved_at_80: [u8_; 8usize],
    pub conn_track_aso_access_pd: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 352usize],
    pub conn_track_aso: mlx5_ifc_conn_track_aso_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_conn_track_aso_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub conn_track_offload: mlx5_ifc_conn_track_offload_bits,
}
pub const mlx5_access_aso_opc_mod_ASO_OPC_MOD_IPSEC: mlx5_access_aso_opc_mod = 0;
pub const mlx5_access_aso_opc_mod_ASO_OPC_MOD_CONNECTION_TRACKING: mlx5_access_aso_opc_mod = 1;
pub const mlx5_access_aso_opc_mod_ASO_OPC_MOD_POLICER: mlx5_access_aso_opc_mod = 2;
pub const mlx5_access_aso_opc_mod_ASO_OPC_MOD_RACE_AVOIDANCE: mlx5_access_aso_opc_mod = 3;
pub const mlx5_access_aso_opc_mod_ASO_OPC_MOD_FLOW_HIT: mlx5_access_aso_opc_mod = 4;
pub type mlx5_access_aso_opc_mod = ::std::os::raw::c_uint;
pub const mlx5_aso_data_mask_mode_BITWISE_64BIT: mlx5_aso_data_mask_mode = 0;
pub const mlx5_aso_data_mask_mode_BYTEWISE_64BYTE: mlx5_aso_data_mask_mode = 1;
pub const mlx5_aso_data_mask_mode_CALCULATED_64BYTE: mlx5_aso_data_mask_mode = 2;
pub type mlx5_aso_data_mask_mode = ::std::os::raw::c_uint;
pub const mlx5_aso_pre_cond_op_ASO_OP_ALWAYS_FALSE: mlx5_aso_pre_cond_op = 0;
pub const mlx5_aso_pre_cond_op_ASO_OP_ALWAYS_TRUE: mlx5_aso_pre_cond_op = 1;
pub const mlx5_aso_pre_cond_op_ASO_OP_EQUAL: mlx5_aso_pre_cond_op = 2;
pub const mlx5_aso_pre_cond_op_ASO_OP_NOT_EQUAL: mlx5_aso_pre_cond_op = 3;
pub const mlx5_aso_pre_cond_op_ASO_OP_GREATER_OR_EQUAL: mlx5_aso_pre_cond_op = 4;
pub const mlx5_aso_pre_cond_op_ASO_OP_LESSER_OR_EQUAL: mlx5_aso_pre_cond_op = 5;
pub const mlx5_aso_pre_cond_op_ASO_OP_LESSER: mlx5_aso_pre_cond_op = 6;
pub const mlx5_aso_pre_cond_op_ASO_OP_GREATER: mlx5_aso_pre_cond_op = 7;
pub const mlx5_aso_pre_cond_op_ASO_OP_CYCLIC_GREATER: mlx5_aso_pre_cond_op = 8;
pub const mlx5_aso_pre_cond_op_ASO_OP_CYCLIC_LESSER: mlx5_aso_pre_cond_op = 9;
pub type mlx5_aso_pre_cond_op = ::std::os::raw::c_uint;
pub const mlx5_aso_op_ASO_OPER_LOGICAL_AND: mlx5_aso_op = 0;
pub const mlx5_aso_op_ASO_OPER_LOGICAL_OR: mlx5_aso_op = 1;
pub type mlx5_aso_op = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cseg {
    pub va_h: u32,
    pub va_l_r: u32,
    pub lkey: u32,
    pub operand_masks: u32,
    pub condition_0_data: u32,
    pub condition_0_mask: u32,
    pub condition_1_data: u32,
    pub condition_1_mask: u32,
    pub bitwise_data: u64,
    pub data_mask: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_dseg {
    pub v_bo_sc_bbog_mm: u32,
    pub reserved: u32,
    pub cbs_cir: u32,
    pub c_tokens: u32,
    pub ebs_eir: u32,
    pub e_tokens: u32,
    pub timestamp: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_dseg {
    pub __bindgen_anon_1: mlx5_aso_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_dseg__bindgen_ty_1 {
    pub data: [u8; 64usize],
    pub mtrs: [mlx5_aso_mtr_dseg; 2usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_wqe {
    pub general_cseg: mlx5_wqe_cseg,
    pub aso_cseg: mlx5_aso_cseg,
    pub aso_dseg: mlx5_aso_dseg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ads_bits {
    pub fl: [u8_; 1usize],
    pub free_ar: [u8_; 1usize],
    pub reserved_at_2: [u8_; 14usize],
    pub pkey_index: [u8_; 16usize],
    pub reserved_at_20: [u8_; 8usize],
    pub grh: [u8_; 1usize],
    pub mlid: [u8_; 7usize],
    pub rlid: [u8_; 16usize],
    pub ack_timeout: [u8_; 5usize],
    pub reserved_at_45: [u8_; 3usize],
    pub src_addr_index: [u8_; 8usize],
    pub reserved_at_50: [u8_; 4usize],
    pub stat_rate: [u8_; 4usize],
    pub hop_limit: [u8_; 8usize],
    pub reserved_at_60: [u8_; 4usize],
    pub tclass: [u8_; 8usize],
    pub flow_label: [u8_; 20usize],
    pub rgid_rip: [[u8_; 8usize]; 16usize],
    pub reserved_at_100: [u8_; 4usize],
    pub f_dscp: [u8_; 1usize],
    pub f_ecn: [u8_; 1usize],
    pub reserved_at_106: [u8_; 1usize],
    pub f_eth_prio: [u8_; 1usize],
    pub ecn: [u8_; 2usize],
    pub dscp: [u8_; 6usize],
    pub udp_sport: [u8_; 16usize],
    pub dei_cfi: [u8_; 1usize],
    pub eth_prio: [u8_; 3usize],
    pub sl: [u8_; 4usize],
    pub vhca_port_num: [u8_; 8usize],
    pub rmac_47_32: [u8_; 16usize],
    pub rmac_31_0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_qpc_bits {
    pub state: [u8_; 4usize],
    pub lag_tx_port_affinity: [u8_; 4usize],
    pub st: [u8_; 8usize],
    pub reserved_at_10: [u8_; 3usize],
    pub pm_state: [u8_; 2usize],
    pub reserved_at_15: [u8_; 1usize],
    pub req_e2e_credit_mode: [u8_; 2usize],
    pub offload_type: [u8_; 4usize],
    pub end_padding_mode: [u8_; 2usize],
    pub reserved_at_1e: [u8_; 2usize],
    pub wq_signature: [u8_; 1usize],
    pub block_lb_mc: [u8_; 1usize],
    pub atomic_like_write_en: [u8_; 1usize],
    pub latency_sensitive: [u8_; 1usize],
    pub reserved_at_24: [u8_; 1usize],
    pub drain_sigerr: [u8_; 1usize],
    pub reserved_at_26: [u8_; 2usize],
    pub pd: [u8_; 24usize],
    pub mtu: [u8_; 3usize],
    pub log_msg_max: [u8_; 5usize],
    pub reserved_at_48: [u8_; 1usize],
    pub log_rq_size: [u8_; 4usize],
    pub log_rq_stride: [u8_; 3usize],
    pub no_sq: [u8_; 1usize],
    pub log_sq_size: [u8_; 4usize],
    pub reserved_at_55: [u8_; 3usize],
    pub ts_format: [u8_; 2usize],
    pub reserved_at_5a: [u8_; 1usize],
    pub rlky: [u8_; 1usize],
    pub ulp_stateless_offload_mode: [u8_; 4usize],
    pub counter_set_id: [u8_; 8usize],
    pub uar_page: [u8_; 24usize],
    pub reserved_at_80: [u8_; 8usize],
    pub user_index: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 3usize],
    pub log_page_size: [u8_; 5usize],
    pub remote_qpn: [u8_; 24usize],
    pub primary_address_path: mlx5_ifc_ads_bits,
    pub secondary_address_path: mlx5_ifc_ads_bits,
    pub log_ack_req_freq: [u8_; 4usize],
    pub reserved_at_384: [u8_; 4usize],
    pub log_sra_max: [u8_; 3usize],
    pub reserved_at_38b: [u8_; 2usize],
    pub retry_count: [u8_; 3usize],
    pub rnr_retry: [u8_; 3usize],
    pub reserved_at_393: [u8_; 1usize],
    pub fre: [u8_; 1usize],
    pub cur_rnr_retry: [u8_; 3usize],
    pub cur_retry_count: [u8_; 3usize],
    pub reserved_at_39b: [u8_; 5usize],
    pub reserved_at_3a0: [u8_; 32usize],
    pub reserved_at_3c0: [u8_; 8usize],
    pub next_send_psn: [u8_; 24usize],
    pub reserved_at_3e0: [u8_; 8usize],
    pub cqn_snd: [u8_; 24usize],
    pub reserved_at_400: [u8_; 8usize],
    pub deth_sqpn: [u8_; 24usize],
    pub reserved_at_420: [u8_; 32usize],
    pub reserved_at_440: [u8_; 8usize],
    pub last_acked_psn: [u8_; 24usize],
    pub reserved_at_460: [u8_; 8usize],
    pub ssn: [u8_; 24usize],
    pub reserved_at_480: [u8_; 8usize],
    pub log_rra_max: [u8_; 3usize],
    pub reserved_at_48b: [u8_; 1usize],
    pub atomic_mode: [u8_; 4usize],
    pub rre: [u8_; 1usize],
    pub rwe: [u8_; 1usize],
    pub rae: [u8_; 1usize],
    pub reserved_at_493: [u8_; 1usize],
    pub page_offset: [u8_; 6usize],
    pub reserved_at_49a: [u8_; 3usize],
    pub cd_slave_receive: [u8_; 1usize],
    pub cd_slave_send: [u8_; 1usize],
    pub cd_master: [u8_; 1usize],
    pub reserved_at_4a0: [u8_; 3usize],
    pub min_rnr_nak: [u8_; 5usize],
    pub next_rcv_psn: [u8_; 24usize],
    pub reserved_at_4c0: [u8_; 8usize],
    pub xrcd: [u8_; 24usize],
    pub reserved_at_4e0: [u8_; 8usize],
    pub cqn_rcv: [u8_; 24usize],
    pub dbr_addr: [u8_; 64usize],
    pub q_key: [u8_; 32usize],
    pub reserved_at_560: [u8_; 5usize],
    pub rq_type: [u8_; 3usize],
    pub srqn_rmpn_xrqn: [u8_; 24usize],
    pub reserved_at_580: [u8_; 8usize],
    pub rmsn: [u8_; 24usize],
    pub hw_sq_wqebb_counter: [u8_; 16usize],
    pub sw_sq_wqebb_counter: [u8_; 16usize],
    pub hw_rq_counter: [u8_; 32usize],
    pub sw_rq_counter: [u8_; 32usize],
    pub reserved_at_600: [u8_; 32usize],
    pub reserved_at_620: [u8_; 15usize],
    pub cgs: [u8_; 1usize],
    pub cs_req: [u8_; 8usize],
    pub cs_res: [u8_; 8usize],
    pub dc_access_key: [u8_; 64usize],
    pub reserved_at_680: [u8_; 3usize],
    pub dbr_umem_valid: [u8_; 1usize],
    pub reserved_at_684: [u8_; 156usize],
    pub dbr_umem_id: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_qpc_extension_bits {
    pub reserved_at_0: [u8_; 2usize],
    pub mmo: [u8_; 1usize],
    pub reserved_at_3: [u8_; 1533usize],
}
#[repr(C)]
pub struct mlx5_ifc_qpc_pas_list_bits {
    pub pas: __IncompleteArrayField<[u8_; 64usize]>,
}
#[repr(C)]
pub struct mlx5_ifc_qpc_extension_and_pas_list_bits {
    pub qpc_data_extension: mlx5_ifc_qpc_extension_bits,
    pub pas: __IncompleteArrayField<[u8_; 64usize]>,
}
#[repr(C)]
pub struct mlx5_ifc_create_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub qpc_ext: [u8_; 1usize],
    pub reserved_at_41: [u8_; 63usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub wq_umem_offset: [u8_; 64usize],
    pub wq_umem_id: [u8_; 32usize],
    pub wq_umem_valid: [u8_; 1usize],
    pub reserved_at_861: [u8_; 31usize],
    pub __bindgen_anon_1: mlx5_ifc_create_qp_in_bits__bindgen_ty_1,
}
#[repr(C)]
pub struct mlx5_ifc_create_qp_in_bits__bindgen_ty_1 {
    pub qpc_pas_list: __BindgenUnionField<mlx5_ifc_qpc_pas_list_bits>,
    pub qpc_extension_and_pas_list: __BindgenUnionField<mlx5_ifc_qpc_extension_and_pas_list_bits>,
    pub bindgen_union_field: [u8; 1536usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_sqerr2rts_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_sqerr2rts_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_sqd2rts_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_sqd2rts_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rts2rts_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rts2rts_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rtr2rts_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rtr2rts_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rst2init_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_rst2init_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_init2rtr_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_init2rtr_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_init2init_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_init2init_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_2rst_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_2rst_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub vhca_tunnel_id: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_80: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dealloc_pd_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_0: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_1: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dealloc_pd_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_0: [u8_; 16usize],
    pub reserved_1: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_2: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_3: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_pd_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_0: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_1: [u8_; 8usize],
    pub pd: [u8_; 24usize],
    pub reserved_2: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_pd_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_0: [u8_; 16usize],
    pub reserved_1: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_2: [u8_; 64usize],
}
#[repr(C)]
pub struct mlx5_ifc_query_qp_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub opt_param_mask: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub qpc: mlx5_ifc_qpc_bits,
    pub reserved_at_800: [u8_; 128usize],
    pub pas: __IncompleteArrayField<[u8_; 64usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_qp_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 8usize],
    pub qpn: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_pp_rate_limit_context_bits {
    pub rate_limit: [u8_; 32usize],
    pub burst_upper_bound: [u8_; 32usize],
    pub reserved_at_40: [u8_; 12usize],
    pub rate_mode: [u8_; 4usize],
    pub typical_packet_size: [u8_; 16usize],
    pub reserved_at_60: [u8_; 288usize],
}
#[repr(C)]
pub struct mlx5_ifc_access_register_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub register_data: __IncompleteArrayField<[u8_; 32usize]>,
}
#[repr(C)]
pub struct mlx5_ifc_access_register_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 16usize],
    pub register_id: [u8_; 16usize],
    pub argument: [u8_; 32usize],
    pub register_data: __IncompleteArrayField<[u8_; 32usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_register_mtutc_bits {
    pub time_stamp_mode: [u8_; 2usize],
    pub time_stamp_state: [u8_; 2usize],
    pub reserved_at_4: [u8_; 24usize],
    pub operation: [u8_; 4usize],
    pub freq_adjustment: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub utc_sec: [u8_; 32usize],
    pub utc_nsec: [u8_; 32usize],
    pub time_adjustment: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_ets_global_config_register_bits {
    pub reserved_at_0: [u8_; 2usize],
    pub rate_limit_update: [u8_; 1usize],
    pub reserved_at_3: [u8_; 41usize],
    pub max_bw_units: [u8_; 4usize],
    pub reserved_at_48: [u8_; 8usize],
    pub max_bw_value: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_register_qshr_bits {
    pub reserved_at_0: [u8_; 4usize],
    pub connected_host: [u8_; 1usize],
    pub vqos: [u8_; 1usize],
    pub fast_response: [u8_; 1usize],
    pub reserved_at_7: [u8_; 1usize],
    pub local_port: [u8_; 8usize],
    pub reserved_at_16: [u8_; 560usize],
    pub global_config: mlx5_ifc_ets_global_config_register_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_crypto_operational_register_bits {
    pub wrapped_crypto_operational: [u8_; 1usize],
    pub reserved_at_1: [u8_; 27usize],
    pub kek_size: [u8_; 4usize],
    pub reserved_at_20: [u8_; 32usize],
    pub credential: [u8_; 320usize],
    pub kek: [u8_; 256usize],
    pub reserved_at_280: [u8_; 384usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_crypto_caps_bits {
    pub wrapped_crypto_operational: [u8_; 1usize],
    pub wrapped_crypto_going_to_commissioning: [u8_; 1usize],
    pub sw_wrapped_dek: [u8_; 1usize],
    pub synchronize_dek: [u8_; 1usize],
    pub int_kek_manual: [u8_; 1usize],
    pub int_kek_auto: [u8_; 1usize],
    pub reserved_at_6: [u8_; 13usize],
    pub sw_wrapped_dek_key_purpose: [u8_; 1usize],
    pub reserved_at_14: [u8_; 4usize],
    pub wrapped_import_method: [u8_; 8usize],
    pub reserved_at_20: [u8_; 3usize],
    pub log_dek_max_alloc: [u8_; 5usize],
    pub reserved_at_28: [u8_; 3usize],
    pub log_max_num_deks: [u8_; 5usize],
    pub reserved_at_30: [u8_; 3usize],
    pub log_max_num_import_keks: [u8_; 5usize],
    pub reserved_at_38: [u8_; 3usize],
    pub log_max_num_creds: [u8_; 5usize],
    pub failed_selftests: [u8_; 16usize],
    pub num_nv_import_keks: [u8_; 8usize],
    pub num_nv_credentials: [u8_; 8usize],
    pub reserved_at_60: [u8_; 3usize],
    pub log_dek_granularity: [u8_; 5usize],
    pub reserved_at_68: [u8_; 3usize],
    pub log_max_num_int_kek: [u8_; 5usize],
    pub sw_wrapped_dek_new: [u8_; 16usize],
    pub reserved_at_80: [u8_; 128usize],
    pub crypto_mmo_qp: [u8_; 1usize],
    pub crypto_aes_gcm_256_encrypt: [u8_; 1usize],
    pub crypto_aes_gcm_128_encrypt: [u8_; 1usize],
    pub crypto_aes_gcm_256_decrypt: [u8_; 1usize],
    pub crypto_aes_gcm_128_decrypt: [u8_; 1usize],
    pub gcm_auth_tag_128: [u8_; 1usize],
    pub gcm_auth_tag_96: [u8_; 1usize],
    pub reserved_at_107: [u8_; 3usize],
    pub log_crypto_mmo_max_size: [u8_; 6usize],
    pub reserved_at_110: [u8_; 16usize],
    pub reserved_at_120: [u8_; 1760usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_crypto_commissioning_register_bits {
    pub token: [u8_; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_import_kek_handle_register_bits {
    pub crypto_login_object: mlx5_ifc_crypto_login_bits,
    pub import_kek_object: mlx5_ifc_import_kek_bits,
    pub reserved_at_200: [u8_; 4usize],
    pub write_operation: [u8_; 4usize],
    pub import_kek_id: [u8_; 24usize],
    pub reserved_at_220: [u8_; 224usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_credential_handle_register_bits {
    pub crypto_login_object: mlx5_ifc_crypto_login_bits,
    pub credential_object: mlx5_ifc_credential_bits,
    pub reserved_at_200: [u8_; 4usize],
    pub write_operation: [u8_; 4usize],
    pub credential_id: [u8_; 24usize],
    pub reserved_at_220: [u8_; 224usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_parse_graph_arc_bits {
    pub start_inner_tunnel: [u8_; 1usize],
    pub reserved_at_1: [u8_; 7usize],
    pub arc_parse_graph_node: [u8_; 8usize],
    pub compare_condition_value: [u8_; 16usize],
    pub parse_graph_node_handle: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_parse_graph_flow_match_sample_bits {
    pub flow_match_sample_en: [u8_; 1usize],
    pub reserved_at_1: [u8_; 3usize],
    pub flow_match_sample_offset_mode: [u8_; 4usize],
    pub reserved_at_5: [u8_; 8usize],
    pub flow_match_sample_field_offset: [u8_; 16usize],
    pub reserved_at_32: [u8_; 4usize],
    pub flow_match_sample_field_offset_shift: [u8_; 4usize],
    pub flow_match_sample_field_base_offset: [u8_; 8usize],
    pub reserved_at_48: [u8_; 13usize],
    pub flow_match_sample_tunnel_mode: [u8_; 3usize],
    pub flow_match_sample_field_offset_mask: [u8_; 32usize],
    pub flow_match_sample_field_id: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_parse_graph_flex_bits {
    pub modify_field_select: [u8_; 64usize],
    pub reserved_at_64: [u8_; 32usize],
    pub header_length_base_value: [u8_; 16usize],
    pub reserved_at_112: [u8_; 4usize],
    pub header_length_field_shift: [u8_; 4usize],
    pub reserved_at_120: [u8_; 4usize],
    pub header_length_mode: [u8_; 4usize],
    pub header_length_field_offset: [u8_; 16usize],
    pub next_header_field_offset: [u8_; 16usize],
    pub reserved_at_160: [u8_; 18usize],
    pub head_anchor_id: [u8_; 6usize],
    pub reserved_at_178: [u8_; 3usize],
    pub next_header_field_size: [u8_; 5usize],
    pub header_length_field_mask: [u8_; 32usize],
    pub reserved_at_224: [u8_; 32usize],
    pub sample_table: [mlx5_ifc_parse_graph_flow_match_sample_bits; 8usize],
    pub input_arc: [mlx5_ifc_parse_graph_arc_bits; 8usize],
    pub output_arc: [mlx5_ifc_parse_graph_arc_bits; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flex_parser_in_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub flex: mlx5_ifc_parse_graph_flex_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flex_parser_out_bits {
    pub hdr: mlx5_ifc_general_obj_in_cmd_hdr_bits,
    pub flex: mlx5_ifc_parse_graph_flex_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_parse_graph_flex_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub capability: mlx5_ifc_parse_graph_flex_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regexp_params_field_select_bits {
    pub reserved_at_0: [u8_; 29usize],
    pub rof_mkey: [u8_; 1usize],
    pub stop_engine: [u8_; 1usize],
    pub reserved_at_1f: [u8_; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_regexp_params_bits {
    pub reserved_at_0: [u8_; 31usize],
    pub stop_engine: [u8_; 1usize],
    pub reserved_at_20: [u8_; 96usize],
    pub rof_mkey: [u8_; 32usize],
    pub rof_size: [u8_; 32usize],
    pub rof_mkey_va: [u8_; 64usize],
    pub reserved_at_100: [u8_; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_regexp_params_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 24usize],
    pub engine_id: [u8_; 8usize],
    pub field_select: regexp_params_field_select_bits,
    pub regexp_params: mlx5_ifc_regexp_params_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_regexp_params_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_18: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_regexp_params_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 24usize],
    pub engine_id: [u8_; 8usize],
    pub reserved: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_regexp_params_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved: [u8_; 64usize],
    pub regexp_params: mlx5_ifc_regexp_params_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_regexp_register_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 24usize],
    pub engine_id: [u8_; 8usize],
    pub register_address: [u8_; 32usize],
    pub register_data: [u8_; 32usize],
    pub reserved: [u8_; 96usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_regexp_register_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_regexp_register_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 24usize],
    pub engine_id: [u8_; 8usize],
    pub register_address: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_regexp_register_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved: [u8_; 32usize],
    pub register_data: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_q_counter_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 24usize],
    pub counter_set_id: [u8_; 8usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_q_counter_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_q_counter_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
    pub rx_write_requests: [u8_; 32usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub rx_read_requests: [u8_; 32usize],
    pub reserved_at_e0: [u8_; 32usize],
    pub rx_atomic_requests: [u8_; 32usize],
    pub reserved_at_120: [u8_; 32usize],
    pub rx_dct_connect: [u8_; 32usize],
    pub reserved_at_160: [u8_; 32usize],
    pub out_of_buffer: [u8_; 32usize],
    pub reserved_at_1a0: [u8_; 32usize],
    pub out_of_sequence: [u8_; 32usize],
    pub reserved_at_1e0: [u8_; 32usize],
    pub duplicate_request: [u8_; 32usize],
    pub reserved_at_220: [u8_; 32usize],
    pub rnr_nak_retry_err: [u8_; 32usize],
    pub reserved_at_260: [u8_; 32usize],
    pub packet_seq_err: [u8_; 32usize],
    pub reserved_at_2a0: [u8_; 32usize],
    pub implied_nak_seq_err: [u8_; 32usize],
    pub reserved_at_2e0: [u8_; 32usize],
    pub local_ack_timeout_err: [u8_; 32usize],
    pub reserved_at_320: [u8_; 160usize],
    pub resp_local_length_error: [u8_; 32usize],
    pub req_local_length_error: [u8_; 32usize],
    pub resp_local_qp_error: [u8_; 32usize],
    pub local_operation_error: [u8_; 32usize],
    pub resp_local_protection: [u8_; 32usize],
    pub req_local_protection: [u8_; 32usize],
    pub resp_cqe_error: [u8_; 32usize],
    pub req_cqe_error: [u8_; 32usize],
    pub req_mw_binding: [u8_; 32usize],
    pub req_bad_response: [u8_; 32usize],
    pub req_remote_invalid_request: [u8_; 32usize],
    pub resp_remote_invalid_request: [u8_; 32usize],
    pub req_remote_access_errors: [u8_; 32usize],
    pub resp_remote_access_errors: [u8_; 32usize],
    pub req_remote_operation_errors: [u8_; 32usize],
    pub req_transport_retries_exceeded: [u8_; 32usize],
    pub cq_overflow: [u8_; 32usize],
    pub resp_cqe_flush_error: [u8_; 32usize],
    pub req_cqe_flush_error: [u8_; 32usize],
    pub reserved_at_620: [u8_; 480usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_q_counter_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 128usize],
    pub clear: [u8_; 1usize],
    pub reserved_at_c1: [u8_; 31usize],
    pub reserved_at_e0: [u8_; 24usize],
    pub counter_set_id: [u8_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_context_bits {
    pub reformat_en: [u8_; 1usize],
    pub decap_en: [u8_; 1usize],
    pub sw_owner: [u8_; 1usize],
    pub termination_table: [u8_; 1usize],
    pub table_miss_action: [u8_; 4usize],
    pub level: [u8_; 8usize],
    pub rtc_valid: [u8_; 1usize],
    pub reserved_at_11: [u8_; 7usize],
    pub log_size: [u8_; 8usize],
    pub reserved_at_20: [u8_; 8usize],
    pub table_miss_id: [u8_; 24usize],
    pub reserved_at_40: [u8_; 8usize],
    pub lag_master_next_table_id: [u8_; 24usize],
    pub reserved_at_60: [u8_; 96usize],
    pub __bindgen_anon_1: mlx5_ifc_flow_table_context_bits__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_flow_table_context_bits__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_ifc_flow_table_context_bits__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_ifc_flow_table_context_bits__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_context_bits__bindgen_ty_1__bindgen_ty_1 {
    pub rtc_id_0: [u8_; 32usize],
    pub rtc_id_1: [u8_; 32usize],
    pub reserved_at_100: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_table_context_bits__bindgen_ty_1__bindgen_ty_2 {
    pub sw_owner_icm_root_1: [u8_; 64usize],
    pub sw_owner_icm_root_0: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_table_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub other_vport: [u8_; 1usize],
    pub reserved_at_41: [u8_; 15usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 32usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 32usize],
    pub flow_table_context: mlx5_ifc_flow_table_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_table_out_bits {
    pub status: [u8_; 8usize],
    pub icm_address_63_40: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub icm_address_39_32: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub icm_address_31_0: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_flow_table_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub vhca_tunnel_id: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub other_vport: [u8_; 1usize],
    pub reserved_at_41: [u8_; 15usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 32usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub reserved_at_c0: [u8_; 320usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_query_flow_table_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 128usize],
    pub flow_table_context: mlx5_ifc_flow_table_context_bits,
}
pub const mlx5_flow_destination_type_MLX5_FLOW_DESTINATION_TYPE_VPORT: mlx5_flow_destination_type =
    0;
pub const mlx5_flow_destination_type_MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE:
    mlx5_flow_destination_type = 1;
pub const mlx5_flow_destination_type_MLX5_FLOW_DESTINATION_TYPE_TIR: mlx5_flow_destination_type = 2;
pub const mlx5_flow_destination_type_MLX5_FLOW_DESTINATION_TYPE_NOP: mlx5_flow_destination_type =
    11;
pub type mlx5_flow_destination_type = ::std::os::raw::c_uint;
pub const mlx5_flow_context_action_MLX5_FLOW_CONTEXT_ACTION_DROP: mlx5_flow_context_action = 2;
pub const mlx5_flow_context_action_MLX5_FLOW_CONTEXT_ACTION_FWD_DEST: mlx5_flow_context_action = 4;
pub const mlx5_flow_context_action_MLX5_FLOW_CONTEXT_ACTION_REFORMAT: mlx5_flow_context_action = 16;
pub const mlx5_flow_context_action_MLX5_FLOW_CONTEXT_ACTION_DECRYPT: mlx5_flow_context_action =
    4096;
pub const mlx5_flow_context_action_MLX5_FLOW_CONTEXT_ACTION_ENCRYPT: mlx5_flow_context_action =
    8192;
pub type mlx5_flow_context_action = ::std::os::raw::c_uint;
pub const mlx5_flow_context_flow_source_MLX5_FLOW_CONTEXT_FLOW_SOURCE_ANY_VPORT:
    mlx5_flow_context_flow_source = 0;
pub const mlx5_flow_context_flow_source_MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK:
    mlx5_flow_context_flow_source = 1;
pub const mlx5_flow_context_flow_source_MLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT:
    mlx5_flow_context_flow_source = 2;
pub type mlx5_flow_context_flow_source = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_set_fte_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_dest_format_bits {
    pub destination_type: [u8_; 8usize],
    pub destination_id: [u8_; 24usize],
    pub destination_eswitch_owner_vhca_id_valid: [u8_; 1usize],
    pub packet_reformat: [u8_; 1usize],
    pub reserved_at_22: [u8_; 14usize],
    pub destination_eswitch_owner_vhca_id: [u8_; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_flow_counter_list_bits {
    pub flow_counter_id: [u8_; 32usize],
    pub reserved_at_20: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ifc_dest_format_flow_counter_list_auto_bits {
    pub dest_format: mlx5_ifc_dest_format_bits,
    pub flow_counter_list: mlx5_ifc_flow_counter_list_bits,
    pub reserved_at_0: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_extended_dest_format_bits {
    pub destination_entry: mlx5_ifc_dest_format_bits,
    pub packet_reformat_id: [u8_; 32usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
pub struct mlx5_ifc_flow_context_bits {
    pub reserved_at_00: [u8_; 32usize],
    pub group_id: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub flow_tag: [u8_; 24usize],
    pub reserved_at_60: [u8_; 16usize],
    pub action: [u8_; 16usize],
    pub extended_destination: [u8_; 1usize],
    pub reserved_at_81: [u8_; 1usize],
    pub flow_source: [u8_; 2usize],
    pub encrypt_decrypt_type: [u8_; 4usize],
    pub destination_list_size: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub flow_counter_list_size: [u8_; 24usize],
    pub packet_reformat_id: [u8_; 32usize],
    pub reserved_at_e0: [u8_; 64usize],
    pub encrypt_decrypt_obj_id: [u8_; 32usize],
    pub reserved_at_140: [u8_; 5824usize],
    pub destination: __IncompleteArrayField<mlx5_ifc_dest_format_flow_counter_list_auto_bits>,
}
#[repr(C)]
pub struct mlx5_ifc_set_fte_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub other_vport: [u8_; 1usize],
    pub reserved_at_41: [u8_; 15usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 32usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub ignore_flow_level: [u8_; 1usize],
    pub reserved_at_c1: [u8_; 23usize],
    pub modify_enable_mask: [u8_; 8usize],
    pub reserved_at_e0: [u8_; 32usize],
    pub flow_index: [u8_; 32usize],
    pub reserved_at_120: [u8_; 224usize],
    pub flow_context: mlx5_ifc_flow_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_group_in_bits {
    pub opcode: [u8_; 16usize],
    pub reserved_at_10: [u8_; 16usize],
    pub reserved_at_20: [u8_; 32usize],
    pub other_vport: [u8_; 1usize],
    pub reserved_at_41: [u8_; 15usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 32usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub reserved_at_c0: [u8_; 8000usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_create_flow_group_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 8usize],
    pub group_id: [u8_; 24usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_flow_table_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 16usize],
    pub vport_number: [u8_; 16usize],
    pub reserved_at_60: [u8_; 16usize],
    pub modify_field_select: [u8_; 16usize],
    pub table_type: [u8_; 8usize],
    pub reserved_at_88: [u8_; 24usize],
    pub reserved_at_a0: [u8_; 8usize],
    pub table_id: [u8_; 24usize],
    pub flow_table_context: mlx5_ifc_flow_table_context_bits,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_modify_flow_table_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub reserved_at_40: [u8_; 96usize],
}
#[repr(C)]
pub struct mlx5_ifc_packet_reformat_context_in_bits {
    pub reformat_type: [u8_; 8usize],
    pub reserved_at_8: [u8_; 4usize],
    pub reformat_param_0: [u8_; 4usize],
    pub reserved_at_16: [u8_; 6usize],
    pub reformat_data_size: [u8_; 10usize],
    pub reformat_param_1: [u8_; 8usize],
    pub reserved_at_40: [u8_; 8usize],
    pub reformat_data: [[u8_; 8usize]; 6usize],
    pub more_reformat_data: __IncompleteArrayField<[u8_; 8usize]>,
}
#[repr(C)]
pub struct mlx5_ifc_alloc_packet_reformat_context_in_bits {
    pub opcode: [u8_; 16usize],
    pub uid: [u8_; 16usize],
    pub reserved_at_20: [u8_; 16usize],
    pub op_mod: [u8_; 16usize],
    pub reserved_at_40: [u8_; 160usize],
    pub packet_reformat_context: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ifc_alloc_packet_reformat_out_bits {
    pub status: [u8_; 8usize],
    pub reserved_at_8: [u8_; 24usize],
    pub syndrome: [u8_; 32usize],
    pub packet_reformat_id: [u8_; 32usize],
    pub reserved_at_60: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mini_cqe8 {
    pub __bindgen_anon_1: mlx5_mini_cqe8__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_mini_cqe8__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_mini_cqe8__bindgen_ty_1 {
    pub rx_hash_result: u32,
    pub __bindgen_anon_1: mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1,
    pub s_wqe_info: mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub stride_idx: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub checksum: u16,
    pub flow_tag_high: u16,
    pub __bindgen_anon_1: mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub reserved: u8,
    pub hdr_type: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mini_cqe8__bindgen_ty_1__bindgen_ty_2 {
    pub wqe_counter: u16,
    pub validity_iteration_count: u8,
    pub s_wqe_opcode: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_mini_cqe8__bindgen_ty_2 {
    pub byte_cnt_flow: u32,
    pub byte_cnt: u32,
}
pub const mlx5_parse_graph_node_len_mode_MLX5_GRAPH_NODE_LEN_FIXED: mlx5_parse_graph_node_len_mode =
    0;
pub const mlx5_parse_graph_node_len_mode_MLX5_GRAPH_NODE_LEN_FIELD: mlx5_parse_graph_node_len_mode =
    1;
pub const mlx5_parse_graph_node_len_mode_MLX5_GRAPH_NODE_LEN_BITMASK:
    mlx5_parse_graph_node_len_mode = 2;
pub type mlx5_parse_graph_node_len_mode = ::std::os::raw::c_uint;
pub const mlx5_parse_graph_flow_match_sample_offset_mode_MLX5_GRAPH_SAMPLE_OFFSET_FIXED:
    mlx5_parse_graph_flow_match_sample_offset_mode = 0;
pub const mlx5_parse_graph_flow_match_sample_offset_mode_MLX5_GRAPH_SAMPLE_OFFSET_FIELD:
    mlx5_parse_graph_flow_match_sample_offset_mode = 1;
pub const mlx5_parse_graph_flow_match_sample_offset_mode_MLX5_GRAPH_SAMPLE_OFFSET_BITMASK:
    mlx5_parse_graph_flow_match_sample_offset_mode = 2;
pub type mlx5_parse_graph_flow_match_sample_offset_mode = ::std::os::raw::c_uint;
pub const mlx5_parse_graph_flow_match_sample_tunnel_mode_MLX5_GRAPH_SAMPLE_TUNNEL_OUTER:
    mlx5_parse_graph_flow_match_sample_tunnel_mode = 0;
pub const mlx5_parse_graph_flow_match_sample_tunnel_mode_MLX5_GRAPH_SAMPLE_TUNNEL_INNER:
    mlx5_parse_graph_flow_match_sample_tunnel_mode = 1;
pub const mlx5_parse_graph_flow_match_sample_tunnel_mode_MLX5_GRAPH_SAMPLE_TUNNEL_FIRST:
    mlx5_parse_graph_flow_match_sample_tunnel_mode = 2;
pub type mlx5_parse_graph_flow_match_sample_tunnel_mode = ::std::os::raw::c_uint;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_NULL:
    mlx5_parse_graph_arc_node_index = 0;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_HEAD:
    mlx5_parse_graph_arc_node_index = 1;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_MAC: mlx5_parse_graph_arc_node_index =
    2;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_IP: mlx5_parse_graph_arc_node_index =
    3;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_GRE: mlx5_parse_graph_arc_node_index =
    4;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_UDP: mlx5_parse_graph_arc_node_index =
    5;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_MPLS:
    mlx5_parse_graph_arc_node_index = 6;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_TCP: mlx5_parse_graph_arc_node_index =
    7;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_VXLAN_GPE:
    mlx5_parse_graph_arc_node_index = 8;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_GENEVE:
    mlx5_parse_graph_arc_node_index = 9;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_IPSEC_ESP:
    mlx5_parse_graph_arc_node_index = 10;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_IPV4:
    mlx5_parse_graph_arc_node_index = 11;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_IPV6:
    mlx5_parse_graph_arc_node_index = 12;
pub const mlx5_parse_graph_arc_node_index_MLX5_GRAPH_ARC_NODE_PROGRAMMABLE:
    mlx5_parse_graph_arc_node_index = 31;
pub type mlx5_parse_graph_arc_node_index = ::std::os::raw::c_uint;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_L2_TO_L2_TUNNEL : mlx5_packet_reformat_context_reformat_type = 2 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_L2_TO_L3_TUNNEL : mlx5_packet_reformat_context_reformat_type = 4 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_IPV4 : mlx5_packet_reformat_context_reformat_type = 5 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_L2_TO_L3_ESP_TUNNEL : mlx5_packet_reformat_context_reformat_type = 6 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_UDPV4 : mlx5_packet_reformat_context_reformat_type = 7 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_DEL_ESP_TRANSPORT : mlx5_packet_reformat_context_reformat_type = 8 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_L3_ESP_TUNNEL_TO_L2 : mlx5_packet_reformat_context_reformat_type = 9 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_DEL_ESP_TRANSPORT_OVER_UDP : mlx5_packet_reformat_context_reformat_type = 10 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_IPV6 : mlx5_packet_reformat_context_reformat_type = 11 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_ADD_ESP_TRANSPORT_OVER_UDPV6 : mlx5_packet_reformat_context_reformat_type = 12 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_ADD_NISP_TNL : mlx5_packet_reformat_context_reformat_type = 13 ;
pub const mlx5_packet_reformat_context_reformat_type_MLX5_PACKET_REFORMAT_CONTEXT_REFORMAT_TYPE_REMOVE_NISP_TNL : mlx5_packet_reformat_context_reformat_type = 14 ;
pub type mlx5_packet_reformat_context_reformat_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_counter_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: mlx5_devx_counter_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_counter_attr__bindgen_ty_1 {
    pub flow_counter_bulk_log_size: u8,
    pub bulk_n_128: u8,
}
impl mlx5_devx_counter_attr {
    #[inline]
    pub fn pd_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bulk_log_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bulk_log_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bulk_log_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bulk_log_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pd_valid: u32,
        pd: u32,
        bulk_log_max_alloc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pd_valid: u32 = unsafe { ::std::mem::transmute(pd_valid) };
            pd_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 24u8, {
            let pd: u32 = unsafe { ::std::mem::transmute(pd) };
            pd as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bulk_log_max_alloc: u32 = unsafe { ::std::mem::transmute(bulk_log_max_alloc) };
            bulk_log_max_alloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_mkey_attr {
    pub addr: u64,
    pub size: u64,
    pub umem_id: u32,
    pub pd: u32,
    pub log_entity_size: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub klm_array: *mut mlx5_klm,
    pub klm_num: ::std::os::raw::c_int,
}
impl mlx5_devx_mkey_attr {
    #[inline]
    pub fn pg_access(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pg_access(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pg_access_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pg_access_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_write_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_write_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_read_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_read_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_remote_rw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_set_remote_rw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_remote_rw_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_set_remote_rw_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pg_access: u32,
        relaxed_ordering_write: u32,
        relaxed_ordering_read: u32,
        umr_en: u32,
        crypto_en: u32,
        set_remote_rw: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pg_access: u32 = unsafe { ::std::mem::transmute(pg_access) };
            pg_access as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let relaxed_ordering_write: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_write) };
            relaxed_ordering_write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let relaxed_ordering_read: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_read) };
            relaxed_ordering_read as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let umr_en: u32 = unsafe { ::std::mem::transmute(umr_en) };
            umr_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let crypto_en: u32 = unsafe { ::std::mem::transmute(crypto_en) };
            crypto_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let set_remote_rw: u32 = unsafe { ::std::mem::transmute(set_remote_rw) };
            set_remote_rw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_qos_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_max_flow_meter: u8,
    pub flow_meter_reg_c_ids: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_hca_qos_attr {
    #[inline]
    pub fn sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_old(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_old(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_old_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_old_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn packet_pacing(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_packet_pacing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_pacing_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_packet_pacing_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_rate_pp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_rate_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_rate_pp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_rate_pp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_aso_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_aso_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_aso_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_aso_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sup: u32,
        flow_meter_old: u32,
        packet_pacing: u32,
        wqe_rate_pp: u32,
        flow_meter: u32,
        flow_meter_aso_sup: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sup: u32 = unsafe { ::std::mem::transmute(sup) };
            sup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_meter_old: u32 = unsafe { ::std::mem::transmute(flow_meter_old) };
            flow_meter_old as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let packet_pacing: u32 = unsafe { ::std::mem::transmute(packet_pacing) };
            packet_pacing as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wqe_rate_pp: u32 = unsafe { ::std::mem::transmute(wqe_rate_pp) };
            wqe_rate_pp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let flow_meter: u32 = unsafe { ::std::mem::transmute(flow_meter) };
            flow_meter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flow_meter_aso_sup: u32 = unsafe { ::std::mem::transmute(flow_meter_aso_sup) };
            flow_meter_aso_sup as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_meter_aso_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_meter_aso_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_num_meter_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_num_meter_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_num_meter_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_num_meter_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        log_meter_aso_granularity: u32,
        log_meter_aso_max_alloc: u32,
        log_max_num_meter_aso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_meter_aso_granularity: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_granularity) };
            log_meter_aso_granularity as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let log_meter_aso_max_alloc: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_max_alloc) };
            log_meter_aso_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let log_max_num_meter_aso: u32 =
                unsafe { ::std::mem::transmute(log_max_num_meter_aso) };
            log_max_num_meter_aso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr {
    pub virtio_queue_type: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_num_virtio_queues: u32,
    pub umems: [mlx5_hca_vdpa_attr__bindgen_ty_1; 3usize],
    pub doorbell_bar_offset: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr__bindgen_ty_1 {
    pub a: u32,
    pub b: u32,
}
impl mlx5_hca_vdpa_attr {
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn desc_tunnel_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_desc_tunnel_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn desc_tunnel_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_desc_tunnel_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_frame_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_frame_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_frame_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_frame_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_version_1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_version_1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_version_1_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_version_1_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv6_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn event_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_event_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_stride(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_stride_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_stride_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_bar_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_bar_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_bar_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_bar_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn queue_counters_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_queue_counters_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn queue_counters_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_queue_counters_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vnet_modify_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vnet_modify_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vnet_modify_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vnet_modify_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_net_q_addr_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_net_q_addr_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_net_q_addr_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_net_q_addr_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_q_index_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_q_index_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_q_index_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_q_index_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid: u32,
        desc_tunnel_offload_type: u32,
        eth_frame_offload_type: u32,
        virtio_version_1_0: u32,
        tso_ipv4: u32,
        tso_ipv6: u32,
        tx_csum: u32,
        rx_csum: u32,
        event_mode: u32,
        log_doorbell_stride: u32,
        log_doorbell_bar_size: u32,
        queue_counters_valid: u32,
        vnet_modify_ext: u32,
        virtio_net_q_addr_modify: u32,
        virtio_q_index_modify: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u32 = unsafe { ::std::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let desc_tunnel_offload_type: u32 =
                unsafe { ::std::mem::transmute(desc_tunnel_offload_type) };
            desc_tunnel_offload_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let eth_frame_offload_type: u32 =
                unsafe { ::std::mem::transmute(eth_frame_offload_type) };
            eth_frame_offload_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let virtio_version_1_0: u32 = unsafe { ::std::mem::transmute(virtio_version_1_0) };
            virtio_version_1_0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tso_ipv4: u32 = unsafe { ::std::mem::transmute(tso_ipv4) };
            tso_ipv4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tso_ipv6: u32 = unsafe { ::std::mem::transmute(tso_ipv6) };
            tso_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_csum: u32 = unsafe { ::std::mem::transmute(tx_csum) };
            tx_csum as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_csum: u32 = unsafe { ::std::mem::transmute(rx_csum) };
            rx_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let event_mode: u32 = unsafe { ::std::mem::transmute(event_mode) };
            event_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let log_doorbell_stride: u32 = unsafe { ::std::mem::transmute(log_doorbell_stride) };
            log_doorbell_stride as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let log_doorbell_bar_size: u32 =
                unsafe { ::std::mem::transmute(log_doorbell_bar_size) };
            log_doorbell_bar_size as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let queue_counters_valid: u32 = unsafe { ::std::mem::transmute(queue_counters_valid) };
            queue_counters_valid as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let vnet_modify_ext: u32 = unsafe { ::std::mem::transmute(vnet_modify_ext) };
            vnet_modify_ext as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let virtio_net_q_addr_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_net_q_addr_modify) };
            virtio_net_q_addr_modify as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let virtio_q_index_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_q_index_modify) };
            virtio_q_index_modify as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flow_attr {
    pub tunnel_header_0_1: u32,
    pub tunnel_header_2_3: u32,
}
#[doc = " Accumulate port PARSE_GRAPH_NODE capabilities from\n PARSE_GRAPH_NODE Capabilities and HCA Capabilities 2 tables"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flex_attr {
    pub node_in: u32,
    pub node_out: u32,
    pub header_length_mode: u16,
    pub sample_offset_mode: u16,
    pub max_num_arc_in: u8,
    pub max_num_arc_out: u8,
    pub max_num_sample: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_base_header_length: u16,
    pub max_sample_base_offset: u8,
    pub max_next_header_offset: u16,
    pub header_length_mask_width: u8,
}
impl mlx5_hca_flex_attr {
    #[inline]
    pub fn max_num_prog_sample(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_max_num_prog_sample(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_num_prog_sample_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_max_num_prog_sample_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_anchor(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parse_graph_anchor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_anchor_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_anchor_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_tunnel_inner2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_tunnel_inner2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_tunnel_inner2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_tunnel_inner2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zero_size_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zero_size_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zero_size_supported_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_zero_size_supported_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_id_in_out(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_id_in_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_id_in_out_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_id_in_out_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_num_prog_sample: u8,
        parse_graph_anchor: u8,
        query_match_sample_info: u8,
        sample_tunnel_inner2: u8,
        zero_size_supported: u8,
        sample_id_in_out: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let max_num_prog_sample: u8 = unsafe { ::std::mem::transmute(max_num_prog_sample) };
            max_num_prog_sample as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let parse_graph_anchor: u8 = unsafe { ::std::mem::transmute(parse_graph_anchor) };
            parse_graph_anchor as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let query_match_sample_info: u8 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sample_tunnel_inner2: u8 = unsafe { ::std::mem::transmute(sample_tunnel_inner2) };
            sample_tunnel_inner2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let zero_size_supported: u8 = unsafe { ::std::mem::transmute(zero_size_supported) };
            zero_size_supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sample_id_in_out: u8 = unsafe { ::std::mem::transmute(sample_id_in_out) };
            sample_id_in_out as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_crypto_mmo_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl mlx5_hca_crypto_mmo_attr {
    #[inline]
    pub fn crypto_mmo_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_mmo_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_mmo_qp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_mmo_qp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_96(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_96(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_96_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_96_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_crypto_mmo_max_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_log_crypto_mmo_max_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_crypto_mmo_max_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_crypto_mmo_max_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        crypto_mmo_qp: u32,
        gcm_256_encrypt: u32,
        gcm_128_encrypt: u32,
        gcm_256_decrypt: u32,
        gcm_128_decrypt: u32,
        gcm_auth_tag_128: u32,
        gcm_auth_tag_96: u32,
        log_crypto_mmo_max_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let crypto_mmo_qp: u32 = unsafe { ::std::mem::transmute(crypto_mmo_qp) };
            crypto_mmo_qp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gcm_256_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_encrypt) };
            gcm_256_encrypt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gcm_128_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_encrypt) };
            gcm_128_encrypt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gcm_256_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_decrypt) };
            gcm_256_decrypt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let gcm_128_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_decrypt) };
            gcm_128_decrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gcm_auth_tag_128: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_128) };
            gcm_auth_tag_128 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gcm_auth_tag_96: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_96) };
            gcm_auth_tag_96 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 6u8, {
            let log_crypto_mmo_max_size: u32 =
                unsafe { ::std::mem::transmute(log_crypto_mmo_max_size) };
            log_crypto_mmo_max_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_counter_bulk_alloc_bitmap: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_lso_cap: u32,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub lro_timer_supported_periods: [u32; 4usize],
    pub lro_min_mss_size: u16,
    pub flex_parser_protocols: u32,
    pub _bitfield_align_4: [u16; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 10usize]>,
    pub dev_freq_khz: u32,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub regexp_num_of_engines: u32,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub geneve_tlv_opt: u32,
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub qos: mlx5_hca_qos_attr,
    pub vdpa: mlx5_hca_vdpa_attr,
    pub flow: mlx5_hca_flow_attr,
    pub flex: mlx5_hca_flex_attr,
    pub crypto_mmo: mlx5_hca_crypto_mmo_attr,
    pub log_max_wq_sz: u8,
    pub log_max_qp_sz: u8,
    pub log_max_cq_sz: u8,
    pub log_max_qp: u8,
    pub log_max_cq: u8,
    pub log_max_pd: u32,
    pub log_max_mrw_sz: u32,
    pub log_max_srq: u32,
    pub log_max_srq_sz: u32,
    pub rss_ind_tbl_cap: u32,
    pub _bitfield_align_8: [u8; 0],
    pub _bitfield_8: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub esw_mgr_vport_id: u16,
    pub max_wqe_sz_sq: u16,
    pub _bitfield_align_9: [u16; 0],
    pub _bitfield_9: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1,
    pub _bitfield_align_10: [u8; 0],
    pub _bitfield_10: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_header_modify_pattern_length: u8,
    pub system_image_guid: u64,
    pub _bitfield_align_11: [u8; 0],
    pub _bitfield_11: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_hca_attr__bindgen_ty_1 {
    pub max_flow_counter: u32,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1 {
    pub max_flow_counter_15_0: u16,
    pub max_flow_counter_31_16: u16,
}
impl mlx5_hca_attr {
    #[inline]
    pub fn eswitch_manager(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eswitch_manager(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eswitch_manager_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eswitch_manager_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counters_dump(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counters_dump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counters_dump_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counters_dump_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_rq_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_rq_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_rq_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_rq_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rqt_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rqt_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rqt_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rqt_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_flex_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parse_graph_flex_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_flex_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_flex_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        eswitch_manager: u32,
        flow_counters_dump: u32,
        mem_rq_rmp: u32,
        log_max_rmp: u32,
        log_max_rqt_size: u32,
        parse_graph_flex_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eswitch_manager: u32 = unsafe { ::std::mem::transmute(eswitch_manager) };
            eswitch_manager as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_counters_dump: u32 = unsafe { ::std::mem::transmute(flow_counters_dump) };
            flow_counters_dump as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mem_rq_rmp: u32 = unsafe { ::std::mem::transmute(mem_rq_rmp) };
            mem_rq_rmp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let log_max_rmp: u32 = unsafe { ::std::mem::transmute(log_max_rmp) };
            log_max_rmp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log_max_rqt_size: u32 = unsafe { ::std::mem::transmute(log_max_rqt_size) };
            log_max_rqt_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let parse_graph_flex_node: u32 =
                unsafe { ::std::mem::transmute(parse_graph_flex_node) };
            parse_graph_flex_node as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eth_net_offloads(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_net_offloads(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_net_offloads_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_net_offloads_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_virt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_virt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_virt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_virt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_vlan_insert(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_vlan_insert(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_vlan_insert_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_vlan_insert_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csum_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_csum_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vport_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vport_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vport_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vport_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_geneve_rx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_geneve_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_geneve_rx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_geneve_rx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_max_opt_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_max_opt_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_max_opt_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_max_opt_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gtp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gtp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gtp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gtp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan_gpe_nsh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan_gpe_nsh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_gpe_nsh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_gpe_nsh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        eth_net_offloads: u32,
        eth_virt: u32,
        wqe_vlan_insert: u32,
        csum_cap: u32,
        vlan_cap: u32,
        wqe_inline_mode: u32,
        vport_inline_mode: u32,
        tunnel_stateless_geneve_rx: u32,
        geneve_max_opt_len: u32,
        tunnel_stateless_gtp: u32,
        tunnel_stateless_vxlan_gpe_nsh: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eth_net_offloads: u32 = unsafe { ::std::mem::transmute(eth_net_offloads) };
            eth_net_offloads as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let eth_virt: u32 = unsafe { ::std::mem::transmute(eth_virt) };
            eth_virt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wqe_vlan_insert: u32 = unsafe { ::std::mem::transmute(wqe_vlan_insert) };
            wqe_vlan_insert as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let csum_cap: u32 = unsafe { ::std::mem::transmute(csum_cap) };
            csum_cap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vlan_cap: u32 = unsafe { ::std::mem::transmute(vlan_cap) };
            vlan_cap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let wqe_inline_mode: u32 = unsafe { ::std::mem::transmute(wqe_inline_mode) };
            wqe_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let vport_inline_mode: u32 = unsafe { ::std::mem::transmute(vport_inline_mode) };
            vport_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tunnel_stateless_geneve_rx: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_geneve_rx) };
            tunnel_stateless_geneve_rx as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let geneve_max_opt_len: u32 = unsafe { ::std::mem::transmute(geneve_max_opt_len) };
            geneve_max_opt_len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tunnel_stateless_gtp: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gtp) };
            tunnel_stateless_gtp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tunnel_stateless_vxlan_gpe_nsh: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan_gpe_nsh) };
            tunnel_stateless_vxlan_gpe_nsh as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_lso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_lso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_lso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_lso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_max_msg_sz_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lro_max_msg_sz_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_max_msg_sz_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_max_msg_sz_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        scatter_fcs: u32,
        lro_cap: u32,
        tunnel_lro_gre: u32,
        tunnel_lro_vxlan: u32,
        tunnel_stateless_gre: u32,
        tunnel_stateless_vxlan: u32,
        swp: u32,
        swp_csum: u32,
        swp_lso: u32,
        lro_max_msg_sz_mode: u32,
        rq_delay_drop: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs: u32 = unsafe { ::std::mem::transmute(scatter_fcs) };
            scatter_fcs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lro_cap: u32 = unsafe { ::std::mem::transmute(lro_cap) };
            lro_cap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tunnel_lro_gre: u32 = unsafe { ::std::mem::transmute(tunnel_lro_gre) };
            tunnel_lro_gre as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tunnel_lro_vxlan: u32 = unsafe { ::std::mem::transmute(tunnel_lro_vxlan) };
            tunnel_lro_vxlan as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tunnel_stateless_gre: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gre) };
            tunnel_stateless_gre as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tunnel_stateless_vxlan: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan) };
            tunnel_stateless_vxlan as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let swp_csum: u32 = unsafe { ::std::mem::transmute(swp_csum) };
            swp_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let swp_lso: u32 = unsafe { ::std::mem::transmute(swp_lso) };
            swp_lso as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let lro_max_msg_sz_mode: u32 = unsafe { ::std::mem::transmute(lro_max_msg_sz_mode) };
            lro_max_msg_sz_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rq_delay_drop: u32 = unsafe { ::std::mem::transmute(rq_delay_drop) };
            rq_delay_drop as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn max_geneve_tlv_options(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_options(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_options_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_options_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_geneve_tlv_option_data_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_option_data_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_option_data_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_option_data_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_sample(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_sample_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_sample_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_sample_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(15usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_sample_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(15usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_sample_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                15usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_sample_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                15usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_queues(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_queues(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_queues_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                20usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_queues_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                20usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_wq_data_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_wq_data_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_wq_data_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                25usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_wq_data_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                25usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_num_packets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_num_packets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_num_packets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_num_packets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wqe_bb_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(37usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wqe_bb_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(37usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wqe_bb_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                37usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wqe_bb_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                37usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wq_in_host_mem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wq_in_host_mem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wq_in_host_mem_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wq_in_host_mem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_data_buffer_locked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_data_buffer_locked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_data_buffer_locked_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                42usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_data_buffer_locked_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vhca_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(43usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_vhca_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(43usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vhca_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                43usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vhca_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                43usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_write_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                59usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_write_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_read_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                60usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_read_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_register_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_access_register_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_register_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                61usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_access_register_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_index_ignore(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_index_ignore(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_index_ignore_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                62usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_index_ignore_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_channel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_channel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_channel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_channel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_wire_sq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_wire_sq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_wire_sq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                64usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_wire_sq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                64usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_static_sq_wq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(65usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_static_sq_wq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(65usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_static_sq_wq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                65usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_static_sq_wq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                65usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_lag_ports(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(70usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_num_lag_ports(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(70usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_lag_ports_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                70usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_lag_ports_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                70usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        max_geneve_tlv_options: u32,
        max_geneve_tlv_option_data_len: u32,
        geneve_tlv_sample: u32,
        geneve_tlv_option_offset: u32,
        geneve_tlv_option_sample_id: u32,
        hairpin: u32,
        log_max_hairpin_queues: u32,
        log_max_hairpin_wq_data_sz: u32,
        log_max_hairpin_num_packets: u32,
        hairpin_sq_wqe_bb_size: u32,
        hairpin_sq_wq_in_host_mem: u32,
        hairpin_data_buffer_locked: u32,
        vhca_id: u32,
        relaxed_ordering_write: u32,
        relaxed_ordering_read: u32,
        access_register_user: u32,
        wqe_index_ignore: u32,
        cross_channel: u32,
        non_wire_sq: u32,
        log_max_static_sq_wq: u32,
        num_lag_ports: u32,
    ) -> __BindgenBitfieldUnit<[u8; 10usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let max_geneve_tlv_options: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_options) };
            max_geneve_tlv_options as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let max_geneve_tlv_option_data_len: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_option_data_len) };
            max_geneve_tlv_option_data_len as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let geneve_tlv_sample: u32 = unsafe { ::std::mem::transmute(geneve_tlv_sample) };
            geneve_tlv_sample as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let geneve_tlv_option_offset: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_offset) };
            geneve_tlv_option_offset as u64
        });
        __bindgen_bitfield_unit.set(15usize, 4u8, {
            let geneve_tlv_option_sample_id: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_sample_id) };
            geneve_tlv_option_sample_id as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let hairpin: u32 = unsafe { ::std::mem::transmute(hairpin) };
            hairpin as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let log_max_hairpin_queues: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_queues) };
            log_max_hairpin_queues as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let log_max_hairpin_wq_data_sz: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_wq_data_sz) };
            log_max_hairpin_wq_data_sz as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let log_max_hairpin_num_packets: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_num_packets) };
            log_max_hairpin_num_packets as u64
        });
        __bindgen_bitfield_unit.set(37usize, 4u8, {
            let hairpin_sq_wqe_bb_size: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wqe_bb_size) };
            hairpin_sq_wqe_bb_size as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let hairpin_sq_wq_in_host_mem: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wq_in_host_mem) };
            hairpin_sq_wq_in_host_mem as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let hairpin_data_buffer_locked: u32 =
                unsafe { ::std::mem::transmute(hairpin_data_buffer_locked) };
            hairpin_data_buffer_locked as u64
        });
        __bindgen_bitfield_unit.set(43usize, 16u8, {
            let vhca_id: u32 = unsafe { ::std::mem::transmute(vhca_id) };
            vhca_id as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let relaxed_ordering_write: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_write) };
            relaxed_ordering_write as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let relaxed_ordering_read: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_read) };
            relaxed_ordering_read as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let access_register_user: u32 = unsafe { ::std::mem::transmute(access_register_user) };
            access_register_user as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let wqe_index_ignore: u32 = unsafe { ::std::mem::transmute(wqe_index_ignore) };
            wqe_index_ignore as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let cross_channel: u32 = unsafe { ::std::mem::transmute(cross_channel) };
            cross_channel as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let non_wire_sq: u32 = unsafe { ::std::mem::transmute(non_wire_sq) };
            non_wire_sq as u64
        });
        __bindgen_bitfield_unit.set(65usize, 5u8, {
            let log_max_static_sq_wq: u32 = unsafe { ::std::mem::transmute(log_max_static_sq_wq) };
            log_max_static_sq_wq as u64
        });
        __bindgen_bitfield_unit.set(70usize, 4u8, {
            let num_lag_ports: u32 = unsafe { ::std::mem::transmute(num_lag_ports) };
            num_lag_ports as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn roce(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn roce_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_roce_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wait_on_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wait_on_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wait_on_time_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wait_on_time_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qp_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_qp_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qp_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qp_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_params(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_params(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_params_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_params_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                15usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                15usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_c_preserve(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg_c_preserve(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_c_preserve_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_preserve_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aes_xts(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aes_xts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aes_xts_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aes_xts_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn import_kek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_import_kek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn import_kek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_import_kek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn credential(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_credential(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn credential_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_credential_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_login(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_login(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_login_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_login_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        scatter_fcs_w_decap_disable: u32,
        flow_hit_aso: u32,
        roce: u32,
        wait_on_time: u32,
        rq_ts_format: u32,
        sq_ts_format: u32,
        steering_format_version: u32,
        qp_ts_format: u32,
        regexp_params: u32,
        regexp_version: u32,
        reg_c_preserve: u32,
        ct_offload: u32,
        crypto: u32,
        aes_xts: u32,
        dek: u32,
        import_kek: u32,
        credential: u32,
        crypto_login: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso: u32 = unsafe { ::std::mem::transmute(flow_hit_aso) };
            flow_hit_aso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let roce: u32 = unsafe { ::std::mem::transmute(roce) };
            roce as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_on_time: u32 = unsafe { ::std::mem::transmute(wait_on_time) };
            wait_on_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rq_ts_format: u32 = unsafe { ::std::mem::transmute(rq_ts_format) };
            rq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let sq_ts_format: u32 = unsafe { ::std::mem::transmute(sq_ts_format) };
            sq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let qp_ts_format: u32 = unsafe { ::std::mem::transmute(qp_ts_format) };
            qp_ts_format as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let regexp_params: u32 = unsafe { ::std::mem::transmute(regexp_params) };
            regexp_params as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let regexp_version: u32 = unsafe { ::std::mem::transmute(regexp_version) };
            regexp_version as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reg_c_preserve: u32 = unsafe { ::std::mem::transmute(reg_c_preserve) };
            reg_c_preserve as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ct_offload: u32 = unsafe { ::std::mem::transmute(ct_offload) };
            ct_offload as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let crypto: u32 = unsafe { ::std::mem::transmute(crypto) };
            crypto as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let aes_xts: u32 = unsafe { ::std::mem::transmute(aes_xts) };
            aes_xts as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let dek: u32 = unsafe { ::std::mem::transmute(dek) };
            dek as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let import_kek: u32 = unsafe { ::std::mem::transmute(import_kek) };
            import_kek as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let credential: u32 = unsafe { ::std::mem::transmute(credential) };
            credential as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let crypto_login: u32 = unsafe { ::std::mem::transmute(crypto_login) };
            crypto_login as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_ft_sampler_num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_ft_sampler_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_ft_sampler_num_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_ft_sampler_num_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inner_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inner_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outer_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outer_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        log_max_ft_sampler_num: u32,
        inner_ipv4_ihl: u32,
        outer_ipv4_ihl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_max_ft_sampler_num: u32 =
                unsafe { ::std::mem::transmute(log_max_ft_sampler_num) };
            log_max_ft_sampler_num as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inner_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(inner_ipv4_ihl) };
            inner_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outer_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(outer_ipv4_ihl) };
            outer_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_flow_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_flow_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_flow_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_flow_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_l3_l4_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_l3_l4_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_l3_l4_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_l3_l4_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkt_integrity_match(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkt_integrity_match(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_integrity_match_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_integrity_match_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        cqe_compression: u32,
        mini_cqe_resp_flow_tag: u32,
        mini_cqe_resp_l3_l4_tag: u32,
        enhanced_cqe_compression: u32,
        pkt_integrity_match: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cqe_compression: u32 = unsafe { ::std::mem::transmute(cqe_compression) };
            cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mini_cqe_resp_flow_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_flow_tag) };
            mini_cqe_resp_flow_tag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mini_cqe_resp_l3_l4_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_l3_l4_tag) };
            mini_cqe_resp_l3_l4_tag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enhanced_cqe_compression: u32 =
                unsafe { ::std::mem::transmute(enhanced_cqe_compression) };
            enhanced_cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pkt_integrity_match: u32 = unsafe { ::std::mem::transmute(pkt_integrity_match) };
            pkt_integrity_match as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mmo_dma_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_decompress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_decompress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_decompress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_decompress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_dma_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v1_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v1_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v1_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v2_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v2_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v2_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn compress_min_block_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_compress_min_block_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compress_min_block_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                9usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compress_min_block_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_dma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_dma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_dma_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                13usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_dma_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                13usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_compress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_compress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_compress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                18usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_compress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                18usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_decompress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_decompress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_decompress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                23usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_decompress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                23usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_data_only_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_data_only_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_data_only_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_data_only_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_no_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_no_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_no_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_no_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_modify_entity_size_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_modify_entity_size_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_modify_entity_size_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_modify_entity_size_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_indirect_mkey_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_indirect_mkey_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_indirect_mkey_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_indirect_mkey_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_min_stride_wqe_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(33usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_min_stride_wqe_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(33usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_min_stride_wqe_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                33usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_min_stride_wqe_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                33usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn esw_mgr_vport_id_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mgr_vport_id_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mgr_vport_id_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mgr_vport_id_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_wrapped_import_method(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_wrapped_import_method(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_wrapped_import_method_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_wrapped_import_method_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_8(
        mmo_dma_sq_en: u32,
        mmo_compress_sq_en: u32,
        mmo_decompress_sq_en: u32,
        mmo_dma_qp_en: u32,
        mmo_compress_qp_en: u32,
        decomp_deflate_v1_en: u32,
        decomp_deflate_v2_en: u32,
        mmo_regex_qp_en: u32,
        mmo_regex_sq_en: u32,
        compress_min_block_size: u32,
        log_max_mmo_dma: u32,
        log_max_mmo_compress: u32,
        log_max_mmo_decompress: u32,
        decomp_lz4_data_only_en: u32,
        decomp_lz4_no_checksum_en: u32,
        decomp_lz4_checksum_en: u32,
        umr_modify_entity_size_disabled: u32,
        umr_indirect_mkey_disabled: u32,
        log_min_stride_wqe_sz: u32,
        esw_mgr_vport_id_valid: u32,
        crypto_wrapped_import_method: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmo_dma_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_sq_en) };
            mmo_dma_sq_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mmo_compress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_sq_en) };
            mmo_compress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmo_decompress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_decompress_sq_en) };
            mmo_decompress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mmo_dma_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_qp_en) };
            mmo_dma_qp_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mmo_compress_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_qp_en) };
            mmo_compress_qp_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let decomp_deflate_v1_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v1_en) };
            decomp_deflate_v1_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let decomp_deflate_v2_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v2_en) };
            decomp_deflate_v2_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mmo_regex_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_qp_en) };
            mmo_regex_qp_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmo_regex_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_sq_en) };
            mmo_regex_sq_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let compress_min_block_size: u32 =
                unsafe { ::std::mem::transmute(compress_min_block_size) };
            compress_min_block_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let log_max_mmo_dma: u32 = unsafe { ::std::mem::transmute(log_max_mmo_dma) };
            log_max_mmo_dma as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let log_max_mmo_compress: u32 = unsafe { ::std::mem::transmute(log_max_mmo_compress) };
            log_max_mmo_compress as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let log_max_mmo_decompress: u32 =
                unsafe { ::std::mem::transmute(log_max_mmo_decompress) };
            log_max_mmo_decompress as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let decomp_lz4_data_only_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_data_only_en) };
            decomp_lz4_data_only_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let decomp_lz4_no_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_no_checksum_en) };
            decomp_lz4_no_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let decomp_lz4_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_checksum_en) };
            decomp_lz4_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let umr_modify_entity_size_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_modify_entity_size_disabled) };
            umr_modify_entity_size_disabled as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let umr_indirect_mkey_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_indirect_mkey_disabled) };
            umr_indirect_mkey_disabled as u64
        });
        __bindgen_bitfield_unit.set(33usize, 5u8, {
            let log_min_stride_wqe_sz: u32 =
                unsafe { ::std::mem::transmute(log_min_stride_wqe_sz) };
            log_min_stride_wqe_sz as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let esw_mgr_vport_id_valid: u32 =
                unsafe { ::std::mem::transmute(esw_mgr_vport_id_valid) };
            esw_mgr_vport_id_valid as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let crypto_wrapped_import_method: u32 =
                unsafe { ::std::mem::transmute(crypto_wrapped_import_method) };
            crypto_wrapped_import_method as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn striding_rq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_striding_rq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn striding_rq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_striding_rq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_stride_num_range(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_stride_num_range(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_stride_num_range_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ext_stride_num_range_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_compression_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_reg_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(5usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_set_reg_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(5usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                5usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_set_reg_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                5usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nic_flow_table(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nic_flow_table(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nic_flow_table_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nic_flow_table_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ip_ecn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ip_ecn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ip_ecn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ip_ecn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ipv6_traffic_class(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ipv6_traffic_class(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ipv6_traffic_class_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ipv6_traffic_class_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_9(
        striding_rq: u32,
        ext_stride_num_range: u32,
        cqe_compression_128: u32,
        multi_pkt_send_wqe: u32,
        enhanced_multi_pkt_send_wqe: u32,
        set_reg_c: u32,
        nic_flow_table: u32,
        modify_outer_ip_ecn: u32,
        modify_outer_ipv6_traffic_class: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let striding_rq: u32 = unsafe { ::std::mem::transmute(striding_rq) };
            striding_rq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ext_stride_num_range: u32 = unsafe { ::std::mem::transmute(ext_stride_num_range) };
            ext_stride_num_range as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cqe_compression_128: u32 = unsafe { ::std::mem::transmute(cqe_compression_128) };
            cqe_compression_128 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let multi_pkt_send_wqe: u32 = unsafe { ::std::mem::transmute(multi_pkt_send_wqe) };
            multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enhanced_multi_pkt_send_wqe: u32 =
                unsafe { ::std::mem::transmute(enhanced_multi_pkt_send_wqe) };
            enhanced_multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(5usize, 16u8, {
            let set_reg_c: u32 = unsafe { ::std::mem::transmute(set_reg_c) };
            set_reg_c as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let nic_flow_table: u32 = unsafe { ::std::mem::transmute(nic_flow_table) };
            nic_flow_table as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let modify_outer_ip_ecn: u32 = unsafe { ::std::mem::transmute(modify_outer_ip_ecn) };
            modify_outer_ip_ecn as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let modify_outer_ipv6_traffic_class: u32 =
                unsafe { ::std::mem::transmute(modify_outer_ipv6_traffic_class) };
            modify_outer_ipv6_traffic_class as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_counter_bulk_log_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_bulk_log_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alloc_flow_counter_pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alloc_flow_counter_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alloc_flow_counter_pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_alloc_flow_counter_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_access_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_access_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_access_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_access_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_access_aso_opc_mod(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(13usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_access_aso_opc_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_access_aso_opc_mod_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                13usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_access_aso_opc_mod_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                13usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_vhca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_vhca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_vhca_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_vhca_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_based_flow_table_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_based_flow_table_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_based_flow_table_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_based_flow_table_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fdb_unified_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_unified_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_unified_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_unified_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jump_fdb_rx_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jump_fdb_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jump_fdb_rx_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_jump_fdb_rx_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_10(
        flow_counter_bulk_log_max_alloc: u32,
        flow_counter_bulk_log_granularity: u32,
        alloc_flow_counter_pd: u32,
        flow_counter_access_aso: u32,
        query_match_sample_info: u32,
        flow_access_aso_opc_mod: u32,
        cross_vhca: u32,
        lag_rx_port_affinity: u32,
        wqe_based_flow_table_sup: u32,
        fdb_unified_en: u32,
        jump_fdb_rx_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let flow_counter_bulk_log_max_alloc: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_max_alloc) };
            flow_counter_bulk_log_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let flow_counter_bulk_log_granularity: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_granularity) };
            flow_counter_bulk_log_granularity as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let alloc_flow_counter_pd: u32 =
                unsafe { ::std::mem::transmute(alloc_flow_counter_pd) };
            alloc_flow_counter_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let flow_counter_access_aso: u32 =
                unsafe { ::std::mem::transmute(flow_counter_access_aso) };
            flow_counter_access_aso as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let query_match_sample_info: u32 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let flow_access_aso_opc_mod: u32 =
                unsafe { ::std::mem::transmute(flow_access_aso_opc_mod) };
            flow_access_aso_opc_mod as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let cross_vhca: u32 = unsafe { ::std::mem::transmute(cross_vhca) };
            cross_vhca as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let lag_rx_port_affinity: u32 = unsafe { ::std::mem::transmute(lag_rx_port_affinity) };
            lag_rx_port_affinity as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wqe_based_flow_table_sup: u32 =
                unsafe { ::std::mem::transmute(wqe_based_flow_table_sup) };
            wqe_based_flow_table_sup as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fdb_unified_en: u32 = unsafe { ::std::mem::transmute(fdb_unified_en) };
            fdb_unified_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let jump_fdb_rx_en: u32 = unsafe { ::std::mem::transmute(jump_fdb_rx_en) };
            jump_fdb_rx_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_conn_track_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_11.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_conn_track_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_11.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_conn_track_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_11),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_conn_track_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_11),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_11(log_max_conn_track_offload: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_max_conn_track_offload: u32 =
                unsafe { ::std::mem::transmute(log_max_conn_track_offload) };
            log_max_conn_track_offload as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_devx_lag_context {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl mlx5_devx_lag_context {
    #[inline]
    pub fn fdb_selection_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_selection_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_selection_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_selection_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn port_select_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_port_select_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn port_select_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_port_select_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_lag_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_remap_affinity_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_remap_affinity_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_remap_affinity_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_remap_affinity_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_remap_affinity_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_remap_affinity_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_remap_affinity_2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_remap_affinity_2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fdb_selection_mode: u32,
        port_select_mode: u32,
        lag_state: u32,
        tx_remap_affinity_1: u32,
        tx_remap_affinity_2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fdb_selection_mode: u32 = unsafe { ::std::mem::transmute(fdb_selection_mode) };
            fdb_selection_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let port_select_mode: u32 = unsafe { ::std::mem::transmute(port_select_mode) };
            port_select_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let lag_state: u32 = unsafe { ::std::mem::transmute(lag_state) };
            lag_state as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let tx_remap_affinity_1: u32 = unsafe { ::std::mem::transmute(tx_remap_affinity_1) };
            tx_remap_affinity_1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let tx_remap_affinity_2: u32 = unsafe { ::std::mem::transmute(tx_remap_affinity_2) };
            tx_remap_affinity_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_wq_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 15usize]>,
    pub dbr_addr: u64,
    pub hw_counter: u32,
    pub sw_counter: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub dbr_umem_id: u32,
    pub wq_umem_id: u32,
    pub wq_umem_offset: u64,
}
impl mlx5_devx_wq_attr {
    #[inline]
    pub fn wq_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_wq_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wq_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wq_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wq_signature(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wq_signature(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wq_signature_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wq_signature_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn end_padding_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_end_padding_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn end_padding_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_end_padding_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cd_slave(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_slave(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cd_slave_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cd_slave_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hds_skip_first_sge(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hds_skip_first_sge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hds_skip_first_sge_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hds_skip_first_sge_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log2_hds_buf_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_log2_hds_buf_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log2_hds_buf_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log2_hds_buf_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn page_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_page_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_page_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lwm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uar_page(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_uar_page(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uar_page_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uar_page_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wq_type: u32,
        wq_signature: u32,
        end_padding_mode: u32,
        cd_slave: u32,
        hds_skip_first_sge: u32,
        log2_hds_buf_size: u32,
        page_offset: u32,
        lwm: u32,
        pd: u32,
        uar_page: u32,
    ) -> __BindgenBitfieldUnit<[u8; 15usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 15usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let wq_type: u32 = unsafe { ::std::mem::transmute(wq_type) };
            wq_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wq_signature: u32 = unsafe { ::std::mem::transmute(wq_signature) };
            wq_signature as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let end_padding_mode: u32 = unsafe { ::std::mem::transmute(end_padding_mode) };
            end_padding_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cd_slave: u32 = unsafe { ::std::mem::transmute(cd_slave) };
            cd_slave as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hds_skip_first_sge: u32 = unsafe { ::std::mem::transmute(hds_skip_first_sge) };
            hds_skip_first_sge as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let log2_hds_buf_size: u32 = unsafe { ::std::mem::transmute(log2_hds_buf_size) };
            log2_hds_buf_size as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let page_offset: u32 = unsafe { ::std::mem::transmute(page_offset) };
            page_offset as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let lwm: u32 = unsafe { ::std::mem::transmute(lwm) };
            lwm as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let pd: u32 = unsafe { ::std::mem::transmute(pd) };
            pd as u64
        });
        __bindgen_bitfield_unit.set(96usize, 24u8, {
            let uar_page: u32 = unsafe { ::std::mem::transmute(uar_page) };
            uar_page as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_wq_stride(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log_wq_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_wq_stride_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_wq_stride_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_wq_pg_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_wq_pg_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_wq_pg_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_wq_pg_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_wq_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(9usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_wq_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_wq_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                9usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_wq_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                9usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dbr_umem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dbr_umem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dbr_umem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dbr_umem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wq_umem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wq_umem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wq_umem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wq_umem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_hairpin_num_packets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_hairpin_num_packets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_hairpin_num_packets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_hairpin_num_packets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_hairpin_data_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(21usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_hairpin_data_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(21usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_hairpin_data_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                21usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_hairpin_data_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                21usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn single_wqe_log_num_of_strides(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_single_wqe_log_num_of_strides(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn single_wqe_log_num_of_strides_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                26usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_single_wqe_log_num_of_strides_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                26usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn two_byte_shift_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_two_byte_shift_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn two_byte_shift_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_two_byte_shift_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn single_stride_log_num_of_bytes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(32usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_single_stride_log_num_of_bytes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn single_stride_log_num_of_bytes_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                32usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_single_stride_log_num_of_bytes_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                32usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        log_wq_stride: u32,
        log_wq_pg_sz: u32,
        log_wq_sz: u32,
        dbr_umem_valid: u32,
        wq_umem_valid: u32,
        log_hairpin_num_packets: u32,
        log_hairpin_data_sz: u32,
        single_wqe_log_num_of_strides: u32,
        two_byte_shift_en: u32,
        single_stride_log_num_of_bytes: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let log_wq_stride: u32 = unsafe { ::std::mem::transmute(log_wq_stride) };
            log_wq_stride as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let log_wq_pg_sz: u32 = unsafe { ::std::mem::transmute(log_wq_pg_sz) };
            log_wq_pg_sz as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let log_wq_sz: u32 = unsafe { ::std::mem::transmute(log_wq_sz) };
            log_wq_sz as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dbr_umem_valid: u32 = unsafe { ::std::mem::transmute(dbr_umem_valid) };
            dbr_umem_valid as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let wq_umem_valid: u32 = unsafe { ::std::mem::transmute(wq_umem_valid) };
            wq_umem_valid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let log_hairpin_num_packets: u32 =
                unsafe { ::std::mem::transmute(log_hairpin_num_packets) };
            log_hairpin_num_packets as u64
        });
        __bindgen_bitfield_unit.set(21usize, 5u8, {
            let log_hairpin_data_sz: u32 = unsafe { ::std::mem::transmute(log_hairpin_data_sz) };
            log_hairpin_data_sz as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let single_wqe_log_num_of_strides: u32 =
                unsafe { ::std::mem::transmute(single_wqe_log_num_of_strides) };
            single_wqe_log_num_of_strides as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let two_byte_shift_en: u32 = unsafe { ::std::mem::transmute(two_byte_shift_en) };
            two_byte_shift_en as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let single_stride_log_num_of_bytes: u32 =
                unsafe { ::std::mem::transmute(single_stride_log_num_of_bytes) };
            single_stride_log_num_of_bytes as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_create_rq_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 15usize]>,
    pub wq_attr: mlx5_devx_wq_attr,
}
impl mlx5_devx_create_rq_attr {
    #[inline]
    pub fn rlky(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rlky(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rlky_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rlky_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delay_drop_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delay_drop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delay_drop_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delay_drop_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scatter_fcs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vsd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vsd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vsd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vsd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_rq_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mem_rq_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_rq_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_rq_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flush_in_error_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_in_error_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flush_in_error_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flush_in_error_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_data_buffer_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_data_buffer_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_data_buffer_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_data_buffer_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_user_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_user_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cqn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn counter_set_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_counter_set_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn counter_set_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_counter_set_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmpn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_rmpn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmpn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmpn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rlky: u32,
        delay_drop_en: u32,
        scatter_fcs: u32,
        vsd: u32,
        mem_rq_type: u32,
        state: u32,
        flush_in_error_en: u32,
        hairpin: u32,
        hairpin_data_buffer_type: u32,
        ts_format: u32,
        user_index: u32,
        cqn: u32,
        counter_set_id: u32,
        rmpn: u32,
    ) -> __BindgenBitfieldUnit<[u8; 15usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 15usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rlky: u32 = unsafe { ::std::mem::transmute(rlky) };
            rlky as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let delay_drop_en: u32 = unsafe { ::std::mem::transmute(delay_drop_en) };
            delay_drop_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let scatter_fcs: u32 = unsafe { ::std::mem::transmute(scatter_fcs) };
            scatter_fcs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let vsd: u32 = unsafe { ::std::mem::transmute(vsd) };
            vsd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let mem_rq_type: u32 = unsafe { ::std::mem::transmute(mem_rq_type) };
            mem_rq_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let flush_in_error_en: u32 = unsafe { ::std::mem::transmute(flush_in_error_en) };
            flush_in_error_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hairpin: u32 = unsafe { ::std::mem::transmute(hairpin) };
            hairpin as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let hairpin_data_buffer_type: u32 =
                unsafe { ::std::mem::transmute(hairpin_data_buffer_type) };
            hairpin_data_buffer_type as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ts_format: u32 = unsafe { ::std::mem::transmute(ts_format) };
            ts_format as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let user_index: u32 = unsafe { ::std::mem::transmute(user_index) };
            user_index as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let cqn: u32 = unsafe { ::std::mem::transmute(cqn) };
            cqn as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let counter_set_id: u32 = unsafe { ::std::mem::transmute(counter_set_id) };
            counter_set_id as u64
        });
        __bindgen_bitfield_unit.set(96usize, 24u8, {
            let rmpn: u32 = unsafe { ::std::mem::transmute(rmpn) };
            rmpn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_modify_rq_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
    pub modify_bitmask: u64,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl mlx5_devx_modify_rq_attr {
    #[inline]
    pub fn rqn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_rqn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rqn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rqn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rq_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scatter_fcs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vsd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vsd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vsd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vsd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn counter_set_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_counter_set_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn counter_set_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_counter_set_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_peer_sq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_peer_sq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_peer_sq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_peer_sq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_peer_vhca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_peer_vhca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_peer_vhca_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 14usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_peer_vhca_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 14usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rqn: u32,
        rq_state: u32,
        state: u32,
        scatter_fcs: u32,
        vsd: u32,
        counter_set_id: u32,
        hairpin_peer_sq: u32,
        hairpin_peer_vhca: u32,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let rqn: u32 = unsafe { ::std::mem::transmute(rqn) };
            rqn as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let rq_state: u32 = unsafe { ::std::mem::transmute(rq_state) };
            rq_state as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let scatter_fcs: u32 = unsafe { ::std::mem::transmute(scatter_fcs) };
            scatter_fcs as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let vsd: u32 = unsafe { ::std::mem::transmute(vsd) };
            vsd as u64
        });
        __bindgen_bitfield_unit.set(34usize, 8u8, {
            let counter_set_id: u32 = unsafe { ::std::mem::transmute(counter_set_id) };
            counter_set_id as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let hairpin_peer_sq: u32 = unsafe { ::std::mem::transmute(hairpin_peer_sq) };
            hairpin_peer_sq as u64
        });
        __bindgen_bitfield_unit.set(96usize, 16u8, {
            let hairpin_peer_vhca: u32 = unsafe { ::std::mem::transmute(hairpin_peer_vhca) };
            hairpin_peer_vhca as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn lwm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lwm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(lwm: u32) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let lwm: u32 = unsafe { ::std::mem::transmute(lwm) };
            lwm as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_create_rmp_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub rsvd8: [u32; 10usize],
    pub wq_attr: mlx5_devx_wq_attr,
}
impl mlx5_devx_create_rmp_attr {
    #[inline]
    pub fn rsvd0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn basic_cyclic_rcv_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_basic_cyclic_rcv_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basic_cyclic_rcv_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_basic_cyclic_rcv_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsvd0: u32,
        state: u32,
        rsvd1: u32,
        basic_cyclic_rcv_wqe: u32,
        rsvd4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rsvd0: u32 = unsafe { ::std::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let rsvd1: u32 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let basic_cyclic_rcv_wqe: u32 = unsafe { ::std::mem::transmute(basic_cyclic_rcv_wqe) };
            basic_cyclic_rcv_wqe as u64
        });
        __bindgen_bitfield_unit.set(33usize, 31u8, {
            let rsvd4: u32 = unsafe { ::std::mem::transmute(rsvd4) };
            rsvd4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rx_hash_field_select {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_rx_hash_field_select {
    #[inline]
    pub fn l3_prot_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3_prot_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_prot_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_prot_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_prot_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l4_prot_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_prot_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l4_prot_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn selected_fields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_selected_fields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selected_fields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_selected_fields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l3_prot_type: u32,
        l4_prot_type: u32,
        selected_fields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let l3_prot_type: u32 = unsafe { ::std::mem::transmute(l3_prot_type) };
            l3_prot_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let l4_prot_type: u32 = unsafe { ::std::mem::transmute(l4_prot_type) };
            l4_prot_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let selected_fields: u32 = unsafe { ::std::mem::transmute(selected_fields) };
            selected_fields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_tir_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 15usize]>,
    pub rx_hash_toeplitz_key: [u8; 40usize],
    pub rx_hash_field_selector_outer: mlx5_rx_hash_field_select,
    pub rx_hash_field_selector_inner: mlx5_rx_hash_field_select,
}
impl mlx5_devx_tir_attr {
    #[inline]
    pub fn disp_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_disp_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disp_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disp_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_timeout_period_usecs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lro_timeout_period_usecs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_timeout_period_usecs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_timeout_period_usecs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_enable_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_lro_enable_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_enable_mask_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_enable_mask_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_max_msg_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lro_max_msg_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_max_msg_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_max_msg_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inline_rqn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_inline_rqn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inline_rqn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inline_rqn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_hash_symmetric(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hash_symmetric(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_hash_symmetric_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_hash_symmetric_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunneled_offload_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunneled_offload_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunneled_offload_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunneled_offload_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn indirect_table(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_indirect_table(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn indirect_table_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_indirect_table_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_hash_fn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hash_fn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_hash_fn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_hash_fn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn self_lb_block(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(92usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_self_lb_block(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(92usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn self_lb_block_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                92usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_self_lb_block_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                92usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_domain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_domain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_domain_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 15usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_domain_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 15usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disp_type: u32,
        lro_timeout_period_usecs: u32,
        lro_enable_mask: u32,
        lro_max_msg_sz: u32,
        inline_rqn: u32,
        rx_hash_symmetric: u32,
        tunneled_offload_en: u32,
        indirect_table: u32,
        rx_hash_fn: u32,
        self_lb_block: u32,
        transport_domain: u32,
    ) -> __BindgenBitfieldUnit<[u8; 15usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 15usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let disp_type: u32 = unsafe { ::std::mem::transmute(disp_type) };
            disp_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let lro_timeout_period_usecs: u32 =
                unsafe { ::std::mem::transmute(lro_timeout_period_usecs) };
            lro_timeout_period_usecs as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let lro_enable_mask: u32 = unsafe { ::std::mem::transmute(lro_enable_mask) };
            lro_enable_mask as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let lro_max_msg_sz: u32 = unsafe { ::std::mem::transmute(lro_max_msg_sz) };
            lro_max_msg_sz as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let inline_rqn: u32 = unsafe { ::std::mem::transmute(inline_rqn) };
            inline_rqn as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let rx_hash_symmetric: u32 = unsafe { ::std::mem::transmute(rx_hash_symmetric) };
            rx_hash_symmetric as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let tunneled_offload_en: u32 = unsafe { ::std::mem::transmute(tunneled_offload_en) };
            tunneled_offload_en as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let indirect_table: u32 = unsafe { ::std::mem::transmute(indirect_table) };
            indirect_table as u64
        });
        __bindgen_bitfield_unit.set(88usize, 4u8, {
            let rx_hash_fn: u32 = unsafe { ::std::mem::transmute(rx_hash_fn) };
            rx_hash_fn as u64
        });
        __bindgen_bitfield_unit.set(92usize, 2u8, {
            let self_lb_block: u32 = unsafe { ::std::mem::transmute(self_lb_block) };
            self_lb_block as u64
        });
        __bindgen_bitfield_unit.set(96usize, 24u8, {
            let transport_domain: u32 = unsafe { ::std::mem::transmute(transport_domain) };
            transport_domain as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_modify_tir_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub modify_bitmask: u64,
    pub tir: mlx5_devx_tir_attr,
}
impl mlx5_devx_modify_tir_attr {
    #[inline]
    pub fn tirn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_tirn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tirn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tirn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(tirn: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let tirn: u32 = unsafe { ::std::mem::transmute(tirn) };
            tirn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct mlx5_devx_rqt_attr {
    pub rq_type: u8,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub rq_list: __IncompleteArrayField<u32>,
}
impl mlx5_devx_rqt_attr {
    #[inline]
    pub fn rqt_max_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rqt_max_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rqt_max_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rqt_max_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rqt_actual_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rqt_actual_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rqt_actual_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rqt_actual_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rqt_max_size: u32,
        rqt_actual_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rqt_max_size: u32 = unsafe { ::std::mem::transmute(rqt_max_size) };
            rqt_max_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let rqt_actual_size: u32 = unsafe { ::std::mem::transmute(rqt_actual_size) };
            rqt_actual_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_tis_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl mlx5_devx_tis_attr {
    #[inline]
    pub fn strict_lag_tx_port_affinity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strict_lag_tx_port_affinity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strict_lag_tx_port_affinity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strict_lag_tx_port_affinity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tls_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tls_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tls_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tls_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_tx_port_affinity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_lag_tx_port_affinity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_tx_port_affinity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_tx_port_affinity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn prio(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prio_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_prio_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_domain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_domain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_domain_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_domain_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strict_lag_tx_port_affinity: u32,
        tls_en: u32,
        lag_tx_port_affinity: u32,
        prio: u32,
        transport_domain: u32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let strict_lag_tx_port_affinity: u32 =
                unsafe { ::std::mem::transmute(strict_lag_tx_port_affinity) };
            strict_lag_tx_port_affinity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tls_en: u32 = unsafe { ::std::mem::transmute(tls_en) };
            tls_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let lag_tx_port_affinity: u32 = unsafe { ::std::mem::transmute(lag_tx_port_affinity) };
            lag_tx_port_affinity as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let prio: u32 = unsafe { ::std::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let transport_domain: u32 = unsafe { ::std::mem::transmute(transport_domain) };
            transport_domain as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_create_sq_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 19usize]>,
    pub wq_attr: mlx5_devx_wq_attr,
}
impl mlx5_devx_create_sq_attr {
    #[inline]
    pub fn rlky(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rlky(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rlky_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rlky_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cd_master(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_master(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cd_master_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cd_master_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flush_in_error_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_in_error_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flush_in_error_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flush_in_error_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn min_wqe_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_min_wqe_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn min_wqe_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_min_wqe_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_umr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg_umr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_umr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reg_umr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_wire(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_wire(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_wire_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_wire_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn static_sq_wq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_static_sq_wq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn static_sq_wq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_static_sq_wq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_wq_buffer_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_wq_buffer_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_wq_buffer_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_wq_buffer_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_user_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_user_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cqn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn packet_pacing_rate_limit_index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_packet_pacing_rate_limit_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_pacing_rate_limit_index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_packet_pacing_rate_limit_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tis_lst_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tis_lst_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tis_lst_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                112usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tis_lst_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                112usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tis_num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_tis_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tis_num_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                128usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tis_num_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                128usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rlky: u32,
        cd_master: u32,
        fre: u32,
        flush_in_error_en: u32,
        allow_multi_pkt_send_wqe: u32,
        min_wqe_inline_mode: u32,
        state: u32,
        reg_umr: u32,
        allow_swp: u32,
        hairpin: u32,
        non_wire: u32,
        static_sq_wq: u32,
        ts_format: u32,
        hairpin_wq_buffer_type: u32,
        user_index: u32,
        cqn: u32,
        packet_pacing_rate_limit_index: u32,
        tis_lst_sz: u32,
        tis_num: u32,
    ) -> __BindgenBitfieldUnit<[u8; 19usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 19usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rlky: u32 = unsafe { ::std::mem::transmute(rlky) };
            rlky as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cd_master: u32 = unsafe { ::std::mem::transmute(cd_master) };
            cd_master as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fre: u32 = unsafe { ::std::mem::transmute(fre) };
            fre as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flush_in_error_en: u32 = unsafe { ::std::mem::transmute(flush_in_error_en) };
            flush_in_error_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let allow_multi_pkt_send_wqe: u32 =
                unsafe { ::std::mem::transmute(allow_multi_pkt_send_wqe) };
            allow_multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let min_wqe_inline_mode: u32 = unsafe { ::std::mem::transmute(min_wqe_inline_mode) };
            min_wqe_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reg_umr: u32 = unsafe { ::std::mem::transmute(reg_umr) };
            reg_umr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let allow_swp: u32 = unsafe { ::std::mem::transmute(allow_swp) };
            allow_swp as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hairpin: u32 = unsafe { ::std::mem::transmute(hairpin) };
            hairpin as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let non_wire: u32 = unsafe { ::std::mem::transmute(non_wire) };
            non_wire as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let static_sq_wq: u32 = unsafe { ::std::mem::transmute(static_sq_wq) };
            static_sq_wq as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ts_format: u32 = unsafe { ::std::mem::transmute(ts_format) };
            ts_format as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let hairpin_wq_buffer_type: u32 =
                unsafe { ::std::mem::transmute(hairpin_wq_buffer_type) };
            hairpin_wq_buffer_type as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let user_index: u32 = unsafe { ::std::mem::transmute(user_index) };
            user_index as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let cqn: u32 = unsafe { ::std::mem::transmute(cqn) };
            cqn as u64
        });
        __bindgen_bitfield_unit.set(96usize, 16u8, {
            let packet_pacing_rate_limit_index: u32 =
                unsafe { ::std::mem::transmute(packet_pacing_rate_limit_index) };
            packet_pacing_rate_limit_index as u64
        });
        __bindgen_bitfield_unit.set(112usize, 16u8, {
            let tis_lst_sz: u32 = unsafe { ::std::mem::transmute(tis_lst_sz) };
            tis_lst_sz as u64
        });
        __bindgen_bitfield_unit.set(128usize, 24u8, {
            let tis_num: u32 = unsafe { ::std::mem::transmute(tis_num) };
            tis_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_modify_sq_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
impl mlx5_devx_modify_sq_attr {
    #[inline]
    pub fn sq_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sq_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sq_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sq_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_peer_rq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_peer_rq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_peer_rq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_peer_rq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_peer_vhca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_peer_vhca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_peer_vhca_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_peer_vhca_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sq_state: u32,
        state: u32,
        hairpin_peer_rq: u32,
        hairpin_peer_vhca: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sq_state: u32 = unsafe { ::std::mem::transmute(sq_state) };
            sq_state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let hairpin_peer_rq: u32 = unsafe { ::std::mem::transmute(hairpin_peer_rq) };
            hairpin_peer_rq as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let hairpin_peer_vhca: u32 = unsafe { ::std::mem::transmute(hairpin_peer_vhca) };
            hairpin_peer_vhca as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_cq_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub uar_page_id: u32,
    pub q_umem_id: u32,
    pub q_umem_offset: u64,
    pub db_umem_id: u32,
    pub db_umem_offset: u64,
    pub eqn: u32,
    pub db_addr: u64,
}
impl mlx5_devx_cq_attr {
    #[inline]
    pub fn q_umem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_q_umem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn q_umem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_q_umem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn db_umem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_db_umem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn db_umem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_db_umem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_first_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_first_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_first_only_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_first_only_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overrun_ignore(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overrun_ignore(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overrun_ignore_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overrun_ignore_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_res_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_res_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_res_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_res_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_res_format_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_res_format_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_res_format_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_res_format_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_layout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_layout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_layout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_layout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_cq_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_cq_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_cq_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_cq_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_page_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_page_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_page_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_page_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        q_umem_valid: u32,
        db_umem_valid: u32,
        use_first_only: u32,
        overrun_ignore: u32,
        cqe_comp_en: u32,
        mini_cqe_res_format: u32,
        mini_cqe_res_format_ext: u32,
        cqe_comp_layout: u32,
        log_cq_size: u32,
        log_page_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let q_umem_valid: u32 = unsafe { ::std::mem::transmute(q_umem_valid) };
            q_umem_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let db_umem_valid: u32 = unsafe { ::std::mem::transmute(db_umem_valid) };
            db_umem_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let use_first_only: u32 = unsafe { ::std::mem::transmute(use_first_only) };
            use_first_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let overrun_ignore: u32 = unsafe { ::std::mem::transmute(overrun_ignore) };
            overrun_ignore as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cqe_comp_en: u32 = unsafe { ::std::mem::transmute(cqe_comp_en) };
            cqe_comp_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let mini_cqe_res_format: u32 = unsafe { ::std::mem::transmute(mini_cqe_res_format) };
            mini_cqe_res_format as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let mini_cqe_res_format_ext: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_res_format_ext) };
            mini_cqe_res_format_ext as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let cqe_comp_layout: u32 = unsafe { ::std::mem::transmute(cqe_comp_layout) };
            cqe_comp_layout as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let log_cq_size: u32 = unsafe { ::std::mem::transmute(log_cq_size) };
            log_cq_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let log_page_size: u32 = unsafe { ::std::mem::transmute(log_page_size) };
            log_page_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_virtq_attr {
    pub hw_available_index: u16,
    pub hw_used_index: u16,
    pub q_size: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 11usize]>,
    pub dirty_bitmap_mkey: u32,
    pub dirty_bitmap_size: u32,
    pub mkey: u32,
    pub qp_id: u32,
    pub queue_index: u32,
    pub tis_id: u32,
    pub counters_obj_id: u32,
    pub dirty_bitmap_addr: u64,
    pub mod_fields_bitmap: u64,
    pub desc_addr: u64,
    pub used_addr: u64,
    pub available_addr: u64,
    pub umems: [mlx5_devx_virtq_attr__bindgen_ty_1; 3usize],
    pub error_type: u8,
    pub q_type: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_virtq_attr__bindgen_ty_1 {
    pub id: u32,
    pub size: u32,
    pub offset: u64,
}
impl mlx5_devx_virtq_attr {
    #[inline]
    pub fn pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_version_1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_version_1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_version_1_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_version_1_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv6_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn event_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_event_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_latency_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hw_latency_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_latency_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_latency_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_max_latency_us(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_hw_max_latency_us(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_max_latency_us_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_max_latency_us_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_max_pending_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hw_max_pending_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_max_pending_comp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_max_pending_comp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dirty_bitmap_dump_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dirty_bitmap_dump_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dirty_bitmap_dump_enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                80usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dirty_bitmap_dump_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                80usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pd: u32,
        virtio_version_1_0: u32,
        tso_ipv4: u32,
        tso_ipv6: u32,
        tx_csum: u32,
        rx_csum: u32,
        event_mode: u32,
        state: u32,
        hw_latency_mode: u32,
        hw_max_latency_us: u32,
        hw_max_pending_comp: u32,
        dirty_bitmap_dump_enable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 11usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 11usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pd: u32 = unsafe { ::std::mem::transmute(pd) };
            pd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let virtio_version_1_0: u32 = unsafe { ::std::mem::transmute(virtio_version_1_0) };
            virtio_version_1_0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tso_ipv4: u32 = unsafe { ::std::mem::transmute(tso_ipv4) };
            tso_ipv4 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let tso_ipv6: u32 = unsafe { ::std::mem::transmute(tso_ipv6) };
            tso_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let tx_csum: u32 = unsafe { ::std::mem::transmute(tx_csum) };
            tx_csum as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rx_csum: u32 = unsafe { ::std::mem::transmute(rx_csum) };
            rx_csum as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let event_mode: u32 = unsafe { ::std::mem::transmute(event_mode) };
            event_mode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(36usize, 2u8, {
            let hw_latency_mode: u32 = unsafe { ::std::mem::transmute(hw_latency_mode) };
            hw_latency_mode as u64
        });
        __bindgen_bitfield_unit.set(38usize, 12u8, {
            let hw_max_latency_us: u32 = unsafe { ::std::mem::transmute(hw_max_latency_us) };
            hw_max_latency_us as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let hw_max_pending_comp: u32 = unsafe { ::std::mem::transmute(hw_max_pending_comp) };
            hw_max_pending_comp as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let dirty_bitmap_dump_enable: u32 =
                unsafe { ::std::mem::transmute(dirty_bitmap_dump_enable) };
            dirty_bitmap_dump_enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_qp_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 19usize]>,
    pub dbr_umem_id: u32,
    pub dbr_address: u64,
    pub wq_umem_id: u32,
    pub wq_umem_offset: u64,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl mlx5_devx_qp_attr {
    #[inline]
    pub fn pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uar_index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_uar_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uar_index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uar_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cqn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_page_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_page_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_page_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_page_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_of_receive_wqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_num_of_receive_wqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_of_receive_wqes_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                17u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_of_receive_wqes_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_rq_stride(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(113usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_log_rq_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(113usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_rq_stride_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                113usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_rq_stride_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                113usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_of_send_wqbbs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_num_of_send_wqbbs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_of_send_wqbbs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                128usize,
                17u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_of_send_wqbbs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                128usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(145usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(145usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                145usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                145usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dbr_umem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(147usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dbr_umem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(147usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dbr_umem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 19usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                147usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dbr_umem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 19usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                147usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pd: u32,
        uar_index: u32,
        cqn: u32,
        log_page_size: u32,
        num_of_receive_wqes: u32,
        log_rq_stride: u32,
        num_of_send_wqbbs: u32,
        ts_format: u32,
        dbr_umem_valid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 19usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 19usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pd: u32 = unsafe { ::std::mem::transmute(pd) };
            pd as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let uar_index: u32 = unsafe { ::std::mem::transmute(uar_index) };
            uar_index as u64
        });
        __bindgen_bitfield_unit.set(64usize, 24u8, {
            let cqn: u32 = unsafe { ::std::mem::transmute(cqn) };
            cqn as u64
        });
        __bindgen_bitfield_unit.set(88usize, 5u8, {
            let log_page_size: u32 = unsafe { ::std::mem::transmute(log_page_size) };
            log_page_size as u64
        });
        __bindgen_bitfield_unit.set(96usize, 17u8, {
            let num_of_receive_wqes: u32 = unsafe { ::std::mem::transmute(num_of_receive_wqes) };
            num_of_receive_wqes as u64
        });
        __bindgen_bitfield_unit.set(113usize, 3u8, {
            let log_rq_stride: u32 = unsafe { ::std::mem::transmute(log_rq_stride) };
            log_rq_stride as u64
        });
        __bindgen_bitfield_unit.set(128usize, 17u8, {
            let num_of_send_wqbbs: u32 = unsafe { ::std::mem::transmute(num_of_send_wqbbs) };
            num_of_send_wqbbs as u64
        });
        __bindgen_bitfield_unit.set(145usize, 2u8, {
            let ts_format: u32 = unsafe { ::std::mem::transmute(ts_format) };
            ts_format as u64
        });
        __bindgen_bitfield_unit.set(147usize, 1u8, {
            let dbr_umem_valid: u32 = unsafe { ::std::mem::transmute(dbr_umem_valid) };
            dbr_umem_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn user_index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_user_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_user_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cd_master(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_master(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cd_master_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cd_master_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cd_slave_send(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_slave_send(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cd_slave_send_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cd_slave_send_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cd_slave_recv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_slave_recv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cd_slave_recv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cd_slave_recv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        user_index: u32,
        mmo: u32,
        cd_master: u32,
        cd_slave_send: u32,
        cd_slave_recv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let user_index: u32 = unsafe { ::std::mem::transmute(user_index) };
            user_index as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let mmo: u32 = unsafe { ::std::mem::transmute(mmo) };
            mmo as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cd_master: u32 = unsafe { ::std::mem::transmute(cd_master) };
            cd_master as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let cd_slave_send: u32 = unsafe { ::std::mem::transmute(cd_slave_send) };
            cd_slave_send as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let cd_slave_recv: u32 = unsafe { ::std::mem::transmute(cd_slave_recv) };
            cd_slave_recv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_virtio_q_couners_attr {
    pub received_desc: u64,
    pub completed_desc: u64,
    pub error_cqes: u32,
    pub bad_desc_errors: u32,
    pub exceed_max_chain: u32,
    pub invalid_buffer: u32,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_info_query_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_devx_match_sample_info_query_attr {
    #[inline]
    pub fn modify_field_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_modify_field_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_field_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_field_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_data_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_data_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modify_field_id: u32,
        sample_dw_data: u32,
        sample_dw_ok_bit: u32,
        sample_dw_ok_bit_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let modify_field_id: u32 = unsafe { ::std::mem::transmute(modify_field_id) };
            modify_field_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let sample_dw_data: u32 = unsafe { ::std::mem::transmute(sample_dw_data) };
            sample_dw_data as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let sample_dw_ok_bit: u32 = unsafe { ::std::mem::transmute(sample_dw_ok_bit) };
            sample_dw_ok_bit as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let sample_dw_ok_bit_offset: u32 =
                unsafe { ::std::mem::transmute(sample_dw_ok_bit_offset) };
            sample_dw_ok_bit_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub flow_match_sample_field_offset_mask: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_match_sample_field_id: u32,
}
impl mlx5_devx_match_sample_attr {
    #[inline]
    pub fn flow_match_sample_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_offset_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_offset_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_offset_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_offset_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flow_match_sample_en: u32,
        flow_match_sample_field_offset: u32,
        flow_match_sample_offset_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flow_match_sample_en: u32 = unsafe { ::std::mem::transmute(flow_match_sample_en) };
            flow_match_sample_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let flow_match_sample_field_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset) };
            flow_match_sample_field_offset as u64
        });
        __bindgen_bitfield_unit.set(17usize, 4u8, {
            let flow_match_sample_offset_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_offset_mode) };
            flow_match_sample_offset_mode as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_match_sample_field_offset_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_base_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_base_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_base_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_base_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_tunnel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_tunnel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_tunnel_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_tunnel_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        flow_match_sample_field_offset_shift: u32,
        flow_match_sample_field_base_offset: u32,
        flow_match_sample_tunnel_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flow_match_sample_field_offset_shift: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset_shift) };
            flow_match_sample_field_offset_shift as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let flow_match_sample_field_base_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_base_offset) };
            flow_match_sample_field_base_offset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let flow_match_sample_tunnel_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_tunnel_mode) };
            flow_match_sample_tunnel_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_arc_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub parse_graph_node_handle: u32,
}
impl mlx5_devx_graph_arc_attr {
    #[inline]
    pub fn compare_condition_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_compare_condition_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compare_condition_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compare_condition_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn start_inner_tunnel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start_inner_tunnel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn start_inner_tunnel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_start_inner_tunnel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arc_parse_graph_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_arc_parse_graph_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arc_parse_graph_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arc_parse_graph_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare_condition_value: u32,
        start_inner_tunnel: u32,
        arc_parse_graph_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let compare_condition_value: u32 =
                unsafe { ::std::mem::transmute(compare_condition_value) };
            compare_condition_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let start_inner_tunnel: u32 = unsafe { ::std::mem::transmute(start_inner_tunnel) };
            start_inner_tunnel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let arc_parse_graph_node: u32 = unsafe { ::std::mem::transmute(arc_parse_graph_node) };
            arc_parse_graph_node as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_node_attr {
    pub modify_field_select: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub header_length_field_mask: u32,
    pub sample: [mlx5_devx_match_sample_attr; 8usize],
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub in_: [mlx5_devx_graph_arc_attr; 8usize],
    pub out: [mlx5_devx_graph_arc_attr; 8usize],
}
impl mlx5_devx_graph_node_attr {
    #[inline]
    pub fn header_length_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_base_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_base_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_base_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_base_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        header_length_mode: u32,
        header_length_base_value: u32,
        header_length_field_shift: u32,
        header_length_field_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let header_length_mode: u32 = unsafe { ::std::mem::transmute(header_length_mode) };
            header_length_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let header_length_base_value: u32 =
                unsafe { ::std::mem::transmute(header_length_base_value) };
            header_length_base_value as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let header_length_field_shift: u32 =
                unsafe { ::std::mem::transmute(header_length_field_shift) };
            header_length_field_shift as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let header_length_field_offset: u32 =
                unsafe { ::std::mem::transmute(header_length_field_offset) };
            header_length_field_offset as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn next_header_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn next_header_field_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        next_header_field_offset: u32,
        next_header_field_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let next_header_field_offset: u32 =
                unsafe { ::std::mem::transmute(next_header_field_offset) };
            next_header_field_offset as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let next_header_field_size: u32 =
                unsafe { ::std::mem::transmute(next_header_field_size) };
            next_header_field_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_dek_attr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub opaque: u64,
    pub key: [u8; 128usize],
}
impl mlx5_devx_dek_attr {
    #[inline]
    pub fn key_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_key_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_key_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_keytag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_keytag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_keytag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_keytag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn key_purpose(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_key_purpose(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_purpose_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_key_purpose_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        key_size: u32,
        has_keytag: u32,
        key_purpose: u32,
        pd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let key_size: u32 = unsafe { ::std::mem::transmute(key_size) };
            key_size as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_keytag: u32 = unsafe { ::std::mem::transmute(has_keytag) };
            has_keytag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let key_purpose: u32 = unsafe { ::std::mem::transmute(key_purpose) };
            key_purpose as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let pd: u32 = unsafe { ::std::mem::transmute(pd) };
            pd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_import_kek_attr {
    pub modify_field_select: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub key: [u8; 128usize],
}
impl mlx5_devx_import_kek_attr {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn key_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_key_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_key_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(state: u32, key_size: u32) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let key_size: u32 = unsafe { ::std::mem::transmute(key_size) };
            key_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_credential_attr {
    pub modify_field_select: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub credential: [u8; 48usize],
}
impl mlx5_devx_credential_attr {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn credential_role(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_credential_role(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn credential_role_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_credential_role_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(state: u32, credential_role: u32) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let credential_role: u32 = unsafe { ::std::mem::transmute(credential_role) };
            credential_role as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_crypto_login_attr {
    pub modify_field_select: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub credential: [u8; 48usize],
}
impl mlx5_devx_crypto_login_attr {
    #[inline]
    pub fn credential_pointer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_credential_pointer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn credential_pointer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_credential_pointer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn session_import_kek_ptr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_session_import_kek_ptr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn session_import_kek_ptr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_session_import_kek_ptr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        credential_pointer: u32,
        session_import_kek_ptr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let credential_pointer: u32 = unsafe { ::std::mem::transmute(credential_pointer) };
            credential_pointer as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let session_import_kek_ptr: u32 =
                unsafe { ::std::mem::transmute(session_import_kek_ptr) };
            session_import_kek_ptr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_devx_geneve_tlv_option_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_devx_geneve_tlv_option_attr {
    #[inline]
    pub fn option_class(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_option_class(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn option_class_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_option_class_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn option_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_option_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn option_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_option_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn option_data_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_option_data_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn option_data_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_option_data_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn option_class_ignore(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_option_class_ignore(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn option_class_ignore_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_option_class_ignore_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        option_class: u32,
        option_type: u32,
        option_data_len: u32,
        option_class_ignore: u32,
        offset_valid: u32,
        sample_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let option_class: u32 = unsafe { ::std::mem::transmute(option_class) };
            option_class as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let option_type: u32 = unsafe { ::std::mem::transmute(option_type) };
            option_type as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let option_data_len: u32 = unsafe { ::std::mem::transmute(option_data_len) };
            option_data_len as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let option_class_ignore: u32 = unsafe { ::std::mem::transmute(option_class_ignore) };
            option_class_ignore as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let offset_valid: u32 = unsafe { ::std::mem::transmute(offset_valid) };
            offset_valid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let sample_offset: u32 = unsafe { ::std::mem::transmute(sample_offset) };
            sample_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_flow_counter_alloc_general(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_counter_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_flow_counter_alloc(
        ctx: *mut ::std::os::raw::c_void,
        bulk_sz: u32,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_destroy(obj: *mut mlx5_devx_obj) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_flow_counter_query(
        dcs: *mut mlx5_devx_obj,
        clear: ::std::os::raw::c_int,
        n_counters: u32,
        pkts: *mut u64,
        bytes: *mut u64,
        mkey: u32,
        addr: *mut ::std::os::raw::c_void,
        cmd_comp: *mut ::std::os::raw::c_void,
        async_id: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_hca_attr(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_hca_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_mkey_create(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_mkey_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_get_out_command_status(
        out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_qp_query_tis_td(
        qp: *mut ::std::os::raw::c_void,
        tis_num: u32,
        tis_td: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_rq(
        ctx: *mut ::std::os::raw::c_void,
        rq_attr: *mut mlx5_devx_create_rq_attr,
        socket: ::std::os::raw::c_int,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_rq(
        rq: *mut mlx5_devx_obj,
        rq_attr: *mut mlx5_devx_modify_rq_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_rmp(
        ctx: *mut ::std::os::raw::c_void,
        rq_attr: *mut mlx5_devx_create_rmp_attr,
        socket: ::std::os::raw::c_int,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_tir(
        ctx: *mut ::std::os::raw::c_void,
        tir_attr: *mut mlx5_devx_tir_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_rqt(
        ctx: *mut ::std::os::raw::c_void,
        rqt_attr: *mut mlx5_devx_rqt_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_sq(
        ctx: *mut ::std::os::raw::c_void,
        sq_attr: *mut mlx5_devx_create_sq_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_sq(
        sq: *mut mlx5_devx_obj,
        sq_attr: *mut mlx5_devx_modify_sq_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_sq(
        sq: *mut mlx5_devx_obj,
        out: *mut ::std::os::raw::c_void,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_cq(
        cq: *mut mlx5_devx_obj,
        out: *mut ::std::os::raw::c_void,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_rq(
        rq: *mut mlx5_devx_obj,
        out: *mut ::std::os::raw::c_void,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_tis(
        ctx: *mut ::std::os::raw::c_void,
        tis_attr: *mut mlx5_devx_tis_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_td(ctx: *mut ::std::os::raw::c_void) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_flow_dump(
        fdb_domain: *mut ::std::os::raw::c_void,
        rx_domain: *mut ::std::os::raw::c_void,
        tx_domain: *mut ::std::os::raw::c_void,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_flow_single_dump(
        rule: *mut ::std::os::raw::c_void,
        file: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_cq(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_cq_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_virtq(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_virtq_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_virtq(
        virtq_obj: *mut mlx5_devx_obj,
        attr: *mut mlx5_devx_virtq_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_virtq(
        virtq_obj: *mut mlx5_devx_obj,
        attr: *mut mlx5_devx_virtq_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_qp(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_qp_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_qp_state(
        qp: *mut mlx5_devx_obj,
        qp_st_mod_op: u32,
        remote_qp_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_rqt(
        rqt: *mut mlx5_devx_obj,
        rqt_attr: *mut mlx5_devx_rqt_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_modify_tir(
        tir: *mut mlx5_devx_obj,
        tir_attr: *mut mlx5_devx_modify_tir_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_match_sample_info_query(
        ctx: *mut ::std::os::raw::c_void,
        sample_field_id: u32,
        attr: *mut mlx5_devx_match_sample_info_query_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_parse_samples(
        flex_obj: *mut mlx5_devx_obj,
        ids: *mut u32,
        num: u32,
        anchor: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_flex_parser(
        ctx: *mut ::std::os::raw::c_void,
        data: *mut mlx5_devx_graph_node_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_register_read(
        ctx: *mut ::std::os::raw::c_void,
        reg_id: u16,
        arg: u32,
        data: *mut u32,
        dw_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_register_write(
        ctx: *mut ::std::os::raw::c_void,
        reg_id: u16,
        arg: u32,
        data: *mut u32,
        dw_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_geneve_tlv_option(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_geneve_tlv_option_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_geneve_tlv_option(
        ctx: *mut ::std::os::raw::c_void,
        geneve_tlv_opt_obj: *mut mlx5_devx_obj,
        attr: *mut mlx5_devx_match_sample_info_query_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create virtio queue counters object DevX API.\n\n @param[in] ctx\n   Device context.\n\n @return\n   The DevX object created, NULL otherwise and rte_errno is set."]
    pub fn mlx5_devx_cmd_create_virtio_q_counters(
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    #[doc = " Query virtio queue counters object using DevX API.\n\n @param[in] couners_obj\n   Pointer to virtq object structure.\n @param [in/out] attr\n   Pointer to virtio queue counters attributes structure.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn mlx5_devx_cmd_query_virtio_q_counters(
        couners_obj: *mut mlx5_devx_obj,
        attr: *mut mlx5_devx_virtio_q_couners_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_flow_hit_aso_obj(
        ctx: *mut ::std::os::raw::c_void,
        pd: u32,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_alloc_pd(ctx: *mut ::std::os::raw::c_void) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_wq_query(
        wq: *mut ::std::os::raw::c_void,
        counter_set_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_queue_counter_alloc(
        ctx: *mut ::std::os::raw::c_void,
        syndrome: *mut ::std::os::raw::c_int,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_queue_counter_query(
        dcs: *mut mlx5_devx_obj,
        clear: ::std::os::raw::c_int,
        out_of_buffers: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_conn_track_offload_obj(
        ctx: *mut ::std::os::raw::c_void,
        pd: u32,
        log_obj_size: u32,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    #[doc = " Create general object of type FLOW_METER_ASO using DevX API..\n\n @param[in] ctx\n   Device context.\n @param [in] pd\n   PD value to associate the FLOW_METER_ASO object with.\n @param [in] log_obj_size\n   log_obj_size define to allocate number of 2 * meters\n   in one FLOW_METER_ASO object.\n\n @return\n   The DevX object created, NULL otherwise and rte_errno is set."]
    pub fn mlx5_devx_cmd_create_flow_meter_aso_obj(
        ctx: *mut ::std::os::raw::c_void,
        pd: u32,
        log_obj_size: u32,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_dek_obj(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_dek_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_import_kek_obj(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_import_kek_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_credential_obj(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_credential_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_create_crypto_login_obj(
        ctx: *mut ::std::os::raw::c_void,
        attr: *mut mlx5_devx_crypto_login_attr,
    ) -> *mut mlx5_devx_obj;
}
unsafe extern "C" {
    pub fn mlx5_devx_cmd_query_lag(
        ctx: *mut ::std::os::raw::c_void,
        lag_ctx: *mut mlx5_devx_lag_context,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_cq {
    pub cq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_cq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_cq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub cqes: *mut mlx5_cqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_sq {
    pub sq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_sq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_sq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub wqes: *mut mlx5_wqe,
    pub aso_wqes: *mut mlx5_aso_wqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_qp {
    pub qp: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_qp__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_qp__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub wqes: *mut mlx5_wqe,
    pub aso_wqes: *mut mlx5_aso_wqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_wq_res {
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_rmp {
    pub rmp: *mut mlx5_devx_obj,
    pub ref_cnt: u32,
    pub wq: mlx5_devx_wq_res,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_rq {
    pub rq: *mut mlx5_devx_obj,
    pub rmp: *mut mlx5_devx_rmp,
    pub wq: mlx5_devx_wq_res,
}
unsafe extern "C" {
    pub fn mlx5_devx_cq_destroy(cq: *mut mlx5_devx_cq);
}
unsafe extern "C" {
    pub fn mlx5_devx_cq_create(
        ctx: *mut ::std::os::raw::c_void,
        cq_obj: *mut mlx5_devx_cq,
        log_desc_n: u16,
        attr: *mut mlx5_devx_cq_attr,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_sq_destroy(sq: *mut mlx5_devx_sq);
}
unsafe extern "C" {
    pub fn mlx5_devx_sq_create(
        ctx: *mut ::std::os::raw::c_void,
        sq_obj: *mut mlx5_devx_sq,
        log_wqbb_n: u16,
        attr: *mut mlx5_devx_create_sq_attr,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_qp_destroy(qp: *mut mlx5_devx_qp);
}
unsafe extern "C" {
    pub fn mlx5_devx_qp_create(
        ctx: *mut ::std::os::raw::c_void,
        qp_obj: *mut mlx5_devx_qp,
        queue_size: u32,
        attr: *mut mlx5_devx_qp_attr,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_rq_destroy(rq: *mut mlx5_devx_rq);
}
unsafe extern "C" {
    pub fn mlx5_devx_rq_create(
        ctx: *mut ::std::os::raw::c_void,
        rq_obj: *mut mlx5_devx_rq,
        wqe_size: u32,
        log_wqbb_n: u16,
        attr: *mut mlx5_devx_create_rq_attr,
        socket: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_qp2rts(qp: *mut mlx5_devx_qp, remote_qp_id: u32) -> ::std::os::raw::c_int;
}
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_UNKNOWN: rte_pci_kernel_driver = 0;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_IGB_UIO: rte_pci_kernel_driver = 1;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_VFIO: rte_pci_kernel_driver = 2;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_UIO_GENERIC: rte_pci_kernel_driver = 3;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NIC_UIO: rte_pci_kernel_driver = 4;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NONE: rte_pci_kernel_driver = 5;
pub const rte_pci_kernel_driver_RTE_PCI_KDRV_NET_UIO: rte_pci_kernel_driver = 6;
pub type rte_pci_kernel_driver = ::std::os::raw::c_uint;
#[doc = " A structure describing a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_device {
    #[doc = "< Next probed PCI device."]
    pub next: rte_pci_device__bindgen_ty_1,
    #[doc = "< Inherit core device"]
    pub device: rte_device,
    #[doc = "< PCI location."]
    pub addr: rte_pci_addr,
    #[doc = "< PCI ID."]
    pub id: rte_pci_id,
    pub mem_resource: [rte_mem_resource; 6usize],
    #[doc = "< Interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = "< PCI driver used in probing"]
    pub driver: *mut rte_pci_driver,
    #[doc = "< sriov enable if not zero"]
    pub max_vfs: u16,
    #[doc = "< Kernel driver passthrough"]
    pub kdrv: rte_pci_kernel_driver,
    #[doc = "< PCI location (ASCII)"]
    pub name: [::std::os::raw::c_char; 18usize],
    #[doc = "< PCI bus specific info"]
    pub bus_info: *mut ::std::os::raw::c_char,
    pub vfio_req_intr_handle: *mut rte_intr_handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_device,
    pub tqe_prev: *mut *mut rte_pci_device,
}
#[doc = " Initialisation function for the driver called during PCI probing."]
pub type rte_pci_probe_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rte_pci_driver,
        arg2: *mut rte_pci_device,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Uninitialisation function for the driver called during hotplugging."]
pub type rte_pci_remove_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_pci_device) -> ::std::os::raw::c_int>;
#[doc = " Driver-specific DMA mapping. After a successful call the device\n will be able to read/write from/to this segment.\n\n @param dev\n   Pointer to the PCI device.\n @param addr\n   Starting virtual address of memory to be mapped.\n @param iova\n   Starting IOVA address of memory to be mapped.\n @param len\n   Length of memory segment being mapped.\n @return\n   - 0 On success.\n   - Negative value and rte_errno is set otherwise."]
pub type pci_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_pci_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Driver-specific DMA un-mapping. After a successful call the device\n will not be able to read/write from/to this segment.\n\n @param dev\n   Pointer to the PCI device.\n @param addr\n   Starting virtual address of memory to be unmapped.\n @param iova\n   Starting IOVA address of memory to be unmapped.\n @param len\n   Length of memory segment being unmapped.\n @return\n   - 0 On success.\n   - Negative value and rte_errno is set otherwise."]
pub type pci_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_pci_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A structure describing a PCI driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_driver {
    #[doc = "< Next in list."]
    pub next: rte_pci_driver__bindgen_ty_1,
    #[doc = "< Inherit core driver."]
    pub driver: rte_driver,
    #[doc = "< Device probe function."]
    pub probe: rte_pci_probe_t,
    #[doc = "< Device remove function."]
    pub remove: rte_pci_remove_t,
    #[doc = "< device dma map function."]
    pub dma_map: pci_dma_map_t,
    #[doc = "< device dma unmap function."]
    pub dma_unmap: pci_dma_unmap_t,
    #[doc = "< ID table, NULL terminated."]
    pub id_table: *const rte_pci_id,
    #[doc = "< Flags RTE_PCI_DRV_*."]
    pub drv_flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_driver,
    pub tqe_prev: *mut *mut rte_pci_driver,
}
#[doc = " Callback prototype used by rte_kvargs_process().\n\n @param key\n   The key to consider, it will not be NULL.\n @param value\n   The value corresponding to the key, it may be NULL (e.g. only with key)\n @param opaque\n   An opaque pointer coming from the caller.\n @return\n   - >=0 handle key success.\n   - <0 on error."]
pub type arg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A key/value association"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_kvargs_pair {
    #[doc = "< the name (key) of the association"]
    pub key: *mut ::std::os::raw::c_char,
    #[doc = "< the value associated to that key"]
    pub value: *mut ::std::os::raw::c_char,
}
#[doc = " Store a list of key/value associations"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_kvargs {
    #[doc = "< copy of the argument string"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = "< number of entries in the list"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< list of key/values"]
    pub pairs: [rte_kvargs_pair; 32usize],
}
pub const mlx5_mem_flags_MLX5_MEM_ANY: mlx5_mem_flags = 0;
pub const mlx5_mem_flags_MLX5_MEM_SYS: mlx5_mem_flags = 1;
pub const mlx5_mem_flags_MLX5_MEM_RTE: mlx5_mem_flags = 2;
pub const mlx5_mem_flags_MLX5_MEM_ZERO: mlx5_mem_flags = 4;
pub type mlx5_mem_flags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Select the PMD memory allocate preference.\n\n Once sys_mem_en is set, the default memory allocate will from\n system only if an explicitly flag is set to order the memory\n from rte hugepage memory.\n\n @param sys_mem_en\n   Use system memory or not."]
    pub fn mlx5_malloc_mem_select(sys_mem_en: u32);
}
unsafe extern "C" {
    #[doc = " Dump the PMD memory usage statistic."]
    pub fn mlx5_memory_stat_dump();
}
unsafe extern "C" {
    #[doc = " Memory allocate function.\n\n @param flags\n   The bits as enum mlx5_mem_flags defined.\n @param size\n   Memory size to be allocated.\n @param align\n   Memory alignment.\n @param socket\n   The socket memory should allocated.\n   Valid only when allocate the memory from rte hugepage.\n\n @return\n   Pointer of the allocated memory, NULL otherwise."]
    pub fn mlx5_malloc(
        flags: u32,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Memory reallocate function.\n\n\n\n @param addr\n   The memory to be reallocated.\n @param flags\n   The bits as enum mlx5_mem_flags defined.\n @param size\n   Memory size to be allocated.\n @param align\n   Memory alignment.\n @param socket\n   The socket memory should allocated.\n   Valid only when allocate the memory from rte hugepage.\n\n @return\n   Pointer of the allocated memory, NULL otherwise."]
    pub fn mlx5_realloc(
        addr: *mut ::std::os::raw::c_void,
        flags: u32,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Memory free function.\n\n @param addr\n   The memory address to be freed.."]
    pub fn mlx5_free(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_set_context_attr(dev: *mut rte_device, ctx: *mut ibv_context);
}
unsafe extern "C" {
    #[doc = " This is used to query system_image_guid as describing in PRM.\n\n @param dev[in]\n  Pointer to a device instance as PCIe id.\n @param guid[out]\n  Pointer to the buffer to hold device guid.\n  Guid is uint64_t and corresponding to 17 bytes string.\n @param len[in]\n  Guid buffer length, 17 bytes at least.\n\n @return\n  -1 if internal failure.\n  0 if OFED doesn't support.\n  >0 if success."]
    pub fn mlx5_get_device_guid(
        dev: *const rte_pci_addr,
        guid: *mut u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_interrupt_handler_create(
        mode: ::std::os::raw::c_int,
        set_fd_nonblock: bool,
        fd: ::std::os::raw::c_int,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut rte_intr_handle;
}
unsafe extern "C" {
    pub fn mlx5_os_interrupt_handler_destroy(
        intr_handle: *mut rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_NOTSET: mlx5_nl_phys_port_name_type =
    0;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_LEGACY: mlx5_nl_phys_port_name_type =
    1;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_UPLINK: mlx5_nl_phys_port_name_type =
    2;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_PFVF: mlx5_nl_phys_port_name_type =
    3;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_PFHPF: mlx5_nl_phys_port_name_type =
    4;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_PFSF: mlx5_nl_phys_port_name_type =
    5;
pub const mlx5_nl_phys_port_name_type_MLX5_PHYS_PORT_NAME_TYPE_UNKNOWN:
    mlx5_nl_phys_port_name_type = 6;
pub type mlx5_nl_phys_port_name_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_nl_info {
    pub ifindex: u32,
    pub valid: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_info {
    pub port_num: u32,
    pub ibindex: u32,
    pub ibname: [::std::os::raw::c_char; 65usize],
    pub probe_opt: u8,
    pub port_info: *mut mlx5_port_nl_info,
}
#[doc = " Switch information returned by mlx5_nl_switch_info()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_switch_info {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name_type: mlx5_nl_phys_port_name_type,
    #[doc = "< Controller number (valid for c#pf#vf# format)."]
    pub ctrl_num: i32,
    #[doc = "< PF number (valid for pfxvfx format only)."]
    pub pf_num: i32,
    #[doc = "< Representor port name."]
    pub port_name: i32,
    #[doc = "< MPESW owner port number."]
    pub mpesw_owner: i32,
    #[doc = "< Switch identifier."]
    pub switch_id: u64,
}
impl mlx5_switch_info {
    #[inline]
    pub fn master(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_master(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn master_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_master_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn representor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_representor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn representor_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_representor_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(master: u32, representor: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let master: u32 = unsafe { ::std::mem::transmute(master) };
            master as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let representor: u32 = unsafe { ::std::mem::transmute(representor) };
            representor as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mlx5_cqe_status_MLX5_CQE_STATUS_SW_OWN: mlx5_cqe_status = -1;
pub const mlx5_cqe_status_MLX5_CQE_STATUS_HW_OWN: mlx5_cqe_status = -2;
pub const mlx5_cqe_status_MLX5_CQE_STATUS_ERR: mlx5_cqe_status = -3;
pub type mlx5_cqe_status = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn mlx5_dev_to_pci_str(
        dev: *const rte_device,
        addr: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_pci_addr(
        dev_path: *const ::std::os::raw::c_char,
        pci_addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_ifname_sysfs(
        ibdev_path: *const ::std::os::raw::c_char,
        ifname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_auxiliary_get_child_name(
        dev: *const ::std::os::raw::c_char,
        node: *const ::std::os::raw::c_char,
        child: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
pub const mlx5_class_MLX5_CLASS_INVALID: mlx5_class = 0;
pub const mlx5_class_MLX5_CLASS_ETH: mlx5_class = 1;
pub const mlx5_class_MLX5_CLASS_VDPA: mlx5_class = 2;
pub const mlx5_class_MLX5_CLASS_REGEX: mlx5_class = 4;
pub const mlx5_class_MLX5_CLASS_COMPRESS: mlx5_class = 8;
pub const mlx5_class_MLX5_CLASS_CRYPTO: mlx5_class = 16;
pub type mlx5_class = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_obj {
    pub obj: *mut ::std::os::raw::c_void,
    pub id: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_klm {
    pub byte_count: u32,
    pub mkey: u32,
    pub address: u64,
}
#[doc = " Control for key/values list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_kvargs_ctrl {
    pub kvlist: *mut rte_kvargs,
    pub is_used: [bool; 32usize],
}
unsafe extern "C" {
    #[doc = " Call a handler function for each key/value in the list of keys.\n\n For each key/value association that matches the given key, calls the\n handler function with the for a given arg_name passing the value on the\n dictionary for that key and a given extra argument.\n\n @param mkvlist\n   The mlx5_kvargs structure.\n @param keys\n   A list of keys to process (table of const char *, the last must be NULL).\n @param handler\n   The function to call for each matching key.\n @param opaque_arg\n   A pointer passed unchanged to the handler.\n\n @return\n   - 0 on success\n   - Negative on error"]
    pub fn mlx5_kvargs_process(
        mkvlist: *mut mlx5_kvargs_ctrl,
        keys: *const *const ::std::os::raw::c_char,
        handler: arg_handler_t,
        opaque_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar_data {
    pub db: *mut u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar {
    pub bf_db: mlx5_uar_data,
    pub cq_db: mlx5_uar_data,
    pub obj: *mut ::std::os::raw::c_void,
    pub dbnc: bool,
}
unsafe extern "C" {
    pub fn mlx5_translate_port_name(
        port_name_in: *const ::std::os::raw::c_char,
        port_info_out: *mut mlx5_switch_info,
    );
}
unsafe extern "C" {
    pub fn mlx5_glue_constructor();
}
unsafe extern "C" {
    pub fn mlx5_common_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_dev_config {
    pub hca_attr: mlx5_hca_attr,
    pub dbnc: ::std::os::raw::c_int,
    pub device_fd: ::std::os::raw::c_int,
    pub pd_handle: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_common_dev_config {
    #[inline]
    pub fn devx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_devx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn devx_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_devx_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sys_mem_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sys_mem_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sys_mem_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sys_mem_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn probe_opt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_probe_opt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn probe_opt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_probe_opt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_mempool_reg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_mempool_reg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_mempool_reg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_mempool_reg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_ext_memseg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_ext_memseg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_ext_memseg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_ext_memseg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        devx: ::std::os::raw::c_uint,
        sys_mem_en: ::std::os::raw::c_uint,
        probe_opt: ::std::os::raw::c_uint,
        mr_mempool_reg_en: ::std::os::raw::c_uint,
        mr_ext_memseg_en: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let devx: u32 = unsafe { ::std::mem::transmute(devx) };
            devx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sys_mem_en: u32 = unsafe { ::std::mem::transmute(sys_mem_en) };
            sys_mem_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let probe_opt: u32 = unsafe { ::std::mem::transmute(probe_opt) };
            probe_opt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mr_mempool_reg_en: u32 = unsafe { ::std::mem::transmute(mr_mempool_reg_en) };
            mr_mempool_reg_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mr_ext_memseg_en: u32 = unsafe { ::std::mem::transmute(mr_ext_memseg_en) };
            mr_ext_memseg_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device {
    pub dev: *mut rte_device,
    pub next: mlx5_common_device__bindgen_ty_1,
    pub classes_loaded: u32,
    pub ctx: *mut ::std::os::raw::c_void,
    pub pd: *mut ::std::os::raw::c_void,
    pub dev_info: mlx5_dev_info,
    pub pdn: u32,
    pub mr_scache: mlx5_mr_share_cache,
    pub config: mlx5_common_dev_config,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_common_device,
    pub tqe_prev: *mut *mut mlx5_common_device,
}
#[doc = " Initialization function for the driver called during device probing."]
pub type mlx5_class_driver_probe_t = ::std::option::Option<
    unsafe extern "C" fn(
        cdev: *mut mlx5_common_device,
        mkvlist: *mut mlx5_kvargs_ctrl,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Uninitialization function for the driver called during hot-unplugging."]
pub type mlx5_class_driver_remove_t = ::std::option::Option<
    unsafe extern "C" fn(cdev: *mut mlx5_common_device) -> ::std::os::raw::c_int,
>;
#[doc = " A structure describing a mlx5 common class driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_class_driver {
    pub next: mlx5_class_driver__bindgen_ty_1,
    #[doc = "< Class of this driver."]
    pub drv_class: mlx5_class,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Device probe function."]
    pub probe: mlx5_class_driver_probe_t,
    #[doc = "< Device remove function."]
    pub remove: mlx5_class_driver_remove_t,
    #[doc = "< ID table, NULL terminated."]
    pub id_table: *const rte_pci_id,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_class_driver__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_class_driver,
    pub tqe_prev: *mut *mut mlx5_class_driver,
}
impl mlx5_class_driver {
    #[inline]
    pub fn probe_again(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_probe_again(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn probe_again_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_probe_again_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intr_lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intr_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intr_lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_intr_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intr_rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intr_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intr_rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_intr_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        probe_again: u32,
        intr_lsc: u32,
        intr_rmv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let probe_again: u32 = unsafe { ::std::mem::transmute(probe_again) };
            probe_again as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let intr_lsc: u32 = unsafe { ::std::mem::transmute(intr_lsc) };
            intr_lsc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let intr_rmv: u32 = unsafe { ::std::mem::transmute(intr_rmv) };
            intr_rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " Register a mlx5 device driver.\n\n @param driver\n   A pointer to a mlx5_driver structure describing the driver\n   to be registered."]
    pub fn mlx5_class_driver_register(driver: *mut mlx5_class_driver);
}
unsafe extern "C" {
    #[doc = " Test device is a PCI bus device.\n\n @param dev\n   Pointer to device.\n\n @return\n   - True on device devargs is a PCI bus device.\n   - False otherwise."]
    pub fn mlx5_dev_is_pci(dev: *const rte_device) -> bool;
}
unsafe extern "C" {
    #[doc = " Test PCI device is a VF device.\n\n @param pci_dev\n   Pointer to PCI device.\n\n @return\n   - True on PCI device is a VF device.\n   - False otherwise."]
    pub fn mlx5_dev_is_vf_pci(pci_dev: *const rte_pci_device) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_dev_mempool_subscribe(cdev: *mut mlx5_common_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_mempool_unregister(cdev: *mut mlx5_common_device, mp: *mut rte_mempool);
}
unsafe extern "C" {
    pub fn mlx5_devx_uar_prepare(
        cdev: *mut mlx5_common_device,
        uar: *mut mlx5_uar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_devx_uar_release(uar: *mut mlx5_uar);
}
unsafe extern "C" {
    pub fn mlx5_os_get_physical_device_ctx(
        cdev: *mut mlx5_common_device,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mlx5_os_open_device(
        cdev: *mut mlx5_common_device,
        classes: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_pd_prepare(cdev: *mut mlx5_common_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_pd_release(cdev: *mut mlx5_common_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_remote_pd_and_ctx_validate(
        config: *mut mlx5_common_dev_config,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_wrapped_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub imkey: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    pub fn mlx5_os_wrapped_mkey_create(
        ctx: *mut ::std::os::raw::c_void,
        pd: *mut ::std::os::raw::c_void,
        pdn: u32,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        pmd_mr: *mut mlx5_pmd_wrapped_mr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_wrapped_mkey_destroy(pmd_mr: *mut mlx5_pmd_wrapped_mr);
}
#[doc = " Structure of the entry in the mlx5 list, user should define its own struct\n that contains this in order to store the data."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry {
    pub next: mlx5_list_entry__bindgen_ty_1,
    pub ref_cnt: u32,
    pub lcore_idx: u32,
    pub __bindgen_anon_1: mlx5_list_entry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry__bindgen_ty_1 {
    pub le_next: *mut mlx5_list_entry,
    pub le_prev: *mut *mut mlx5_list_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_list_entry__bindgen_ty_2 {
    pub gentry: *mut mlx5_list_entry,
    pub bucket_idx: u32,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache {
    pub h: mlx5_list_cache_mlx5_list_head,
    pub inv_cnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache_mlx5_list_head {
    pub lh_first: *mut mlx5_list_entry,
}
#[doc = " Type of callback function for entry removal.\n\n @param tool_ctx\n   The tool instance user context.\n @param entry\n   The entry in the list."]
pub type mlx5_list_remove_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined matching.\n\n @param tool_ctx\n   The tool instance context.\n @param entry\n   The entry in the list.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   0 if matching, non-zero number otherwise."]
pub type mlx5_list_match_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_list_clone_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
pub type mlx5_list_clone_free_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined mlx5 list entry creation.\n\n @param tool_ctx\n   The mlx5 tool instance context.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   Pointer of entry on success, NULL otherwise."]
pub type mlx5_list_create_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
#[doc = " Linked mlx5 list constant object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_const {
    #[doc = "< Name of the mlx5 list."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub ctx: *mut ::std::os::raw::c_void,
    pub lcores_share: bool,
    pub lcore_lock: rte_spinlock_t,
    #[doc = "< entry create callback."]
    pub cb_create: mlx5_list_create_cb,
    #[doc = "< entry match callback."]
    pub cb_match: mlx5_list_match_cb,
    #[doc = "< entry remove callback."]
    pub cb_remove: mlx5_list_remove_cb,
    #[doc = "< entry clone callback."]
    pub cb_clone: mlx5_list_clone_cb,
    pub cb_clone_free: mlx5_list_clone_free_cb,
}
#[doc = " Linked mlx5 list inconstant data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_inconst {
    pub lock: rte_rwlock_t,
    pub gen_cnt: u32,
    pub count: u32,
    pub cache: [*mut mlx5_list_cache; 130usize],
}
#[doc = " Linked mlx5 list structure.\n\n Entry in mlx5 list could be reused if entry already exists,\n reference count will increase and the existing entry returns.\n\n When destroy an entry from list, decrease reference count and only\n destroy when no further reference.\n\n Linked list is designed for limited number of entries,\n read mostly, less modification.\n\n For huge amount of entries, please consider hash list.\n"]
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_list {
    pub l_const: mlx5_list_const,
    pub l_inconst: mlx5_list_inconst,
}
unsafe extern "C" {
    #[doc = " Create a mlx5 list.\n\n For actions in SW-steering is only memory and  can be allowed\n to create duplicate objects, the lists don't need to check if\n there are existing same objects in other sub local lists,\n search the object only in local list will be more efficient.\n\n @param list\n   Pointer to the hast list table.\n @param name\n   Name of the mlx5 list.\n @param ctx\n   Pointer to the list context data.\n @param lcores_share\n   Whether to share objects between the lcores.\n @param cb_create\n   Callback function for entry create.\n @param cb_match\n   Callback function for entry match.\n @param cb_remove\n   Callback function for entry remove.\n @return\n   List pointer on success, otherwise NULL."]
    pub fn mlx5_list_create(
        name: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
        lcores_share: bool,
        cb_create: mlx5_list_create_cb,
        cb_match: mlx5_list_match_cb,
        cb_remove: mlx5_list_remove_cb,
        cb_clone: mlx5_list_clone_cb,
        cb_clone_free: mlx5_list_clone_free_cb,
    ) -> *mut mlx5_list;
}
unsafe extern "C" {
    #[doc = " Search an entry matching the key.\n\n Result returned might be destroyed by other thread, must use\n this function only in main thread.\n\n @param list\n   Pointer to the mlx5 list.\n @param ctx\n   Common context parameter used by entry callback function.\n\n @return\n   Pointer of the list entry if found, NULL otherwise."]
    pub fn mlx5_list_lookup(
        list: *mut mlx5_list,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    #[doc = " Reuse or create an entry to the mlx5 list.\n\n @param list\n   Pointer to the hast list table.\n @param ctx\n   Common context parameter used by callback function.\n\n @return\n   registered entry on success, NULL otherwise"]
    pub fn mlx5_list_register(
        list: *mut mlx5_list,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    #[doc = " Remove an entry from the mlx5 list.\n\n User should guarantee the validity of the entry.\n\n @param list\n   Pointer to the hast list.\n @param entry\n   Entry to be removed from the mlx5 list table.\n @return\n   0 on entry removed, 1 on entry still referenced."]
    pub fn mlx5_list_unregister(
        list: *mut mlx5_list,
        entry: *mut mlx5_list_entry,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy the mlx5 list.\n\n @param list\n   Pointer to the mlx5 list."]
    pub fn mlx5_list_destroy(list: *mut mlx5_list);
}
unsafe extern "C" {
    #[doc = " Get entry number from the mlx5 list.\n\n @param list\n   Pointer to the hast list.\n @return\n   mlx5 list entry number."]
    pub fn mlx5_list_get_entry_num(list: *mut mlx5_list) -> u32;
}
#[doc = " Hash List"]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hlist_bucket {
    pub l: mlx5_list_inconst,
}
#[doc = " Hash list table structure\n\n The hash list bucket using the mlx5_list object for managing."]
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_hlist {
    pub mask: u32,
    pub flags: u8,
    pub direct_key: bool,
    pub l_const: mlx5_list_const,
    pub __bindgen_padding_0: [u64; 4usize],
    pub buckets: __IncompleteArrayField<mlx5_hlist_bucket>,
}
unsafe extern "C" {
    #[doc = " Create a hash list table, the user can specify the list heads array size\n of the table, now the size should be a power of 2 in order to get better\n distribution for the entries. Each entry is a part of the whole data element\n and the caller should be responsible for the data element's allocation and\n cleanup / free. Key of each entry will be calculated with CRC in order to\n generate a little fairer distribution.\n\n @param name\n   Name of the hash list(optional).\n @param size\n   Heads array size of the hash list.\n @param entry_size\n   Entry size to allocate if cb_create not specified.\n @param direct key\n   Whether to use the key directly as hash index.\n @param lcores_share\n   Whether to share objects between the lcores.\n @param ctx\n   The hlist instance context.\n @param cb_create\n   Callback function for entry create.\n @param cb_match\n   Callback function for entry match.\n @param cb_remove\n   Callback function for entry remove.\n @param cb_clone\n   Callback function for entry clone.\n @param cb_clone_free\n   Callback function for entry clone free.\n @return\n   Pointer of the hash list table created, NULL on failure."]
    pub fn mlx5_hlist_create(
        name: *const ::std::os::raw::c_char,
        size: u32,
        direct_key: bool,
        lcores_share: bool,
        ctx: *mut ::std::os::raw::c_void,
        cb_create: mlx5_list_create_cb,
        cb_match: mlx5_list_match_cb,
        cb_remove: mlx5_list_remove_cb,
        cb_clone: mlx5_list_clone_cb,
        cb_clone_free: mlx5_list_clone_free_cb,
    ) -> *mut mlx5_hlist;
}
unsafe extern "C" {
    #[doc = " Search an entry matching the key.\n\n Result returned might be destroyed by other thread, must use\n this function only in main thread.\n\n @param h\n   Pointer to the hast list table.\n @param key\n   Key for the searching entry.\n @param ctx\n   Common context parameter used by entry callback function.\n\n @return\n   Pointer of the hlist entry if found, NULL otherwise."]
    pub fn mlx5_hlist_lookup(
        h: *mut mlx5_hlist,
        key: u64,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    #[doc = " Insert an entry to the hash list table, the entry is only part of whole data\n element and a 64B key is used for matching. User should construct the key or\n give a calculated hash signature and guarantee there is no collision.\n\n @param h\n   Pointer to the hast list table.\n @param entry\n   Entry to be inserted into the hash list table.\n @param ctx\n   Common context parameter used by callback function.\n\n @return\n   registered entry on success, NULL otherwise"]
    pub fn mlx5_hlist_register(
        h: *mut mlx5_hlist,
        key: u64,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    #[doc = " Remove an entry from the hash list table. User should guarantee the validity\n of the entry.\n\n @param h\n   Pointer to the hast list table. (not used)\n @param entry\n   Entry to be removed from the hash list table.\n @return\n   0 on entry removed, 1 on entry still referenced."]
    pub fn mlx5_hlist_unregister(
        h: *mut mlx5_hlist,
        entry: *mut mlx5_list_entry,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy the hash list table, all the entries already inserted into the lists\n will be handled by the callback function provided by the user (including\n free if needed) before the table is freed.\n\n @param h\n   Pointer to the hast list table."]
    pub fn mlx5_hlist_destroy(h: *mut mlx5_hlist);
}
pub const mlx5_l3t_type_MLX5_L3T_TYPE_WORD: mlx5_l3t_type = 0;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_DWORD: mlx5_l3t_type = 1;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_QWORD: mlx5_l3t_type = 2;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_PTR: mlx5_l3t_type = 3;
pub const mlx5_l3t_type_MLX5_L3T_TYPE_MAX: mlx5_l3t_type = 4;
pub type mlx5_l3t_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_l3t_data {
    pub word: u16,
    pub dword: u32,
    pub qword: u64,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct mlx5_l3t_level_tbl {
    pub ref_cnt: u64,
    pub tbl: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_word {
    pub idx: u32,
    pub ref_cnt: u64,
    pub entry: [mlx5_l3t_entry_word__bindgen_ty_1; 4096usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_word__bindgen_ty_1 {
    pub data: u16,
    pub ref_cnt: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_dword {
    pub idx: u32,
    pub ref_cnt: u64,
    pub entry: [mlx5_l3t_entry_dword__bindgen_ty_1; 4096usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_dword__bindgen_ty_1 {
    pub data: u32,
    pub ref_cnt: i32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_qword {
    pub idx: u32,
    pub ref_cnt: u64,
    pub entry: [mlx5_l3t_entry_qword__bindgen_ty_1; 4096usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_qword__bindgen_ty_1 {
    pub data: u64,
    pub ref_cnt: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_ptr {
    pub idx: u32,
    pub ref_cnt: u64,
    pub entry: [mlx5_l3t_entry_ptr__bindgen_ty_1; 4096usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_entry_ptr__bindgen_ty_1 {
    pub data: *mut ::std::os::raw::c_void,
    pub ref_cnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_l3t_tbl {
    pub type_: mlx5_l3t_type,
    pub eip: *mut mlx5_indexed_pool,
    pub tbl: *mut mlx5_l3t_level_tbl,
    pub sl: rte_spinlock_t,
}
#[doc = " Type of function that is used to handle the data before freeing."]
pub type mlx5_l3t_alloc_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, data: *mut mlx5_l3t_data) -> i32,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool_config {
    pub size: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_idx: u32,
    pub per_core_cache: u32,
    pub type_: *const ::std::os::raw::c_char,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            flags: u32,
            size: usize,
            align: ::std::os::raw::c_uint,
            socket: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>,
}
impl mlx5_indexed_pool_config {
    #[inline]
    pub fn trunk_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_trunk_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trunk_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trunk_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_trunk(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_trunk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_trunk_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_trunk_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn need_lock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_lock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn need_lock_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_need_lock_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn release_mem_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_release_mem_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn release_mem_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_release_mem_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        trunk_size: u32,
        grow_trunk: u32,
        grow_shift: u32,
        need_lock: u32,
        release_mem_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let trunk_size: u32 = unsafe { ::std::mem::transmute(trunk_size) };
            trunk_size as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let grow_trunk: u32 = unsafe { ::std::mem::transmute(grow_trunk) };
            grow_trunk as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let grow_shift: u32 = unsafe { ::std::mem::transmute(grow_shift) };
            grow_shift as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let need_lock: u32 = unsafe { ::std::mem::transmute(need_lock) };
            need_lock as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let release_mem_en: u32 = unsafe { ::std::mem::transmute(release_mem_en) };
            release_mem_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_indexed_trunk {
    pub idx: u32,
    pub prev: u32,
    pub next: u32,
    pub free: u32,
    pub bmp: *mut rte_bitmap,
    pub __bindgen_padding_0: [u8; 40usize],
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
pub struct mlx5_indexed_cache {
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub ref_cnt: u32,
    pub len: u32,
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_ipool_per_lcore {
    pub lc: *mut mlx5_indexed_cache,
    #[doc = "< Current cache count."]
    pub len: u32,
    #[doc = "< Cache objects."]
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_indexed_pool {
    pub cfg: mlx5_indexed_pool_config,
    pub rsz_lock: rte_spinlock_t,
    pub lcore_lock: rte_spinlock_t,
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1,
    pub n_entry: u32,
    pub trunk_new: u32,
    pub trunk_avail: u32,
    pub trunk_empty: u32,
    pub trunk_free: u32,
    pub grow_tbl: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_indexed_pool__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1 {
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub free_list: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2 {
    pub gc: *mut mlx5_indexed_cache,
    pub cache: [*mut mlx5_ipool_per_lcore; 129usize],
    pub ibmp: *mut rte_bitmap,
    pub bmp_mem: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " This function allocates non-initialized memory entry from pool.\n In NUMA systems, the memory entry allocated resides on the same\n NUMA socket as the core that calls this function.\n\n Memory entry is allocated from memory trunk, no alignment.\n\n @param pool\n   Pointer to indexed memory entry pool.\n   No initialization required.\n @param[out] idx\n   Pointer to memory to save allocated index.\n   Memory index always positive value.\n @return\n   - Pointer to the allocated memory entry.\n   - NULL on error. Not enough memory, or invalid arguments."]
    pub fn mlx5_ipool_malloc(
        pool: *mut mlx5_indexed_pool,
        idx: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " This function allocates zero initialized memory entry from pool.\n In NUMA systems, the memory entry allocated resides on the same\n NUMA socket as the core that calls this function.\n\n Memory entry is allocated from memory trunk, no alignment.\n\n @param pool\n   Pointer to indexed memory pool.\n   No initialization required.\n @param[out] idx\n   Pointer to memory to save allocated index.\n   Memory index always positive value.\n @return\n   - Pointer to the allocated memory entry .\n   - NULL on error. Not enough memory, or invalid arguments."]
    pub fn mlx5_ipool_zmalloc(
        pool: *mut mlx5_indexed_pool,
        idx: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " This function frees indexed memory entry to pool.\n Caller has to make sure that the index is allocated from same pool.\n\n @param pool\n   Pointer to indexed memory pool.\n @param idx\n   Allocated memory entry index."]
    pub fn mlx5_ipool_free(pool: *mut mlx5_indexed_pool, idx: u32);
}
unsafe extern "C" {
    #[doc = " This function returns pointer of indexed memory entry from index.\n Caller has to make sure that the index is valid, and allocated\n from same pool.\n\n @param pool\n   Pointer to indexed memory pool.\n @param idx\n   Allocated memory index.\n @return\n   - Pointer to indexed memory entry."]
    pub fn mlx5_ipool_get(pool: *mut mlx5_indexed_pool, idx: u32) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " This function creates indexed memory pool.\n Caller has to configure the configuration accordingly.\n\n @param pool\n   Pointer to indexed memory pool.\n @param cfg\n   Allocated memory index."]
    pub fn mlx5_ipool_create(cfg: *mut mlx5_indexed_pool_config) -> *mut mlx5_indexed_pool;
}
unsafe extern "C" {
    #[doc = " This function releases all resources of pool.\n Caller has to make sure that all indexes and memories allocated\n from this pool not referenced anymore.\n\n @param pool\n   Pointer to indexed memory pool.\n @return\n   - non-zero value on error.\n   - 0 on success."]
    pub fn mlx5_ipool_destroy(pool: *mut mlx5_indexed_pool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function dumps debug info of pool.\n\n @param pool\n   Pointer to indexed memory pool."]
    pub fn mlx5_ipool_dump(pool: *mut mlx5_indexed_pool);
}
unsafe extern "C" {
    #[doc = " This function flushes all the cache index back to pool trunk.\n\n @param pool\n   Pointer to the index memory pool handler.\n"]
    pub fn mlx5_ipool_flush_cache(pool: *mut mlx5_indexed_pool);
}
unsafe extern "C" {
    #[doc = " This function gets the available entry from pos.\n\n @param pool\n   Pointer to the index memory pool handler.\n @param pos\n   Pointer to the index position start from.\n\n @return\n  - Pointer to the next available entry.\n"]
    pub fn mlx5_ipool_get_next(
        pool: *mut mlx5_indexed_pool,
        pos: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " This function resize the ipool.\n\n @param pool\n   Pointer to the index memory pool handler.\n @param num_entries\n   Number of entries to be added to the pool.\n   This number should be divisible by trunk_size.\n\n @return\n   - non-zero value on error.\n   - 0 on success.\n"]
    pub fn mlx5_ipool_resize(
        pool: *mut mlx5_indexed_pool,
        num_entries: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " This function allocates new empty Three-level table.\n\n @param type\n   The l3t can set as word, double word, quad word or pointer with index.\n\n @return\n   - Pointer to the allocated l3t.\n   - NULL on error. Not enough memory, or invalid arguments."]
    pub fn mlx5_l3t_create(type_: mlx5_l3t_type) -> *mut mlx5_l3t_tbl;
}
unsafe extern "C" {
    #[doc = " This function destroys Three-level table.\n\n @param tbl\n   Pointer to the l3t."]
    pub fn mlx5_l3t_destroy(tbl: *mut mlx5_l3t_tbl);
}
unsafe extern "C" {
    #[doc = " This function gets the index entry from Three-level table.\n\n @param tbl\n   Pointer to the l3t.\n @param idx\n   Index to the entry.\n @param data\n   Pointer to the memory which saves the entry data.\n   When function call returns 0, data contains the entry data get from\n   l3t.\n   When function call returns -1, data is not modified.\n\n @return\n   0 if success, -1 on error."]
    pub fn mlx5_l3t_get_entry(tbl: *mut mlx5_l3t_tbl, idx: u32, data: *mut mlx5_l3t_data) -> i32;
}
unsafe extern "C" {
    #[doc = " This function decreases and clear index entry if reference\n counter is 0 from Three-level table.\n\n @param tbl\n   Pointer to the l3t.\n @param idx\n   Index to the entry.\n\n @return\n   The remaining reference count, 0 means entry be cleared, -1 on error."]
    pub fn mlx5_l3t_clear_entry(tbl: *mut mlx5_l3t_tbl, idx: u32) -> i32;
}
unsafe extern "C" {
    #[doc = " This function sets the index entry to Three-level table.\n If the entry is already set, the EEXIST errno will be given, and\n the set data will be filled to the data.\n\n @param tbl[in]\n   Pointer to the l3t.\n @param idx[in]\n   Index to the entry.\n @param data[in/out]\n   Pointer to the memory which contains the entry data save to l3t.\n   If the entry is already set, the set data will be filled.\n\n @return\n   0 if success, -1 on error."]
    pub fn mlx5_l3t_set_entry(tbl: *mut mlx5_l3t_tbl, idx: u32, data: *mut mlx5_l3t_data) -> i32;
}
unsafe extern "C" {
    pub fn mlx5_auxiliary_get_ifindex(
        sf_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const mlx5_sw_parsing_offloads_MLX5_SW_PARSING_CAP: mlx5_sw_parsing_offloads = 1;
pub const mlx5_sw_parsing_offloads_MLX5_SW_PARSING_CSUM_CAP: mlx5_sw_parsing_offloads = 2;
pub const mlx5_sw_parsing_offloads_MLX5_SW_PARSING_TSO_CAP: mlx5_sw_parsing_offloads = 4;
pub type mlx5_sw_parsing_offloads = ::std::os::raw::c_uint;
pub const mlx5_tunnel_offloads_MLX5_TUNNELED_OFFLOADS_VXLAN_CAP: mlx5_tunnel_offloads = 1;
pub const mlx5_tunnel_offloads_MLX5_TUNNELED_OFFLOADS_GRE_CAP: mlx5_tunnel_offloads = 2;
pub const mlx5_tunnel_offloads_MLX5_TUNNELED_OFFLOADS_GENEVE_CAP: mlx5_tunnel_offloads = 4;
pub type mlx5_tunnel_offloads = ::std::os::raw::c_uint;
pub const rte_pmd_mlx5_flow_engine_mode_RTE_PMD_MLX5_FLOW_ENGINE_MODE_ACTIVE:
    rte_pmd_mlx5_flow_engine_mode = 0;
pub const rte_pmd_mlx5_flow_engine_mode_RTE_PMD_MLX5_FLOW_ENGINE_MODE_STANDBY:
    rte_pmd_mlx5_flow_engine_mode = 1;
pub type rte_pmd_mlx5_flow_engine_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dr_context {
    _unused: [u8; 0],
}
pub const mlx5_ipool_index_MLX5_IPOOL_DECAP_ENCAP: mlx5_ipool_index = 0;
pub const mlx5_ipool_index_MLX5_IPOOL_PUSH_VLAN: mlx5_ipool_index = 1;
pub const mlx5_ipool_index_MLX5_IPOOL_TAG: mlx5_ipool_index = 2;
pub const mlx5_ipool_index_MLX5_IPOOL_PORT_ID: mlx5_ipool_index = 3;
pub const mlx5_ipool_index_MLX5_IPOOL_JUMP: mlx5_ipool_index = 4;
pub const mlx5_ipool_index_MLX5_IPOOL_HW_GRP: mlx5_ipool_index = 4;
pub const mlx5_ipool_index_MLX5_IPOOL_SAMPLE: mlx5_ipool_index = 5;
pub const mlx5_ipool_index_MLX5_IPOOL_DEST_ARRAY: mlx5_ipool_index = 6;
pub const mlx5_ipool_index_MLX5_IPOOL_TUNNEL_ID: mlx5_ipool_index = 7;
pub const mlx5_ipool_index_MLX5_IPOOL_TNL_TBL_ID: mlx5_ipool_index = 8;
pub const mlx5_ipool_index_MLX5_IPOOL_MTR: mlx5_ipool_index = 9;
pub const mlx5_ipool_index_MLX5_IPOOL_MCP: mlx5_ipool_index = 10;
pub const mlx5_ipool_index_MLX5_IPOOL_HRXQ: mlx5_ipool_index = 11;
pub const mlx5_ipool_index_MLX5_IPOOL_MLX5_FLOW: mlx5_ipool_index = 12;
pub const mlx5_ipool_index_MLX5_IPOOL_RTE_FLOW: mlx5_ipool_index = 13;
pub const mlx5_ipool_index_MLX5_IPOOL_RSS_EXPANTION_FLOW_ID: mlx5_ipool_index = 14;
pub const mlx5_ipool_index_MLX5_IPOOL_RSS_SHARED_ACTIONS: mlx5_ipool_index = 15;
pub const mlx5_ipool_index_MLX5_IPOOL_MTR_POLICY: mlx5_ipool_index = 16;
pub const mlx5_ipool_index_MLX5_IPOOL_MAX: mlx5_ipool_index = 17;
pub type mlx5_ipool_index = ::std::os::raw::c_uint;
pub const mlx5_reclaim_mem_mode_MLX5_RCM_NONE: mlx5_reclaim_mem_mode = 0;
pub const mlx5_reclaim_mem_mode_MLX5_RCM_LIGHT: mlx5_reclaim_mem_mode = 1;
pub const mlx5_reclaim_mem_mode_MLX5_RCM_AGGR: mlx5_reclaim_mem_mode = 2;
pub type mlx5_reclaim_mem_mode = ::std::os::raw::c_uint;
pub const mlx5_flow_type_MLX5_FLOW_TYPE_CTL: mlx5_flow_type = 0;
pub const mlx5_flow_type_MLX5_FLOW_TYPE_GEN: mlx5_flow_type = 1;
pub const mlx5_flow_type_MLX5_FLOW_TYPE_MCP: mlx5_flow_type = 2;
pub const mlx5_flow_type_MLX5_FLOW_TYPE_MAXI: mlx5_flow_type = 3;
pub type mlx5_flow_type = ::std::os::raw::c_uint;
pub const mlx5_delay_drop_mode_MLX5_DELAY_DROP_NONE: mlx5_delay_drop_mode = 0;
pub const mlx5_delay_drop_mode_MLX5_DELAY_DROP_STANDARD: mlx5_delay_drop_mode = 1;
pub const mlx5_delay_drop_mode_MLX5_DELAY_DROP_HAIRPIN: mlx5_delay_drop_mode = 2;
pub type mlx5_delay_drop_mode = ::std::os::raw::c_uint;
pub const mlx5_hw_action_flag_type_MLX5_HW_ACTION_FLAG_ROOT: mlx5_hw_action_flag_type = 0;
pub const mlx5_hw_action_flag_type_MLX5_HW_ACTION_FLAG_NONE_ROOT: mlx5_hw_action_flag_type = 1;
pub const mlx5_hw_action_flag_type_MLX5_HW_ACTION_FLAG_MAX: mlx5_hw_action_flag_type = 2;
pub type mlx5_hw_action_flag_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_cb_ctx {
    pub dev: *mut rte_eth_dev,
    pub error: *mut rte_flow_error,
    pub data: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_hw_port_info {
    pub regc_mask: u32,
    pub regc_value: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl flow_hw_port_info {
    #[inline]
    pub fn is_wire(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_wire(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_wire_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_wire_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_wire: u32, direction: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_wire: u32 = unsafe { ::std::mem::transmute(is_wire) };
            is_wire as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mlx5_vport_direction_MLX5_VPORT_DIRECTION_ANY: mlx5_vport_direction = 0;
pub const mlx5_vport_direction_MLX5_VPORT_DIRECTION_NORTH: mlx5_vport_direction = 1;
pub const mlx5_vport_direction_MLX5_VPORT_DIRECTION_SOUTH: mlx5_vport_direction = 2;
pub type mlx5_vport_direction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap {
    pub max_cq: ::std::os::raw::c_int,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub max_sge: ::std::os::raw::c_int,
    pub mps: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub ind_table_max_size: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tso_max_payload_sz: u32,
    pub mprq: mlx5_dev_cap__bindgen_ty_1,
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub esw_info: flow_hw_port_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_min_stride_size: u32,
    pub log_max_stride_size: u32,
    pub log_min_stride_num: u32,
    pub log_max_stride_num: u32,
    pub log_min_stride_wqe_size: u32,
}
impl mlx5_dev_cap__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl mlx5_dev_cap {
    #[inline]
    pub fn vf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn txpp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txpp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn txpp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_txpp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_padding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_padding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_padding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_padding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dest_tir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_tir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dest_tir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dest_tir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vf: u32,
        sf: u32,
        txpp_en: u32,
        mpls_en: u32,
        cqe_comp: u32,
        hw_csum: u32,
        hw_padding: u32,
        dest_tir: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        swp: u32,
        hw_vlan_strip: u32,
        scatter_fcs_w_decap_disable: u32,
        hw_fcs_strip: u32,
        rt_timestamp: u32,
        rq_delay_drop_en: u32,
        tunnel_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vf: u32 = unsafe { ::std::mem::transmute(vf) };
            vf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sf: u32 = unsafe { ::std::mem::transmute(sf) };
            sf as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let txpp_en: u32 = unsafe { ::std::mem::transmute(txpp_en) };
            txpp_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpls_en: u32 = unsafe { ::std::mem::transmute(mpls_en) };
            mpls_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cqe_comp: u32 = unsafe { ::std::mem::transmute(cqe_comp) };
            cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hw_csum: u32 = unsafe { ::std::mem::transmute(hw_csum) };
            hw_csum as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hw_padding: u32 = unsafe { ::std::mem::transmute(hw_padding) };
            hw_padding as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dest_tir: u32 = unsafe { ::std::mem::transmute(dest_tir) };
            dest_tir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_vlan_strip: u32 = unsafe { ::std::mem::transmute(hw_vlan_strip) };
            hw_vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rt_timestamp: u32 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rq_delay_drop_en: u32 = unsafe { ::std::mem::transmute(rq_delay_drop_en) };
            rq_delay_drop_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let tunnel_en: u32 = unsafe { ::std::mem::transmute(tunnel_en) };
            tunnel_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(tso: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tso: u32 = unsafe { ::std::mem::transmute(tso) };
            tso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Data associated with devices to spawn."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_spawn_data {
    #[doc = "< Network interface index."]
    pub ifindex: u32,
    #[doc = "< Device maximal port index."]
    pub max_port: u32,
    #[doc = "< Device physical port index."]
    pub phys_port: u32,
    #[doc = "< bonding device PF index. < 0 - no bonding"]
    pub pf_bond: ::std::os::raw::c_int,
    #[doc = "< MPESW uplink index. Valid if mpesw_owner_port >= 0."]
    pub mpesw_port: ::std::os::raw::c_int,
    #[doc = "< Switch information."]
    pub info: mlx5_switch_info,
    #[doc = "< Name of physical device."]
    pub phys_dev_name: *const ::std::os::raw::c_char,
    #[doc = "< Associated Ethernet device."]
    pub eth_dev: *mut rte_eth_dev,
    #[doc = "< Backend PCI device."]
    pub pci_dev: *mut rte_pci_device,
    #[doc = "< Backend common device."]
    pub cdev: *mut mlx5_common_device,
    pub bond_info: *mut mlx5_bond_info,
}
#[doc = " Data associated with socket messages."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dump_req {
    #[doc = "< There are plans in DPDK to extend port_id."]
    pub port_id: u32,
    pub flow_id: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dump_ack {
    #[doc = "< Return code."]
    pub rc: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_list {
    pub lh_first: *mut mlx5_dev_ctx_shared,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_shared_data {
    pub lock: rte_spinlock_t,
    pub init_done: ::std::os::raw::c_int,
    pub secondary_cnt: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_local_data {
    pub init_done: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn mlx5_xstats_enable(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_xstats_disable(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_xstats_query_state(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int;
}
pub type mlx5_enable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
pub type mlx5_disable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, id: u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_stat_counter_ctrl {
    pub enable: mlx5_enable_counter_t,
    pub disable: mlx5_disable_counter_t,
    pub enabled: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_ctrl {
    pub dpdk_name: [::std::os::raw::c_char; 64usize],
    pub ctr_name: [::std::os::raw::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ctrl: mlx5_stat_counter_ctrl,
}
impl mlx5_counter_ctrl {
    #[inline]
    pub fn dev(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dev(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dev_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(dev: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dev: u32 = unsafe { ::std::mem::transmute(dev) };
            dev as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_xstats_ctrl {
    pub stats_n: u16,
    pub stats_n_2nd: u16,
    pub mlx5_stats_n: u16,
    pub dev_cnt_start: u16,
    pub dev_table_idx: [u16; 64usize],
    pub xstats_o_idx: [u16; 64usize],
    pub base: [u64; 64usize],
    pub xstats: [u64; 64usize],
    pub hw_stats: [u64; 64usize],
    pub info: [mlx5_counter_ctrl; 64usize],
    pub dev_table_idx_2nd: [u16; 64usize],
    pub xstats_o_idx_2nd: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_stats_ctrl {
    pub imissed_base: u64,
    pub imissed: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub mprq: mlx5_port_config__bindgen_ty_1,
    pub mps: ::std::os::raw::c_int,
    pub max_dump_files_num: ::std::os::raw::c_uint,
    pub log_hp_size: ::std::os::raw::c_uint,
    pub lro_timeout: ::std::os::raw::c_uint,
    pub txqs_inline: ::std::os::raw::c_int,
    pub txq_inline_min: ::std::os::raw::c_int,
    pub txq_inline_max: ::std::os::raw::c_int,
    pub txq_inline_mpw: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_stride_num: ::std::os::raw::c_uint,
    pub log_stride_size: ::std::os::raw::c_uint,
    pub max_memcpy_len: ::std::os::raw::c_uint,
    pub min_rxqs_num: ::std::os::raw::c_uint,
}
impl mlx5_port_config__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl mlx5_port_config {
    #[inline]
    pub fn hw_vlan_insert(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_vlan_insert(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_padding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_padding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_padding_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_padding_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enh_cqe_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enh_cqe_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enh_cqe_comp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enh_cqe_comp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_fmt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_fmt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_fmt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_fmt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_vec_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_vec_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_vec_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_vec_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn std_delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_std_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn std_delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_std_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hp_delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hp_delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hp_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_insert: ::std::os::raw::c_uint,
        hw_padding: ::std::os::raw::c_uint,
        cqe_comp: ::std::os::raw::c_uint,
        enh_cqe_comp: ::std::os::raw::c_uint,
        cqe_comp_fmt: ::std::os::raw::c_uint,
        rx_vec_en: ::std::os::raw::c_uint,
        std_delay_drop: ::std::os::raw::c_uint,
        hp_delay_drop: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_insert: u32 = unsafe { ::std::mem::transmute(hw_vlan_insert) };
            hw_vlan_insert as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_padding: u32 = unsafe { ::std::mem::transmute(hw_padding) };
            hw_padding as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cqe_comp: u32 = unsafe { ::std::mem::transmute(cqe_comp) };
            cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enh_cqe_comp: u32 = unsafe { ::std::mem::transmute(enh_cqe_comp) };
            enh_cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let cqe_comp_fmt: u32 = unsafe { ::std::mem::transmute(cqe_comp_fmt) };
            cqe_comp_fmt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_vec_en: u32 = unsafe { ::std::mem::transmute(rx_vec_en) };
            rx_vec_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let std_delay_drop: u32 = unsafe { ::std::mem::transmute(std_delay_drop) };
            std_delay_drop as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hp_delay_drop: u32 = unsafe { ::std::mem::transmute(hp_delay_drop) };
            hp_delay_drop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config {
    pub tx_pp: ::std::os::raw::c_int,
    pub tx_skew: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: mlx5_sh_config__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config__bindgen_ty_1 {
    pub service_core: u16,
    pub cycle_time: u32,
}
impl mlx5_sh_config {
    #[inline]
    pub fn reclaim_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reclaim_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reclaim_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reclaim_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_xmeta_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dv_xmeta_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_xmeta_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_xmeta_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_miss_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_miss_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_miss_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_miss_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_vxlan_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3_vxlan_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_vxlan_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_vxlan_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vf_nl_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf_nl_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_nl_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_nl_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lacp_by_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lacp_by_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lacp_by_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lacp_by_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decap_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decap_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decap_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decap_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_duplicate_pattern(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_duplicate_pattern(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_duplicate_pattern_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_duplicate_pattern_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reclaim_mode: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        dv_xmeta_en: u32,
        dv_miss_info: u32,
        l3_vxlan_en: u32,
        vf_nl_en: u32,
        lacp_by_user: u32,
        decap_en: u32,
        hw_fcs_strip: u32,
        allow_duplicate_pattern: u32,
        lro_allowed: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reclaim_mode: u32 = unsafe { ::std::mem::transmute(reclaim_mode) };
            reclaim_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let dv_xmeta_en: u32 = unsafe { ::std::mem::transmute(dv_xmeta_en) };
            dv_xmeta_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_miss_info: u32 = unsafe { ::std::mem::transmute(dv_miss_info) };
            dv_miss_info as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l3_vxlan_en: u32 = unsafe { ::std::mem::transmute(l3_vxlan_en) };
            l3_vxlan_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vf_nl_en: u32 = unsafe { ::std::mem::transmute(vf_nl_en) };
            vf_nl_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let lacp_by_user: u32 = unsafe { ::std::mem::transmute(lacp_by_user) };
            lacp_by_user as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let decap_en: u32 = unsafe { ::std::mem::transmute(decap_en) };
            decap_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let allow_duplicate_pattern: u32 =
                unsafe { ::std::mem::transmute(allow_duplicate_pattern) };
            allow_duplicate_pattern as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let lro_allowed: u32 = unsafe { ::std::mem::transmute(lro_allowed) };
            lro_allowed as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn fdb_def_rule(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_def_rule(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_def_rule_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_def_rule_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repr_matching(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repr_matching(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repr_matching_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repr_matching_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        fdb_def_rule: u32,
        repr_matching: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fdb_def_rule: u32 = unsafe { ::std::mem::transmute(fdb_def_rule) };
            fdb_def_rule as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let repr_matching: u32 = unsafe { ::std::mem::transmute(repr_matching) };
            repr_matching as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_vf_vlan {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl mlx5_vf_vlan {
    #[inline]
    pub fn tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn created(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_created(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn created_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_created_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(tag: u32, created: u32) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let tag: u32 = unsafe { ::std::mem::transmute(tag) };
            tag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let created: u32 = unsafe { ::std::mem::transmute(created) };
            created as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_drop {
    pub hrxq: *mut mlx5_hrxq,
    pub rxq: *mut mlx5_rxq_priv,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lb_ctx {
    pub qp: *mut ibv_qp,
    pub ibv_cq: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_external_q {
    pub hw_id: u32,
    pub refcnt: u32,
}
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_CREATE: mlx5_hw_job_type = 0;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_DESTROY: mlx5_hw_job_type = 1;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_UPDATE: mlx5_hw_job_type = 2;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_QUERY: mlx5_hw_job_type = 3;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_UPDATE_QUERY: mlx5_hw_job_type = 4;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_RSZTBL_FLOW_CREATE: mlx5_hw_job_type = 5;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_RSZTBL_FLOW_DESTROY: mlx5_hw_job_type = 6;
pub const mlx5_hw_job_type_MLX5_HW_Q_JOB_TYPE_RSZTBL_FLOW_MOVE: mlx5_hw_job_type = 7;
pub type mlx5_hw_job_type = ::std::os::raw::c_uint;
pub const mlx5_hw_indirect_type_MLX5_HW_INDIRECT_TYPE_LEGACY: mlx5_hw_indirect_type = 0;
pub const mlx5_hw_indirect_type_MLX5_HW_INDIRECT_TYPE_LIST: mlx5_hw_indirect_type = 1;
pub type mlx5_hw_indirect_type = ::std::os::raw::c_uint;
#[doc = " Container for flow action data constructed during flow rule creation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_action_params {
    #[doc = " Array of constructed modify header commands."]
    pub mhdr_cmd: [mlx5_modification_cmd; 65usize],
    #[doc = " Constructed encap/decap data buffer."]
    pub encap_data: [u8; 132usize],
    #[doc = " Constructed IPv6 routing data buffer."]
    pub ipv6_push_data: [u8; 128usize],
}
#[doc = " Container for dynamically generated flow items used during flow rule creation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_pattern_params {
    #[doc = " Array of dynamically generated flow items."]
    pub items: [rte_flow_item; 16usize],
    #[doc = " Temporary REPRESENTED_PORT item generated by PMD."]
    pub port_spec: rte_flow_item_ethdev,
    #[doc = " Temporary TAG item generated by PMD."]
    pub tag_spec: rte_flow_item_tag,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q_job {
    pub type_: u32,
    pub indirect_type: u32,
    pub action: *const ::std::os::raw::c_void,
    pub user_data: *mut ::std::os::raw::c_void,
    pub query: mlx5_hw_q_job__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q_job__bindgen_ty_1 {
    pub user: *mut ::std::os::raw::c_void,
    pub hw: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hw_q {
    pub job_idx: u32,
    pub size: u32,
    pub ongoing_flow_ops: u32,
    pub job: *mut *mut mlx5_hw_q_job,
    pub indir_cq: *mut rte_ring,
    pub indir_iq: *mut rte_ring,
    pub flow_transfer_pending: *mut rte_ring,
    pub flow_transfer_completed: *mut rte_ring,
    pub ap: mlx5_flow_hw_action_params,
    pub pp: mlx5_flow_hw_pattern_params,
}
pub const mlx5_counter_type_MLX5_COUNTER_TYPE_ORIGIN: mlx5_counter_type = 0;
pub const mlx5_counter_type_MLX5_COUNTER_TYPE_AGE: mlx5_counter_type = 1;
pub const mlx5_counter_type_MLX5_COUNTER_TYPE_MAX: mlx5_counter_type = 2;
pub type mlx5_counter_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_param {
    #[doc = "< Age state (atomically accessed)."]
    pub state: u16,
    #[doc = "< Port id of the counter."]
    pub port_id: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub sec_since_last_hit: u32,
    #[doc = "< Flow counter age context."]
    pub context: *mut ::std::os::raw::c_void,
}
impl mlx5_age_param {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_counter_stats {
    pub hits: u64,
    pub bytes: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_shared {
    pub __bindgen_anon_1: mlx5_flow_counter_shared__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter_shared__bindgen_ty_1 {
    pub refcnt: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter {
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_flow_counter__bindgen_ty_2,
    pub __bindgen_anon_3: mlx5_flow_counter__bindgen_ty_3,
    #[doc = "< Pointer to the dv action."]
    pub action: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_1 {
    pub next: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter,
    pub tqe_prev: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2 {
    pub shared_info: mlx5_flow_counter_shared,
    pub dcs_when_active: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_2 {
    #[doc = "< Reset value of hits packets."]
    pub hits: u64,
    #[doc = "< Counter pool."]
    pub pool: *mut mlx5_flow_counter_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_3 {
    #[doc = "< Reset value of bytes."]
    pub bytes: u64,
    pub dcs_when_free: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counters {
    pub tqh_first: *mut mlx5_flow_counter,
    pub tqh_last: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool {
    pub next: mlx5_flow_counter_pool__bindgen_ty_1,
    pub counters: [mlx5_counters; 2usize],
    pub min_dcs: *mut mlx5_devx_obj,
    pub time_of_last_age_check: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sl: rte_spinlock_t,
    pub csl: rte_spinlock_t,
    pub raw: *mut mlx5_counter_stats_raw,
    pub raw_hw: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter_pool,
    pub tqe_prev: *mut *mut mlx5_flow_counter_pool,
}
impl mlx5_flow_counter_pool {
    #[inline]
    pub fn index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_aged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_aged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_gen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_gen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_gen_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_gen_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        index: u32,
        is_aged: u32,
        query_gen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let index: u32 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_aged: u32 = unsafe { ::std::mem::transmute(is_aged) };
            is_aged as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let query_gen: u32 = unsafe { ::std::mem::transmute(query_gen) };
            query_gen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng {
    pub next: mlx5_counter_stats_mem_mng__bindgen_ty_1,
    pub raws: *mut mlx5_counter_stats_raw,
    pub wm: mlx5_pmd_wrapped_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_mem_mng,
    pub le_prev: *mut *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw {
    pub next: mlx5_counter_stats_raw__bindgen_ty_1,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub data: *mut flow_counter_stats,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_raw,
    pub le_prev: *mut *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_pools {
    pub tqh_first: *mut mlx5_flow_counter_pool,
    pub tqh_last: *mut *mut mlx5_flow_counter_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng {
    pub n_valid: u16,
    pub last_pool_idx: u16,
    pub min_id: ::std::os::raw::c_int,
    pub max_id: ::std::os::raw::c_int,
    pub pool_update_sl: rte_spinlock_t,
    pub csl: [rte_spinlock_t; 2usize],
    pub counters: [mlx5_counters; 2usize],
    pub pools: *mut *mut mlx5_flow_counter_pool,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub flow_counters: mlx5_counters,
    pub pending_queries: u8,
    pub pool_index: u16,
    pub query_thread_on: u8,
    pub counter_fallback: bool,
    pub mem_mngs: mlx5_flow_counter_mng_mem_mngs,
    pub free_stat_raws: mlx5_flow_counter_mng_stat_raws,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_mem_mngs {
    pub lh_first: *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_stat_raws {
    pub lh_first: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cq {
    pub log_desc_n: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub cq_obj: mlx5_devx_cq,
    pub errors: u64,
}
impl mlx5_aso_cq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_sq_elem__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1,
    pub mtr: *mut mlx5_aso_mtr,
    pub __bindgen_anon_2: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2,
    pub user_data: *mut ::std::os::raw::c_void,
    pub quota_obj: *mut mlx5_quota,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1 {
    pub pool: *mut mlx5_aso_age_pool,
    pub burst_size: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2 {
    pub ct: *mut mlx5_aso_ct_action,
    pub query_data: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq {
    pub log_desc_n: u16,
    pub sqsl: rte_spinlock_t,
    pub cq: mlx5_aso_cq,
    pub sq_obj: mlx5_devx_sq,
    pub mr: mlx5_pmd_mr,
    pub db: *mut mlx5_aso_wqe,
    pub pi: u16,
    pub db_pi: u16,
    pub head: u32,
    pub tail: u32,
    pub sqn: u32,
    pub elts: [mlx5_aso_sq_elem; 1024usize],
    pub next: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action {
    pub next: mlx5_aso_age_action__bindgen_ty_1,
    pub dr_action: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u16,
    pub age_params: mlx5_age_param,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_age_action,
    pub le_prev: *mut *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_pool {
    pub flow_hit_aso_obj: *mut mlx5_devx_obj,
    pub index: u16,
    pub time_of_last_age_check: u64,
    pub actions: [mlx5_aso_age_action; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_age_list {
    pub lh_first: *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_mng {
    pub pools: *mut *mut mlx5_aso_age_pool,
    pub n: u16,
    pub next: u16,
    pub resize_rwl: rte_rwlock_t,
    pub free_sl: rte_spinlock_t,
    pub free: aso_age_list,
    pub aso_sq: mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_option_resource {
    pub obj: *mut mlx5_devx_obj,
    pub option_class: rte_be16_t,
    pub option_type: u8,
    pub length: u8,
    pub refcnt: u32,
}
#[repr(C)]
pub struct mlx5_hws_q_age_info {
    pub nb_rings: u16,
    pub aged_lists: __IncompleteArrayField<*mut rte_ring>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_age_info {
    pub aged_list: *mut rte_ring,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info {
    pub flags: u8,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_age_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_1 {
    pub aged_counters: mlx5_counters,
    pub aged_aso: aso_age_list,
    pub aged_sl: rte_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_2 {
    pub ages_ipool: *mut mlx5_indexed_pool,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub hw_age: mlx5_hws_age_info,
    pub hw_q_age: *mut mlx5_hws_q_age_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_shared_port {
    pub ih_port_id: u32,
    pub devx_ih_port_id: u32,
    pub nl_ih_port_id: u32,
    pub age_info: mlx5_age_info,
}
pub const mlx5_meter_domain_MLX5_MTR_DOMAIN_INGRESS: mlx5_meter_domain = 0;
pub const mlx5_meter_domain_MLX5_MTR_DOMAIN_EGRESS: mlx5_meter_domain = 1;
pub const mlx5_meter_domain_MLX5_MTR_DOMAIN_TRANSFER: mlx5_meter_domain = 2;
pub const mlx5_meter_domain_MLX5_MTR_DOMAIN_MAX: mlx5_meter_domain = 3;
pub type mlx5_meter_domain = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule {
    pub rule: *mut ::std::os::raw::c_void,
    pub matcher: *mut mlx5_flow_dv_matcher,
    pub next_port: mlx5_sub_policy_color_rule__bindgen_ty_1,
    pub src_port: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_sub_policy_color_rule,
    pub tqe_prev: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rules {
    pub tqh_first: *mut mlx5_sub_policy_color_rule,
    pub tqh_last: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_sub_policy {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub main_policy: *mut ::std::os::raw::c_void,
    pub tbl_rsc: *mut mlx5_flow_tbl_resource,
    pub rix_hrxq: [u32; 2usize],
    pub jump_tbl: [*mut mlx5_flow_tbl_resource; 2usize],
    pub color_rules: [mlx5_sub_policy_color_rules; 3usize],
}
impl mlx5_flow_meter_sub_policy {
    #[inline]
    pub fn main_policy_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_policy_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn main_policy_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_main_policy_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_idx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(main_policy_id: u32, idx: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let main_policy_id: u32 = unsafe { ::std::mem::transmute(main_policy_id) };
            main_policy_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let idx: u32 = unsafe { ::std::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_meter_policy_acts {
    pub actions_n: u8,
    pub dv_actions: [*mut ::std::os::raw::c_void; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_meter_policy_action_container {
    pub rix_mark: u32,
    pub modify_hdr: *mut mlx5_flow_dv_modify_hdr_resource,
    pub fate_action: u8,
    pub __bindgen_anon_1: mlx5_meter_policy_action_container__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_meter_policy_action_container__bindgen_ty_1 {
    pub rss: *mut rte_flow_action,
    pub rix_port_id_action: u32,
    pub dr_jump_action: [*mut ::std::os::raw::c_void; 3usize],
    pub queue: u16,
    pub __bindgen_anon_1: mlx5_meter_policy_action_container__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_meter_policy_action_container__bindgen_ty_1__bindgen_ty_1 {
    pub next_mtr_id: u32,
    pub next_sub_policy: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_policy {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub group: u16,
    pub sl: rte_spinlock_t,
    pub ref_cnt: u32,
    pub hws_item_templ: *mut rte_flow_pattern_template,
    pub hws_act_templ: [*mut rte_flow_actions_template; 3usize],
    pub hws_flow_table: [*mut rte_flow_template_table; 3usize],
    pub hws_flow_rule: [[*mut rte_flow; 3usize]; 3usize],
    pub act_cnt: [mlx5_meter_policy_action_container; 2usize],
    pub dr_drop_action: [*mut ::std::os::raw::c_void; 3usize],
    pub sub_policy_num: u16,
    pub sub_policys: [*mut *mut mlx5_flow_meter_sub_policy; 3usize],
}
impl mlx5_flow_meter_policy {
    #[inline]
    pub fn is_rss(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_rss(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_rss_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_rss_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_queue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_queue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_queue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_queue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_hierarchy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hierarchy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_hierarchy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_hierarchy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn match_port(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_match_port(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn match_port_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_match_port_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchy_match_port(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchy_match_port(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchy_match_port_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchy_match_port_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_r(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_r(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_r_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_r_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_y_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_y_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_g(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_g_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_g_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_rss: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
        is_queue: u32,
        is_hierarchy: u32,
        match_port: u32,
        hierarchy_match_port: u32,
        skip_r: u32,
        skip_y: u32,
        skip_g: u32,
        mark: u32,
        initialized: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_rss: u32 = unsafe { ::std::mem::transmute(is_rss) };
            is_rss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_queue: u32 = unsafe { ::std::mem::transmute(is_queue) };
            is_queue as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_hierarchy: u32 = unsafe { ::std::mem::transmute(is_hierarchy) };
            is_hierarchy as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let match_port: u32 = unsafe { ::std::mem::transmute(match_port) };
            match_port as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hierarchy_match_port: u32 = unsafe { ::std::mem::transmute(hierarchy_match_port) };
            hierarchy_match_port as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skip_r: u32 = unsafe { ::std::mem::transmute(skip_r) };
            skip_r as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let skip_y: u32 = unsafe { ::std::mem::transmute(skip_y) };
            skip_y as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let skip_g: u32 = unsafe { ::std::mem::transmute(skip_g) };
            skip_g as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mark: u32 = unsafe { ::std::mem::transmute(mark) };
            mark as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_def_policy {
    pub sub_policy: mlx5_flow_meter_sub_policy,
    pub dr_jump_action: [*mut ::std::os::raw::c_void; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_info {
    pub meter_id: u32,
    pub policy_id: u32,
    pub profile: *mut mlx5_flow_meter_profile,
    #[doc = "< Meter action spinlock."]
    pub sl: rte_spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub drop_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub drop_cnt: u32,
    pub ref_cnt: u32,
    pub flow_ipool: *mut mlx5_indexed_pool,
    pub meter_action_g: *mut ::std::os::raw::c_void,
    pub meter_action_y: *mut ::std::os::raw::c_void,
    pub meter_offset: u32,
    pub group: u16,
}
impl mlx5_flow_meter_info {
    #[inline]
    pub fn bytes_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkts_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkts_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkts_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkts_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_active_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn def_policy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_def_policy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn def_policy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_def_policy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color_aware(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_aware(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_aware_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_color_aware_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bytes_dropped: u32,
        pkts_dropped: u32,
        active_state: u32,
        shared: u32,
        is_enable: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
        def_policy: u32,
        initialized: u32,
        color_aware: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bytes_dropped: u32 = unsafe { ::std::mem::transmute(bytes_dropped) };
            bytes_dropped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pkts_dropped: u32 = unsafe { ::std::mem::transmute(pkts_dropped) };
            pkts_dropped as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let active_state: u32 = unsafe { ::std::mem::transmute(active_state) };
            active_state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_enable: u32 = unsafe { ::std::mem::transmute(is_enable) };
            is_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let def_policy: u32 = unsafe { ::std::mem::transmute(def_policy) };
            def_policy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let color_aware: u32 = unsafe { ::std::mem::transmute(color_aware) };
            color_aware as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_srtcm_rfc2697_prm {
    pub cbs_cir: rte_be32_t,
    pub ebs_eir: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile {
    pub next: mlx5_flow_meter_profile__bindgen_ty_1,
    #[doc = "< Profile id."]
    pub id: u32,
    #[doc = "< Profile detail."]
    pub profile: rte_mtr_meter_profile,
    pub __bindgen_anon_1: mlx5_flow_meter_profile__bindgen_ty_2,
    #[doc = "< Use count."]
    pub ref_cnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_meter_profile,
    pub tqe_prev: *mut *mut mlx5_flow_meter_profile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_meter_profile__bindgen_ty_2 {
    pub srtcm_prm: mlx5_flow_meter_srtcm_rfc2697_prm,
}
impl mlx5_flow_meter_profile {
    #[inline]
    pub fn g_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_g_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn g_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_g_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn y_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_y_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn y_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_y_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        g_support: u32,
        y_support: u32,
        initialized: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let g_support: u32 = unsafe { ::std::mem::transmute(g_support) };
            g_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_support: u32 = unsafe { ::std::mem::transmute(y_support) };
            y_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mlx5_aso_mtr_state_ASO_METER_FREE: mlx5_aso_mtr_state = 0;
pub const mlx5_aso_mtr_state_ASO_METER_WAIT: mlx5_aso_mtr_state = 1;
pub const mlx5_aso_mtr_state_ASO_METER_WAIT_ASYNC: mlx5_aso_mtr_state = 2;
pub const mlx5_aso_mtr_state_ASO_METER_READY: mlx5_aso_mtr_state = 3;
pub type mlx5_aso_mtr_state = ::std::os::raw::c_uint;
pub const mlx5_aso_mtr_type_ASO_METER_INDIRECT: mlx5_aso_mtr_type = 0;
pub const mlx5_aso_mtr_type_ASO_METER_DIRECT: mlx5_aso_mtr_type = 1;
pub type mlx5_aso_mtr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr {
    pub __bindgen_anon_1: mlx5_aso_mtr__bindgen_ty_1,
    pub type_: mlx5_aso_mtr_type,
    pub fm: mlx5_flow_meter_info,
    #[doc = "< ASO flow meter state."]
    pub state: u8,
    pub offset: u32,
    pub init_color: rte_color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_mtr__bindgen_ty_1 {
    pub next: mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1,
    pub pool: *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_mtr,
    pub le_prev: *mut *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pool {
    pub mtrs: [mlx5_aso_mtr; 128usize],
    pub devx_obj: *mut mlx5_devx_obj,
    pub action: *mut mlx5dr_action,
    pub idx_pool: *mut mlx5_indexed_pool,
    pub index: u32,
    pub nb_sq: u32,
    pub sq: *mut mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_meter_list {
    pub lh_first: *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pools_mng {
    pub n_valid: u16,
    pub n: u16,
    pub mtrsl: rte_spinlock_t,
    pub resize_mtrwl: rte_rwlock_t,
    pub meters: aso_meter_list,
    pub sq: mlx5_aso_sq,
    pub pools: *mut *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mtr_bulk {
    pub size: u32,
    pub action: *mut mlx5dr_action,
    pub devx_obj: *mut mlx5_devx_obj,
    pub aso: *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_mtr_mng {
    pub pools_mng: mlx5_aso_mtr_pools_mng,
    pub def_policy: [*mut mlx5_flow_meter_def_policy; 3usize],
    pub def_policy_id: u32,
    pub def_policy_ref_cnt: u32,
    #[doc = " def_policy meter use count."]
    pub drop_tbl: [*mut mlx5_flow_tbl_resource; 3usize],
    pub drop_matcher: [[*mut mlx5_flow_dv_matcher; 32usize]; 3usize],
    pub def_matcher: [*mut mlx5_flow_dv_matcher; 3usize],
    pub def_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub max_mtr_bits: u8,
    pub max_mtr_flow_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_tbl_key {
    pub __bindgen_anon_1: mlx5_flow_tbl_key__bindgen_ty_1,
    #[doc = "< full 64bits value of key"]
    pub v64: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tbl_key__bindgen_ty_1 {
    #[doc = "< Level of the table."]
    pub level: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mlx5_flow_tbl_key__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dummy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dummy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dummy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_fdb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_fdb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_fdb_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_fdb_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        id: u32,
        dummy: u32,
        is_fdb: u32,
        is_egress: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let dummy: u32 = unsafe { ::std::mem::transmute(dummy) };
            dummy as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let is_fdb: u32 = unsafe { ::std::mem::transmute(is_fdb) };
            is_fdb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let is_egress: u32 = unsafe { ::std::mem::transmute(is_egress) };
            is_egress as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tbl_resource {
    #[doc = "< Pointer to DR table object."]
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_id_pool {
    #[doc = "< Pointer to the a array of free values."]
    pub free_arr: *mut u32,
    pub base_index: u32,
    #[doc = "< Pointer to the index to pop."]
    pub curr: *mut u32,
    #[doc = "< Pointer to the last element in the empty array."]
    pub last: *mut u32,
    #[doc = "< Maximum id can be allocated from the pool."]
    pub max_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_wq {
    pub cq_obj: mlx5_devx_cq,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sq_obj: mlx5_devx_sq,
    pub sq_size: u16,
    pub sq_ci: u16,
}
impl mlx5_txpp_wq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arm_sn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arm_sn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arm_sn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arm_sn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32, arm_sn: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let arm_sn: u32 = unsafe { ::std::mem::transmute(arm_sn) };
            arm_sn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_ts {
    pub ci_ts: u64,
    pub ts: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_txpp {
    pub mutex: pthread_mutex_t,
    pub refcnt: u32,
    pub freq: u32,
    pub tick: u32,
    pub test: u32,
    pub skew: i32,
    pub intr_handle: *mut rte_intr_handle,
    pub echan: *mut ::std::os::raw::c_void,
    pub clock_queue: mlx5_txpp_wq,
    pub rearm_queue: mlx5_txpp_wq,
    pub pp: *mut ::std::os::raw::c_void,
    pub pp_id: u16,
    pub ts_n: u16,
    pub ts_p: u16,
    pub tsa: *mut mlx5_txpp_ts,
    pub ts: mlx5_txpp_ts,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub err_miss_int: u64,
    pub err_rearm_queue: u64,
    pub err_clock_queue: u64,
    pub err_ts_past: u64,
    pub err_ts_future: u64,
    pub err_ts_order: u64,
}
impl mlx5_dev_txpp {
    #[inline]
    pub fn sync_lost(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync_lost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sync_lost_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sync_lost_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sync_lost: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sync_lost: u32 = unsafe { ::std::mem::transmute(sync_lost) };
            sync_lost as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ecpri_parser_profile {
    pub num: u32,
    pub ids: [u32; 8usize],
    pub offset: [u8; 8usize],
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info {
    pub n_port: ::std::os::raw::c_int,
    pub ifindex: u32,
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ports: [mlx5_bond_info__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info__bindgen_ty_1 {
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ifindex: u32,
    pub pci_addr: rte_pci_addr,
}
pub const mlx5_aso_ct_state_ASO_CONNTRACK_FREE: mlx5_aso_ct_state = 0;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT: mlx5_aso_ct_state = 1;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT_ASYNC: mlx5_aso_ct_state = 2;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_READY: mlx5_aso_ct_state = 3;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_QUERY: mlx5_aso_ct_state = 4;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_MAX: mlx5_aso_ct_state = 5;
pub type mlx5_aso_ct_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1,
    pub dr_action_orig: *mut ::std::os::raw::c_void,
    pub dr_action_rply: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u32,
    pub peer: u16,
    pub state: mlx5_aso_ct_state,
    pub is_original: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_action__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1 {
    pub next: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_ct_action,
    pub le_prev: *mut *mut mlx5_aso_ct_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2 {
    pub pool: *mut mlx5_aso_ct_pool,
}
#[repr(C)]
pub struct mlx5_aso_ct_pool {
    pub index: u16,
    pub cts: *mut mlx5_indexed_pool,
    pub devx_obj: *mut mlx5_devx_obj,
    pub __bindgen_anon_1: mlx5_aso_ct_pool__bindgen_ty_1,
    pub sq: *mut mlx5_aso_sq,
    pub shared_sq: *mut mlx5_aso_sq,
    pub actions: __IncompleteArrayField<mlx5_aso_ct_action>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_pool__bindgen_ty_1 {
    pub dummy_action: *mut ::std::os::raw::c_void,
    pub dr_action: *mut mlx5dr_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_ct_list {
    pub lh_first: *mut mlx5_aso_ct_action,
}
#[repr(C)]
pub struct mlx5_aso_ct_pools_mng {
    pub pools: *mut *mut mlx5_aso_ct_pool,
    pub n: u16,
    pub next: u16,
    pub nb_sq: u32,
    pub ct_sl: rte_spinlock_t,
    pub resize_rwl: rte_rwlock_t,
    pub free_cts: aso_ct_list,
    pub aso_sqs: __IncompleteArrayField<mlx5_aso_sq>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lag {
    pub tx_remap_affinity: [u8; 16usize],
    pub affinity_mode: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_parser_devx {
    pub entry: mlx5_list_entry,
    pub num_samples: u32,
    pub anchor_id: u8,
    pub devx_obj: *mut ::std::os::raw::c_void,
    pub devx_conf: mlx5_devx_graph_node_attr,
    pub sample_ids: [u32; 8usize],
    pub sample_info: [mlx5_devx_match_sample_info_query_attr; 8usize],
}
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct mlx5_flex_pattern_field {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl mlx5_flex_pattern_field {
    #[inline]
    pub fn width(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn width_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_width_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shift_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_shift_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_id(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_reg_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_id_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reg_id_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        width: u16,
        shift: u16,
        reg_id: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let width: u16 = unsafe { ::std::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let shift: u16 = unsafe { ::std::mem::transmute(shift) };
            shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let reg_id: u16 = unsafe { ::std::mem::transmute(reg_id) };
            reg_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_item {
    pub devx_fp: *mut mlx5_flex_parser_devx,
    pub refcnt: u32,
    pub tunnel_mode: rte_flow_item_flex_tunnel_mode,
    pub mapnum: u32,
    pub map: [mlx5_flex_pattern_field; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_internal_flex_parser_profile {
    pub refcnt: u32,
    pub flex: mlx5_flex_item,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_send_to_kernel_action {
    pub action: *mut ::std::os::raw::c_void,
    pub tbl: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_aso_mng {
    pub sq_num: u16,
    pub sqs: [mlx5_aso_sq; 4usize],
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_svc_mng {
    pub refcnt: u32,
    pub service_core: u32,
    pub query_interval: u32,
    pub service_thread: rte_thread_t,
    pub svc_running: u8,
    pub __bindgen_padding_0: [u64; 4usize],
    pub aso_mng: mlx5_hws_aso_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_registers {
    pub aso_reg: modify_reg,
    pub hw_avl_tags: [modify_reg; 12usize],
    pub nat64_regs: [modify_reg; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_options {
    _unused: [u8; 0],
}
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_UNKNOWN: mlx5_ipv6_tc_support = 0;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_FALLBACK: mlx5_ipv6_tc_support = 1;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_OK: mlx5_ipv6_tc_support = 2;
pub type mlx5_ipv6_tc_support = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_nic_config {
    pub ipv6_tc_fallback: mlx5_ipv6_tc_support,
}
#[doc = " Physical device structure.\n This device is created once per NIC to manage recourses shared by all ports\n under same physical device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device {
    pub next: mlx5_physical_device__bindgen_ty_1,
    pub ctx: *mut ::std::os::raw::c_void,
    pub guid: u64,
    pub tlv_options: *mut mlx5_geneve_tlv_options,
    pub config: mlx5_common_nic_config,
    pub refcnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device__bindgen_ty_1 {
    pub le_next: *mut mlx5_physical_device,
    pub le_prev: *mut *mut mlx5_physical_device,
}
#[repr(C)]
pub struct mlx5_dev_ctx_shared {
    pub next: mlx5_dev_ctx_shared__bindgen_ty_1,
    pub refcnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hws_max_nb_counters: u32,
    pub max_port: u32,
    pub bond: mlx5_bond_info,
    pub cdev: *mut mlx5_common_device,
    pub phdev: *mut mlx5_physical_device,
    pub tdn: u32,
    pub ibdev_name: [::std::os::raw::c_char; 65usize],
    pub ibdev_path: [::std::os::raw::c_char; 257usize],
    pub dev_cap: mlx5_dev_cap,
    pub config: mlx5_sh_config,
    pub numa_node: ::std::os::raw::c_int,
    pub txpp: mlx5_dev_txpp,
    pub dv_meta_mask: u32,
    pub dv_mark_mask: u32,
    pub dv_regc0_mask: u32,
    pub fdb_domain: *mut ::std::os::raw::c_void,
    pub rx_domain: *mut ::std::os::raw::c_void,
    pub tx_domain: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_dev_ctx_shared__bindgen_ty_2,
    pub mreg_cp_tbl: *mut mlx5_hlist,
    pub tunnel_hub: *mut mlx5_flow_tunnel_hub,
    pub dr_drop_action: *mut ::std::os::raw::c_void,
    pub pop_vlan_action: *mut ::std::os::raw::c_void,
    pub send_to_kernel_action: [mlx5_send_to_kernel_action; 6usize],
    pub encaps_decaps: *mut mlx5_hlist,
    pub modify_cmds: *mut mlx5_hlist,
    pub tag_table: *mut mlx5_hlist,
    pub port_id_action_list: *mut mlx5_list,
    pub push_vlan_action_list: *mut mlx5_list,
    pub sample_action_list: *mut mlx5_list,
    pub dest_array_list: *mut mlx5_list,
    pub flex_parsers_dv: *mut mlx5_list,
    pub sws_cmng: mlx5_flow_counter_mng,
    pub default_miss_action: *mut ::std::os::raw::c_void,
    pub ipool: [*mut mlx5_indexed_pool; 17usize],
    pub mdh_ipools: [*mut mlx5_indexed_pool; 32usize],
    pub intr_handle: *mut rte_intr_handle,
    pub intr_handle_devx: *mut rte_intr_handle,
    pub intr_handle_nl: *mut rte_intr_handle,
    pub intr_handle_ib: *mut rte_intr_handle,
    pub devx_comp: *mut ::std::os::raw::c_void,
    pub tis: [*mut mlx5_devx_obj; 16usize],
    pub td: *mut mlx5_devx_obj,
    pub lag: mlx5_lag,
    pub tx_uar: mlx5_uar,
    pub rx_uar: mlx5_uar,
    pub pppriv: *mut mlx5_proc_priv,
    pub ecpri_parser: mlx5_ecpri_parser_profile,
    pub srh_flex_parser: mlx5_internal_flex_parser_profile,
    pub shared_rxqs: mlx5_dev_ctx_shared_shared_rxqs,
    pub aso_age_mng: *mut mlx5_aso_age_mng,
    pub geneve_tlv_option_resource: *mut mlx5_geneve_tlv_option_resource,
    pub geneve_tlv_opt_sl: rte_spinlock_t,
    pub mtrmng: *mut mlx5_flow_mtr_mng,
    pub ct_mng: *mut mlx5_aso_ct_pools_mng,
    pub self_lb: mlx5_lb_ctx,
    pub flow_max_priority: ::std::os::raw::c_uint,
    pub flow_mreg_c: [modify_reg; 8usize],
    pub devx_channel_lwm: *mut ::std::os::raw::c_void,
    pub intr_handle_lwm: *mut rte_intr_handle,
    pub lwm_config_lock: pthread_mutex_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: *mut mlx5_hws_cnt_svc_mng,
    pub cpool_lock: rte_spinlock_t,
    pub hws_cpool_list: mlx5_dev_ctx_shared_hws_cpool_list,
    pub registers: mlx5_dev_registers,
    pub port: __IncompleteArrayField<mlx5_dev_shared_port>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared__bindgen_ty_1 {
    pub le_next: *mut mlx5_dev_ctx_shared,
    pub le_prev: *mut *mut mlx5_dev_ctx_shared,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_dev_ctx_shared__bindgen_ty_2 {
    pub flow_tbls: *mut mlx5_hlist,
    pub groups: *mut mlx5_hlist,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_shared_rxqs {
    pub lh_first: *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_hws_cpool_list {
    pub lh_first: *mut mlx5_hws_cnt_pool,
}
impl mlx5_dev_ctx_shared {
    #[inline]
    pub fn esw_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn meter_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meter_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn meter_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_meter_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_0_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_0_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_0_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_0_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_2_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_2_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_2_3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_2_3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn misc5_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_misc5_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn misc5_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_misc5_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dr_root_drop_action_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dr_root_drop_action_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dr_root_drop_action_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dr_root_drop_action_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn drop_action_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drop_action_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn drop_action_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_drop_action_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_priority_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_priority_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_priority_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_priority_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn metadata_regc_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_regc_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn metadata_regc_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_metadata_regc_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared_mark_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared_mark_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_mark_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_mark_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hws_max_log_bulk_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hws_max_log_bulk_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_max_log_bulk_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_max_log_bulk_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rdma_monitor_supp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdma_monitor_supp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rdma_monitor_supp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rdma_monitor_supp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        esw_mode: u32,
        flow_hit_aso_en: u32,
        steering_format_version: u32,
        meter_aso_en: u32,
        ct_aso_en: u32,
        tunnel_header_0_1: u32,
        tunnel_header_2_3: u32,
        misc5_cap: u32,
        dr_root_drop_action_en: u32,
        drop_action_check_flag: u32,
        flow_priority_check_flag: u32,
        metadata_regc_check_flag: u32,
        shared_mark_enabled: u32,
        lag_rx_port_affinity_en: u32,
        hws_max_log_bulk_sz: u32,
        rdma_monitor_supp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let esw_mode: u32 = unsafe { ::std::mem::transmute(esw_mode) };
            esw_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso_en: u32 = unsafe { ::std::mem::transmute(flow_hit_aso_en) };
            flow_hit_aso_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let meter_aso_en: u32 = unsafe { ::std::mem::transmute(meter_aso_en) };
            meter_aso_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ct_aso_en: u32 = unsafe { ::std::mem::transmute(ct_aso_en) };
            ct_aso_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tunnel_header_0_1: u32 = unsafe { ::std::mem::transmute(tunnel_header_0_1) };
            tunnel_header_0_1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tunnel_header_2_3: u32 = unsafe { ::std::mem::transmute(tunnel_header_2_3) };
            tunnel_header_2_3 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let misc5_cap: u32 = unsafe { ::std::mem::transmute(misc5_cap) };
            misc5_cap as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dr_root_drop_action_en: u32 =
                unsafe { ::std::mem::transmute(dr_root_drop_action_en) };
            dr_root_drop_action_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let drop_action_check_flag: u32 =
                unsafe { ::std::mem::transmute(drop_action_check_flag) };
            drop_action_check_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let flow_priority_check_flag: u32 =
                unsafe { ::std::mem::transmute(flow_priority_check_flag) };
            flow_priority_check_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let metadata_regc_check_flag: u32 =
                unsafe { ::std::mem::transmute(metadata_regc_check_flag) };
            metadata_regc_check_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let shared_mark_enabled: u32 = unsafe { ::std::mem::transmute(shared_mark_enabled) };
            shared_mark_enabled as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let lag_rx_port_affinity_en: u32 =
                unsafe { ::std::mem::transmute(lag_rx_port_affinity_en) };
            lag_rx_port_affinity_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let hws_max_log_bulk_sz: u32 = unsafe { ::std::mem::transmute(hws_max_log_bulk_sz) };
            hws_max_log_bulk_sz as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rdma_monitor_supp: u32 = unsafe { ::std::mem::transmute(rdma_monitor_supp) };
            rdma_monitor_supp as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn host_shaper_rate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_host_shaper_rate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn host_shaper_rate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_host_shaper_rate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_triggered(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_triggered(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_triggered_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_triggered_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        host_shaper_rate: u32,
        lwm_triggered: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let host_shaper_rate: u32 = unsafe { ::std::mem::transmute(host_shaper_rate) };
            host_shaper_rate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let lwm_triggered: u32 = unsafe { ::std::mem::transmute(lwm_triggered) };
            lwm_triggered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct mlx5_proc_priv {
    pub hca_bar: *mut ::std::os::raw::c_void,
    pub uar_table_sz: usize,
    pub uar_table: __IncompleteArrayField<mlx5_uar_data>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mtr_profiles {
    pub tqh_first: *mut mlx5_flow_meter_profile,
    pub tqh_last: *mut *mut mlx5_flow_meter_profile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_legacy_flow_meters {
    pub tqh_first: *mut mlx5_legacy_flow_meter,
    pub tqh_last: *mut *mut mlx5_legacy_flow_meter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mtr_config {
    #[doc = "< Number of configured meters"]
    pub nb_meters: u32,
    #[doc = "< Number of configured meter profiles"]
    pub nb_meter_profiles: u32,
    #[doc = "< Number of configured meter policies"]
    pub nb_meter_policies: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_rss_desc {
    #[doc = "< Symmetric hash function"]
    pub symmetric_hash_function: bool,
    pub level: u32,
    #[doc = "< Number of entries in @p queue."]
    pub queue_num: u32,
    #[doc = "< Specific RSS hash types (see RTE_ETH_RSS_*)."]
    pub types: u64,
    pub hash_fields: u64,
    #[doc = "< RSS hash key."]
    pub key: [u8; 40usize],
    #[doc = "< RSS hash key len."]
    pub key_len: u32,
    #[doc = "< HW steering action."]
    pub hws_flags: u32,
    #[doc = "< Queue in tunnel."]
    pub tunnel: u32,
    #[doc = "< Shared RSS index."]
    pub shared_rss: u32,
    pub ind_tbl: *mut mlx5_ind_table_obj,
    pub __bindgen_anon_1: mlx5_flow_rss_desc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_rss_desc__bindgen_ty_1 {
    #[doc = "< Destination queues."]
    pub queue: *mut u16,
    #[doc = "< Const pointer convert."]
    pub const_q: *const u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj {
    pub next: mlx5_rxq_obj__bindgen_ty_1,
    pub rxq_ctrl: *mut mlx5_rxq_ctrl,
    pub fd: ::std::os::raw::c_int,
    pub __bindgen_anon_1: mlx5_rxq_obj__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_obj,
    pub le_prev: *mut *mut mlx5_rxq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_rxq_obj__bindgen_ty_2 {
    pub __bindgen_anon_1: mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_1,
    pub rq: *mut mlx5_devx_obj,
    pub __bindgen_anon_2: mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_1 {
    pub wq: *mut ::std::os::raw::c_void,
    pub ibv_cq: *mut ::std::os::raw::c_void,
    pub ibv_channel: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_obj__bindgen_ty_2__bindgen_ty_2 {
    pub devx_rmp: mlx5_devx_rmp,
    pub cq_obj: mlx5_devx_cq,
    pub devx_channel: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ind_table_obj {
    pub next: mlx5_ind_table_obj__bindgen_ty_1,
    pub refcnt: u32,
    pub __bindgen_anon_1: mlx5_ind_table_obj__bindgen_ty_2,
    #[doc = "< Number of queues in the list."]
    pub queues_n: u32,
    #[doc = "< Queue list."]
    pub queues: *mut u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ind_table_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_ind_table_obj,
    pub le_prev: *mut *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ind_table_obj__bindgen_ty_2 {
    #[doc = "< Indirection table."]
    pub ind_table: *mut ::std::os::raw::c_void,
    pub rqt: *mut mlx5_devx_obj,
}
#[repr(C)]
pub struct mlx5_hrxq {
    pub entry: mlx5_list_entry,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ind_table: *mut mlx5_ind_table_obj,
    pub __bindgen_anon_1: mlx5_hrxq__bindgen_ty_1,
    pub action: *mut ::std::os::raw::c_void,
    pub symmetric_hash_function: bool,
    pub hws_flags: u32,
    pub hash_fields: u64,
    pub rss_key_len: u32,
    pub idx: u32,
    pub rss_key: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_hrxq__bindgen_ty_1 {
    pub qp: *mut ::std::os::raw::c_void,
    pub tir: *mut mlx5_devx_obj,
}
impl mlx5_hrxq {
    #[inline]
    pub fn standalone(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_standalone(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn standalone_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_standalone_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(standalone: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let standalone: u32 = unsafe { ::std::mem::transmute(standalone) };
            standalone as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj {
    pub next: mlx5_txq_obj__bindgen_ty_1,
    pub txq_ctrl: *mut mlx5_txq_ctrl,
    pub __bindgen_anon_1: mlx5_txq_obj__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_1 {
    pub le_next: *mut mlx5_txq_obj,
    pub le_prev: *mut *mut mlx5_txq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_txq_obj__bindgen_ty_2 {
    pub __bindgen_anon_1: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_2,
    pub __bindgen_anon_3: mlx5_txq_obj__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_1 {
    pub cq: *mut ::std::os::raw::c_void,
    pub qp: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_2 {
    pub sq: *mut mlx5_devx_obj,
    pub tis: *mut mlx5_devx_obj,
    pub umem_buf_wq_buffer: *mut ::std::os::raw::c_void,
    pub umem_obj_wq_buffer: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_obj__bindgen_ty_2__bindgen_ty_3 {
    pub dev: *mut rte_eth_dev,
    pub cq_obj: mlx5_devx_cq,
    pub sq_obj: mlx5_devx_sq,
}
pub const mlx5_rxq_modify_type_MLX5_RXQ_MOD_ERR2RST: mlx5_rxq_modify_type = 0;
pub const mlx5_rxq_modify_type_MLX5_RXQ_MOD_RST2RDY: mlx5_rxq_modify_type = 1;
pub const mlx5_rxq_modify_type_MLX5_RXQ_MOD_RDY2ERR: mlx5_rxq_modify_type = 2;
pub const mlx5_rxq_modify_type_MLX5_RXQ_MOD_RDY2RST: mlx5_rxq_modify_type = 3;
pub const mlx5_rxq_modify_type_MLX5_RXQ_MOD_RDY2RDY: mlx5_rxq_modify_type = 4;
pub type mlx5_rxq_modify_type = ::std::os::raw::c_uint;
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_RST2RDY: mlx5_txq_modify_type = 0;
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_RDY2RST: mlx5_txq_modify_type = 1;
pub const mlx5_txq_modify_type_MLX5_TXQ_MOD_ERR2RDY: mlx5_txq_modify_type = 2;
pub type mlx5_txq_modify_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_obj_ops {
    pub rxq_obj_modify_vlan_strip: ::std::option::Option<
        unsafe extern "C" fn(
            rxq: *mut mlx5_rxq_priv,
            on: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_modify_counter_set_id: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv, counter_set_id: u32) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_new: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv) -> ::std::os::raw::c_int,
    >,
    pub rxq_event_get: ::std::option::Option<
        unsafe extern "C" fn(rxq_obj: *mut mlx5_rxq_obj) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_modify: ::std::option::Option<
        unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv, type_: u8) -> ::std::os::raw::c_int,
    >,
    pub rxq_obj_release: ::std::option::Option<unsafe extern "C" fn(rxq: *mut mlx5_rxq_priv)>,
    pub rxq_event_get_lwm: ::std::option::Option<
        unsafe extern "C" fn(
            priv_: *mut mlx5_priv,
            rxq_idx: *mut ::std::os::raw::c_int,
            port_id: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_new: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            log_n: ::std::os::raw::c_uint,
            ind_tbl: *mut mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_modify: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            log_n: ::std::os::raw::c_uint,
            queues: *const u16,
            queues_n: u32,
            ind_tbl: *mut mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub ind_table_destroy:
        ::std::option::Option<unsafe extern "C" fn(ind_tbl: *mut mlx5_ind_table_obj)>,
    pub hrxq_new: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            hrxq: *mut mlx5_hrxq,
            tunnel: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub hrxq_modify: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut rte_eth_dev,
            hrxq: *mut mlx5_hrxq,
            rss_key: *const u8,
            hash_fields: u64,
            symmetric_hash_function: bool,
            ind_tbl: *const mlx5_ind_table_obj,
        ) -> ::std::os::raw::c_int,
    >,
    pub hrxq_destroy: ::std::option::Option<unsafe extern "C" fn(hrxq: *mut mlx5_hrxq)>,
    pub drop_action_create:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>,
    pub drop_action_destroy: ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>,
    pub txq_obj_new: ::std::option::Option<
        unsafe extern "C" fn(dev: *mut rte_eth_dev, idx: u16) -> ::std::os::raw::c_int,
    >,
    pub txq_obj_modify: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut mlx5_txq_obj,
            type_: mlx5_txq_modify_type,
            dev_port: u8,
        ) -> ::std::os::raw::c_int,
    >,
    pub txq_obj_release: ::std::option::Option<unsafe extern "C" fn(txq_obj: *mut mlx5_txq_obj)>,
    pub lb_dummy_queue_create:
        ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>,
    pub lb_dummy_queue_release: ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>,
}
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_GENERAL: mlx5_ctrl_flow_type = 0;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_SQ_MISS_ROOT: mlx5_ctrl_flow_type = 1;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_SQ_MISS: mlx5_ctrl_flow_type = 2;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_JUMP: mlx5_ctrl_flow_type = 3;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_TX_META_COPY: mlx5_ctrl_flow_type = 4;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_TX_REPR_MATCH: mlx5_ctrl_flow_type = 5;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_LACP_RX: mlx5_ctrl_flow_type = 6;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS: mlx5_ctrl_flow_type = 7;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS_UNICAST_DMAC: mlx5_ctrl_flow_type =
    8;
pub const mlx5_ctrl_flow_type_MLX5_CTRL_FLOW_TYPE_DEFAULT_RX_RSS_UNICAST_DMAC_VLAN:
    mlx5_ctrl_flow_type = 9;
pub type mlx5_ctrl_flow_type = ::std::os::raw::c_uint;
#[doc = " Additional info about control flow rule."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_info {
    #[doc = " Determines the kind of control flow rule."]
    pub type_: mlx5_ctrl_flow_type,
    pub __bindgen_anon_1: mlx5_ctrl_flow_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_ctrl_flow_info__bindgen_ty_1 {
    #[doc = " If control flow is a SQ miss flow (root or not),\n then fields contains matching SQ number."]
    pub esw_mgr_sq: u32,
    #[doc = " If control flow is a Tx representor matching,\n then fields contains matching SQ number."]
    pub tx_repr_sq: u32,
    pub uc: mlx5_ctrl_flow_info__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Contains data relevant for unicast control flow rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_info__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " If control flow is a unicast DMAC (or with VLAN) flow rule,\n then this field contains DMAC."]
    pub dmac: rte_ether_addr,
    #[doc = " If control flow is a unicast DMAC with VLAN flow rule,\n then this field contains VLAN ID."]
    pub vlan: u16,
}
unsafe extern "C" {
    #[doc = " Returns true if a control flow rule with unicast DMAC match on given address was created."]
    pub fn mlx5_ctrl_flow_uc_dmac_exists(
        dev: *mut rte_eth_dev,
        addr: *const rte_ether_addr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if a control flow rule with unicast DMAC and VLAN match\n on given values was created."]
    pub fn mlx5_ctrl_flow_uc_dmac_vlan_exists(
        dev: *mut rte_eth_dev,
        addr: *const rte_ether_addr,
        vid: u16,
    ) -> bool;
}
#[doc = " Entry for tracking control flow rules in HWS."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_entry {
    pub next: mlx5_ctrl_flow_entry__bindgen_ty_1,
    #[doc = " Owner device is a port on behalf of which flow rule was created.\n\n It's different from the port which really created the flow rule\n if and only if flow rule is created on transfer proxy port\n on behalf of representor port."]
    pub owner_dev: *mut rte_eth_dev,
    #[doc = " Pointer to flow rule handle."]
    pub flow: *mut rte_flow,
    #[doc = " Additional information about the control flow rule."]
    pub info: mlx5_ctrl_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ctrl_flow_entry__bindgen_ty_1 {
    pub le_next: *mut mlx5_ctrl_flow_entry,
    pub le_prev: *mut *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_attr {
    pub port_attr: rte_flow_port_attr,
    pub nb_queue: u16,
    pub queue_attr: *mut rte_flow_queue_attr,
    pub nt_mode: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dv_flow_info {
    pub next: mlx5_dv_flow_info__bindgen_ty_1,
    pub orig_prio: u32,
    pub flow_idx_high_prio: u32,
    pub flow_idx_low_prio: u32,
    pub items: *mut rte_flow_item,
    pub actions: *mut rte_flow_action,
    pub attr: rte_flow_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dv_flow_info__bindgen_ty_1 {
    pub le_next: *mut mlx5_dv_flow_info,
    pub le_prev: *mut *mut mlx5_dv_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pmd_mlx5_flow_engine_mode_info {
    pub mode: rte_pmd_mlx5_flow_engine_mode,
    pub mode_flag: u32,
    pub hot_upgrade: rte_pmd_mlx5_flow_engine_mode_info_hot_up_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pmd_mlx5_flow_engine_mode_info_hot_up_info {
    pub lh_first: *mut mlx5_dv_flow_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_ctrl_rx {
    _unused: [u8; 0],
}
pub const mlx5_quota_state_MLX5_QUOTA_STATE_FREE: mlx5_quota_state = 0;
pub const mlx5_quota_state_MLX5_QUOTA_STATE_READY: mlx5_quota_state = 1;
pub const mlx5_quota_state_MLX5_QUOTA_STATE_WAIT: mlx5_quota_state = 2;
pub type mlx5_quota_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_quota {
    pub state: u8,
    pub mode: u8,
    #[doc = " Keep track of application update types.\n PMD does not allow 2 consecutive ADD updates."]
    pub last_update: rte_flow_update_quota_op,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_quota_ctx {
    pub dr_action: *mut mlx5dr_action,
    pub devx_obj: *mut mlx5_devx_obj,
    pub mr: mlx5_pmd_mr,
    pub read_buf: *mut *mut mlx5_aso_mtr_dseg,
    pub sq: *mut mlx5_aso_sq,
    pub quota_ipool: *mut mlx5_indexed_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv {
    pub dev_data: *mut rte_eth_dev_data,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub dev_port: u32,
    pub pci_dev: *mut rte_pci_device,
    pub mac: [rte_ether_addr; 256usize],
    pub mac_own: [u64; 4usize],
    pub vlan_filter: [u16; 128usize],
    pub vlan_filter_n: ::std::os::raw::c_uint,
    pub mtu: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub domain_id: u16,
    pub vport_id: u16,
    pub vport_meta_tag: u32,
    pub vport_meta_mask: u32,
    pub representor_id: u16,
    pub pf_bond: i32,
    pub mpesw_owner: i32,
    pub mpesw_port: i32,
    pub mpesw_uplink: bool,
    pub if_index: ::std::os::raw::c_uint,
    pub rxqs_n: ::std::os::raw::c_uint,
    pub txqs_n: ::std::os::raw::c_uint,
    pub ext_rxqs: *mut mlx5_external_q,
    pub ext_txqs: *mut mlx5_external_q,
    pub rxq_privs: *mut [*mut mlx5_rxq_priv; 0usize],
    pub txqs: *mut [*mut mlx5_txq_data; 0usize],
    pub mprq_mp: *mut rte_mempool,
    pub rss_conf: rte_eth_rss_conf,
    pub reta_idx: *mut [::std::os::raw::c_uint; 0usize],
    pub reta_idx_n: ::std::os::raw::c_uint,
    pub drop_queue: mlx5_drop,
    pub root_drop_action: *mut ::std::os::raw::c_void,
    pub hw_ctrl_lock: rte_spinlock_t,
    pub hw_ctrl_flows: mlx5_priv_hw_ctrl_flow,
    pub hw_ext_ctrl_flows: mlx5_priv_hw_ext_ctrl_flow,
    pub hw_ctrl_fdb: *mut mlx5_flow_hw_ctrl_fdb,
    pub hw_tx_repr_tagging_pt: *mut rte_flow_pattern_template,
    pub hw_tx_repr_tagging_at: *mut rte_flow_actions_template,
    pub hw_tx_repr_tagging_tbl: *mut rte_flow_template_table,
    pub flows: [*mut mlx5_indexed_pool; 3usize],
    pub ctrl_flows: u32,
    pub flow_list_lock: rte_spinlock_t,
    pub obj_ops: mlx5_obj_ops,
    pub rxqsctrl: mlx5_priv_rxq,
    pub rxqsobj: mlx5_priv_rxqobj,
    pub hrxqs: *mut mlx5_list,
    pub txqsctrl: mlx5_priv_txq,
    pub txqsobj: mlx5_priv_txqobj,
    pub ind_tbls: mlx5_priv_ind_tables,
    pub standalone_ind_tbls: mlx5_priv_stdl_ind_tables,
    pub indirect_list_head: mlx5_priv_indirect_list,
    pub ind_tbls_lock: rte_rwlock_t,
    #[doc = "< Reference counter. */\n/**< Verbs modify header action object."]
    pub refcnt: u32,
    #[doc = "< Flow table type, Rx or Tx."]
    pub ft_type: u8,
    pub max_lro_msg_size: u32,
    pub link_speed_capa: u32,
    pub xstats_ctrl: mlx5_xstats_ctrl,
    pub stats_ctrl: mlx5_stats_ctrl,
    pub config: mlx5_port_config,
    pub nl_socket_rdma: ::std::os::raw::c_int,
    pub nl_socket_route: ::std::os::raw::c_int,
    pub vmwa_context: *mut mlx5_nl_vlan_vmwa_context,
    pub mtr_config: mlx5_mtr_config,
    pub mtr_sfx_reg: u8,
    pub flow_meters: mlx5_legacy_flow_meters,
    pub mtr_profile_tbl: *mut mlx5_l3t_tbl,
    pub mtr_profile_arr: *mut mlx5_flow_meter_profile,
    pub policy_idx_tbl: *mut mlx5_l3t_tbl,
    pub mtr_policy_arr: *mut mlx5_flow_meter_policy,
    pub mtr_idx_tbl: *mut mlx5_l3t_tbl,
    pub mtr_bulk: mlx5_mtr_bulk,
    pub quota_ctx: mlx5_quota_ctx,
    pub skip_default_rss_reta: u8,
    pub fdb_def_rule: u8,
    pub mp_id: mlx5_mp_id,
    pub fdir_flows: mlx5_priv_fdir,
    pub shared_act_sl: rte_spinlock_t,
    pub rss_shared_actions: u32,
    pub num_of_hairpin_q_counter_enabled: u64,
    pub q_counters: *mut mlx5_devx_obj,
    pub counter_set_id: u32,
    pub q_counter_hairpin: *mut mlx5_devx_obj,
    pub lag_affinity_idx: u32,
    pub flex_item_sl: rte_spinlock_t,
    pub flex_item: [mlx5_flex_item; 8usize],
    pub flex_item_map: u32,
    pub nb_queue: u32,
    pub hws_cpool: *mut mlx5_hws_cnt_pool,
    pub hws_mark_refcnt: u32,
    pub mode_info: rte_pmd_mlx5_flow_engine_mode_info,
    pub hw_attr: *mut mlx5_flow_hw_attr,
    #[doc = "< Whether this port is in rules flushing stage."]
    pub hws_rule_flushing: bool,
    pub flow_hw_itt: mlx5_priv_flow_hw_itt,
    pub flow_hw_at: mlx5_priv_flow_hw_at,
    #[doc = "< HW steering DR context."]
    pub dr_ctx: *mut mlx5dr_context,
    pub tlv_options: *mut mlx5_geneve_tlv_options,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub hw_q: *mut mlx5_hw_q,
    pub flow_hw_tbl: mlx5_priv_flow_hw_tbl,
    pub flow_hw_grp: mlx5_priv_flow_hw_grp,
    pub hw_push_vlan: [*mut mlx5dr_action; 6usize],
    pub hw_pop_vlan: [*mut mlx5dr_action; 6usize],
    pub hw_vport: *mut *mut mlx5dr_action,
    pub hw_drop: [*mut mlx5dr_action; 2usize],
    pub hw_tag: [*mut mlx5dr_action; 2usize],
    pub hw_def_miss: *mut mlx5dr_action,
    pub hw_send_to_kernel: [*mut mlx5dr_action; 6usize],
    pub flow_hw_tbl_ongo: mlx5_priv_flow_hw_tbl_ongo,
    pub acts_ipool: *mut mlx5_indexed_pool,
    pub ct_mng: *mut mlx5_aso_ct_pools_mng,
    pub hws_ctpool: *mut mlx5_aso_ct_pool,
    pub hws_mpool: *mut mlx5_aso_mtr_pool,
    pub hw_ctrl_rx: *mut mlx5_flow_hw_ctrl_rx,
    pub action_template_drop: [*mut rte_flow_actions_template; 6usize],
    pub action_nat64: [[*mut mlx5dr_action; 2usize]; 6usize],
    pub ptype_rss_groups: *mut mlx5_indexed_pool,
    pub shared_host: *mut rte_eth_dev,
    pub shared_refcnt: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_hw_ctrl_flow {
    pub lh_first: *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_hw_ext_ctrl_flow {
    pub lh_first: *mut mlx5_ctrl_flow_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_rxq {
    pub lh_first: *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_rxqobj {
    pub lh_first: *mut mlx5_rxq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_txq {
    pub lh_first: *mut mlx5_txq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_txqobj {
    pub lh_first: *mut mlx5_txq_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_ind_tables {
    pub lh_first: *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_stdl_ind_tables {
    pub lh_first: *mut mlx5_ind_table_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_indirect_list {
    pub lh_first: *mut mlx5_indirect_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_fdir {
    pub lh_first: *mut mlx5_fdir_flow,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_itt {
    pub lh_first: *mut rte_flow_pattern_template,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_at {
    pub lh_first: *mut rte_flow_actions_template,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_tbl {
    pub lh_first: *mut rte_flow_template_table,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_grp {
    pub lh_first: *mut mlx5_flow_group,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_priv_flow_hw_tbl_ongo {
    pub lh_first: *mut rte_flow_template_table,
}
impl mlx5_priv {
    #[inline]
    pub fn isolated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isolated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isolated_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_isolated_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn representor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_representor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn representor_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_representor_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn master(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_master(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn master_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_master_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn txpp_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txpp_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn txpp_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_txpp_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sampler_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sampler_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sampler_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sampler_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mtr_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mtr_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mtr_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mtr_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mtr_reg_share(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mtr_reg_share(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mtr_reg_share_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mtr_reg_share_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lb_used(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lb_used(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lb_used_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lb_used_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv_notified(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv_notified(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_notified_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_notified_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_lag_ports(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_num_lag_ports(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_lag_ports_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_lag_ports_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unified_fdb_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unified_fdb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unified_fdb_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unified_fdb_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jump_fdb_rx_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jump_fdb_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jump_fdb_rx_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_jump_fdb_rx_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isolated: ::std::os::raw::c_uint,
        representor: ::std::os::raw::c_uint,
        master: ::std::os::raw::c_uint,
        txpp_en: ::std::os::raw::c_uint,
        sampler_en: ::std::os::raw::c_uint,
        mtr_en: ::std::os::raw::c_uint,
        mtr_reg_share: ::std::os::raw::c_uint,
        lb_used: ::std::os::raw::c_uint,
        rmv_notified: ::std::os::raw::c_uint,
        mark_enabled: u32,
        num_lag_ports: u32,
        tunnel_enabled: u32,
        unified_fdb_en: u32,
        jump_fdb_rx_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isolated: u32 = unsafe { ::std::mem::transmute(isolated) };
            isolated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let representor: u32 = unsafe { ::std::mem::transmute(representor) };
            representor as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let master: u32 = unsafe { ::std::mem::transmute(master) };
            master as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let txpp_en: u32 = unsafe { ::std::mem::transmute(txpp_en) };
            txpp_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sampler_en: u32 = unsafe { ::std::mem::transmute(sampler_en) };
            sampler_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mtr_en: u32 = unsafe { ::std::mem::transmute(mtr_en) };
            mtr_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mtr_reg_share: u32 = unsafe { ::std::mem::transmute(mtr_reg_share) };
            mtr_reg_share as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lb_used: u32 = unsafe { ::std::mem::transmute(lb_used) };
            lb_used as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rmv_notified: u32 = unsafe { ::std::mem::transmute(rmv_notified) };
            rmv_notified as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mark_enabled: u32 = unsafe { ::std::mem::transmute(mark_enabled) };
            mark_enabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let num_lag_ports: u32 = unsafe { ::std::mem::transmute(num_lag_ports) };
            num_lag_ports as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tunnel_enabled: u32 = unsafe { ::std::mem::transmute(tunnel_enabled) };
            tunnel_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let unified_fdb_en: u32 = unsafe { ::std::mem::transmute(unified_fdb_en) };
            unified_fdb_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let jump_fdb_rx_en: u32 = unsafe { ::std::mem::transmute(jump_fdb_rx_en) };
            jump_fdb_rx_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn hws_strict_queue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hws_strict_queue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_strict_queue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_strict_queue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hws_age_req(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hws_age_req(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_age_req_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_age_req_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        hws_strict_queue: u32,
        hws_age_req: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hws_strict_queue: u32 = unsafe { ::std::mem::transmute(hws_strict_queue) };
            hws_strict_queue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hws_age_req: u32 = unsafe { ::std::mem::transmute(hws_age_req) };
            hws_age_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @internal Declaration of the hairpin peer queue information structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_hairpin_peer_info {
    pub qp_id: u32,
    pub vhca_id: u32,
    pub peer_q: u16,
    pub tx_explicit: u16,
    pub manual_bind: u16,
}
unsafe extern "C" {
    pub fn mlx5_flow_action_job_init(
        priv_: *mut mlx5_priv,
        queue: u32,
        handle: *const rte_flow_action_handle,
        user_data: *mut ::std::os::raw::c_void,
        query_data: *mut ::std::os::raw::c_void,
        type_: mlx5_hw_job_type,
        error: *mut rte_flow_error,
    ) -> *mut mlx5_hw_q_job;
}
unsafe extern "C" {
    pub fn mlx5_getenv_int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_proc_priv_init(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_proc_priv_uninit(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_udp_tunnel_port_add(
        dev: *mut rte_eth_dev,
        udp_tunnel: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_eth_find_next(port_id: u16, odev: *mut rte_device) -> u16;
}
unsafe extern "C" {
    pub fn mlx5_dev_close(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_net_remove(cdev: *mut mlx5_common_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_is_hpf(dev: *mut rte_eth_dev) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_is_sf_repr(dev: *mut rte_eth_dev) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_age_event_prepare(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_lwm_setup(priv_: *mut mlx5_priv) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_lwm_unset(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_enable_port_level_hairpin_counter(
        dev: *mut rte_eth_dev,
        id: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_disable_port_level_hairpin_counter(
        dev: *mut rte_eth_dev,
        id: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_enable_per_queue_hairpin_counter(
        dev: *mut rte_eth_dev,
        id: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_disable_per_queue_hairpin_counter(
        dev: *mut rte_eth_dev,
        id: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rt_timestamp_config(sh: *mut mlx5_dev_ctx_shared, hca_attr: *mut mlx5_hca_attr);
}
unsafe extern "C" {
    pub fn mlx5_alloc_shared_dev_ctx(
        spawn: *const mlx5_dev_spawn_data,
        mkvlist: *mut mlx5_kvargs_ctrl,
    ) -> *mut mlx5_dev_ctx_shared;
}
unsafe extern "C" {
    pub fn mlx5_free_shared_dev_ctx(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_dev_ctx_shared_mempool_subscribe(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_free_table_hash_list(priv_: *mut mlx5_priv);
}
unsafe extern "C" {
    pub fn mlx5_alloc_table_hash_list(priv_: *mut mlx5_priv) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_set_min_inline(priv_: *mut mlx5_priv);
}
unsafe extern "C" {
    pub fn mlx5_set_metadata_mask(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_probe_again_args_validate(
        cdev: *mut mlx5_common_device,
        mkvlist: *mut mlx5_kvargs_ctrl,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_port_args_config(
        priv_: *mut mlx5_priv,
        mkvlist: *mut mlx5_kvargs_ctrl,
        config: *mut mlx5_port_config,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_port_args_set_used(
        name: *const ::std::os::raw::c_char,
        port_id: u16,
        mkvlist: *mut mlx5_kvargs_ctrl,
    );
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_ecpri_exist(dev: *mut rte_eth_dev) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_ecpri_alloc(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_counter_mode_config(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flow_aso_age_mng_init(sh: *mut mlx5_dev_ctx_shared) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_flow_mtrs_mng_init(sh: *mut mlx5_dev_ctx_shared) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_aso_ct_mng_init(sh: *mut mlx5_dev_ctx_shared) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_locked_physical_device(priv_: *mut mlx5_priv) -> *mut mlx5_physical_device;
}
unsafe extern "C" {
    pub fn mlx5_unlock_physical_device();
}
unsafe extern "C" {
    pub fn mlx5_read_queue_counter(
        q_counter: *mut mlx5_devx_obj,
        ctr_name: *const ::std::os::raw::c_char,
        stat: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_configure(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_representor_info_get(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_representor_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_representor_id_encode(
        info: *const mlx5_switch_info,
        hpf_type: rte_eth_representor_type,
    ) -> u16;
}
unsafe extern "C" {
    pub fn mlx5_dev_infos_get(
        dev: *mut rte_eth_dev,
        info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_fw_version_get(
        dev: *mut rte_eth_dev,
        fw_ver: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_supported_ptypes_get(
        dev: *mut rte_eth_dev,
        no_of_elements: *mut usize,
    ) -> *const u32;
}
unsafe extern "C" {
    pub fn mlx5_dev_set_mtu(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_cap_get(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_select_rx_function(dev: *mut rte_eth_dev) -> eth_rx_burst_t;
}
unsafe extern "C" {
    pub fn mlx5_port_to_eswitch_info(port: u16, valid: bool) -> *mut mlx5_priv;
}
unsafe extern "C" {
    pub fn mlx5_dev_to_eswitch_info(dev: *mut rte_eth_dev) -> *mut mlx5_priv;
}
unsafe extern "C" {
    pub fn mlx5_dev_configure_rss_reta(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_restore_flags(dev: *mut rte_eth_dev, op: rte_eth_dev_operation) -> u64;
}
unsafe extern "C" {
    pub fn mlx5_get_ifname(
        dev: *const rte_eth_dev,
        ifname: *mut [::std::os::raw::c_char; 16usize],
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ifindex(dev: *const rte_eth_dev) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn mlx5_get_mac(dev: *mut rte_eth_dev, mac: *mut [u8; 6usize]) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_mtu(dev: *mut rte_eth_dev, mtu: *mut u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_set_mtu(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_read_clock(dev: *mut rte_eth_dev, clock: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_link_update(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_get_flow_ctrl(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_set_flow_ctrl(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_interrupt_handler(arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_dev_interrupt_handler_devx(arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_dev_interrupt_handler_nl(arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_dev_interrupt_handler_ib(arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_set_link_down(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_set_link_up(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_is_removed(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_sysfs_switch_info(
        ifindex: ::std::os::raw::c_uint,
        info: *mut mlx5_switch_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_sysfs_bond_info(
        pf_ifindex: ::std::os::raw::c_uint,
        ifindex: *mut ::std::os::raw::c_uint,
        ifname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_module_info(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_module_eeprom(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_read_dev_stat(
        priv_: *mut mlx5_priv,
        ctr_name: *const ::std::os::raw::c_char,
        stat: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_read_dev_counters(
        dev: *mut rte_eth_dev,
        bond_master: bool,
        stats: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_get_stats_n(
        dev: *mut rte_eth_dev,
        bond_master: bool,
        n_stats: *mut u16,
        n_stats_sec: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_stats_init(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_get_flag_dropless_rq(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mac_addr_remove(dev: *mut rte_eth_dev, index: u32);
}
unsafe extern "C" {
    pub fn mlx5_mac_addr_add(
        dev: *mut rte_eth_dev,
        mac: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mac_addr_set(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_set_mc_addr_list(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rss_hash_update(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rss_hash_conf_get(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rss_reta_index_resize(
        dev: *mut rte_eth_dev,
        reta_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_rss_reta_query(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_rss_reta_update(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_promiscuous_enable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_promiscuous_disable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_allmulticast_enable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_allmulticast_disable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_stats_get(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_stats_reset(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_xstats_get(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_xstats_reset(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_xstats_get_names(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_reset_xstats_by_name(
        priv_: *mut mlx5_priv,
        ctr_name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn mlx5_reset_xstats_rq(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_vlan_filter_set(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_vlan_strip_queue_set(dev: *mut rte_eth_dev, queue: u16, on: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn mlx5_vlan_offload_set(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_vlan_vmwa_exit(ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_vlan_vmwa_release(dev: *mut rte_eth_dev, vf_vlan: *mut mlx5_vf_vlan);
}
unsafe extern "C" {
    pub fn mlx5_vlan_vmwa_acquire(dev: *mut rte_eth_dev, vf_vlan: *mut mlx5_vf_vlan);
}
unsafe extern "C" {
    pub fn mlx5_vlan_vmwa_init(dev: *mut rte_eth_dev, ifindex: u32) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mlx5_dev_start(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_stop(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_enable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_disable(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_traffic_restart(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_queue_peer_update(
        dev: *mut rte_eth_dev,
        peer_queue: u16,
        current_info: *mut rte_hairpin_peer_info,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_queue_peer_bind(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        peer_info: *mut rte_hairpin_peer_info,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_queue_peer_unbind(
        dev: *mut rte_eth_dev,
        cur_queue: u16,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_bind(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_unbind(dev: *mut rte_eth_dev, rx_port: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hairpin_get_peer_ports(
        dev: *mut rte_eth_dev,
        peer_ports: *mut u16,
        len: usize,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_mac_add(
        dev: *mut rte_eth_dev,
        addr: *const rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_mac_remove(
        dev: *mut rte_eth_dev,
        addr: *const rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_vlan_add(dev: *mut rte_eth_dev, vid: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_traffic_vlan_remove(dev: *mut rte_eth_dev, vid: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_discover_mreg_c(eth_dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_ext_mreg_supported(dev: *mut rte_eth_dev) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_flow_print(flow: *mut rte_flow);
}
unsafe extern "C" {
    pub fn mlx5_flow_validate(
        dev: *mut rte_eth_dev,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_list_create(
        dev: *mut rte_eth_dev,
        type_: mlx5_flow_type,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
        external: bool,
        error: *mut rte_flow_error,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mlx5_flow_list_destroy(dev: *mut rte_eth_dev, type_: mlx5_flow_type, flow_idx: usize);
}
unsafe extern "C" {
    pub fn mlx5_flow_create(
        dev: *mut rte_eth_dev,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    pub fn mlx5_flow_destroy(
        dev: *mut rte_eth_dev,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_list_flush(dev: *mut rte_eth_dev, type_: mlx5_flow_type, active: bool);
}
unsafe extern "C" {
    pub fn mlx5_flow_flush(
        dev: *mut rte_eth_dev,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_query(
        dev: *mut rte_eth_dev,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_isolate(
        dev: *mut rte_eth_dev,
        enable: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_ops_get(
        dev: *mut rte_eth_dev,
        ops: *mut *const rte_flow_ops,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_start_default(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_stop_default(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flow_verify(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ctrl_flow_source_queue(dev: *mut rte_eth_dev, sq_num: u32)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ctrl_flow_vlan(
        dev: *mut rte_eth_dev,
        eth_spec: *mut rte_flow_item_eth,
        eth_mask: *mut rte_flow_item_eth,
        vlan_spec: *mut rte_flow_item_vlan,
        vlan_mask: *mut rte_flow_item_vlan,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ctrl_flow(
        dev: *mut rte_eth_dev,
        eth_spec: *mut rte_flow_item_eth,
        eth_mask: *mut rte_flow_item_eth,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_lacp_miss(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_create_esw_table_zero_flow(dev: *mut rte_eth_dev) -> *mut rte_flow;
}
unsafe extern "C" {
    pub fn mlx5_flow_create_devx_sq_miss_flow(dev: *mut rte_eth_dev, sq_num: u32) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_flow_async_pool_query_handle(
        sh: *mut mlx5_dev_ctx_shared,
        async_id: u64,
        status: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn mlx5_set_query_alarm(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_flow_query_alarm(arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_counter_alloc(dev: *mut rte_eth_dev) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_counter_free(dev: *mut rte_eth_dev, cnt: u32);
}
unsafe extern "C" {
    pub fn mlx5_counter_query(
        dev: *mut rte_eth_dev,
        cnt: u32,
        clear: bool,
        pkts: *mut u64,
        bytes: *mut u64,
        action: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_dev_dump(
        dev: *mut rte_eth_dev,
        flow: *mut rte_flow,
        file: *mut FILE,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_query_counter(
        dev: *mut rte_eth_dev,
        flow: *mut rte_flow,
        count: *mut rte_flow_query_count,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_dev_dump_ipool(
        dev: *mut rte_eth_dev,
        flow: *mut rte_flow,
        file: *mut FILE,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_rx_metadata_negotiate(
        dev: *mut rte_eth_dev,
        features: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_rxq_dynf_set(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flow_get_aged_flows(
        dev: *mut rte_eth_dev,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_validate_action_ct(
        dev: *mut rte_eth_dev,
        conntrack: *const rte_flow_action_conntrack,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_get_q_aged_flows(
        dev: *mut rte_eth_dev,
        queue_id: u32,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_os_primary_handle(
        mp_msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_os_secondary_handle(
        mp_msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mp_os_req_start_rxtx(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_mp_os_req_stop_rxtx(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_mp_os_req_queue_control(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        req_type: mlx5_mp_req_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_pmd_socket_init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_pmd_socket_uninit();
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_init(
        dev: *mut rte_eth_dev,
        nb_meters: u32,
        nb_meter_profiles: u32,
        nb_meter_policies: u32,
        nb_queues: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_uninit(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_ops_get(
        dev: *mut rte_eth_dev,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_find(
        priv_: *mut mlx5_priv,
        meter_id: u32,
        mtr_idx: *mut u32,
    ) -> *mut mlx5_flow_meter_info;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_attach(
        priv_: *mut mlx5_priv,
        fm: *mut mlx5_flow_meter_info,
        attr: *const rte_flow_attr,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_detach(priv_: *mut mlx5_priv, fm: *mut mlx5_flow_meter_info);
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_policy_find(
        dev: *mut rte_eth_dev,
        policy_id: u32,
        policy_idx: *mut u32,
    ) -> *mut mlx5_flow_meter_policy;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_hierarchy_next_meter(
        priv_: *mut mlx5_priv,
        policy: *mut mlx5_flow_meter_policy,
        mtr_idx: *mut u32,
    ) -> *mut mlx5_flow_meter_info;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_hierarchy_get_final_policy(
        dev: *mut rte_eth_dev,
        policy: *mut mlx5_flow_meter_policy,
    ) -> *mut mlx5_flow_meter_policy;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_flush(
        dev: *mut rte_eth_dev,
        error: *mut rte_mtr_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_meter_rxq_flush(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flow_mtr_max_get(priv_: *mut mlx5_priv) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_os_capabilities_prepare(sh: *mut mlx5_dev_ctx_shared) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_free_shared_dr(priv_: *mut mlx5_priv);
}
unsafe extern "C" {
    pub fn mlx5_os_net_probe(
        cdev: *mut mlx5_common_device,
        mkvlist: *mut mlx5_kvargs_ctrl,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_dev_shared_handler_install(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_os_dev_shared_handler_uninstall(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_os_mac_addr_remove(dev: *mut rte_eth_dev, index: u32);
}
unsafe extern "C" {
    pub fn mlx5_os_mac_addr_add(
        dev: *mut rte_eth_dev,
        mac: *mut rte_ether_addr,
        index: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_vf_mac_addr_modify(
        priv_: *mut mlx5_priv,
        iface_idx: ::std::os::raw::c_uint,
        mac_addr: *mut rte_ether_addr,
        vf_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_set_promisc(
        dev: *mut rte_eth_dev,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_set_allmulti(
        dev: *mut rte_eth_dev,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_set_nonblock_channel_fd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_os_mac_addr_flush(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_os_net_cleanup();
}
unsafe extern "C" {
    pub fn mlx5_txpp_start(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_stop(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_txpp_read_clock(
        dev: *mut rte_eth_dev,
        timestamp: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_xstats_get(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
        n_used: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_xstats_reset(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_xstats_get_names(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        n: ::std::os::raw::c_uint,
        n_used: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_interrupt_handler(cb_arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_txpp_map_hca_bar(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_txpp_unmap_hca_bar(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_select_tx_function(dev: *mut rte_eth_dev) -> eth_tx_burst_t;
}
unsafe extern "C" {
    pub fn mlx5_aso_mtr_queue_init(
        sh: *mut mlx5_dev_ctx_shared,
        hws_pool: *mut mlx5_aso_mtr_pool,
        pool_mng: *mut mlx5_aso_mtr_pools_mng,
        nb_queues: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_mtr_queue_uninit(
        sh: *mut mlx5_dev_ctx_shared,
        hws_pool: *mut mlx5_aso_mtr_pool,
        pool_mng: *mut mlx5_aso_mtr_pools_mng,
    );
}
unsafe extern "C" {
    pub fn mlx5_aso_queue_init(
        sh: *mut mlx5_dev_ctx_shared,
        aso_opc_mode: mlx5_access_aso_opc_mod,
        nb_queues: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_flow_hit_queue_poll_start(
        sh: *mut mlx5_dev_ctx_shared,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_flow_hit_queue_poll_stop(sh: *mut mlx5_dev_ctx_shared)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_queue_uninit(
        sh: *mut mlx5_dev_ctx_shared,
        aso_opc_mod: mlx5_access_aso_opc_mod,
    );
}
unsafe extern "C" {
    pub fn mlx5_aso_meter_update_by_wqe(
        priv_: *mut mlx5_priv,
        queue: u32,
        mtr: *mut mlx5_aso_mtr,
        bulk: *mut mlx5_mtr_bulk,
        job: *mut mlx5_hw_q_job,
        push: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_mtr_wait(
        priv_: *mut mlx5_priv,
        mtr: *mut mlx5_aso_mtr,
        is_tmpl_api: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_update_by_wqe(
        sh: *mut mlx5_dev_ctx_shared,
        queue: u32,
        ct: *mut mlx5_aso_ct_action,
        profile: *const rte_flow_action_conntrack,
        user_data: *mut ::std::os::raw::c_void,
        push: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_wait_ready(
        sh: *mut mlx5_dev_ctx_shared,
        queue: u32,
        ct: *mut mlx5_aso_ct_action,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_query_by_wqe(
        sh: *mut mlx5_dev_ctx_shared,
        queue: u32,
        ct: *mut mlx5_aso_ct_action,
        profile: *mut rte_flow_action_conntrack,
        user_data: *mut ::std::os::raw::c_void,
        push: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_available(
        sh: *mut mlx5_dev_ctx_shared,
        queue: u32,
        ct: *mut mlx5_aso_ct_action,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_supported_sw_parsing_offloads(attr: *const mlx5_hca_attr) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_get_supported_tunneling_offloads(attr: *const mlx5_hca_attr) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_obj_analyze(
        profile: *mut rte_flow_action_conntrack,
        wdata: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn mlx5_aso_push_wqe(sh: *mut mlx5_dev_ctx_shared, sq: *mut mlx5_aso_sq);
}
unsafe extern "C" {
    pub fn mlx5_aso_pull_completion(
        sq: *mut mlx5_aso_sq,
        res: *mut rte_flow_op_result,
        n_res: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_cnt_queue_init(sh: *mut mlx5_dev_ctx_shared) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_cnt_queue_uninit(sh: *mut mlx5_dev_ctx_shared);
}
unsafe extern "C" {
    pub fn mlx5_aso_cnt_query(
        sh: *mut mlx5_dev_ctx_shared,
        cpool: *mut mlx5_hws_cnt_pool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_queue_init(
        sh: *mut mlx5_dev_ctx_shared,
        ct_mng: *mut mlx5_aso_ct_pools_mng,
        nb_queues: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_ct_queue_uninit(
        sh: *mut mlx5_dev_ctx_shared,
        ct_mng: *mut mlx5_aso_ct_pools_mng,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_sq_create(
        cdev: *mut mlx5_common_device,
        sq: *mut mlx5_aso_sq,
        uar: *mut ::std::os::raw::c_void,
        log_desc_n: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_aso_destroy_sq(sq: *mut mlx5_aso_sq);
}
unsafe extern "C" {
    pub fn mlx5_aso_mtr_init_sq(sq: *mut mlx5_aso_sq);
}
unsafe extern "C" {
    pub fn mlx5_aso_cqe_err_handle(sq: *mut mlx5_aso_sq);
}
unsafe extern "C" {
    pub fn mlx5_flex_item_port_init(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_item_port_cleanup(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_flex_flow_translate_item(
        dev: *mut rte_eth_dev,
        matcher: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        item: *const rte_flow_item,
        is_inner: bool,
    );
}
unsafe extern "C" {
    pub fn mlx5_flex_get_sample_id(
        tp: *const mlx5_flex_item,
        idx: u32,
        pos: *mut u32,
        is_inner: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_get_parser_value_per_byte_off(
        item: *const rte_flow_item_flex,
        flex: *mut ::std::os::raw::c_void,
        byte_off: u32,
        tunnel: bool,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_get_tunnel_mode(
        item: *const rte_flow_item,
        tunnel_mode: *mut rte_flow_item_flex_tunnel_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_acquire_index(
        dev: *mut rte_eth_dev,
        handle: *mut rte_flow_item_flex_handle,
        acquire: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_release_index(
        dev: *mut rte_eth_dev,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_create_cb(
        list_ctx: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_match_cb(
        list_ctx: *mut ::std::os::raw::c_void,
        iter: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_remove_cb(
        list_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
    );
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_clone_cb(
        list_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    pub fn mlx5_flex_parser_clone_free_cb(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
    );
}
unsafe extern "C" {
    pub fn mlx5_flow_quota_destroy(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_flow_quota_init(dev: *mut rte_eth_dev, nb_quotas: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_quota_alloc(
        dev: *mut rte_eth_dev,
        queue: u32,
        conf: *const rte_flow_action_quota,
        job: *mut mlx5_hw_q_job,
        push: bool,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_action_handle;
}
unsafe extern "C" {
    pub fn mlx5_quota_async_completion(dev: *mut rte_eth_dev, queue: u32, job: *mut mlx5_hw_q_job);
}
unsafe extern "C" {
    pub fn mlx5_quota_query_update(
        dev: *mut rte_eth_dev,
        queue: u32,
        handle: *mut rte_flow_action_handle,
        update: *const rte_flow_action,
        query: *mut rte_flow_query_quota,
        async_job: *mut mlx5_hw_q_job,
        push: bool,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_quota_query(
        dev: *mut rte_eth_dev,
        queue: u32,
        handle: *const rte_flow_action_handle,
        query: *mut rte_flow_query_quota,
        async_job: *mut mlx5_hw_q_job,
        push: bool,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_alloc_srh_flex_parser(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_free_srh_flex_parser(dev: *mut rte_eth_dev);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pmd_mlx5_host_action {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn mlx5_flow_hw_get_dr_action(
        dev: *mut rte_eth_dev,
        action: *mut rte_pmd_mlx5_host_action,
        release_data: *mut *mut ::std::os::raw::c_void,
    ) -> *mut mlx5dr_action;
}
unsafe extern "C" {
    pub fn mlx5_flow_hw_put_dr_action(
        dev: *mut rte_eth_dev,
        type_: rte_flow_action_type,
        release_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn mlx5_hw_ctx_validate(dev: *const rte_eth_dev, error: *mut rte_flow_error) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_stat {
    pub id: ::std::os::raw::c_int,
    pub count: u64,
    pub ctrl: mlx5_stat_counter_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_stats {
    #[doc = "< Total of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total of packets dropped when RX ring full."]
    pub idropped: u64,
    #[doc = "< Total of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = "< Total of hairpin queue out of buffers."]
    pub oobs: mlx5_rxq_stat,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_xstats_name_off {
    pub name: [::std::os::raw::c_char; 64usize],
    pub offset: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rq_stats {
    #[doc = " Total number of hairpin queue packets received that are dropped."]
    pub q_oobs: [u64; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rxq_zip {
    pub cqe_cnt: u16,
    pub ai: u16,
    pub ca: u32,
    pub na: u32,
    pub cq_ci: u32,
}
pub const mlx5_rxq_err_state_MLX5_RXQ_ERR_STATE_NO_ERROR: mlx5_rxq_err_state = 0;
pub const mlx5_rxq_err_state_MLX5_RXQ_ERR_STATE_NEED_RESET: mlx5_rxq_err_state = 1;
pub const mlx5_rxq_err_state_MLX5_RXQ_ERR_STATE_NEED_READY: mlx5_rxq_err_state = 2;
pub const mlx5_rxq_err_state_MLX5_RXQ_ERR_STATE_IGNORE: mlx5_rxq_err_state = 3;
pub type mlx5_rxq_err_state = ::std::os::raw::c_uint;
pub const mlx5_rqx_code_MLX5_RXQ_CODE_EXIT: mlx5_rqx_code = 0;
pub const mlx5_rqx_code_MLX5_RXQ_CODE_NOMBUF: mlx5_rqx_code = 1;
pub const mlx5_rqx_code_MLX5_RXQ_CODE_DROPPED: mlx5_rqx_code = 2;
pub type mlx5_rqx_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_eth_rxseg {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = "< Reserved field."]
    pub reserved: u32,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_data {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub port_id: u16,
    pub rq_db: *mut u32,
    pub cq_db: *mut u32,
    pub elts_ci: u32,
    pub rq_ci: u32,
    pub consumed_strd: u16,
    pub rq_pi: u32,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub rq_repl_thresh: u16,
    pub byte_mask: u32,
    pub __bindgen_anon_1: mlx5_rxq_data__bindgen_ty_1,
    pub mr_ctrl: mlx5_mr_ctrl,
    pub mprq_max_memcpy_len: u16,
    pub wqes: *mut ::std::os::raw::c_void,
    pub cqes: *mut [mlx5_cqe; 0usize],
    pub title_cqe: mlx5_cqe,
    pub elts: *mut [*mut rte_mbuf; 0usize],
    pub __bindgen_padding_0: [u64; 4usize],
    pub title_pkt: rte_mbuf,
    pub mprq_bufs: *mut [*mut mlx5_mprq_buf; 0usize],
    pub mp: *mut rte_mempool,
    pub mprq_mp: *mut rte_mempool,
    pub mprq_repl: *mut mlx5_mprq_buf,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub idx: u16,
    pub stats: mlx5_rxq_stats,
    pub stats_reset: mlx5_rxq_stats,
    pub mbuf_initializer: rte_xmm_t,
    pub __bindgen_padding_1: [u64; 6usize],
    pub fake_mbuf: rte_mbuf,
    pub uar_data: mlx5_uar_data,
    pub cqn: u32,
    pub cq_arm_sn: u8,
    pub mark_flag: u64,
    pub tunnel: u32,
    pub timestamp_offset: ::std::os::raw::c_int,
    pub timestamp_rx_flag: u64,
    pub flow_meta_mask: u64,
    pub flow_meta_offset: i32,
    pub flow_meta_port_mask: u32,
    pub rxseg_n: u32,
    pub rxseg: [mlx5_eth_rxseg; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_rxq_data__bindgen_ty_1 {
    pub zip: rxq_zip,
    pub decompressed: u16,
}
impl mlx5_rxq_data {
    #[inline]
    pub fn csum(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csum(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_csum_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_timestamp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_timestamp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_timestamp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_timestamp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_strip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_strip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_strip_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_strip_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crc_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crc_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crc_present_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crc_present_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sges_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sges_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sges_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sges_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn elts_n(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_elts_n(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn elts_n_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_elts_n_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rss_hash(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rss_hash(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rss_hash_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rss_hash_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mark(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mark(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mark_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mark_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_strd_num(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_strd_num(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_strd_num_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_strd_num_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_strd_sz(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log_strd_sz(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_strd_sz_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_strd_sz_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strd_shift_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strd_shift_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strd_shift_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strd_shift_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn err_state(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_err_state(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn err_state_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_err_state_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strd_scatter_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strd_scatter_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strd_scatter_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strd_scatter_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dynf_meta(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dynf_meta(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dynf_meta_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dynf_meta_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mcqe_format(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcqe_format(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mcqe_format_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mcqe_format_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delay_drop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delay_drop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delay_drop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delay_drop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp_layout(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp_layout(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_layout_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_layout_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        csum: ::std::os::raw::c_uint,
        hw_timestamp: ::std::os::raw::c_uint,
        rt_timestamp: ::std::os::raw::c_uint,
        vlan_strip: ::std::os::raw::c_uint,
        crc_present: ::std::os::raw::c_uint,
        sges_n: ::std::os::raw::c_uint,
        cqe_n: ::std::os::raw::c_uint,
        elts_n: ::std::os::raw::c_uint,
        rss_hash: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_uint,
        log_strd_num: ::std::os::raw::c_uint,
        log_strd_sz: ::std::os::raw::c_uint,
        strd_shift_en: ::std::os::raw::c_uint,
        err_state: ::std::os::raw::c_uint,
        strd_scatter_en: ::std::os::raw::c_uint,
        lro: ::std::os::raw::c_uint,
        dynf_meta: ::std::os::raw::c_uint,
        mcqe_format: ::std::os::raw::c_uint,
        shared: ::std::os::raw::c_uint,
        delay_drop: ::std::os::raw::c_uint,
        cqe_comp_layout: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csum: u32 = unsafe { ::std::mem::transmute(csum) };
            csum as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_timestamp: u32 = unsafe { ::std::mem::transmute(hw_timestamp) };
            hw_timestamp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rt_timestamp: u32 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let vlan_strip: u32 = unsafe { ::std::mem::transmute(vlan_strip) };
            vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let crc_present: u32 = unsafe { ::std::mem::transmute(crc_present) };
            crc_present as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let sges_n: u32 = unsafe { ::std::mem::transmute(sges_n) };
            sges_n as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let cqe_n: u32 = unsafe { ::std::mem::transmute(cqe_n) };
            cqe_n as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let elts_n: u32 = unsafe { ::std::mem::transmute(elts_n) };
            elts_n as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rss_hash: u32 = unsafe { ::std::mem::transmute(rss_hash) };
            rss_hash as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mark: u32 = unsafe { ::std::mem::transmute(mark) };
            mark as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let log_strd_num: u32 = unsafe { ::std::mem::transmute(log_strd_num) };
            log_strd_num as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let log_strd_sz: u32 = unsafe { ::std::mem::transmute(log_strd_sz) };
            log_strd_sz as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let strd_shift_en: u32 = unsafe { ::std::mem::transmute(strd_shift_en) };
            strd_shift_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let err_state: u32 = unsafe { ::std::mem::transmute(err_state) };
            err_state as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let strd_scatter_en: u32 = unsafe { ::std::mem::transmute(strd_scatter_en) };
            strd_scatter_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lro: u32 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let dynf_meta: u32 = unsafe { ::std::mem::transmute(dynf_meta) };
            dynf_meta as u64
        });
        __bindgen_bitfield_unit.set(33usize, 3u8, {
            let mcqe_format: u32 = unsafe { ::std::mem::transmute(mcqe_format) };
            mcqe_format as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let delay_drop: u32 = unsafe { ::std::mem::transmute(delay_drop) };
            delay_drop as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let cqe_comp_layout: u32 = unsafe { ::std::mem::transmute(cqe_comp_layout) };
            cqe_comp_layout as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(cq_ci: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl {
    pub rxq: mlx5_rxq_data,
    pub next: mlx5_rxq_ctrl__bindgen_ty_1,
    pub owners: mlx5_rxq_ctrl_priv,
    pub obj: *mut mlx5_rxq_obj,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub is_hairpin: bool,
    pub socket: ::std::os::raw::c_uint,
    pub share_entry: mlx5_rxq_ctrl__bindgen_ty_2,
    pub ctrl_ref: i32,
    pub share_group: u32,
    pub share_qid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub flow_tunnels_n: [u32; 10usize],
    pub wqn: u32,
    pub rxseg_n: u32,
    pub rxseg: [rte_eth_rxseg_split; 32usize],
    pub dump_file_n: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_ctrl,
    pub le_prev: *mut *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl_priv {
    pub lh_first: *mut mlx5_rxq_priv,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl__bindgen_ty_2 {
    pub le_next: *mut mlx5_rxq_ctrl,
    pub le_prev: *mut *mut mlx5_rxq_ctrl,
}
impl mlx5_rxq_ctrl {
    #[inline]
    pub fn started(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_started(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn started_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_started_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_irq_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        started: ::std::os::raw::c_uint,
        irq: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let started: u32 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let irq: u32 = unsafe { ::std::mem::transmute(irq) };
            irq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_priv {
    pub idx: u16,
    pub refcnt: u32,
    pub ctrl: *mut mlx5_rxq_ctrl,
    pub owner_entry: mlx5_rxq_priv__bindgen_ty_1,
    pub priv_: *mut mlx5_priv,
    pub devx_rq: mlx5_devx_rq,
    pub hairpin_conf: rte_eth_hairpin_conf,
    pub hairpin_status: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub q_counter: *mut mlx5_devx_obj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_priv__bindgen_ty_1 {
    pub le_next: *mut mlx5_rxq_priv,
    pub le_prev: *mut *mut mlx5_rxq_priv,
}
impl mlx5_rxq_priv {
    #[inline]
    pub fn lwm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lwm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_event_pending(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_event_pending(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_event_pending_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_event_pending_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_devx_subscribed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_devx_subscribed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_devx_subscribed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_devx_subscribed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lwm: u32,
        lwm_event_pending: u32,
        lwm_devx_subscribed: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let lwm: u32 = unsafe { ::std::mem::transmute(lwm) };
            lwm as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let lwm_event_pending: u32 = unsafe { ::std::mem::transmute(lwm_event_pending) };
            lwm_event_pending as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let lwm_devx_subscribed: u32 = unsafe { ::std::mem::transmute(lwm_devx_subscribed) };
            lwm_devx_subscribed as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn mlx5_rxq_cqe_num(rxq_data: *mut mlx5_rxq_data) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn mlx5_mprq_free_mp(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mprq_alloc_mp(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_start(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_stop(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_start_primary(
        dev: *mut rte_eth_dev,
        queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_stop_primary(
        dev: *mut rte_eth_dev,
        queue_id: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_setup(
        dev: *mut rte_eth_dev,
        idx: u16,
        desc: u16,
        socket: ::std::os::raw::c_uint,
        conf: *const rte_eth_rxconf,
        mp: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_hairpin_queue_setup(
        dev: *mut rte_eth_dev,
        idx: u16,
        desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_release(dev: *mut rte_eth_dev, qid: u16);
}
unsafe extern "C" {
    pub fn mlx5_rx_intr_vec_enable(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_intr_vec_disable(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_rx_intr_enable(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_intr_disable(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rxq_obj_verify(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_q_counters_destroy(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_rxq_new(
        dev: *mut rte_eth_dev,
        idx: u16,
        desc: u16,
        socket: ::std::os::raw::c_uint,
        conf: *const rte_eth_rxconf,
        rx_seg: *const rte_eth_rxseg_split,
        n_seg: u16,
        is_extmem: bool,
    ) -> *mut mlx5_rxq_ctrl;
}
unsafe extern "C" {
    pub fn mlx5_rxq_hairpin_new(
        dev: *mut rte_eth_dev,
        rxq: *mut mlx5_rxq_priv,
        desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> *mut mlx5_rxq_ctrl;
}
unsafe extern "C" {
    pub fn mlx5_rxq_ref(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_rxq_priv;
}
unsafe extern "C" {
    pub fn mlx5_rxq_deref(dev: *mut rte_eth_dev, idx: u16) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_rxq_get(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_rxq_priv;
}
unsafe extern "C" {
    pub fn mlx5_rxq_ctrl_get(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_rxq_ctrl;
}
unsafe extern "C" {
    pub fn mlx5_rxq_data_get(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_rxq_data;
}
unsafe extern "C" {
    pub fn mlx5_ext_rxq_ref(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_external_q;
}
unsafe extern "C" {
    pub fn mlx5_ext_rxq_deref(dev: *mut rte_eth_dev, idx: u16) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_ext_rxq_get(dev: *mut rte_eth_dev, idx: u16) -> *mut mlx5_external_q;
}
unsafe extern "C" {
    pub fn mlx5_rxq_release(dev: *mut rte_eth_dev, idx: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rxq_verify(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ext_rxq_verify(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_verify(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_get(
        dev: *mut rte_eth_dev,
        queues: *const u16,
        queues_n: u32,
    ) -> *mut mlx5_ind_table_obj;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_new(
        dev: *mut rte_eth_dev,
        queues: *const u16,
        queues_n: u32,
        standalone: bool,
        ref_qs: bool,
    ) -> *mut mlx5_ind_table_obj;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_release(
        dev: *mut rte_eth_dev,
        ind_tbl: *mut mlx5_ind_table_obj,
        deref_rxqs: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_setup(
        dev: *mut rte_eth_dev,
        ind_tbl: *mut mlx5_ind_table_obj,
        ref_qs: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_modify(
        dev: *mut rte_eth_dev,
        ind_tbl: *mut mlx5_ind_table_obj,
        queues: *mut u16,
        queues_n: u32,
        standalone: bool,
        ref_new_qs: bool,
        deref_old_qs: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_attach(
        dev: *mut rte_eth_dev,
        ind_tbl: *mut mlx5_ind_table_obj,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_ind_table_obj_detach(
        dev: *mut rte_eth_dev,
        ind_tbl: *mut mlx5_ind_table_obj,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_create_cb(
        tool_ctx: *mut ::std::os::raw::c_void,
        cb_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_match_cb(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        cb_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_remove_cb(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry);
}
unsafe extern "C" {
    pub fn mlx5_hrxq_clone_cb(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        cb_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_clone_free_cb(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
    );
}
unsafe extern "C" {
    pub fn mlx5_hrxq_get(
        dev: *mut rte_eth_dev,
        rss_desc: *mut mlx5_flow_rss_desc,
    ) -> *mut mlx5_hrxq;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_obj_release(
        dev: *mut rte_eth_dev,
        hrxq: *mut mlx5_hrxq,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_release(dev: *mut rte_eth_dev, hxrq_idx: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_hrxq_verify(dev: *mut rte_eth_dev) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_rxq_is_hairpin(dev: *mut rte_eth_dev, idx: u16) -> bool;
}
unsafe extern "C" {
    pub fn mlx5_rxq_get_hairpin_conf(
        dev: *mut rte_eth_dev,
        idx: u16,
    ) -> *const rte_eth_hairpin_conf;
}
unsafe extern "C" {
    pub fn mlx5_drop_action_create(dev: *mut rte_eth_dev) -> *mut mlx5_hrxq;
}
unsafe extern "C" {
    pub fn mlx5_drop_action_destroy(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_get_rx_port_offloads() -> u64;
}
unsafe extern "C" {
    pub fn mlx5_get_rx_queue_offloads(dev: *mut rte_eth_dev) -> u64;
}
unsafe extern "C" {
    pub fn mlx5_rxq_timestamp_set(dev: *mut rte_eth_dev);
}
unsafe extern "C" {
    pub fn mlx5_hrxq_modify(
        dev: *mut rte_eth_dev,
        hxrq_idx: u32,
        rss_key: *const u8,
        rss_key_len: u32,
        hash_fields: u64,
        symmetric_hash_function: bool,
        queues: *const u16,
        queues_n: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_burst(
        dpdk_rxq: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_n: u16,
    ) -> u16;
}
unsafe extern "C" {
    pub fn mlx5_rxq_initialize(rxq: *mut mlx5_rxq_data);
}
unsafe extern "C" {
    pub fn mlx5_rx_err_handle(
        rxq: *mut mlx5_rxq_data,
        vec: u8,
        err_n: u16,
        skip_cnt: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_mprq_buf_free(buf: *mut mlx5_mprq_buf);
}
unsafe extern "C" {
    pub fn mlx5_rx_burst_mprq(
        dpdk_rxq: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_n: u16,
    ) -> u16;
}
unsafe extern "C" {
    pub fn mlx5_rx_descriptor_status(
        rx_queue: *mut ::std::os::raw::c_void,
        offset: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_count(rx_queue: *mut ::std::os::raw::c_void) -> u32;
}
unsafe extern "C" {
    pub fn mlx5_rxq_info_get(dev: *mut rte_eth_dev, queue_id: u16, qinfo: *mut rte_eth_rxq_info);
}
unsafe extern "C" {
    pub fn mlx5_rx_burst_mode_get(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_get_monitor_addr(
        rx_queue: *mut ::std::os::raw::c_void,
        pmc: *mut rte_power_monitor_cond,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_dev_interrupt_handler_lwm(args: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_lwm_set(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        lwm: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_queue_lwm_query(
        dev: *mut rte_eth_dev,
        rx_queue_id: *mut u16,
        lwm: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rxq_check_vec_support(rxq_data: *mut mlx5_rxq_data) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_check_vec_rx_support(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlx5_rx_burst_vec(
        dpdk_rxq: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_n: u16,
    ) -> u16;
}
unsafe extern "C" {
    pub fn mlx5_rx_burst_mprq_vec(
        dpdk_rxq: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_n: u16,
    ) -> u16;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg {
    pub _address: u8,
}
#[doc = "< class handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
#[doc = "< Opaque item handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_flex_handle {
    pub _address: u8,
}
#[doc = " Fast path flow API functions exported by PMD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_fp_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dr_action {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dv_matcher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dv_modify_hdr_resource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tunnel_hub {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_legacy_flow_meter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_ctrl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_hw_ctrl_fdb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indirect_list {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_nl_vlan_vmwa_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_fdir_flow {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_group {
    pub _address: u8,
}
