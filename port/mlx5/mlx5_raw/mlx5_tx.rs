/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }}
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) { unsafe {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }}
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }}
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) { unsafe {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }}
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Thread id descriptor."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_thread_t {
    #[doc = "< thread identifier"]
    pub opaque_id: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
#[doc = " memseg list is a special case as we need to store a bunch of other data\n together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[doc = "< multi-thread safe (default mode)"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
#[doc = "< single thread only"]
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
#[doc = "< multi-thread relaxed tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
#[doc = "< multi-thread head/tail sync"]
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
#[doc = " prod/cons sync types"]
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[doc = " structures to hold a pair of head/tail values and other metadata.\n Depending on sync_type format of that structure might be different,\n but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type,
}
#[doc = " An RTE ring structure.\n\n The producer and the consumer have a head and a tail index. The particularity\n of these index is that they are not between 0 and size(ring)-1. These indexes\n are between 0 and 2^32 -1, and we mask their value when we access the ring[]\n field. Thanks to this assumption, we can do subtractions between 2 index\n values in a modulo-32bit base: that's why the overflow of the indexes is not\n a problem."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n layout for the first cache line for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(packed(8))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_bus {
    _unused: [u8; 0],
}
pub const rte_dev_policy_RTE_DEV_ALLOWED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLOCKED: rte_dev_policy = 1;
#[doc = " Device policies."]
pub type rte_dev_policy = ::std::os::raw::c_uint;
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Device bus specific information"]
    pub bus_info: *const ::std::os::raw::c_char,
    #[doc = "< Driver assigned after probing"]
    pub driver: *const rte_driver,
    #[doc = "< Bus handle assigned on scan"]
    pub bus: *const rte_bus,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Arguments for latest probing"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
pub const rte_devtype_RTE_DEVTYPE_ALLOWED: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLOCKED: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
#[doc = " Type of generic device"]
pub type rte_devtype = ::std::os::raw::c_uint;
#[doc = " Structure that stores a device given by the user with its arguments\n\n A user device is a physical or a virtual device given by the user to\n the DPDK application at startup through command line arguments.\n\n The structure stores the configuration of the device, its PCI\n identifier if it's a PCI device or the driver name if it's a virtual\n device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< raw string including bus, class and driver parts."]
    pub data: *mut ::std::os::raw::c_char,
}
#[doc = " Next in list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = "< legacy name."]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< driver-related part of device string."]
    pub drv_str: *const ::std::os::raw::c_char,
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub const ibv_node_type_IBV_NODE_UNKNOWN: ibv_node_type = -1;
pub const ibv_node_type_IBV_NODE_CA: ibv_node_type = 1;
pub const ibv_node_type_IBV_NODE_SWITCH: ibv_node_type = 2;
pub const ibv_node_type_IBV_NODE_ROUTER: ibv_node_type = 3;
pub const ibv_node_type_IBV_NODE_RNIC: ibv_node_type = 4;
pub const ibv_node_type_IBV_NODE_USNIC: ibv_node_type = 5;
pub const ibv_node_type_IBV_NODE_USNIC_UDP: ibv_node_type = 6;
pub const ibv_node_type_IBV_NODE_UNSPECIFIED: ibv_node_type = 7;
pub type ibv_node_type = ::std::os::raw::c_int;
pub const ibv_transport_type_IBV_TRANSPORT_UNKNOWN: ibv_transport_type = -1;
pub const ibv_transport_type_IBV_TRANSPORT_IB: ibv_transport_type = 0;
pub const ibv_transport_type_IBV_TRANSPORT_IWARP: ibv_transport_type = 1;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC: ibv_transport_type = 2;
pub const ibv_transport_type_IBV_TRANSPORT_USNIC_UDP: ibv_transport_type = 3;
pub const ibv_transport_type_IBV_TRANSPORT_UNSPECIFIED: ibv_transport_type = 4;
pub type ibv_transport_type = ::std::os::raw::c_int;
pub const ibv_atomic_cap_IBV_ATOMIC_NONE: ibv_atomic_cap = 0;
pub const ibv_atomic_cap_IBV_ATOMIC_HCA: ibv_atomic_cap = 1;
pub const ibv_atomic_cap_IBV_ATOMIC_GLOB: ibv_atomic_cap = 2;
pub type ibv_atomic_cap = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
pub const ibv_wc_status_IBV_WC_SUCCESS: ibv_wc_status = 0;
pub const ibv_wc_status_IBV_WC_LOC_LEN_ERR: ibv_wc_status = 1;
pub const ibv_wc_status_IBV_WC_LOC_QP_OP_ERR: ibv_wc_status = 2;
pub const ibv_wc_status_IBV_WC_LOC_EEC_OP_ERR: ibv_wc_status = 3;
pub const ibv_wc_status_IBV_WC_LOC_PROT_ERR: ibv_wc_status = 4;
pub const ibv_wc_status_IBV_WC_WR_FLUSH_ERR: ibv_wc_status = 5;
pub const ibv_wc_status_IBV_WC_MW_BIND_ERR: ibv_wc_status = 6;
pub const ibv_wc_status_IBV_WC_BAD_RESP_ERR: ibv_wc_status = 7;
pub const ibv_wc_status_IBV_WC_LOC_ACCESS_ERR: ibv_wc_status = 8;
pub const ibv_wc_status_IBV_WC_REM_INV_REQ_ERR: ibv_wc_status = 9;
pub const ibv_wc_status_IBV_WC_REM_ACCESS_ERR: ibv_wc_status = 10;
pub const ibv_wc_status_IBV_WC_REM_OP_ERR: ibv_wc_status = 11;
pub const ibv_wc_status_IBV_WC_RETRY_EXC_ERR: ibv_wc_status = 12;
pub const ibv_wc_status_IBV_WC_RNR_RETRY_EXC_ERR: ibv_wc_status = 13;
pub const ibv_wc_status_IBV_WC_LOC_RDD_VIOL_ERR: ibv_wc_status = 14;
pub const ibv_wc_status_IBV_WC_REM_INV_RD_REQ_ERR: ibv_wc_status = 15;
pub const ibv_wc_status_IBV_WC_REM_ABORT_ERR: ibv_wc_status = 16;
pub const ibv_wc_status_IBV_WC_INV_EECN_ERR: ibv_wc_status = 17;
pub const ibv_wc_status_IBV_WC_INV_EEC_STATE_ERR: ibv_wc_status = 18;
pub const ibv_wc_status_IBV_WC_FATAL_ERR: ibv_wc_status = 19;
pub const ibv_wc_status_IBV_WC_RESP_TIMEOUT_ERR: ibv_wc_status = 20;
pub const ibv_wc_status_IBV_WC_GENERAL_ERR: ibv_wc_status = 21;
pub const ibv_wc_status_IBV_WC_TM_ERR: ibv_wc_status = 22;
pub const ibv_wc_status_IBV_WC_TM_RNDV_INCOMPLETE: ibv_wc_status = 23;
pub type ibv_wc_status = ::std::os::raw::c_uint;
pub const ibv_wc_opcode_IBV_WC_SEND: ibv_wc_opcode = 0;
pub const ibv_wc_opcode_IBV_WC_RDMA_WRITE: ibv_wc_opcode = 1;
pub const ibv_wc_opcode_IBV_WC_RDMA_READ: ibv_wc_opcode = 2;
pub const ibv_wc_opcode_IBV_WC_COMP_SWAP: ibv_wc_opcode = 3;
pub const ibv_wc_opcode_IBV_WC_FETCH_ADD: ibv_wc_opcode = 4;
pub const ibv_wc_opcode_IBV_WC_BIND_MW: ibv_wc_opcode = 5;
pub const ibv_wc_opcode_IBV_WC_LOCAL_INV: ibv_wc_opcode = 6;
pub const ibv_wc_opcode_IBV_WC_TSO: ibv_wc_opcode = 7;
pub const ibv_wc_opcode_IBV_WC_FLUSH: ibv_wc_opcode = 8;
pub const ibv_wc_opcode_IBV_WC_ATOMIC_WRITE: ibv_wc_opcode = 9;
pub const ibv_wc_opcode_IBV_WC_RECV: ibv_wc_opcode = 128;
pub const ibv_wc_opcode_IBV_WC_RECV_RDMA_WITH_IMM: ibv_wc_opcode = 129;
pub const ibv_wc_opcode_IBV_WC_TM_ADD: ibv_wc_opcode = 130;
pub const ibv_wc_opcode_IBV_WC_TM_DEL: ibv_wc_opcode = 131;
pub const ibv_wc_opcode_IBV_WC_TM_SYNC: ibv_wc_opcode = 132;
pub const ibv_wc_opcode_IBV_WC_TM_RECV: ibv_wc_opcode = 133;
pub const ibv_wc_opcode_IBV_WC_TM_NO_TAG: ibv_wc_opcode = 134;
pub const ibv_wc_opcode_IBV_WC_DRIVER1: ibv_wc_opcode = 135;
pub const ibv_wc_opcode_IBV_WC_DRIVER2: ibv_wc_opcode = 136;
pub const ibv_wc_opcode_IBV_WC_DRIVER3: ibv_wc_opcode = 137;
pub type ibv_wc_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status,
    pub opcode: ibv_wc_opcode,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
pub const ibv_mw_type_IBV_MW_TYPE_1: ibv_mw_type = 1;
pub const ibv_mw_type_IBV_MW_TYPE_2: ibv_mw_type = 2;
pub type ibv_mw_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type,
}
pub const ibv_qp_type_IBV_QPT_RC: ibv_qp_type = 2;
pub const ibv_qp_type_IBV_QPT_UC: ibv_qp_type = 3;
pub const ibv_qp_type_IBV_QPT_UD: ibv_qp_type = 4;
pub const ibv_qp_type_IBV_QPT_RAW_PACKET: ibv_qp_type = 8;
pub const ibv_qp_type_IBV_QPT_XRC_SEND: ibv_qp_type = 9;
pub const ibv_qp_type_IBV_QPT_XRC_RECV: ibv_qp_type = 10;
pub const ibv_qp_type_IBV_QPT_DRIVER: ibv_qp_type = 255;
pub type ibv_qp_type = ::std::os::raw::c_uint;
pub const ibv_qp_state_IBV_QPS_RESET: ibv_qp_state = 0;
pub const ibv_qp_state_IBV_QPS_INIT: ibv_qp_state = 1;
pub const ibv_qp_state_IBV_QPS_RTR: ibv_qp_state = 2;
pub const ibv_qp_state_IBV_QPS_RTS: ibv_qp_state = 3;
pub const ibv_qp_state_IBV_QPS_SQD: ibv_qp_state = 4;
pub const ibv_qp_state_IBV_QPS_SQE: ibv_qp_state = 5;
pub const ibv_qp_state_IBV_QPS_ERR: ibv_qp_state = 6;
pub const ibv_qp_state_IBV_QPS_UNKNOWN: ibv_qp_state = 7;
pub type ibv_qp_state = ::std::os::raw::c_uint;
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE: ibv_wr_opcode = 0;
pub const ibv_wr_opcode_IBV_WR_RDMA_WRITE_WITH_IMM: ibv_wr_opcode = 1;
pub const ibv_wr_opcode_IBV_WR_SEND: ibv_wr_opcode = 2;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_IMM: ibv_wr_opcode = 3;
pub const ibv_wr_opcode_IBV_WR_RDMA_READ: ibv_wr_opcode = 4;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_CMP_AND_SWP: ibv_wr_opcode = 5;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_FETCH_AND_ADD: ibv_wr_opcode = 6;
pub const ibv_wr_opcode_IBV_WR_LOCAL_INV: ibv_wr_opcode = 7;
pub const ibv_wr_opcode_IBV_WR_BIND_MW: ibv_wr_opcode = 8;
pub const ibv_wr_opcode_IBV_WR_SEND_WITH_INV: ibv_wr_opcode = 9;
pub const ibv_wr_opcode_IBV_WR_TSO: ibv_wr_opcode = 10;
pub const ibv_wr_opcode_IBV_WR_DRIVER1: ibv_wr_opcode = 11;
pub const ibv_wr_opcode_IBV_WR_FLUSH: ibv_wr_opcode = 14;
pub const ibv_wr_opcode_IBV_WR_ATOMIC_WRITE: ibv_wr_opcode = 15;
pub type ibv_wr_opcode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state,
    pub qp_type: ibv_qp_type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_cseg {
    pub opcode: u32,
    pub sq_ds: u32,
    pub flags: u32,
    pub misc: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg {
    pub bcount: u32,
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_dseg__bindgen_ty_1 {
    pub inline_data: [u8; 12usize],
    pub __bindgen_anon_1: mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_dseg__bindgen_ty_1__bindgen_ty_1 {
    pub lkey: u32,
    pub pbuf: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1 {
    pub swp_offs: u32,
    pub cs_flags: u8,
    pub swp_flags: u8,
    pub mss: u16,
    pub metadata: u32,
    pub inline_hdr_sz: u16,
    pub __bindgen_anon_1: mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inline_data: u16,
    pub vlan_tag: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe_eseg__bindgen_ty_1__bindgen_ty_2 {
    pub offsets: u32,
    pub flags: u32,
    pub flow_metadata: u32,
    pub inline_hdr: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_wqe {
    pub __bindgen_anon_1: mlx5_wqe__bindgen_ty_1,
    pub eseg: mlx5_wqe_eseg,
    pub __bindgen_anon_2: mlx5_wqe__bindgen_ty_2,
}
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_1 {
    pub cseg: mlx5_wqe_cseg,
    pub ctrl: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_wqe__bindgen_ty_2 {
    pub dseg: [mlx5_wqe_dseg; 2usize],
    pub data: [u8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe {
    pub pkt_info: u8,
    pub rsvd0: u8,
    pub wqe_id: u16,
    pub lro_tcppsh_abort_dupack: u8,
    pub lro_min_ttl: u8,
    pub lro_tcp_win: u16,
    pub lro_ack_seq_num: u32,
    pub rx_hash_res: u32,
    pub rx_hash_type: u8,
    pub rsvd1: [u8; 3usize],
    pub csum: u16,
    pub rsvd2: [u8; 6usize],
    pub hdr_type_etc: u16,
    pub vlan_info: u16,
    pub lro_num_seg: u8,
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1,
    pub flow_table_metadata: u32,
    pub rsvd4: [u8; 4usize],
    pub byte_cnt: u32,
    pub timestamp: u64,
    pub sop_drop_qpn: u32,
    pub wqe_counter: u16,
    pub validity_iteration_count: u8,
    pub op_own: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_cqe__bindgen_ty_1 {
    pub user_index_bytes: [u8; 3usize],
    pub __bindgen_anon_1: mlx5_cqe__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_cqe__bindgen_ty_1__bindgen_ty_1 {
    pub user_index_hi: u8,
    pub user_index_low: u16,
}
pub const modify_reg_REG_NON: modify_reg = 0;
pub const modify_reg_REG_A: modify_reg = 1;
pub const modify_reg_REG_B: modify_reg = 2;
pub const modify_reg_REG_C_0: modify_reg = 3;
pub const modify_reg_REG_C_1: modify_reg = 4;
pub const modify_reg_REG_C_2: modify_reg = 5;
pub const modify_reg_REG_C_3: modify_reg = 6;
pub const modify_reg_REG_C_4: modify_reg = 7;
pub const modify_reg_REG_C_5: modify_reg = 8;
pub const modify_reg_REG_C_6: modify_reg = 9;
pub const modify_reg_REG_C_7: modify_reg = 10;
pub const modify_reg_REG_C_8: modify_reg = 11;
pub const modify_reg_REG_C_9: modify_reg = 12;
pub const modify_reg_REG_C_10: modify_reg = 13;
pub const modify_reg_REG_C_11: modify_reg = 14;
pub type modify_reg = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cseg {
    pub va_h: u32,
    pub va_l_r: u32,
    pub lkey: u32,
    pub operand_masks: u32,
    pub condition_0_data: u32,
    pub condition_0_mask: u32,
    pub condition_1_data: u32,
    pub condition_1_mask: u32,
    pub bitwise_data: u64,
    pub data_mask: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_dseg {
    pub v_bo_sc_bbog_mm: u32,
    pub reserved: u32,
    pub cbs_cir: u32,
    pub c_tokens: u32,
    pub ebs_eir: u32,
    pub e_tokens: u32,
    pub timestamp: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_dseg {
    pub __bindgen_anon_1: mlx5_aso_dseg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_dseg__bindgen_ty_1 {
    pub data: [u8; 64usize],
    pub mtrs: [mlx5_aso_mtr_dseg; 2usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_wqe {
    pub general_cseg: mlx5_wqe_cseg,
    pub aso_cseg: mlx5_aso_cseg,
    pub aso_dseg: mlx5_aso_dseg,
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_qos_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_max_flow_meter: u8,
    pub flow_meter_reg_c_ids: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_hca_qos_attr {
    #[inline]
    pub fn sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_old(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_old(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_old_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_old_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn packet_pacing(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_packet_pacing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_pacing_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_packet_pacing_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_rate_pp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_rate_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_rate_pp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_rate_pp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_meter_aso_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_meter_aso_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_meter_aso_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_meter_aso_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sup: u32,
        flow_meter_old: u32,
        packet_pacing: u32,
        wqe_rate_pp: u32,
        flow_meter: u32,
        flow_meter_aso_sup: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sup: u32 = unsafe { ::std::mem::transmute(sup) };
            sup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_meter_old: u32 = unsafe { ::std::mem::transmute(flow_meter_old) };
            flow_meter_old as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let packet_pacing: u32 = unsafe { ::std::mem::transmute(packet_pacing) };
            packet_pacing as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wqe_rate_pp: u32 = unsafe { ::std::mem::transmute(wqe_rate_pp) };
            wqe_rate_pp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let flow_meter: u32 = unsafe { ::std::mem::transmute(flow_meter) };
            flow_meter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flow_meter_aso_sup: u32 = unsafe { ::std::mem::transmute(flow_meter_aso_sup) };
            flow_meter_aso_sup as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_meter_aso_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_meter_aso_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_meter_aso_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_meter_aso_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_meter_aso_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_num_meter_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_num_meter_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_num_meter_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_num_meter_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        log_meter_aso_granularity: u32,
        log_meter_aso_max_alloc: u32,
        log_max_num_meter_aso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_meter_aso_granularity: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_granularity) };
            log_meter_aso_granularity as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let log_meter_aso_max_alloc: u32 =
                unsafe { ::std::mem::transmute(log_meter_aso_max_alloc) };
            log_meter_aso_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let log_max_num_meter_aso: u32 =
                unsafe { ::std::mem::transmute(log_max_num_meter_aso) };
            log_max_num_meter_aso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr {
    pub virtio_queue_type: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_num_virtio_queues: u32,
    pub umems: [mlx5_hca_vdpa_attr__bindgen_ty_1; 3usize],
    pub doorbell_bar_offset: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_vdpa_attr__bindgen_ty_1 {
    pub a: u32,
    pub b: u32,
}
impl mlx5_hca_vdpa_attr {
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn desc_tunnel_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_desc_tunnel_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn desc_tunnel_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_desc_tunnel_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_frame_offload_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_frame_offload_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_frame_offload_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_frame_offload_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_version_1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_version_1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_version_1_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_version_1_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_ipv6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso_ipv6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_ipv6_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_ipv6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rx_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rx_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn event_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_event_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_stride(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_stride_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_stride_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_doorbell_bar_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_doorbell_bar_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_doorbell_bar_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_doorbell_bar_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn queue_counters_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_queue_counters_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn queue_counters_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_queue_counters_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vnet_modify_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vnet_modify_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vnet_modify_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vnet_modify_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_net_q_addr_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_net_q_addr_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_net_q_addr_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_net_q_addr_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtio_q_index_modify(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virtio_q_index_modify(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtio_q_index_modify_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_virtio_q_index_modify_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid: u32,
        desc_tunnel_offload_type: u32,
        eth_frame_offload_type: u32,
        virtio_version_1_0: u32,
        tso_ipv4: u32,
        tso_ipv6: u32,
        tx_csum: u32,
        rx_csum: u32,
        event_mode: u32,
        log_doorbell_stride: u32,
        log_doorbell_bar_size: u32,
        queue_counters_valid: u32,
        vnet_modify_ext: u32,
        virtio_net_q_addr_modify: u32,
        virtio_q_index_modify: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid: u32 = unsafe { ::std::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let desc_tunnel_offload_type: u32 =
                unsafe { ::std::mem::transmute(desc_tunnel_offload_type) };
            desc_tunnel_offload_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let eth_frame_offload_type: u32 =
                unsafe { ::std::mem::transmute(eth_frame_offload_type) };
            eth_frame_offload_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let virtio_version_1_0: u32 = unsafe { ::std::mem::transmute(virtio_version_1_0) };
            virtio_version_1_0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tso_ipv4: u32 = unsafe { ::std::mem::transmute(tso_ipv4) };
            tso_ipv4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tso_ipv6: u32 = unsafe { ::std::mem::transmute(tso_ipv6) };
            tso_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_csum: u32 = unsafe { ::std::mem::transmute(tx_csum) };
            tx_csum as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_csum: u32 = unsafe { ::std::mem::transmute(rx_csum) };
            rx_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let event_mode: u32 = unsafe { ::std::mem::transmute(event_mode) };
            event_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let log_doorbell_stride: u32 = unsafe { ::std::mem::transmute(log_doorbell_stride) };
            log_doorbell_stride as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let log_doorbell_bar_size: u32 =
                unsafe { ::std::mem::transmute(log_doorbell_bar_size) };
            log_doorbell_bar_size as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let queue_counters_valid: u32 = unsafe { ::std::mem::transmute(queue_counters_valid) };
            queue_counters_valid as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let vnet_modify_ext: u32 = unsafe { ::std::mem::transmute(vnet_modify_ext) };
            vnet_modify_ext as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let virtio_net_q_addr_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_net_q_addr_modify) };
            virtio_net_q_addr_modify as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let virtio_q_index_modify: u32 =
                unsafe { ::std::mem::transmute(virtio_q_index_modify) };
            virtio_q_index_modify as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flow_attr {
    pub tunnel_header_0_1: u32,
    pub tunnel_header_2_3: u32,
}
#[doc = " Accumulate port PARSE_GRAPH_NODE capabilities from\n PARSE_GRAPH_NODE Capabilities and HCA Capabilities 2 tables"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_flex_attr {
    pub node_in: u32,
    pub node_out: u32,
    pub header_length_mode: u16,
    pub sample_offset_mode: u16,
    pub max_num_arc_in: u8,
    pub max_num_arc_out: u8,
    pub max_num_sample: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_base_header_length: u16,
    pub max_sample_base_offset: u8,
    pub max_next_header_offset: u16,
    pub header_length_mask_width: u8,
}
impl mlx5_hca_flex_attr {
    #[inline]
    pub fn max_num_prog_sample(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_max_num_prog_sample(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_num_prog_sample_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_max_num_prog_sample_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_anchor(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parse_graph_anchor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_anchor_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_anchor_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_tunnel_inner2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_tunnel_inner2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_tunnel_inner2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_tunnel_inner2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zero_size_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zero_size_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zero_size_supported_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_zero_size_supported_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_id_in_out(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sample_id_in_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_id_in_out_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sample_id_in_out_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_num_prog_sample: u8,
        parse_graph_anchor: u8,
        query_match_sample_info: u8,
        sample_tunnel_inner2: u8,
        zero_size_supported: u8,
        sample_id_in_out: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let max_num_prog_sample: u8 = unsafe { ::std::mem::transmute(max_num_prog_sample) };
            max_num_prog_sample as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let parse_graph_anchor: u8 = unsafe { ::std::mem::transmute(parse_graph_anchor) };
            parse_graph_anchor as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let query_match_sample_info: u8 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sample_tunnel_inner2: u8 = unsafe { ::std::mem::transmute(sample_tunnel_inner2) };
            sample_tunnel_inner2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let zero_size_supported: u8 = unsafe { ::std::mem::transmute(zero_size_supported) };
            zero_size_supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sample_id_in_out: u8 = unsafe { ::std::mem::transmute(sample_id_in_out) };
            sample_id_in_out as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_hca_crypto_mmo_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl mlx5_hca_crypto_mmo_attr {
    #[inline]
    pub fn crypto_mmo_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_mmo_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_mmo_qp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_mmo_qp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_encrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_encrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_encrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_256_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_256_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_256_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_256_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_128_decrypt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_128_decrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_128_decrypt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_128_decrypt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gcm_auth_tag_96(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gcm_auth_tag_96(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gcm_auth_tag_96_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gcm_auth_tag_96_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_crypto_mmo_max_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_log_crypto_mmo_max_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_crypto_mmo_max_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_crypto_mmo_max_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        crypto_mmo_qp: u32,
        gcm_256_encrypt: u32,
        gcm_128_encrypt: u32,
        gcm_256_decrypt: u32,
        gcm_128_decrypt: u32,
        gcm_auth_tag_128: u32,
        gcm_auth_tag_96: u32,
        log_crypto_mmo_max_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let crypto_mmo_qp: u32 = unsafe { ::std::mem::transmute(crypto_mmo_qp) };
            crypto_mmo_qp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gcm_256_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_encrypt) };
            gcm_256_encrypt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gcm_128_encrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_encrypt) };
            gcm_128_encrypt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gcm_256_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_256_decrypt) };
            gcm_256_decrypt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let gcm_128_decrypt: u32 = unsafe { ::std::mem::transmute(gcm_128_decrypt) };
            gcm_128_decrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gcm_auth_tag_128: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_128) };
            gcm_auth_tag_128 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gcm_auth_tag_96: u32 = unsafe { ::std::mem::transmute(gcm_auth_tag_96) };
            gcm_auth_tag_96 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 6u8, {
            let log_crypto_mmo_max_size: u32 =
                unsafe { ::std::mem::transmute(log_crypto_mmo_max_size) };
            log_crypto_mmo_max_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_counter_bulk_alloc_bitmap: u8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub max_lso_cap: u32,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub lro_timer_supported_periods: [u32; 4usize],
    pub lro_min_mss_size: u16,
    pub flex_parser_protocols: u32,
    pub _bitfield_align_4: [u16; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 10usize]>,
    pub dev_freq_khz: u32,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub regexp_num_of_engines: u32,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub geneve_tlv_opt: u32,
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub qos: mlx5_hca_qos_attr,
    pub vdpa: mlx5_hca_vdpa_attr,
    pub flow: mlx5_hca_flow_attr,
    pub flex: mlx5_hca_flex_attr,
    pub crypto_mmo: mlx5_hca_crypto_mmo_attr,
    pub log_max_wq_sz: u8,
    pub log_max_qp_sz: u8,
    pub log_max_cq_sz: u8,
    pub log_max_qp: u8,
    pub log_max_cq: u8,
    pub log_max_pd: u32,
    pub log_max_mrw_sz: u32,
    pub log_max_srq: u32,
    pub log_max_srq_sz: u32,
    pub rss_ind_tbl_cap: u32,
    pub _bitfield_align_8: [u8; 0],
    pub _bitfield_8: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub esw_mgr_vport_id: u16,
    pub max_wqe_sz_sq: u16,
    pub _bitfield_align_9: [u16; 0],
    pub _bitfield_9: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1,
    pub _bitfield_align_10: [u8; 0],
    pub _bitfield_10: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_header_modify_pattern_length: u8,
    pub system_image_guid: u64,
    pub _bitfield_align_11: [u8; 0],
    pub _bitfield_11: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_hca_attr__bindgen_ty_1 {
    pub max_flow_counter: u32,
    pub __bindgen_anon_1: mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hca_attr__bindgen_ty_1__bindgen_ty_1 {
    pub max_flow_counter_15_0: u16,
    pub max_flow_counter_31_16: u16,
}
impl mlx5_hca_attr {
    #[inline]
    pub fn eswitch_manager(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eswitch_manager(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eswitch_manager_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eswitch_manager_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counters_dump(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counters_dump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counters_dump_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counters_dump_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_rq_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_rq_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_rq_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_rq_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rmp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rmp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rmp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rmp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_rqt_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_rqt_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_rqt_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_rqt_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn parse_graph_flex_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parse_graph_flex_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn parse_graph_flex_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_parse_graph_flex_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        eswitch_manager: u32,
        flow_counters_dump: u32,
        mem_rq_rmp: u32,
        log_max_rmp: u32,
        log_max_rqt_size: u32,
        parse_graph_flex_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eswitch_manager: u32 = unsafe { ::std::mem::transmute(eswitch_manager) };
            eswitch_manager as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_counters_dump: u32 = unsafe { ::std::mem::transmute(flow_counters_dump) };
            flow_counters_dump as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mem_rq_rmp: u32 = unsafe { ::std::mem::transmute(mem_rq_rmp) };
            mem_rq_rmp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let log_max_rmp: u32 = unsafe { ::std::mem::transmute(log_max_rmp) };
            log_max_rmp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log_max_rqt_size: u32 = unsafe { ::std::mem::transmute(log_max_rqt_size) };
            log_max_rqt_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let parse_graph_flex_node: u32 =
                unsafe { ::std::mem::transmute(parse_graph_flex_node) };
            parse_graph_flex_node as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eth_net_offloads(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_net_offloads(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_net_offloads_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_net_offloads_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn eth_virt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eth_virt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn eth_virt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_eth_virt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_vlan_insert(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_vlan_insert(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_vlan_insert_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_vlan_insert_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csum_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csum_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csum_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_csum_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vport_inline_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vport_inline_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vport_inline_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vport_inline_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_geneve_rx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_geneve_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_geneve_rx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_geneve_rx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_max_opt_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_max_opt_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_max_opt_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_max_opt_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gtp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gtp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gtp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gtp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan_gpe_nsh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan_gpe_nsh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_gpe_nsh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_gpe_nsh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        eth_net_offloads: u32,
        eth_virt: u32,
        wqe_vlan_insert: u32,
        csum_cap: u32,
        vlan_cap: u32,
        wqe_inline_mode: u32,
        vport_inline_mode: u32,
        tunnel_stateless_geneve_rx: u32,
        geneve_max_opt_len: u32,
        tunnel_stateless_gtp: u32,
        tunnel_stateless_vxlan_gpe_nsh: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eth_net_offloads: u32 = unsafe { ::std::mem::transmute(eth_net_offloads) };
            eth_net_offloads as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let eth_virt: u32 = unsafe { ::std::mem::transmute(eth_virt) };
            eth_virt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wqe_vlan_insert: u32 = unsafe { ::std::mem::transmute(wqe_vlan_insert) };
            wqe_vlan_insert as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let csum_cap: u32 = unsafe { ::std::mem::transmute(csum_cap) };
            csum_cap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vlan_cap: u32 = unsafe { ::std::mem::transmute(vlan_cap) };
            vlan_cap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let wqe_inline_mode: u32 = unsafe { ::std::mem::transmute(wqe_inline_mode) };
            wqe_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let vport_inline_mode: u32 = unsafe { ::std::mem::transmute(vport_inline_mode) };
            vport_inline_mode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tunnel_stateless_geneve_rx: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_geneve_rx) };
            tunnel_stateless_geneve_rx as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let geneve_max_opt_len: u32 = unsafe { ::std::mem::transmute(geneve_max_opt_len) };
            geneve_max_opt_len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tunnel_stateless_gtp: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gtp) };
            tunnel_stateless_gtp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tunnel_stateless_vxlan_gpe_nsh: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan_gpe_nsh) };
            tunnel_stateless_vxlan_gpe_nsh as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_lro_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_lro_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_lro_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_lro_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_gre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_gre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_gre_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_gre_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_stateless_vxlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_stateless_vxlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_stateless_vxlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_stateless_vxlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_lso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp_lso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_lso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_lso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_max_msg_sz_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lro_max_msg_sz_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_max_msg_sz_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_max_msg_sz_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        scatter_fcs: u32,
        lro_cap: u32,
        tunnel_lro_gre: u32,
        tunnel_lro_vxlan: u32,
        tunnel_stateless_gre: u32,
        tunnel_stateless_vxlan: u32,
        swp: u32,
        swp_csum: u32,
        swp_lso: u32,
        lro_max_msg_sz_mode: u32,
        rq_delay_drop: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs: u32 = unsafe { ::std::mem::transmute(scatter_fcs) };
            scatter_fcs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lro_cap: u32 = unsafe { ::std::mem::transmute(lro_cap) };
            lro_cap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tunnel_lro_gre: u32 = unsafe { ::std::mem::transmute(tunnel_lro_gre) };
            tunnel_lro_gre as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tunnel_lro_vxlan: u32 = unsafe { ::std::mem::transmute(tunnel_lro_vxlan) };
            tunnel_lro_vxlan as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tunnel_stateless_gre: u32 = unsafe { ::std::mem::transmute(tunnel_stateless_gre) };
            tunnel_stateless_gre as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tunnel_stateless_vxlan: u32 =
                unsafe { ::std::mem::transmute(tunnel_stateless_vxlan) };
            tunnel_stateless_vxlan as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let swp_csum: u32 = unsafe { ::std::mem::transmute(swp_csum) };
            swp_csum as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let swp_lso: u32 = unsafe { ::std::mem::transmute(swp_lso) };
            swp_lso as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let lro_max_msg_sz_mode: u32 = unsafe { ::std::mem::transmute(lro_max_msg_sz_mode) };
            lro_max_msg_sz_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rq_delay_drop: u32 = unsafe { ::std::mem::transmute(rq_delay_drop) };
            rq_delay_drop as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn max_geneve_tlv_options(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_options(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_options_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_options_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_geneve_tlv_option_data_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_max_geneve_tlv_option_data_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_geneve_tlv_option_data_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                8usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_geneve_tlv_option_data_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_sample(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_sample_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_sample_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn geneve_tlv_option_sample_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(15usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_geneve_tlv_option_sample_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(15usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn geneve_tlv_option_sample_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                15usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_geneve_tlv_option_sample_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                15usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_queues(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_queues(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_queues_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                20usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_queues_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                20usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_wq_data_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_wq_data_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_wq_data_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                25usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_wq_data_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                25usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_hairpin_num_packets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_hairpin_num_packets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_hairpin_num_packets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_hairpin_num_packets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wqe_bb_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(37usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wqe_bb_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(37usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wqe_bb_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                37usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wqe_bb_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                37usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_sq_wq_in_host_mem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_sq_wq_in_host_mem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_sq_wq_in_host_mem_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_sq_wq_in_host_mem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hairpin_data_buffer_locked(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hairpin_data_buffer_locked(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hairpin_data_buffer_locked_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                42usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hairpin_data_buffer_locked_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vhca_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(43usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_vhca_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(43usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vhca_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                43usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vhca_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                43usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_write_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                59usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_write_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn relaxed_ordering_read(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relaxed_ordering_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relaxed_ordering_read_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                60usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relaxed_ordering_read_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_register_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_access_register_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_register_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                61usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_access_register_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_index_ignore(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_index_ignore(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_index_ignore_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                62usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_index_ignore_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_channel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_channel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_channel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_channel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_wire_sq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_wire_sq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_wire_sq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                64usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_non_wire_sq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                64usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_static_sq_wq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(65usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_static_sq_wq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(65usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_static_sq_wq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                65usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_static_sq_wq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                65usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_lag_ports(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(70usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_num_lag_ports(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_4.set(70usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_lag_ports_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 10usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                70usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_lag_ports_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 10usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                70usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        max_geneve_tlv_options: u32,
        max_geneve_tlv_option_data_len: u32,
        geneve_tlv_sample: u32,
        geneve_tlv_option_offset: u32,
        geneve_tlv_option_sample_id: u32,
        hairpin: u32,
        log_max_hairpin_queues: u32,
        log_max_hairpin_wq_data_sz: u32,
        log_max_hairpin_num_packets: u32,
        hairpin_sq_wqe_bb_size: u32,
        hairpin_sq_wq_in_host_mem: u32,
        hairpin_data_buffer_locked: u32,
        vhca_id: u32,
        relaxed_ordering_write: u32,
        relaxed_ordering_read: u32,
        access_register_user: u32,
        wqe_index_ignore: u32,
        cross_channel: u32,
        non_wire_sq: u32,
        log_max_static_sq_wq: u32,
        num_lag_ports: u32,
    ) -> __BindgenBitfieldUnit<[u8; 10usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let max_geneve_tlv_options: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_options) };
            max_geneve_tlv_options as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let max_geneve_tlv_option_data_len: u32 =
                unsafe { ::std::mem::transmute(max_geneve_tlv_option_data_len) };
            max_geneve_tlv_option_data_len as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let geneve_tlv_sample: u32 = unsafe { ::std::mem::transmute(geneve_tlv_sample) };
            geneve_tlv_sample as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let geneve_tlv_option_offset: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_offset) };
            geneve_tlv_option_offset as u64
        });
        __bindgen_bitfield_unit.set(15usize, 4u8, {
            let geneve_tlv_option_sample_id: u32 =
                unsafe { ::std::mem::transmute(geneve_tlv_option_sample_id) };
            geneve_tlv_option_sample_id as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let hairpin: u32 = unsafe { ::std::mem::transmute(hairpin) };
            hairpin as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let log_max_hairpin_queues: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_queues) };
            log_max_hairpin_queues as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let log_max_hairpin_wq_data_sz: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_wq_data_sz) };
            log_max_hairpin_wq_data_sz as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let log_max_hairpin_num_packets: u32 =
                unsafe { ::std::mem::transmute(log_max_hairpin_num_packets) };
            log_max_hairpin_num_packets as u64
        });
        __bindgen_bitfield_unit.set(37usize, 4u8, {
            let hairpin_sq_wqe_bb_size: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wqe_bb_size) };
            hairpin_sq_wqe_bb_size as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let hairpin_sq_wq_in_host_mem: u32 =
                unsafe { ::std::mem::transmute(hairpin_sq_wq_in_host_mem) };
            hairpin_sq_wq_in_host_mem as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let hairpin_data_buffer_locked: u32 =
                unsafe { ::std::mem::transmute(hairpin_data_buffer_locked) };
            hairpin_data_buffer_locked as u64
        });
        __bindgen_bitfield_unit.set(43usize, 16u8, {
            let vhca_id: u32 = unsafe { ::std::mem::transmute(vhca_id) };
            vhca_id as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let relaxed_ordering_write: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_write) };
            relaxed_ordering_write as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let relaxed_ordering_read: u32 =
                unsafe { ::std::mem::transmute(relaxed_ordering_read) };
            relaxed_ordering_read as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let access_register_user: u32 = unsafe { ::std::mem::transmute(access_register_user) };
            access_register_user as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let wqe_index_ignore: u32 = unsafe { ::std::mem::transmute(wqe_index_ignore) };
            wqe_index_ignore as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let cross_channel: u32 = unsafe { ::std::mem::transmute(cross_channel) };
            cross_channel as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let non_wire_sq: u32 = unsafe { ::std::mem::transmute(non_wire_sq) };
            non_wire_sq as u64
        });
        __bindgen_bitfield_unit.set(65usize, 5u8, {
            let log_max_static_sq_wq: u32 = unsafe { ::std::mem::transmute(log_max_static_sq_wq) };
            log_max_static_sq_wq as u64
        });
        __bindgen_bitfield_unit.set(70usize, 4u8, {
            let num_lag_ports: u32 = unsafe { ::std::mem::transmute(num_lag_ports) };
            num_lag_ports as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn roce(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn roce_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_roce_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wait_on_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wait_on_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wait_on_time_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wait_on_time_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sq_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sq_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sq_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sq_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qp_ts_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_qp_ts_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qp_ts_format_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qp_ts_format_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_params(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_params(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_params_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_params_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regexp_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_regexp_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regexp_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                15usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_regexp_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                15usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_c_preserve(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg_c_preserve(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_c_preserve_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_preserve_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aes_xts(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aes_xts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aes_xts_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aes_xts_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn import_kek(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_import_kek(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn import_kek_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_import_kek_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn credential(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_credential(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn credential_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_credential_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_login(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_login(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_5.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_login_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_login_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        scatter_fcs_w_decap_disable: u32,
        flow_hit_aso: u32,
        roce: u32,
        wait_on_time: u32,
        rq_ts_format: u32,
        sq_ts_format: u32,
        steering_format_version: u32,
        qp_ts_format: u32,
        regexp_params: u32,
        regexp_version: u32,
        reg_c_preserve: u32,
        ct_offload: u32,
        crypto: u32,
        aes_xts: u32,
        dek: u32,
        import_kek: u32,
        credential: u32,
        crypto_login: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso: u32 = unsafe { ::std::mem::transmute(flow_hit_aso) };
            flow_hit_aso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let roce: u32 = unsafe { ::std::mem::transmute(roce) };
            roce as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_on_time: u32 = unsafe { ::std::mem::transmute(wait_on_time) };
            wait_on_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rq_ts_format: u32 = unsafe { ::std::mem::transmute(rq_ts_format) };
            rq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let sq_ts_format: u32 = unsafe { ::std::mem::transmute(sq_ts_format) };
            sq_ts_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let qp_ts_format: u32 = unsafe { ::std::mem::transmute(qp_ts_format) };
            qp_ts_format as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let regexp_params: u32 = unsafe { ::std::mem::transmute(regexp_params) };
            regexp_params as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let regexp_version: u32 = unsafe { ::std::mem::transmute(regexp_version) };
            regexp_version as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reg_c_preserve: u32 = unsafe { ::std::mem::transmute(reg_c_preserve) };
            reg_c_preserve as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ct_offload: u32 = unsafe { ::std::mem::transmute(ct_offload) };
            ct_offload as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let crypto: u32 = unsafe { ::std::mem::transmute(crypto) };
            crypto as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let aes_xts: u32 = unsafe { ::std::mem::transmute(aes_xts) };
            aes_xts as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let dek: u32 = unsafe { ::std::mem::transmute(dek) };
            dek as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let import_kek: u32 = unsafe { ::std::mem::transmute(import_kek) };
            import_kek as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let credential: u32 = unsafe { ::std::mem::transmute(credential) };
            credential as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let crypto_login: u32 = unsafe { ::std::mem::transmute(crypto_login) };
            crypto_login as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_ft_sampler_num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_ft_sampler_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_ft_sampler_num_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_ft_sampler_num_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inner_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inner_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_ipv4_ihl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outer_ipv4_ihl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_6.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_ipv4_ihl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outer_ipv4_ihl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        log_max_ft_sampler_num: u32,
        inner_ipv4_ihl: u32,
        outer_ipv4_ihl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_max_ft_sampler_num: u32 =
                unsafe { ::std::mem::transmute(log_max_ft_sampler_num) };
            log_max_ft_sampler_num as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inner_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(inner_ipv4_ihl) };
            inner_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outer_ipv4_ihl: u32 = unsafe { ::std::mem::transmute(outer_ipv4_ihl) };
            outer_ipv4_ihl as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_flow_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_flow_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_flow_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_flow_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mini_cqe_resp_l3_l4_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mini_cqe_resp_l3_l4_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mini_cqe_resp_l3_l4_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mini_cqe_resp_l3_l4_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_cqe_compression(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_cqe_compression(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_cqe_compression_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_cqe_compression_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkt_integrity_match(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkt_integrity_match(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_7.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkt_integrity_match_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkt_integrity_match_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        cqe_compression: u32,
        mini_cqe_resp_flow_tag: u32,
        mini_cqe_resp_l3_l4_tag: u32,
        enhanced_cqe_compression: u32,
        pkt_integrity_match: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cqe_compression: u32 = unsafe { ::std::mem::transmute(cqe_compression) };
            cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mini_cqe_resp_flow_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_flow_tag) };
            mini_cqe_resp_flow_tag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mini_cqe_resp_l3_l4_tag: u32 =
                unsafe { ::std::mem::transmute(mini_cqe_resp_l3_l4_tag) };
            mini_cqe_resp_l3_l4_tag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enhanced_cqe_compression: u32 =
                unsafe { ::std::mem::transmute(enhanced_cqe_compression) };
            enhanced_cqe_compression as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pkt_integrity_match: u32 = unsafe { ::std::mem::transmute(pkt_integrity_match) };
            pkt_integrity_match as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mmo_dma_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_decompress_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_decompress_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_decompress_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_decompress_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_dma_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_dma_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_dma_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_dma_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_compress_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_compress_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_compress_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_compress_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v1_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v1_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v1_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_deflate_v2_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_deflate_v2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_deflate_v2_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_deflate_v2_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_qp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_qp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_qp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_qp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mmo_regex_sq_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmo_regex_sq_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmo_regex_sq_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mmo_regex_sq_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn compress_min_block_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_compress_min_block_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compress_min_block_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                9usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compress_min_block_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_dma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_dma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_dma_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                13usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_dma_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                13usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_compress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_compress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_compress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                18usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_compress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                18usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_max_mmo_decompress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_mmo_decompress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_mmo_decompress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                23usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_mmo_decompress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                23usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_data_only_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_data_only_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_data_only_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_data_only_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_no_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_no_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_no_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_no_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decomp_lz4_checksum_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decomp_lz4_checksum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decomp_lz4_checksum_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decomp_lz4_checksum_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_modify_entity_size_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_modify_entity_size_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_modify_entity_size_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_modify_entity_size_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn umr_indirect_mkey_disabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_umr_indirect_mkey_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn umr_indirect_mkey_disabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_umr_indirect_mkey_disabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn log_min_stride_wqe_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(33usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_min_stride_wqe_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(33usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_min_stride_wqe_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                33usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_min_stride_wqe_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                33usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn esw_mgr_vport_id_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mgr_vport_id_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mgr_vport_id_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mgr_vport_id_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crypto_wrapped_import_method(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_8.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_wrapped_import_method(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_8.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crypto_wrapped_import_method_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_8),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_crypto_wrapped_import_method_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_8),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_8(
        mmo_dma_sq_en: u32,
        mmo_compress_sq_en: u32,
        mmo_decompress_sq_en: u32,
        mmo_dma_qp_en: u32,
        mmo_compress_qp_en: u32,
        decomp_deflate_v1_en: u32,
        decomp_deflate_v2_en: u32,
        mmo_regex_qp_en: u32,
        mmo_regex_sq_en: u32,
        compress_min_block_size: u32,
        log_max_mmo_dma: u32,
        log_max_mmo_compress: u32,
        log_max_mmo_decompress: u32,
        decomp_lz4_data_only_en: u32,
        decomp_lz4_no_checksum_en: u32,
        decomp_lz4_checksum_en: u32,
        umr_modify_entity_size_disabled: u32,
        umr_indirect_mkey_disabled: u32,
        log_min_stride_wqe_sz: u32,
        esw_mgr_vport_id_valid: u32,
        crypto_wrapped_import_method: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmo_dma_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_sq_en) };
            mmo_dma_sq_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mmo_compress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_sq_en) };
            mmo_compress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmo_decompress_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_decompress_sq_en) };
            mmo_decompress_sq_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mmo_dma_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_dma_qp_en) };
            mmo_dma_qp_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mmo_compress_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_compress_qp_en) };
            mmo_compress_qp_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let decomp_deflate_v1_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v1_en) };
            decomp_deflate_v1_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let decomp_deflate_v2_en: u32 = unsafe { ::std::mem::transmute(decomp_deflate_v2_en) };
            decomp_deflate_v2_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mmo_regex_qp_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_qp_en) };
            mmo_regex_qp_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmo_regex_sq_en: u32 = unsafe { ::std::mem::transmute(mmo_regex_sq_en) };
            mmo_regex_sq_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let compress_min_block_size: u32 =
                unsafe { ::std::mem::transmute(compress_min_block_size) };
            compress_min_block_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let log_max_mmo_dma: u32 = unsafe { ::std::mem::transmute(log_max_mmo_dma) };
            log_max_mmo_dma as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let log_max_mmo_compress: u32 = unsafe { ::std::mem::transmute(log_max_mmo_compress) };
            log_max_mmo_compress as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let log_max_mmo_decompress: u32 =
                unsafe { ::std::mem::transmute(log_max_mmo_decompress) };
            log_max_mmo_decompress as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let decomp_lz4_data_only_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_data_only_en) };
            decomp_lz4_data_only_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let decomp_lz4_no_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_no_checksum_en) };
            decomp_lz4_no_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let decomp_lz4_checksum_en: u32 =
                unsafe { ::std::mem::transmute(decomp_lz4_checksum_en) };
            decomp_lz4_checksum_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let umr_modify_entity_size_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_modify_entity_size_disabled) };
            umr_modify_entity_size_disabled as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let umr_indirect_mkey_disabled: u32 =
                unsafe { ::std::mem::transmute(umr_indirect_mkey_disabled) };
            umr_indirect_mkey_disabled as u64
        });
        __bindgen_bitfield_unit.set(33usize, 5u8, {
            let log_min_stride_wqe_sz: u32 =
                unsafe { ::std::mem::transmute(log_min_stride_wqe_sz) };
            log_min_stride_wqe_sz as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let esw_mgr_vport_id_valid: u32 =
                unsafe { ::std::mem::transmute(esw_mgr_vport_id_valid) };
            esw_mgr_vport_id_valid as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let crypto_wrapped_import_method: u32 =
                unsafe { ::std::mem::transmute(crypto_wrapped_import_method) };
            crypto_wrapped_import_method as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn striding_rq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_striding_rq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn striding_rq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_striding_rq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_stride_num_range(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_stride_num_range(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_stride_num_range_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ext_stride_num_range_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_compression_128(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_compression_128(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_compression_128_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_compression_128_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_multi_pkt_send_wqe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enhanced_multi_pkt_send_wqe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_multi_pkt_send_wqe_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_multi_pkt_send_wqe_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_reg_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(5usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_set_reg_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(5usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reg_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                5usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_set_reg_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                5usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nic_flow_table(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nic_flow_table(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nic_flow_table_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nic_flow_table_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ip_ecn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ip_ecn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ip_ecn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ip_ecn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modify_outer_ipv6_traffic_class(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_9.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modify_outer_ipv6_traffic_class(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_9.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_outer_ipv6_traffic_class_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_9),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_outer_ipv6_traffic_class_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_9),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_9(
        striding_rq: u32,
        ext_stride_num_range: u32,
        cqe_compression_128: u32,
        multi_pkt_send_wqe: u32,
        enhanced_multi_pkt_send_wqe: u32,
        set_reg_c: u32,
        nic_flow_table: u32,
        modify_outer_ip_ecn: u32,
        modify_outer_ipv6_traffic_class: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let striding_rq: u32 = unsafe { ::std::mem::transmute(striding_rq) };
            striding_rq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ext_stride_num_range: u32 = unsafe { ::std::mem::transmute(ext_stride_num_range) };
            ext_stride_num_range as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cqe_compression_128: u32 = unsafe { ::std::mem::transmute(cqe_compression_128) };
            cqe_compression_128 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let multi_pkt_send_wqe: u32 = unsafe { ::std::mem::transmute(multi_pkt_send_wqe) };
            multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enhanced_multi_pkt_send_wqe: u32 =
                unsafe { ::std::mem::transmute(enhanced_multi_pkt_send_wqe) };
            enhanced_multi_pkt_send_wqe as u64
        });
        __bindgen_bitfield_unit.set(5usize, 16u8, {
            let set_reg_c: u32 = unsafe { ::std::mem::transmute(set_reg_c) };
            set_reg_c as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let nic_flow_table: u32 = unsafe { ::std::mem::transmute(nic_flow_table) };
            nic_flow_table as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let modify_outer_ip_ecn: u32 = unsafe { ::std::mem::transmute(modify_outer_ip_ecn) };
            modify_outer_ip_ecn as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let modify_outer_ipv6_traffic_class: u32 =
                unsafe { ::std::mem::transmute(modify_outer_ipv6_traffic_class) };
            modify_outer_ipv6_traffic_class as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_counter_bulk_log_max_alloc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_max_alloc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_max_alloc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_max_alloc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_bulk_log_granularity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_bulk_log_granularity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_bulk_log_granularity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                5usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_bulk_log_granularity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alloc_flow_counter_pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alloc_flow_counter_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alloc_flow_counter_pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_alloc_flow_counter_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_counter_access_aso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_counter_access_aso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_counter_access_aso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_counter_access_aso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_match_sample_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_match_sample_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_match_sample_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_match_sample_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_access_aso_opc_mod(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(13usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_access_aso_opc_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_access_aso_opc_mod_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                13usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_access_aso_opc_mod_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                13usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cross_vhca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_vhca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cross_vhca_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cross_vhca_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_based_flow_table_sup(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wqe_based_flow_table_sup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_based_flow_table_sup_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_based_flow_table_sup_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fdb_unified_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_unified_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_unified_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_unified_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jump_fdb_rx_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_10.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jump_fdb_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_10.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jump_fdb_rx_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_10),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_jump_fdb_rx_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_10),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_10(
        flow_counter_bulk_log_max_alloc: u32,
        flow_counter_bulk_log_granularity: u32,
        alloc_flow_counter_pd: u32,
        flow_counter_access_aso: u32,
        query_match_sample_info: u32,
        flow_access_aso_opc_mod: u32,
        cross_vhca: u32,
        lag_rx_port_affinity: u32,
        wqe_based_flow_table_sup: u32,
        fdb_unified_en: u32,
        jump_fdb_rx_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let flow_counter_bulk_log_max_alloc: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_max_alloc) };
            flow_counter_bulk_log_max_alloc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let flow_counter_bulk_log_granularity: u32 =
                unsafe { ::std::mem::transmute(flow_counter_bulk_log_granularity) };
            flow_counter_bulk_log_granularity as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let alloc_flow_counter_pd: u32 =
                unsafe { ::std::mem::transmute(alloc_flow_counter_pd) };
            alloc_flow_counter_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let flow_counter_access_aso: u32 =
                unsafe { ::std::mem::transmute(flow_counter_access_aso) };
            flow_counter_access_aso as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let query_match_sample_info: u32 =
                unsafe { ::std::mem::transmute(query_match_sample_info) };
            query_match_sample_info as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let flow_access_aso_opc_mod: u32 =
                unsafe { ::std::mem::transmute(flow_access_aso_opc_mod) };
            flow_access_aso_opc_mod as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let cross_vhca: u32 = unsafe { ::std::mem::transmute(cross_vhca) };
            cross_vhca as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let lag_rx_port_affinity: u32 = unsafe { ::std::mem::transmute(lag_rx_port_affinity) };
            lag_rx_port_affinity as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wqe_based_flow_table_sup: u32 =
                unsafe { ::std::mem::transmute(wqe_based_flow_table_sup) };
            wqe_based_flow_table_sup as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fdb_unified_en: u32 = unsafe { ::std::mem::transmute(fdb_unified_en) };
            fdb_unified_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let jump_fdb_rx_en: u32 = unsafe { ::std::mem::transmute(jump_fdb_rx_en) };
            jump_fdb_rx_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn log_max_conn_track_offload(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_11.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log_max_conn_track_offload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_11.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log_max_conn_track_offload_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_11),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log_max_conn_track_offload_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_11),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_11(log_max_conn_track_offload: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let log_max_conn_track_offload: u32 =
                unsafe { ::std::mem::transmute(log_max_conn_track_offload) };
            log_max_conn_track_offload as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(4))]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_info_query_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_devx_match_sample_info_query_attr {
    #[inline]
    pub fn modify_field_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_modify_field_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modify_field_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modify_field_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_data_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_data_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sample_dw_ok_bit_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sample_dw_ok_bit_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sample_dw_ok_bit_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sample_dw_ok_bit_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modify_field_id: u32,
        sample_dw_data: u32,
        sample_dw_ok_bit: u32,
        sample_dw_ok_bit_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let modify_field_id: u32 = unsafe { ::std::mem::transmute(modify_field_id) };
            modify_field_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let sample_dw_data: u32 = unsafe { ::std::mem::transmute(sample_dw_data) };
            sample_dw_data as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let sample_dw_ok_bit: u32 = unsafe { ::std::mem::transmute(sample_dw_ok_bit) };
            sample_dw_ok_bit as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let sample_dw_ok_bit_offset: u32 =
                unsafe { ::std::mem::transmute(sample_dw_ok_bit_offset) };
            sample_dw_ok_bit_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_match_sample_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub flow_match_sample_field_offset_mask: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flow_match_sample_field_id: u32,
}
impl mlx5_devx_match_sample_attr {
    #[inline]
    pub fn flow_match_sample_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_offset_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_offset_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_offset_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_offset_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flow_match_sample_en: u32,
        flow_match_sample_field_offset: u32,
        flow_match_sample_offset_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flow_match_sample_en: u32 = unsafe { ::std::mem::transmute(flow_match_sample_en) };
            flow_match_sample_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let flow_match_sample_field_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset) };
            flow_match_sample_field_offset as u64
        });
        __bindgen_bitfield_unit.set(17usize, 4u8, {
            let flow_match_sample_offset_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_offset_mode) };
            flow_match_sample_offset_mode as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flow_match_sample_field_offset_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_offset_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_offset_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_offset_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_field_base_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_field_base_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_field_base_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_field_base_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_match_sample_tunnel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_flow_match_sample_tunnel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_match_sample_tunnel_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                12usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_match_sample_tunnel_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        flow_match_sample_field_offset_shift: u32,
        flow_match_sample_field_base_offset: u32,
        flow_match_sample_tunnel_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flow_match_sample_field_offset_shift: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_offset_shift) };
            flow_match_sample_field_offset_shift as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let flow_match_sample_field_base_offset: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_field_base_offset) };
            flow_match_sample_field_base_offset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let flow_match_sample_tunnel_mode: u32 =
                unsafe { ::std::mem::transmute(flow_match_sample_tunnel_mode) };
            flow_match_sample_tunnel_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_arc_attr {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub parse_graph_node_handle: u32,
}
impl mlx5_devx_graph_arc_attr {
    #[inline]
    pub fn compare_condition_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_compare_condition_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compare_condition_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_compare_condition_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn start_inner_tunnel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start_inner_tunnel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn start_inner_tunnel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_start_inner_tunnel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arc_parse_graph_node(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_arc_parse_graph_node(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arc_parse_graph_node_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arc_parse_graph_node_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare_condition_value: u32,
        start_inner_tunnel: u32,
        arc_parse_graph_node: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let compare_condition_value: u32 =
                unsafe { ::std::mem::transmute(compare_condition_value) };
            compare_condition_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let start_inner_tunnel: u32 = unsafe { ::std::mem::transmute(start_inner_tunnel) };
            start_inner_tunnel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let arc_parse_graph_node: u32 = unsafe { ::std::mem::transmute(arc_parse_graph_node) };
            arc_parse_graph_node as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_graph_node_attr {
    pub modify_field_select: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub header_length_field_mask: u32,
    pub sample: [mlx5_devx_match_sample_attr; 8usize],
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub in_: [mlx5_devx_graph_arc_attr; 8usize],
    pub out: [mlx5_devx_graph_arc_attr; 8usize],
}
impl mlx5_devx_graph_node_attr {
    #[inline]
    pub fn header_length_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_base_value(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_base_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_base_value_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_base_value_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn header_length_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_header_length_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn header_length_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_header_length_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        header_length_mode: u32,
        header_length_base_value: u32,
        header_length_field_shift: u32,
        header_length_field_offset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let header_length_mode: u32 = unsafe { ::std::mem::transmute(header_length_mode) };
            header_length_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let header_length_base_value: u32 =
                unsafe { ::std::mem::transmute(header_length_base_value) };
            header_length_base_value as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let header_length_field_shift: u32 =
                unsafe { ::std::mem::transmute(header_length_field_shift) };
            header_length_field_shift as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let header_length_field_offset: u32 =
                unsafe { ::std::mem::transmute(header_length_field_offset) };
            header_length_field_offset as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn next_header_field_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn next_header_field_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_next_header_field_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_header_field_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                16usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_header_field_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        next_header_field_offset: u32,
        next_header_field_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let next_header_field_offset: u32 =
                unsafe { ::std::mem::transmute(next_header_field_offset) };
            next_header_field_offset as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let next_header_field_size: u32 =
                unsafe { ::std::mem::transmute(next_header_field_size) };
            next_header_field_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Bitmap data structure"]
#[repr(C)]
pub struct rte_bitmap {
    #[doc = "< Bitmap array1"]
    pub array1: *mut u64,
    #[doc = "< Bitmap array2"]
    pub array2: *mut u64,
    #[doc = "< Number of 64-bit slabs in array1 that are actually used"]
    pub array1_size: u32,
    #[doc = "< Number of 64-bit slabs in array2"]
    pub array2_size: u32,
    #[doc = "< Bitmap scan: Index of current array1 slab"]
    pub index1: u32,
    #[doc = "< Bitmap scan: Offset of current bit within current array1 slab"]
    pub offset1: u32,
    #[doc = "< Bitmap scan: Index of current array2 slab"]
    pub index2: u32,
    #[doc = "< Bitmap scan: Go/stop condition for current array2 cache line"]
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub mkey: *mut mlx5_devx_obj,
}
#[doc = " mr operations typedef"]
pub type mlx5_reg_mr_t = ::std::option::Option<
    unsafe extern "C" fn(
        pd: *mut ::std::os::raw::c_void,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        pmd_mr: *mut mlx5_pmd_mr,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_dereg_mr_t = ::std::option::Option<unsafe extern "C" fn(pmd_mr: *mut mlx5_pmd_mr)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr {
    #[doc = "< Pointer to the prev/next entry."]
    pub mr: mlx5_mr__bindgen_ty_1,
    pub pmd_mr: mlx5_pmd_mr,
    pub msl: *const rte_memseg_list,
    pub ms_base_idx: ::std::os::raw::c_int,
    pub ms_n: ::std::os::raw::c_int,
    pub ms_bmp_n: u32,
    pub ms_bmp: *mut rte_bitmap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr__bindgen_ty_1 {
    pub le_next: *mut mlx5_mr,
    pub le_prev: *mut *mut mlx5_mr,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mr_cache_entry {
    pub start: usize,
    pub end: usize,
    pub lkey: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_btree {
    pub len: u32,
    pub size: u32,
    pub table: *mut [mr_cache_entry; 0usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_ctrl {
    pub dev_gen_ptr: *mut u32,
    pub cur_gen: u32,
    pub mru: u16,
    pub head: u16,
    pub cache: [mr_cache_entry; 8usize],
    pub cache_bh: mlx5_mr_btree,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_list {
    pub lh_first: *mut mlx5_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg_list {
    pub lh_first: *mut mlx5_mempool_reg,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mlx5_mr_share_cache {
    pub dev_gen: u32,
    pub rwlock: rte_rwlock_t,
    pub mprwlock: rte_rwlock_t,
    pub cache: mlx5_mr_btree,
    pub mr_list: mlx5_mr_list,
    pub mr_free_list: mlx5_mr_list,
    pub mempool_reg_list: mlx5_mempool_reg_list,
    pub reg_mr_cb: mlx5_reg_mr_t,
    pub dereg_mr_cb: mlx5_dereg_mr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_port_nl_info {
    pub ifindex: u32,
    pub valid: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_info {
    pub port_num: u32,
    pub ibindex: u32,
    pub ibname: [::std::os::raw::c_char; 65usize],
    pub probe_opt: u8,
    pub port_info: *mut mlx5_port_nl_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_obj {
    pub obj: *mut ::std::os::raw::c_void,
    pub id: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar_data {
    pub db: *mut u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_uar {
    pub bf_db: mlx5_uar_data,
    pub cq_db: mlx5_uar_data,
    pub obj: *mut ::std::os::raw::c_void,
    pub dbnc: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_dev_config {
    pub hca_attr: mlx5_hca_attr,
    pub dbnc: ::std::os::raw::c_int,
    pub device_fd: ::std::os::raw::c_int,
    pub pd_handle: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mlx5_common_dev_config {
    #[inline]
    pub fn devx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_devx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn devx_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_devx_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sys_mem_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sys_mem_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sys_mem_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sys_mem_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn probe_opt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_probe_opt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn probe_opt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_probe_opt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_mempool_reg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_mempool_reg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_mempool_reg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_mempool_reg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mr_ext_memseg_en(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr_ext_memseg_en(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mr_ext_memseg_en_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mr_ext_memseg_en_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        devx: ::std::os::raw::c_uint,
        sys_mem_en: ::std::os::raw::c_uint,
        probe_opt: ::std::os::raw::c_uint,
        mr_mempool_reg_en: ::std::os::raw::c_uint,
        mr_ext_memseg_en: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let devx: u32 = unsafe { ::std::mem::transmute(devx) };
            devx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sys_mem_en: u32 = unsafe { ::std::mem::transmute(sys_mem_en) };
            sys_mem_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let probe_opt: u32 = unsafe { ::std::mem::transmute(probe_opt) };
            probe_opt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mr_mempool_reg_en: u32 = unsafe { ::std::mem::transmute(mr_mempool_reg_en) };
            mr_mempool_reg_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mr_ext_memseg_en: u32 = unsafe { ::std::mem::transmute(mr_ext_memseg_en) };
            mr_ext_memseg_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device {
    pub dev: *mut rte_device,
    pub next: mlx5_common_device__bindgen_ty_1,
    pub classes_loaded: u32,
    pub ctx: *mut ::std::os::raw::c_void,
    pub pd: *mut ::std::os::raw::c_void,
    pub dev_info: mlx5_dev_info,
    pub pdn: u32,
    pub mr_scache: mlx5_mr_share_cache,
    pub config: mlx5_common_dev_config,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_device__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_common_device,
    pub tqe_prev: *mut *mut mlx5_common_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_pmd_wrapped_mr {
    pub lkey: u32,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub obj: *mut ::std::os::raw::c_void,
    pub imkey: *mut ::std::os::raw::c_void,
}
#[doc = "< Green"]
pub const rte_color_RTE_COLOR_GREEN: rte_color = 0;
#[doc = "< Yellow"]
pub const rte_color_RTE_COLOR_YELLOW: rte_color = 1;
#[doc = "< Red"]
pub const rte_color_RTE_COLOR_RED: rte_color = 2;
#[doc = "< Number of colors"]
pub const rte_color_RTE_COLORS: rte_color = 3;
#[doc = " Color"]
pub type rte_color = ::std::os::raw::c_uint;
#[doc = " The protocol header can be present in the packet only once.\n No multiple flex item flow inclusions (for inner/outer) are allowed.\n No any relations with tunnel protocols are imposed. The drivers\n can optimize hardware resource usage to handle match on single flex\n item of specific type."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_SINGLE: rte_flow_item_flex_tunnel_mode =
    0;
#[doc = " Flex item presents outer header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_OUTER: rte_flow_item_flex_tunnel_mode = 1;
#[doc = " Flex item presents inner header only."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_INNER: rte_flow_item_flex_tunnel_mode = 2;
#[doc = " Flex item presents either inner or outer header. The driver\n handles as many multiple inners as hardware supports."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_MULTI: rte_flow_item_flex_tunnel_mode = 3;
#[doc = " Flex item presents tunnel protocol header."]
pub const rte_flow_item_flex_tunnel_mode_FLEX_TUNNEL_MODE_TUNNEL: rte_flow_item_flex_tunnel_mode =
    4;
#[doc = " Flex item field tunnel mode"]
pub type rte_flow_item_flex_tunnel_mode = ::std::os::raw::c_uint;
#[doc = "< Set new quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_SET: rte_flow_update_quota_op = 0;
#[doc = "< Increase quota value."]
pub const rte_flow_update_quota_op_RTE_FLOW_UPDATE_QUOTA_ADD: rte_flow_update_quota_op = 1;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Indirect QUOTA update operations.\n\n @see struct rte_flow_update_quota"]
pub type rte_flow_update_quota_op = ::std::os::raw::c_uint;
#[doc = " No traffic metering performed, the output color is the same as the\n input color for every input packet. The meter of the MTR object is\n working in pass-through mode, having same effect as meter disable.\n @see rte_mtr_meter_disable()"]
pub const rte_mtr_algorithm_RTE_MTR_NONE: rte_mtr_algorithm = 0;
#[doc = " Single Rate Three Color Marker (srTCM) - IETF RFC 2697."]
pub const rte_mtr_algorithm_RTE_MTR_SRTCM_RFC2697: rte_mtr_algorithm = 1;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 2698."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC2698: rte_mtr_algorithm = 2;
#[doc = " Two Rate Three Color Marker (trTCM) - IETF RFC 4115."]
pub const rte_mtr_algorithm_RTE_MTR_TRTCM_RFC4115: rte_mtr_algorithm = 3;
#[doc = " Traffic metering algorithms"]
pub type rte_mtr_algorithm = ::std::os::raw::c_uint;
#[doc = " Meter profile"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile {
    #[doc = " Traffic metering algorithm."]
    pub alg: rte_mtr_algorithm,
    pub __bindgen_anon_1: rte_mtr_meter_profile__bindgen_ty_1,
    #[doc = " When zero, the byte mode is enabled for the current profile, so the\n *rate* and *size* fields are specified in bytes per second\n and bytes, respectively.\n When non-zero, the packet mode is enabled for the current profile,\n so the *rate* and *size* fields are specified in packets per second\n and packets, respectively."]
    pub packet_mode: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mtr_meter_profile__bindgen_ty_1 {
    pub srtcm_rfc2697: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1,
    pub trtcm_rfc2698: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2,
    pub trtcm_rfc4115: rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3,
}
#[doc = " Items only valid when *alg* is set to srTCM - RFC 2697."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 2698."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Peak Information Rate (PIR)\n (bytes per second or packets per second)."]
    pub pir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Peak Burst Size (PBS) (bytes or packets)."]
    pub pbs: u64,
}
#[doc = " Items only valid when *alg* is set to trTCM - RFC 4115."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mtr_meter_profile__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Committed Information Rate (CIR)\n (bytes per second or packets per second)."]
    pub cir: u64,
    #[doc = " Excess Information Rate (EIR)\n (bytes per second or packets per second)."]
    pub eir: u64,
    #[doc = " Committed Burst Size (CBS) (bytes or packets)."]
    pub cbs: u64,
    #[doc = " Excess Burst Size (EBS) (bytes or packets)."]
    pub ebs: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_cq {
    pub cq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_cq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_cq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub cqes: *mut mlx5_cqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_devx_sq {
    pub sq: *mut mlx5_devx_obj,
    pub umem_obj: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_devx_sq__bindgen_ty_1,
    pub db_rec: *mut u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_devx_sq__bindgen_ty_1 {
    pub umem_buf: *mut ::std::os::raw::c_void,
    pub wqes: *mut mlx5_wqe,
    pub aso_wqes: *mut mlx5_aso_wqe,
}
#[doc = " Structure of the entry in the mlx5 list, user should define its own struct\n that contains this in order to store the data."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry {
    pub next: mlx5_list_entry__bindgen_ty_1,
    pub ref_cnt: u32,
    pub lcore_idx: u32,
    pub __bindgen_anon_1: mlx5_list_entry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_entry__bindgen_ty_1 {
    pub le_next: *mut mlx5_list_entry,
    pub le_prev: *mut *mut mlx5_list_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_list_entry__bindgen_ty_2 {
    pub gentry: *mut mlx5_list_entry,
    pub bucket_idx: u32,
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache {
    pub h: mlx5_list_cache_mlx5_list_head,
    pub inv_cnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_cache_mlx5_list_head {
    pub lh_first: *mut mlx5_list_entry,
}
#[doc = " Type of callback function for entry removal.\n\n @param tool_ctx\n   The tool instance user context.\n @param entry\n   The entry in the list."]
pub type mlx5_list_remove_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined matching.\n\n @param tool_ctx\n   The tool instance context.\n @param entry\n   The entry in the list.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   0 if matching, non-zero number otherwise."]
pub type mlx5_list_match_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type mlx5_list_clone_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        entry: *mut mlx5_list_entry,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
pub type mlx5_list_clone_free_cb = ::std::option::Option<
    unsafe extern "C" fn(tool_ctx: *mut ::std::os::raw::c_void, entry: *mut mlx5_list_entry),
>;
#[doc = " Type of function for user defined mlx5 list entry creation.\n\n @param tool_ctx\n   The mlx5 tool instance context.\n @param ctx\n   The pointer to new entry context.\n\n @return\n   Pointer of entry on success, NULL otherwise."]
pub type mlx5_list_create_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tool_ctx: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut mlx5_list_entry,
>;
#[doc = " Linked mlx5 list constant object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_const {
    #[doc = "< Name of the mlx5 list."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub ctx: *mut ::std::os::raw::c_void,
    pub lcores_share: bool,
    pub lcore_lock: rte_spinlock_t,
    #[doc = "< entry create callback."]
    pub cb_create: mlx5_list_create_cb,
    #[doc = "< entry match callback."]
    pub cb_match: mlx5_list_match_cb,
    #[doc = "< entry remove callback."]
    pub cb_remove: mlx5_list_remove_cb,
    #[doc = "< entry clone callback."]
    pub cb_clone: mlx5_list_clone_cb,
    pub cb_clone_free: mlx5_list_clone_free_cb,
}
#[doc = " Linked mlx5 list inconstant data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_list_inconst {
    pub lock: rte_rwlock_t,
    pub gen_cnt: u32,
    pub count: u32,
    pub cache: [*mut mlx5_list_cache; 130usize],
}
#[doc = " Linked mlx5 list structure.\n\n Entry in mlx5 list could be reused if entry already exists,\n reference count will increase and the existing entry returns.\n\n When destroy an entry from list, decrease reference count and only\n destroy when no further reference.\n\n Linked list is designed for limited number of entries,\n read mostly, less modification.\n\n For huge amount of entries, please consider hash list.\n"]
#[repr(C)]
#[repr(packed(16))]
#[derive(Copy, Clone)]
pub struct mlx5_list {
    pub l_const: mlx5_list_const,
    pub l_inconst: mlx5_list_inconst,
}
#[doc = " Hash List"]
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hlist_bucket {
    pub l: mlx5_list_inconst,
}
#[doc = " Hash list table structure\n\n The hash list bucket using the mlx5_list object for managing."]
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_hlist {
    pub mask: u32,
    pub flags: u8,
    pub direct_key: bool,
    pub l_const: mlx5_list_const,
    pub __bindgen_padding_0: [u64; 4usize],
    pub buckets: __IncompleteArrayField<mlx5_hlist_bucket>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool_config {
    pub size: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub max_idx: u32,
    pub per_core_cache: u32,
    pub type_: *const ::std::os::raw::c_char,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            flags: u32,
            size: usize,
            align: ::std::os::raw::c_uint,
            socket: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>,
}
impl mlx5_indexed_pool_config {
    #[inline]
    pub fn trunk_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_trunk_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trunk_size_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trunk_size_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_trunk(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_trunk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_trunk_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_trunk_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grow_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_grow_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grow_shift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grow_shift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn need_lock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_lock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn need_lock_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_need_lock_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn release_mem_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_release_mem_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn release_mem_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_release_mem_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        trunk_size: u32,
        grow_trunk: u32,
        grow_shift: u32,
        need_lock: u32,
        release_mem_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let trunk_size: u32 = unsafe { ::std::mem::transmute(trunk_size) };
            trunk_size as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let grow_trunk: u32 = unsafe { ::std::mem::transmute(grow_trunk) };
            grow_trunk as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let grow_shift: u32 = unsafe { ::std::mem::transmute(grow_shift) };
            grow_shift as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let need_lock: u32 = unsafe { ::std::mem::transmute(need_lock) };
            need_lock as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let release_mem_en: u32 = unsafe { ::std::mem::transmute(release_mem_en) };
            release_mem_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_indexed_trunk {
    pub idx: u32,
    pub prev: u32,
    pub next: u32,
    pub free: u32,
    pub bmp: *mut rte_bitmap,
    pub __bindgen_padding_0: [u8; 40usize],
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
pub struct mlx5_indexed_cache {
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub ref_cnt: u32,
    pub len: u32,
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_ipool_per_lcore {
    pub lc: *mut mlx5_indexed_cache,
    #[doc = "< Current cache count."]
    pub len: u32,
    #[doc = "< Cache objects."]
    pub idx: __IncompleteArrayField<u32>,
}
#[repr(C)]
pub struct mlx5_indexed_pool {
    pub cfg: mlx5_indexed_pool_config,
    pub rsz_lock: rte_spinlock_t,
    pub lcore_lock: rte_spinlock_t,
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1,
    pub n_entry: u32,
    pub trunk_new: u32,
    pub trunk_avail: u32,
    pub trunk_empty: u32,
    pub trunk_free: u32,
    pub grow_tbl: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_indexed_pool__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_1 {
    pub n_trunk_valid: u32,
    pub n_trunk: u32,
    pub trunks: *mut *mut mlx5_indexed_trunk,
    pub free_list: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_indexed_pool__bindgen_ty_1__bindgen_ty_2 {
    pub gc: *mut mlx5_indexed_cache,
    pub cache: [*mut mlx5_ipool_per_lcore; 129usize],
    pub ibmp: *mut rte_bitmap,
    pub bmp_mem: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_hw_port_info {
    pub regc_mask: u32,
    pub regc_value: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl flow_hw_port_info {
    #[inline]
    pub fn is_wire(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_wire(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_wire_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_wire_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_wire: u32, direction: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_wire: u32 = unsafe { ::std::mem::transmute(is_wire) };
            is_wire as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap {
    pub max_cq: ::std::os::raw::c_int,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub max_sge: ::std::os::raw::c_int,
    pub mps: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub ind_table_max_size: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tso_max_payload_sz: u32,
    pub mprq: mlx5_dev_cap__bindgen_ty_1,
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub esw_info: flow_hw_port_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_cap__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log_min_stride_size: u32,
    pub log_max_stride_size: u32,
    pub log_min_stride_num: u32,
    pub log_max_stride_num: u32,
    pub log_min_stride_wqe_size: u32,
}
impl mlx5_dev_cap__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl mlx5_dev_cap {
    #[inline]
    pub fn vf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn txpp_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txpp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn txpp_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_txpp_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpls_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpls_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mpls_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqe_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_comp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_comp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_csum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_csum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_csum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_csum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_padding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_padding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_padding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_padding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dest_tir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_tir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dest_tir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dest_tir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scatter_fcs_w_decap_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scatter_fcs_w_decap_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scatter_fcs_w_decap_disable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scatter_fcs_w_decap_disable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rq_delay_drop_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rq_delay_drop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rq_delay_drop_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rq_delay_drop_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vf: u32,
        sf: u32,
        txpp_en: u32,
        mpls_en: u32,
        cqe_comp: u32,
        hw_csum: u32,
        hw_padding: u32,
        dest_tir: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        swp: u32,
        hw_vlan_strip: u32,
        scatter_fcs_w_decap_disable: u32,
        hw_fcs_strip: u32,
        rt_timestamp: u32,
        rq_delay_drop_en: u32,
        tunnel_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vf: u32 = unsafe { ::std::mem::transmute(vf) };
            vf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sf: u32 = unsafe { ::std::mem::transmute(sf) };
            sf as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let txpp_en: u32 = unsafe { ::std::mem::transmute(txpp_en) };
            txpp_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpls_en: u32 = unsafe { ::std::mem::transmute(mpls_en) };
            mpls_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cqe_comp: u32 = unsafe { ::std::mem::transmute(cqe_comp) };
            cqe_comp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hw_csum: u32 = unsafe { ::std::mem::transmute(hw_csum) };
            hw_csum as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hw_padding: u32 = unsafe { ::std::mem::transmute(hw_padding) };
            hw_padding as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dest_tir: u32 = unsafe { ::std::mem::transmute(dest_tir) };
            dest_tir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let swp: u32 = unsafe { ::std::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_vlan_strip: u32 = unsafe { ::std::mem::transmute(hw_vlan_strip) };
            hw_vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scatter_fcs_w_decap_disable: u32 =
                unsafe { ::std::mem::transmute(scatter_fcs_w_decap_disable) };
            scatter_fcs_w_decap_disable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rt_timestamp: u32 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rq_delay_drop_en: u32 = unsafe { ::std::mem::transmute(rq_delay_drop_en) };
            rq_delay_drop_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let tunnel_en: u32 = unsafe { ::std::mem::transmute(tunnel_en) };
            tunnel_en as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tso(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tso_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(tso: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tso: u32 = unsafe { ::std::mem::transmute(tso) };
            tso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config {
    pub tx_pp: ::std::os::raw::c_int,
    pub tx_skew: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: mlx5_sh_config__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sh_config__bindgen_ty_1 {
    pub service_core: u16,
    pub cycle_time: u32,
}
impl mlx5_sh_config {
    #[inline]
    pub fn reclaim_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reclaim_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reclaim_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reclaim_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_esw_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_esw_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_esw_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_esw_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_flow_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dv_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_flow_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_flow_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_xmeta_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dv_xmeta_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_xmeta_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_xmeta_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dv_miss_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dv_miss_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dv_miss_info_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dv_miss_info_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_vxlan_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3_vxlan_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_vxlan_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_vxlan_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vf_nl_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vf_nl_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vf_nl_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vf_nl_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lacp_by_user(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lacp_by_user(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lacp_by_user_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lacp_by_user_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decap_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decap_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decap_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decap_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_fcs_strip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_fcs_strip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_fcs_strip_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_fcs_strip_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_duplicate_pattern(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_duplicate_pattern(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_duplicate_pattern_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_duplicate_pattern_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lro_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lro_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reclaim_mode: u32,
        dv_esw_en: u32,
        dv_flow_en: u32,
        dv_xmeta_en: u32,
        dv_miss_info: u32,
        l3_vxlan_en: u32,
        vf_nl_en: u32,
        lacp_by_user: u32,
        decap_en: u32,
        hw_fcs_strip: u32,
        allow_duplicate_pattern: u32,
        lro_allowed: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reclaim_mode: u32 = unsafe { ::std::mem::transmute(reclaim_mode) };
            reclaim_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dv_esw_en: u32 = unsafe { ::std::mem::transmute(dv_esw_en) };
            dv_esw_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let dv_flow_en: u32 = unsafe { ::std::mem::transmute(dv_flow_en) };
            dv_flow_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let dv_xmeta_en: u32 = unsafe { ::std::mem::transmute(dv_xmeta_en) };
            dv_xmeta_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dv_miss_info: u32 = unsafe { ::std::mem::transmute(dv_miss_info) };
            dv_miss_info as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l3_vxlan_en: u32 = unsafe { ::std::mem::transmute(l3_vxlan_en) };
            l3_vxlan_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vf_nl_en: u32 = unsafe { ::std::mem::transmute(vf_nl_en) };
            vf_nl_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let lacp_by_user: u32 = unsafe { ::std::mem::transmute(lacp_by_user) };
            lacp_by_user as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let decap_en: u32 = unsafe { ::std::mem::transmute(decap_en) };
            decap_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hw_fcs_strip: u32 = unsafe { ::std::mem::transmute(hw_fcs_strip) };
            hw_fcs_strip as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let allow_duplicate_pattern: u32 =
                unsafe { ::std::mem::transmute(allow_duplicate_pattern) };
            allow_duplicate_pattern as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let lro_allowed: u32 = unsafe { ::std::mem::transmute(lro_allowed) };
            lro_allowed as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn fdb_def_rule(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_def_rule(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fdb_def_rule_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fdb_def_rule_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repr_matching(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repr_matching(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repr_matching_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repr_matching_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        fdb_def_rule: u32,
        repr_matching: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fdb_def_rule: u32 = unsafe { ::std::mem::transmute(fdb_def_rule) };
            fdb_def_rule as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let repr_matching: u32 = unsafe { ::std::mem::transmute(repr_matching) };
            repr_matching as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lb_ctx {
    pub qp: *mut ibv_qp,
    pub ibv_cq: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_param {
    #[doc = "< Age state (atomically accessed)."]
    pub state: u16,
    #[doc = "< Port id of the counter."]
    pub port_id: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub sec_since_last_hit: u32,
    #[doc = "< Flow counter age context."]
    pub context: *mut ::std::os::raw::c_void,
}
impl mlx5_age_param {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timeout_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timeout_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_counter_stats {
    pub hits: u64,
    pub bytes: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_shared {
    pub __bindgen_anon_1: mlx5_flow_counter_shared__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter_shared__bindgen_ty_1 {
    pub refcnt: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter {
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_flow_counter__bindgen_ty_2,
    pub __bindgen_anon_3: mlx5_flow_counter__bindgen_ty_3,
    #[doc = "< Pointer to the dv action."]
    pub action: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_1 {
    pub next: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter,
    pub tqe_prev: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter__bindgen_ty_1__bindgen_ty_2 {
    pub shared_info: mlx5_flow_counter_shared,
    pub dcs_when_active: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_2 {
    #[doc = "< Reset value of hits packets."]
    pub hits: u64,
    #[doc = "< Counter pool."]
    pub pool: *mut mlx5_flow_counter_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_counter__bindgen_ty_3 {
    #[doc = "< Reset value of bytes."]
    pub bytes: u64,
    pub dcs_when_free: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counters {
    pub tqh_first: *mut mlx5_flow_counter,
    pub tqh_last: *mut *mut mlx5_flow_counter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool {
    pub next: mlx5_flow_counter_pool__bindgen_ty_1,
    pub counters: [mlx5_counters; 2usize],
    pub min_dcs: *mut mlx5_devx_obj,
    pub time_of_last_age_check: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sl: rte_spinlock_t,
    pub csl: rte_spinlock_t,
    pub raw: *mut mlx5_counter_stats_raw,
    pub raw_hw: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_pool__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_counter_pool,
    pub tqe_prev: *mut *mut mlx5_flow_counter_pool,
}
impl mlx5_flow_counter_pool {
    #[inline]
    pub fn index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_aged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_aged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_gen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_gen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_gen_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_query_gen_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        index: u32,
        is_aged: u32,
        query_gen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let index: u32 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_aged: u32 = unsafe { ::std::mem::transmute(is_aged) };
            is_aged as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let query_gen: u32 = unsafe { ::std::mem::transmute(query_gen) };
            query_gen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng {
    pub next: mlx5_counter_stats_mem_mng__bindgen_ty_1,
    pub raws: *mut mlx5_counter_stats_raw,
    pub wm: mlx5_pmd_wrapped_mr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_mem_mng__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_mem_mng,
    pub le_prev: *mut *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw {
    pub next: mlx5_counter_stats_raw__bindgen_ty_1,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub data: *mut flow_counter_stats,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_counter_stats_raw__bindgen_ty_1 {
    pub le_next: *mut mlx5_counter_stats_raw,
    pub le_prev: *mut *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng {
    pub n_valid: u16,
    pub last_pool_idx: u16,
    pub min_id: ::std::os::raw::c_int,
    pub max_id: ::std::os::raw::c_int,
    pub pool_update_sl: rte_spinlock_t,
    pub csl: [rte_spinlock_t; 2usize],
    pub counters: [mlx5_counters; 2usize],
    pub pools: *mut *mut mlx5_flow_counter_pool,
    pub mem_mng: *mut mlx5_counter_stats_mem_mng,
    pub flow_counters: mlx5_counters,
    pub pending_queries: u8,
    pub pool_index: u16,
    pub query_thread_on: u8,
    pub counter_fallback: bool,
    pub mem_mngs: mlx5_flow_counter_mng_mem_mngs,
    pub free_stat_raws: mlx5_flow_counter_mng_stat_raws,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_mem_mngs {
    pub lh_first: *mut mlx5_counter_stats_mem_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_counter_mng_stat_raws {
    pub lh_first: *mut mlx5_counter_stats_raw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_cq {
    pub log_desc_n: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub cq_obj: mlx5_devx_cq,
    pub errors: u64,
}
impl mlx5_aso_cq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_sq_elem__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1,
    pub mtr: *mut mlx5_aso_mtr,
    pub __bindgen_anon_2: mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2,
    pub user_data: *mut ::std::os::raw::c_void,
    pub quota_obj: *mut mlx5_quota,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_1 {
    pub pool: *mut mlx5_aso_age_pool,
    pub burst_size: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq_elem__bindgen_ty_1__bindgen_ty_2 {
    pub ct: *mut mlx5_aso_ct_action,
    pub query_data: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_sq {
    pub log_desc_n: u16,
    pub sqsl: rte_spinlock_t,
    pub cq: mlx5_aso_cq,
    pub sq_obj: mlx5_devx_sq,
    pub mr: mlx5_pmd_mr,
    pub db: *mut mlx5_aso_wqe,
    pub pi: u16,
    pub db_pi: u16,
    pub head: u32,
    pub tail: u32,
    pub sqn: u32,
    pub elts: [mlx5_aso_sq_elem; 1024usize],
    pub next: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action {
    pub next: mlx5_aso_age_action__bindgen_ty_1,
    pub dr_action: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u16,
    pub age_params: mlx5_age_param,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_action__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_age_action,
    pub le_prev: *mut *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_pool {
    pub flow_hit_aso_obj: *mut mlx5_devx_obj,
    pub index: u16,
    pub time_of_last_age_check: u64,
    pub actions: [mlx5_aso_age_action; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_age_list {
    pub lh_first: *mut mlx5_aso_age_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_age_mng {
    pub pools: *mut *mut mlx5_aso_age_pool,
    pub n: u16,
    pub next: u16,
    pub resize_rwl: rte_rwlock_t,
    pub free_sl: rte_spinlock_t,
    pub free: aso_age_list,
    pub aso_sq: mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_option_resource {
    pub obj: *mut mlx5_devx_obj,
    pub option_class: rte_be16_t,
    pub option_type: u8,
    pub length: u8,
    pub refcnt: u32,
}
#[repr(C)]
pub struct mlx5_hws_q_age_info {
    pub nb_rings: u16,
    pub aged_lists: __IncompleteArrayField<*mut rte_ring>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_age_info {
    pub aged_list: *mut rte_ring,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info {
    pub flags: u8,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_age_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_1 {
    pub aged_counters: mlx5_counters,
    pub aged_aso: aso_age_list,
    pub aged_sl: rte_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_age_info__bindgen_ty_1__bindgen_ty_2 {
    pub ages_ipool: *mut mlx5_indexed_pool,
    pub __bindgen_anon_1: mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_age_info__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub hw_age: mlx5_hws_age_info,
    pub hw_q_age: *mut mlx5_hws_q_age_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_shared_port {
    pub ih_port_id: u32,
    pub devx_ih_port_id: u32,
    pub nl_ih_port_id: u32,
    pub age_info: mlx5_age_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule {
    pub rule: *mut ::std::os::raw::c_void,
    pub matcher: *mut mlx5_flow_dv_matcher,
    pub next_port: mlx5_sub_policy_color_rule__bindgen_ty_1,
    pub src_port: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rule__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_sub_policy_color_rule,
    pub tqe_prev: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_sub_policy_color_rules {
    pub tqh_first: *mut mlx5_sub_policy_color_rule,
    pub tqh_last: *mut *mut mlx5_sub_policy_color_rule,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_sub_policy {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub main_policy: *mut ::std::os::raw::c_void,
    pub tbl_rsc: *mut mlx5_flow_tbl_resource,
    pub rix_hrxq: [u32; 2usize],
    pub jump_tbl: [*mut mlx5_flow_tbl_resource; 2usize],
    pub color_rules: [mlx5_sub_policy_color_rules; 3usize],
}
impl mlx5_flow_meter_sub_policy {
    #[inline]
    pub fn main_policy_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_policy_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn main_policy_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_main_policy_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idx_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_idx_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(main_policy_id: u32, idx: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let main_policy_id: u32 = unsafe { ::std::mem::transmute(main_policy_id) };
            main_policy_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let idx: u32 = unsafe { ::std::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_def_policy {
    pub sub_policy: mlx5_flow_meter_sub_policy,
    pub dr_jump_action: [*mut ::std::os::raw::c_void; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_info {
    pub meter_id: u32,
    pub policy_id: u32,
    pub profile: *mut mlx5_flow_meter_profile,
    #[doc = "< Meter action spinlock."]
    pub sl: rte_spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub drop_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub drop_cnt: u32,
    pub ref_cnt: u32,
    pub flow_ipool: *mut mlx5_indexed_pool,
    pub meter_action_g: *mut ::std::os::raw::c_void,
    pub meter_action_y: *mut ::std::os::raw::c_void,
    pub meter_offset: u32,
    pub group: u16,
}
impl mlx5_flow_meter_info {
    #[inline]
    pub fn bytes_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pkts_dropped(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pkts_dropped(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pkts_dropped_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pkts_dropped_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_active_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_enable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_enable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn def_policy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_def_policy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn def_policy_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_def_policy_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color_aware(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_aware(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_aware_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_color_aware_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bytes_dropped: u32,
        pkts_dropped: u32,
        active_state: u32,
        shared: u32,
        is_enable: u32,
        ingress: u32,
        egress: u32,
        transfer: u32,
        def_policy: u32,
        initialized: u32,
        color_aware: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bytes_dropped: u32 = unsafe { ::std::mem::transmute(bytes_dropped) };
            bytes_dropped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pkts_dropped: u32 = unsafe { ::std::mem::transmute(pkts_dropped) };
            pkts_dropped as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let active_state: u32 = unsafe { ::std::mem::transmute(active_state) };
            active_state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_enable: u32 = unsafe { ::std::mem::transmute(is_enable) };
            is_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let def_policy: u32 = unsafe { ::std::mem::transmute(def_policy) };
            def_policy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let color_aware: u32 = unsafe { ::std::mem::transmute(color_aware) };
            color_aware as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_srtcm_rfc2697_prm {
    pub cbs_cir: rte_be32_t,
    pub ebs_eir: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile {
    pub next: mlx5_flow_meter_profile__bindgen_ty_1,
    #[doc = "< Profile id."]
    pub id: u32,
    #[doc = "< Profile detail."]
    pub profile: rte_mtr_meter_profile,
    pub __bindgen_anon_1: mlx5_flow_meter_profile__bindgen_ty_2,
    #[doc = "< Use count."]
    pub ref_cnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_meter_profile__bindgen_ty_1 {
    pub tqe_next: *mut mlx5_flow_meter_profile,
    pub tqe_prev: *mut *mut mlx5_flow_meter_profile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_flow_meter_profile__bindgen_ty_2 {
    pub srtcm_prm: mlx5_flow_meter_srtcm_rfc2697_prm,
}
impl mlx5_flow_meter_profile {
    #[inline]
    pub fn g_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_g_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn g_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_g_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn y_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_y_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn y_support_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_y_support_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initialized(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initialized_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_initialized_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        g_support: u32,
        y_support: u32,
        initialized: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let g_support: u32 = unsafe { ::std::mem::transmute(g_support) };
            g_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_support: u32 = unsafe { ::std::mem::transmute(y_support) };
            y_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mlx5_aso_mtr_type_ASO_METER_INDIRECT: mlx5_aso_mtr_type = 0;
pub const mlx5_aso_mtr_type_ASO_METER_DIRECT: mlx5_aso_mtr_type = 1;
pub type mlx5_aso_mtr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr {
    pub __bindgen_anon_1: mlx5_aso_mtr__bindgen_ty_1,
    pub type_: mlx5_aso_mtr_type,
    pub fm: mlx5_flow_meter_info,
    #[doc = "< ASO flow meter state."]
    pub state: u8,
    pub offset: u32,
    pub init_color: rte_color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_mtr__bindgen_ty_1 {
    pub next: mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1,
    pub pool: *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_mtr,
    pub le_prev: *mut *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pool {
    pub mtrs: [mlx5_aso_mtr; 128usize],
    pub devx_obj: *mut mlx5_devx_obj,
    pub action: *mut mlx5dr_action,
    pub idx_pool: *mut mlx5_indexed_pool,
    pub index: u32,
    pub nb_sq: u32,
    pub sq: *mut mlx5_aso_sq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_meter_list {
    pub lh_first: *mut mlx5_aso_mtr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_mtr_pools_mng {
    pub n_valid: u16,
    pub n: u16,
    pub mtrsl: rte_spinlock_t,
    pub resize_mtrwl: rte_rwlock_t,
    pub meters: aso_meter_list,
    pub sq: mlx5_aso_sq,
    pub pools: *mut *mut mlx5_aso_mtr_pool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_mtr_mng {
    pub pools_mng: mlx5_aso_mtr_pools_mng,
    pub def_policy: [*mut mlx5_flow_meter_def_policy; 3usize],
    pub def_policy_id: u32,
    pub def_policy_ref_cnt: u32,
    #[doc = " def_policy meter use count."]
    pub drop_tbl: [*mut mlx5_flow_tbl_resource; 3usize],
    pub drop_matcher: [[*mut mlx5_flow_dv_matcher; 32usize]; 3usize],
    pub def_matcher: [*mut mlx5_flow_dv_matcher; 3usize],
    pub def_rule: [*mut ::std::os::raw::c_void; 3usize],
    pub max_mtr_bits: u8,
    pub max_mtr_flow_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tbl_resource {
    #[doc = "< Pointer to DR table object."]
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_wq {
    pub cq_obj: mlx5_devx_cq,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sq_obj: mlx5_devx_sq,
    pub sq_size: u16,
    pub sq_ci: u16,
}
impl mlx5_txpp_wq {
    #[inline]
    pub fn cq_ci(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cq_ci(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cq_ci_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cq_ci_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arm_sn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arm_sn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arm_sn_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arm_sn_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(cq_ci: u32, arm_sn: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cq_ci: u32 = unsafe { ::std::mem::transmute(cq_ci) };
            cq_ci as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let arm_sn: u32 = unsafe { ::std::mem::transmute(arm_sn) };
            arm_sn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txpp_ts {
    pub ci_ts: u64,
    pub ts: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_txpp {
    pub mutex: pthread_mutex_t,
    pub refcnt: u32,
    pub freq: u32,
    pub tick: u32,
    pub test: u32,
    pub skew: i32,
    pub intr_handle: *mut rte_intr_handle,
    pub echan: *mut ::std::os::raw::c_void,
    pub clock_queue: mlx5_txpp_wq,
    pub rearm_queue: mlx5_txpp_wq,
    pub pp: *mut ::std::os::raw::c_void,
    pub pp_id: u16,
    pub ts_n: u16,
    pub ts_p: u16,
    pub tsa: *mut mlx5_txpp_ts,
    pub ts: mlx5_txpp_ts,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub err_miss_int: u64,
    pub err_rearm_queue: u64,
    pub err_clock_queue: u64,
    pub err_ts_past: u64,
    pub err_ts_future: u64,
    pub err_ts_order: u64,
}
impl mlx5_dev_txpp {
    #[inline]
    pub fn sync_lost(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync_lost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sync_lost_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sync_lost_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sync_lost: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sync_lost: u32 = unsafe { ::std::mem::transmute(sync_lost) };
            sync_lost as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_ecpri_parser_profile {
    pub num: u32,
    pub ids: [u32; 8usize],
    pub offset: [u8; 8usize],
    pub obj: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info {
    pub n_port: ::std::os::raw::c_int,
    pub ifindex: u32,
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ports: [mlx5_bond_info__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_bond_info__bindgen_ty_1 {
    pub ifname: [::std::os::raw::c_char; 17usize],
    pub ifindex: u32,
    pub pci_addr: rte_pci_addr,
}
pub const mlx5_aso_ct_state_ASO_CONNTRACK_FREE: mlx5_aso_ct_state = 0;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT: mlx5_aso_ct_state = 1;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_WAIT_ASYNC: mlx5_aso_ct_state = 2;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_READY: mlx5_aso_ct_state = 3;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_QUERY: mlx5_aso_ct_state = 4;
pub const mlx5_aso_ct_state_ASO_CONNTRACK_MAX: mlx5_aso_ct_state = 5;
pub type mlx5_aso_ct_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1,
    pub dr_action_orig: *mut ::std::os::raw::c_void,
    pub dr_action_rply: *mut ::std::os::raw::c_void,
    pub refcnt: u32,
    pub offset: u32,
    pub peer: u16,
    pub state: mlx5_aso_ct_state,
    pub is_original: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_action__bindgen_ty_1 {
    pub __bindgen_anon_1: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1 {
    pub next: mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut mlx5_aso_ct_action,
    pub le_prev: *mut *mut mlx5_aso_ct_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_aso_ct_action__bindgen_ty_1__bindgen_ty_2 {
    pub pool: *mut mlx5_aso_ct_pool,
}
#[repr(C)]
pub struct mlx5_aso_ct_pool {
    pub index: u16,
    pub cts: *mut mlx5_indexed_pool,
    pub devx_obj: *mut mlx5_devx_obj,
    pub __bindgen_anon_1: mlx5_aso_ct_pool__bindgen_ty_1,
    pub sq: *mut mlx5_aso_sq,
    pub shared_sq: *mut mlx5_aso_sq,
    pub actions: __IncompleteArrayField<mlx5_aso_ct_action>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_aso_ct_pool__bindgen_ty_1 {
    pub dummy_action: *mut ::std::os::raw::c_void,
    pub dr_action: *mut mlx5dr_action,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aso_ct_list {
    pub lh_first: *mut mlx5_aso_ct_action,
}
#[repr(C)]
pub struct mlx5_aso_ct_pools_mng {
    pub pools: *mut *mut mlx5_aso_ct_pool,
    pub n: u16,
    pub next: u16,
    pub nb_sq: u32,
    pub ct_sl: rte_spinlock_t,
    pub resize_rwl: rte_rwlock_t,
    pub free_cts: aso_ct_list,
    pub aso_sqs: __IncompleteArrayField<mlx5_aso_sq>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_lag {
    pub tx_remap_affinity: [u8; 16usize],
    pub affinity_mode: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_parser_devx {
    pub entry: mlx5_list_entry,
    pub num_samples: u32,
    pub anchor_id: u8,
    pub devx_obj: *mut ::std::os::raw::c_void,
    pub devx_conf: mlx5_devx_graph_node_attr,
    pub sample_ids: [u32; 8usize],
    pub sample_info: [mlx5_devx_match_sample_info_query_attr; 8usize],
}
#[repr(C)]
#[repr(packed(2))]
#[derive(Copy, Clone)]
pub struct mlx5_flex_pattern_field {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl mlx5_flex_pattern_field {
    #[inline]
    pub fn width(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn width_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_width_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shift_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_shift_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reg_id(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_reg_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_id_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reg_id_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        width: u16,
        shift: u16,
        reg_id: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let width: u16 = unsafe { ::std::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let shift: u16 = unsafe { ::std::mem::transmute(shift) };
            shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let reg_id: u16 = unsafe { ::std::mem::transmute(reg_id) };
            reg_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flex_item {
    pub devx_fp: *mut mlx5_flex_parser_devx,
    pub refcnt: u32,
    pub tunnel_mode: rte_flow_item_flex_tunnel_mode,
    pub mapnum: u32,
    pub map: [mlx5_flex_pattern_field; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_internal_flex_parser_profile {
    pub refcnt: u32,
    pub flex: mlx5_flex_item,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_send_to_kernel_action {
    pub action: *mut ::std::os::raw::c_void,
    pub tbl: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_aso_mng {
    pub sq_num: u16,
    pub sqs: [mlx5_aso_sq; 4usize],
}
#[repr(C)]
#[repr(packed(64))]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_svc_mng {
    pub refcnt: u32,
    pub service_core: u32,
    pub query_interval: u32,
    pub service_thread: rte_thread_t,
    pub svc_running: u8,
    pub __bindgen_padding_0: [u64; 4usize],
    pub aso_mng: mlx5_hws_aso_mng,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_registers {
    pub aso_reg: modify_reg,
    pub hw_avl_tags: [modify_reg; 12usize],
    pub nat64_regs: [modify_reg; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_geneve_tlv_options {
    _unused: [u8; 0],
}
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_UNKNOWN: mlx5_ipv6_tc_support = 0;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_FALLBACK: mlx5_ipv6_tc_support = 1;
pub const mlx5_ipv6_tc_support_MLX5_IPV6_TC_OK: mlx5_ipv6_tc_support = 2;
pub type mlx5_ipv6_tc_support = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_common_nic_config {
    pub ipv6_tc_fallback: mlx5_ipv6_tc_support,
}
#[doc = " Physical device structure.\n This device is created once per NIC to manage recourses shared by all ports\n under same physical device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device {
    pub next: mlx5_physical_device__bindgen_ty_1,
    pub ctx: *mut ::std::os::raw::c_void,
    pub guid: u64,
    pub tlv_options: *mut mlx5_geneve_tlv_options,
    pub config: mlx5_common_nic_config,
    pub refcnt: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_physical_device__bindgen_ty_1 {
    pub le_next: *mut mlx5_physical_device,
    pub le_prev: *mut *mut mlx5_physical_device,
}
#[repr(C)]
pub struct mlx5_dev_ctx_shared {
    pub next: mlx5_dev_ctx_shared__bindgen_ty_1,
    pub refcnt: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hws_max_nb_counters: u32,
    pub max_port: u32,
    pub bond: mlx5_bond_info,
    pub cdev: *mut mlx5_common_device,
    pub phdev: *mut mlx5_physical_device,
    pub tdn: u32,
    pub ibdev_name: [::std::os::raw::c_char; 65usize],
    pub ibdev_path: [::std::os::raw::c_char; 257usize],
    pub dev_cap: mlx5_dev_cap,
    pub config: mlx5_sh_config,
    pub numa_node: ::std::os::raw::c_int,
    pub txpp: mlx5_dev_txpp,
    pub dv_meta_mask: u32,
    pub dv_mark_mask: u32,
    pub dv_regc0_mask: u32,
    pub fdb_domain: *mut ::std::os::raw::c_void,
    pub rx_domain: *mut ::std::os::raw::c_void,
    pub tx_domain: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: mlx5_dev_ctx_shared__bindgen_ty_2,
    pub mreg_cp_tbl: *mut mlx5_hlist,
    pub tunnel_hub: *mut mlx5_flow_tunnel_hub,
    pub dr_drop_action: *mut ::std::os::raw::c_void,
    pub pop_vlan_action: *mut ::std::os::raw::c_void,
    pub send_to_kernel_action: [mlx5_send_to_kernel_action; 6usize],
    pub encaps_decaps: *mut mlx5_hlist,
    pub modify_cmds: *mut mlx5_hlist,
    pub tag_table: *mut mlx5_hlist,
    pub port_id_action_list: *mut mlx5_list,
    pub push_vlan_action_list: *mut mlx5_list,
    pub sample_action_list: *mut mlx5_list,
    pub dest_array_list: *mut mlx5_list,
    pub flex_parsers_dv: *mut mlx5_list,
    pub sws_cmng: mlx5_flow_counter_mng,
    pub default_miss_action: *mut ::std::os::raw::c_void,
    pub ipool: [*mut mlx5_indexed_pool; 17usize],
    pub mdh_ipools: [*mut mlx5_indexed_pool; 32usize],
    pub intr_handle: *mut rte_intr_handle,
    pub intr_handle_devx: *mut rte_intr_handle,
    pub intr_handle_nl: *mut rte_intr_handle,
    pub intr_handle_ib: *mut rte_intr_handle,
    pub devx_comp: *mut ::std::os::raw::c_void,
    pub tis: [*mut mlx5_devx_obj; 16usize],
    pub td: *mut mlx5_devx_obj,
    pub lag: mlx5_lag,
    pub tx_uar: mlx5_uar,
    pub rx_uar: mlx5_uar,
    pub pppriv: *mut mlx5_proc_priv,
    pub ecpri_parser: mlx5_ecpri_parser_profile,
    pub srh_flex_parser: mlx5_internal_flex_parser_profile,
    pub shared_rxqs: mlx5_dev_ctx_shared_shared_rxqs,
    pub aso_age_mng: *mut mlx5_aso_age_mng,
    pub geneve_tlv_option_resource: *mut mlx5_geneve_tlv_option_resource,
    pub geneve_tlv_opt_sl: rte_spinlock_t,
    pub mtrmng: *mut mlx5_flow_mtr_mng,
    pub ct_mng: *mut mlx5_aso_ct_pools_mng,
    pub self_lb: mlx5_lb_ctx,
    pub flow_max_priority: ::std::os::raw::c_uint,
    pub flow_mreg_c: [modify_reg; 8usize],
    pub devx_channel_lwm: *mut ::std::os::raw::c_void,
    pub intr_handle_lwm: *mut rte_intr_handle,
    pub lwm_config_lock: pthread_mutex_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cnt_svc: *mut mlx5_hws_cnt_svc_mng,
    pub cpool_lock: rte_spinlock_t,
    pub hws_cpool_list: mlx5_dev_ctx_shared_hws_cpool_list,
    pub registers: mlx5_dev_registers,
    pub port: __IncompleteArrayField<mlx5_dev_shared_port>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared__bindgen_ty_1 {
    pub le_next: *mut mlx5_dev_ctx_shared,
    pub le_prev: *mut *mut mlx5_dev_ctx_shared,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mlx5_dev_ctx_shared__bindgen_ty_2 {
    pub flow_tbls: *mut mlx5_hlist,
    pub groups: *mut mlx5_hlist,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_shared_rxqs {
    pub lh_first: *mut mlx5_rxq_ctrl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_dev_ctx_shared_hws_cpool_list {
    pub lh_first: *mut mlx5_hws_cnt_pool,
}
impl mlx5_dev_ctx_shared {
    #[inline]
    pub fn esw_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_esw_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn esw_mode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_esw_mode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_hit_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_hit_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_hit_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_hit_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn steering_format_version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_steering_format_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn steering_format_version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_steering_format_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn meter_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meter_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn meter_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_meter_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ct_aso_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ct_aso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_aso_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_aso_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_0_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_0_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_0_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_0_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_header_2_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tunnel_header_2_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_header_2_3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_header_2_3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn misc5_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_misc5_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn misc5_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_misc5_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dr_root_drop_action_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dr_root_drop_action_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dr_root_drop_action_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dr_root_drop_action_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn drop_action_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drop_action_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn drop_action_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_drop_action_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_priority_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flow_priority_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_priority_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flow_priority_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn metadata_regc_check_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_regc_check_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn metadata_regc_check_flag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_metadata_regc_check_flag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared_mark_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared_mark_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_mark_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_mark_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lag_rx_port_affinity_en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lag_rx_port_affinity_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lag_rx_port_affinity_en_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lag_rx_port_affinity_en_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hws_max_log_bulk_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hws_max_log_bulk_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hws_max_log_bulk_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hws_max_log_bulk_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rdma_monitor_supp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdma_monitor_supp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rdma_monitor_supp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rdma_monitor_supp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        esw_mode: u32,
        flow_hit_aso_en: u32,
        steering_format_version: u32,
        meter_aso_en: u32,
        ct_aso_en: u32,
        tunnel_header_0_1: u32,
        tunnel_header_2_3: u32,
        misc5_cap: u32,
        dr_root_drop_action_en: u32,
        drop_action_check_flag: u32,
        flow_priority_check_flag: u32,
        metadata_regc_check_flag: u32,
        shared_mark_enabled: u32,
        lag_rx_port_affinity_en: u32,
        hws_max_log_bulk_sz: u32,
        rdma_monitor_supp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let esw_mode: u32 = unsafe { ::std::mem::transmute(esw_mode) };
            esw_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_hit_aso_en: u32 = unsafe { ::std::mem::transmute(flow_hit_aso_en) };
            flow_hit_aso_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let steering_format_version: u32 =
                unsafe { ::std::mem::transmute(steering_format_version) };
            steering_format_version as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let meter_aso_en: u32 = unsafe { ::std::mem::transmute(meter_aso_en) };
            meter_aso_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ct_aso_en: u32 = unsafe { ::std::mem::transmute(ct_aso_en) };
            ct_aso_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tunnel_header_0_1: u32 = unsafe { ::std::mem::transmute(tunnel_header_0_1) };
            tunnel_header_0_1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tunnel_header_2_3: u32 = unsafe { ::std::mem::transmute(tunnel_header_2_3) };
            tunnel_header_2_3 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let misc5_cap: u32 = unsafe { ::std::mem::transmute(misc5_cap) };
            misc5_cap as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dr_root_drop_action_en: u32 =
                unsafe { ::std::mem::transmute(dr_root_drop_action_en) };
            dr_root_drop_action_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let drop_action_check_flag: u32 =
                unsafe { ::std::mem::transmute(drop_action_check_flag) };
            drop_action_check_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let flow_priority_check_flag: u32 =
                unsafe { ::std::mem::transmute(flow_priority_check_flag) };
            flow_priority_check_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let metadata_regc_check_flag: u32 =
                unsafe { ::std::mem::transmute(metadata_regc_check_flag) };
            metadata_regc_check_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let shared_mark_enabled: u32 = unsafe { ::std::mem::transmute(shared_mark_enabled) };
            shared_mark_enabled as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let lag_rx_port_affinity_en: u32 =
                unsafe { ::std::mem::transmute(lag_rx_port_affinity_en) };
            lag_rx_port_affinity_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let hws_max_log_bulk_sz: u32 = unsafe { ::std::mem::transmute(hws_max_log_bulk_sz) };
            hws_max_log_bulk_sz as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rdma_monitor_supp: u32 = unsafe { ::std::mem::transmute(rdma_monitor_supp) };
            rdma_monitor_supp as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn host_shaper_rate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_host_shaper_rate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn host_shaper_rate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_host_shaper_rate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lwm_triggered(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lwm_triggered(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lwm_triggered_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lwm_triggered_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        host_shaper_rate: u32,
        lwm_triggered: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let host_shaper_rate: u32 = unsafe { ::std::mem::transmute(host_shaper_rate) };
            host_shaper_rate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let lwm_triggered: u32 = unsafe { ::std::mem::transmute(lwm_triggered) };
            lwm_triggered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct mlx5_proc_priv {
    pub hca_bar: *mut ::std::os::raw::c_void,
    pub uar_table_sz: usize,
    pub uar_table: __IncompleteArrayField<mlx5_uar_data>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_quota {
    pub state: u8,
    pub mode: u8,
    #[doc = " Keep track of application update types.\n PMD does not allow 2 consecutive ADD updates."]
    pub last_update: rte_flow_update_quota_op,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_txq_stats {
    #[doc = "< Total of successfully sent packets."]
    pub opackets: u64,
    #[doc = "< Total of successfully sent bytes."]
    pub obytes: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
}
#[repr(C)]
#[repr(packed(64))]
pub struct mlx5_txq_data {
    pub elts_head: u16,
    pub elts_tail: u16,
    pub elts_comp: u16,
    pub elts_s: u16,
    pub elts_m: u16,
    pub wqe_ci: u16,
    pub wqe_pi: u16,
    pub wqe_s: u16,
    pub wqe_m: u16,
    pub wqe_comp: u16,
    pub wqe_thres: u16,
    pub cq_ci: u16,
    pub cq_pi: u16,
    pub cqe_s: u16,
    pub cqe_m: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub inlen_send: u16,
    pub inlen_empw: u16,
    pub inlen_mode: u16,
    pub tx_aggr_affinity: u8,
    pub qp_num_8s: u32,
    pub offloads: u64,
    pub mr_ctrl: mlx5_mr_ctrl,
    pub wqes: *mut mlx5_wqe,
    pub wqes_end: *mut mlx5_wqe,
    pub fcqs: *mut u32,
    pub cqes: *mut mlx5_cqe,
    pub qp_db: *mut u32,
    pub cq_db: *mut u32,
    pub port_id: u16,
    pub idx: u16,
    pub rt_timemask: u64,
    pub ts_mask: u64,
    pub ts_last: u64,
    pub ts_offset: i32,
    pub sh: *mut mlx5_dev_ctx_shared,
    pub stats: mlx5_txq_stats,
    pub stats_reset: mlx5_txq_stats,
    pub uar_data: mlx5_uar_data,
    pub elts: __IncompleteArrayField<*mut rte_mbuf>,
}
impl mlx5_txq_data {
    #[inline]
    pub fn elts_n(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_elts_n(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn elts_n_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_elts_n_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqe_n(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_cqe_n(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqe_n_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cqe_n_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wqe_n(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_wqe_n(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wqe_n_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_wqe_n_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_en(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tso_en(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_en_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_tso_en_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tunnel_en(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tunnel_en(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tunnel_en_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_tunnel_en_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swp_en(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_swp_en(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swp_en_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_swp_en_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vlan_en(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_en(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlan_en_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_vlan_en_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn db_nc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_db_nc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn db_nc_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_db_nc_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn db_heu(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_db_heu(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn db_heu_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_db_heu_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rt_timestamp(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rt_timestamp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rt_timestamp_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rt_timestamp_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wait_on_time(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_wait_on_time(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wait_on_time_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_wait_on_time_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fast_free(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fast_free(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fast_free_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_fast_free_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        elts_n: u16,
        cqe_n: u16,
        wqe_n: u16,
        tso_en: u16,
        tunnel_en: u16,
        swp_en: u16,
        vlan_en: u16,
        db_nc: u16,
        db_heu: u16,
        rt_timestamp: u16,
        wait_on_time: u16,
        fast_free: u16,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let elts_n: u16 = unsafe { ::std::mem::transmute(elts_n) };
            elts_n as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let cqe_n: u16 = unsafe { ::std::mem::transmute(cqe_n) };
            cqe_n as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let wqe_n: u16 = unsafe { ::std::mem::transmute(wqe_n) };
            wqe_n as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tso_en: u16 = unsafe { ::std::mem::transmute(tso_en) };
            tso_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tunnel_en: u16 = unsafe { ::std::mem::transmute(tunnel_en) };
            tunnel_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let swp_en: u16 = unsafe { ::std::mem::transmute(swp_en) };
            swp_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let vlan_en: u16 = unsafe { ::std::mem::transmute(vlan_en) };
            vlan_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let db_nc: u16 = unsafe { ::std::mem::transmute(db_nc) };
            db_nc as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let db_heu: u16 = unsafe { ::std::mem::transmute(db_heu) };
            db_heu as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rt_timestamp: u16 = unsafe { ::std::mem::transmute(rt_timestamp) };
            rt_timestamp as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let wait_on_time: u16 = unsafe { ::std::mem::transmute(wait_on_time) };
            wait_on_time as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let fast_free: u16 = unsafe { ::std::mem::transmute(fast_free) };
            fast_free as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn mlx5_tx_burst_none_empw(
        txq: *mut ::std::os::raw::c_void,
        pkts: *mut *mut rte_mbuf,
        pkts_n: u16,
    ) -> u16;
}
#[doc = "< class handle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_mempool_reg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5dr_action {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_dv_matcher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_flow_tunnel_hub {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_rxq_ctrl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mlx5_hws_cnt_pool {
    pub _address: u8,
}
